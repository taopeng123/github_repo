0:00:00.150,0:00:03.730
Great. So to move one step closer to building awesome apps like the ones you

0:00:03.730,0:00:06.880
submitted to the discussion forum, we're going to learn about how to build up

0:00:06.880,0:00:11.290
the Sunshine UI. We'll do a quick recap first to help remind you of the concepts

0:00:11.290,0:00:16.940
that you learned in lesson one. In order to build a UI in Android, we use views.

0:00:16.940,0:00:20.400
Views are rectangles on the screen, and we may or may not see the borders of

0:00:20.400,0:00:24.890
that rectangle. Essentially, a view handles drawing and event handling. And

0:00:24.890,0:00:29.790
all the basic widgets in Android extend from this base class. The Android design

0:00:29.790,0:00:35.450
guide has visual examples of these basic building blocks of apps. For example,

0:00:35.450,0:00:38.800
we have the basic text field, as well as editable text fields.

0:00:38.800,0:00:42.970
We can do auto complete on them, and it comes with text selection as well.

0:00:42.970,0:00:46.640
Where it pops up a contextual action bar, for you to copy and paste.

0:00:46.640,0:00:51.840
There are also buttons, and also a suggestion to use borderless buttons.

0:00:51.840,0:00:55.210
It also has spinners, where you can select from a drop down menu.

0:00:55.210,0:00:58.330
There's also checkboxes, radio buttons, on/off switches, and

0:00:58.330,0:01:02.720
they also have some progress bars. There's a ton more basic widgets here, and

0:01:02.720,0:01:07.390
also in the Java docs. Check those out. And even ones that aren't listed here,

0:01:07.390,0:01:10.600
so. You'll come across them as you need them.

0:01:10.600,0:01:14.390
Now, if you want to display multiple views together, you'll need a view group.

0:01:14.390,0:01:17.640
A view group is a container for children views. Here are a couple of

0:01:17.640,0:01:22.030
common view groups, which Dan introduced earlier. First, we have a frame layout.

0:01:22.030,0:01:25.230
A child that gets added will be default positioned in the top left corner of

0:01:25.230,0:01:29.530
the view group. If you add a second view here, it will overlap the first one. So

0:01:29.530,0:01:33.840
typically we only have one child per frame layout. Next we have a linear layout,

0:01:33.840,0:01:37.900
it's composed of children either in a horizontal row or in a vertical column.

0:01:37.900,0:01:41.590
We can also specify layout weight. Lay out weight allows us to

0:01:41.590,0:01:45.410
distribute the width or height of a parent across the children. For example,

0:01:45.410,0:01:48.940
this has weight one, and this has weight one then the width of the parent can be

0:01:48.940,0:01:53.930
split across them evenly. Then we have a relative layout where we can specify

0:01:53.930,0:01:58.950
that a view should be aligned to the parent's left, top, right or bottom edge.

0:01:58.950,0:02:02.520
We can also specify that one view should be relative to another view.

0:02:02.520,0:02:05.490
It isn't full if the space is nicely compared to a linear layout, but

0:02:05.490,0:02:10.530
there are pros and cons to each. There's a grid layout where the views fill

0:02:10.530,0:02:15.590
up cells in a grid. You can also have views that span multiple cells.

0:02:15.590,0:02:18.090
I also want to point out that a view group is a view.

0:02:18.090,0:02:21.650
So in our code when we refer to a list item layout as being a single view.

0:02:21.650,0:02:26.050
That just means the root view of the whole view hierarchy for that layout.

0:02:26.050,0:02:30.110
Chances are that root view is a ViewGroup, so it contains children views as well

0:02:30.110,0:02:34.169
as ViewGroups. So basically you can nest ViewGroups within ViewGroups.

0:02:35.210,0:02:38.510
The reason why we care so much about parent child view relationships,

0:02:38.510,0:02:42.470
is because the way a child view gets laid out depends on its parent.

0:02:42.470,0:02:45.500
The simplest example of this is specifying a view's width and

0:02:45.500,0:02:48.770
height. By now you've seen that every view requires a height and

0:02:48.770,0:02:53.529
width. The two possible values are either wrap content or match parent.

0:02:54.540,0:02:57.860
This diagram shows all the possible combinations for width and height for

0:02:57.860,0:03:01.620
this text view. This is the balance of the view when we set wrap_content for

0:03:01.620,0:03:05.230
height and width. This is what happens when we do match_parent for

0:03:05.230,0:03:09.090
the width and match_parent for the height. And this is what happens when

0:03:09.090,0:03:12.731
both are set as match_parent. It shows the full dimensions of the parent.

0:03:12.731,0:03:16.750
When you run this on the device. All of these would visually look the same,

0:03:16.750,0:03:19.860
because you wouldn't see these boundaries. So why does it matter which one

0:03:19.860,0:03:23.160
we pick? Well, it matters as soon as you have other children that need to

0:03:23.160,0:03:27.270
be beside this view. And another reason is you want to specify gravity.

0:03:27.270,0:03:31.250
Let me spend a quick moment explaining gravity. Say for example, you

0:03:31.250,0:03:35.640
have this text view within a frame layout. By default, the text is left aligned.

0:03:35.640,0:03:39.540
And in this case, no gravity is set. If we specify gravity equals center,

0:03:39.540,0:03:43.250
then it will center the content within the text view. Vertically it can't move,

0:03:43.250,0:03:46.960
'because it's already centered, but horizontally it does shift over to be in

0:03:46.960,0:03:50.570
the middle. Instead of this. If we specify layout gravity equals center,

0:03:50.570,0:03:53.540
that means to center horizontally and vertically within the parent.

0:03:53.540,0:03:57.160
So we grab the whole child text view and we move it into the center.

0:03:57.160,0:04:00.440
Now it can't be centered horizontally, because it already takes up the max width

0:04:00.440,0:04:03.530
of the parent. If we really want to move the content to the middle,

0:04:03.530,0:04:07.600
then we should specify wrap content on this text view, so that it can be

0:04:07.600,0:04:11.350
moved to the center with this attribute. You can also specify padding and

0:04:11.350,0:04:15.710
margin on views. For example, if you added padding on this text view,

0:04:15.710,0:04:19.750
then it would shift the content inside by x amount on all sides.

0:04:19.750,0:04:23.390
If you specify layout margin to be x, then remember that the parent is

0:04:23.390,0:04:27.320
the one who will be interpreting this layout ground. In this case,

0:04:27.320,0:04:31.240
it adds a margin of x all around the text view. The text view is only this size.

0:04:32.260,0:04:35.280
When you render both of these, they would visually look the same.

0:04:35.280,0:04:37.690
Here's one case where it could matter. If this was a button and

0:04:37.690,0:04:41.740
you pressed it, there could be a gray background here showing. In some cases you

0:04:41.740,0:04:47.010
may want padding or margin or both. All views have a visibility property. For

0:04:47.010,0:04:50.020
this image view, it can be visible, invisible, or gone.

0:04:50.020,0:04:53.390
If it's invisible then it's not shown, but there's still a place holder for

0:04:53.390,0:04:56.830
it, we still have to go and measure the size of it. If it's gone,

0:04:56.830,0:04:59.920
then it's not even in the layout. It's as if it didn't exist in the XML.

0:04:59.920,0:05:04.490
You can also toggle the visibility of a view dynamically during runtime.

0:05:04.490,0:05:08.680
In the java doc, you can find all the possible XML attributes for that class.

0:05:08.680,0:05:12.740
It also shows inherited XML attributes, for example, from the view class.

0:05:12.740,0:05:16.430
For this image view, and then it shows the corresponding Java methods for

0:05:16.430,0:05:20.310
those attributes. Now as a briefer for [UNKNOWN] basics to help us get started,

0:05:20.310,0:05:22.250
but definitely check out the developer site for

0:05:22.250,0:05:26.670
more details later. Much like the real world, if you were working with a team to

0:05:26.670,0:05:30.660
build an Android app, you would start by implementing the wire frames first.

0:05:30.660,0:05:33.920
This has a correct flow for how the user will interact with the app. But

0:05:33.920,0:05:37.780
it doesn't have the final visual look and feel yet. We'll build this up step by

0:05:37.780,0:05:42.030
step, starting with the main activity then we'll move on to the detail activity

0:05:42.030,0:05:46.630
and then later build up the tablet UI. Then we'll receive a set of visual marks

0:05:46.630,0:05:50.780
red lines and assets, all of this will help us build a pixel perfect layout
