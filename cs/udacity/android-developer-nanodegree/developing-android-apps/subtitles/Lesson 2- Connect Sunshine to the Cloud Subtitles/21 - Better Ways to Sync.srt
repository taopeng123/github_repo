0:00:00.400,0:00:02.710
Because it's being created within an activity, it can be

0:00:02.710,0:00:05.400
terminated as simply as rotating the phone into a different

0:00:05.400,0:00:08.710
orientation. So, should only ever be used for tasks whose

0:00:08.710,0:00:12.050
lifecycle is tied to the host activity, and is expected

0:00:12.050,0:00:15.420
to run for only a second or two. On mobile,

0:00:15.420,0:00:18.100
it's unwise to assume that even the most trivial network

0:00:18.100,0:00:21.680
access is going to happen quickly. So a better approach

0:00:21.680,0:00:25.770
would be to use a service. An application component without

0:00:25.770,0:00:27.220
the UI that's less likely to be

0:00:27.220,0:00:30.820
interrupted. Possibly scheduled using an inexact repeating alarm.

0:00:32.970,0:00:35.860
Even better, Android has a specialized solution know

0:00:35.860,0:00:39.170
as Async Adapter. And it's designed especially to schedule

0:00:39.170,0:00:42.700
your background data syncs as efficiently as possible. Better

0:00:42.700,0:00:46.830
still would be using Google Cloud Messaging. This lets

0:00:46.830,0:00:48.740
you notify your Async Adapter of changes on the

0:00:48.740,0:00:52.460
server side. So you're only ever initiating network requests

0:00:52.460,0:00:54.510
from your app when you know there's something to

0:00:54.510,0:00:58.030
be updated on the server. For now we're concentrating

0:00:58.030,0:01:01.340
on making our app work when it's in the foreground. But we'll return to

0:01:01.340,0:01:03.340
look at these approaches to invisibly updating

0:01:03.340,0:01:04.890
your app from the background a little

0:01:04.890,0:01:09.200
later. For now, keep in mind that the Refresh button and the new thread

0:01:09.200,0:01:12.530
solution is just a place holder while we hook up the rest of the app.
