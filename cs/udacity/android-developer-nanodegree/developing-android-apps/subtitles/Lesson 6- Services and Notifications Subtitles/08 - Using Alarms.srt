0:00:00.640,0:00:02.820
So now we have a simple service.

0:00:02.820,0:00:04.350
Wasn't that easy?

0:00:04.350,0:00:06.840
But it still doesn't wake itself up.

0:00:06.840,0:00:09.710
Fortunately, there's[br]a system service for that.

0:00:09.710,0:00:12.860
This is a good opportunity to[br]introduce the alarm manager.

0:00:12.860,0:00:15.570
The alarm manager allows you to[br]tell the system that you want it to

0:00:15.570,0:00:18.740
wake a component of your application[br]up after a period of time and

0:00:18.740,0:00:20.980
do some processing in the background.

0:00:20.980,0:00:24.170
You can even have it wake up your[br]application periodically, but

0:00:24.170,0:00:26.780
what do we wake up in the background?

0:00:26.780,0:00:29.560
That would be an Android[br]component we haven't seen before,

0:00:29.560,0:00:31.700
called a broadcast receiver.

0:00:31.700,0:00:35.250
A broadcast receiver is a special[br]class that is used to receive

0:00:35.250,0:00:38.750
intent broadcasts,[br]often from other applications.

0:00:38.750,0:00:42.030
Typically, a broadcast receiver[br]will register an intent filter for

0:00:42.030,0:00:43.610
these broadcasts.

0:00:43.610,0:00:47.320
It's also one way the application[br]will listen in on alarms.

0:00:47.320,0:00:51.560
Alarms take advantage of a new kind[br]of intent, called a PendingIntent.

0:00:51.560,0:00:54.170
A PendingIntent is[br]a special kind of intent

0:00:54.170,0:00:57.470
that is handed from one[br]application to another.

0:00:57.470,0:01:01.310
The big difference between[br]a PendingIntent and a regular intent

0:01:01.310,0:01:05.970
is that a PendingIntent gives permission[br]for the app using it to send data with

0:01:05.970,0:01:10.650
the same permissions and application[br]identity as the app that created it.

0:01:10.650,0:01:15.520
In Android this allows the system[br]process to call your application back

0:01:15.520,0:01:20.770
in a specific asynchronous way without[br]compromising the Android security model.

0:01:20.770,0:01:24.830
In alarms a pending intent[br]is used by the alarm manager

0:01:24.830,0:01:27.330
to talk to the broadcast[br]receiver we create.

0:01:28.960,0:01:30.790
Let's add some alarm stuff.

0:01:30.790,0:01:34.475
First, I'm going to add[br]a BroadcastReceiver as a static inner

0:01:34.475,0:01:36.970
class of SunshineService.

0:01:36.970,0:01:39.060
Since this is an Android component,

0:01:39.060,0:01:41.630
I'll register this broadcast[br]receiver in the manifest.

0:01:42.980,0:01:46.590
Note the way a static[br]inner class is notated.

0:01:46.590,0:01:47.490
Okay.

0:01:47.490,0:01:51.570
I've given you the bones of a broadcast[br]receiver that can handle an alarm.

0:01:51.570,0:01:52.450
But now it's your turn.

0:01:53.520,0:01:56.920
You can create a PendingIntent[br]from an explicit intent

0:01:56.920,0:02:00.580
to have the alarm manager[br]activate your broadcast receiver.

0:02:00.580,0:02:03.920
I recommend setting the alarm[br]to something absurdly short,

0:02:03.920,0:02:06.910
like five seconds, so[br]you can easily test that it's working.
