
The book "C++ Primer" has been all recroded in this note.

==
findcbegin                   C begin
findcscanf                   scanf in C
findcdatatype                Data types in C
findcstring                  Strin in C
findcbool                    Bool in C
findcinclude                 Include in C
findcheader                  Header in C
findcmath                    math.h in C
findcif                      if in C
findcswitch                  switch in C
findcwhile                   while in C
findcfor                     for in C
findccontinue                C has "continue" and "break"
findcbreak                   C has "continue" and "break"
findcgoto                    goto in C
findcarray                   Array in C
findcfunction                Function in C
findcstatic                  static & extern in C
findcextern                  static & extern in C
findcpointer                 Pointer in C
findcargs                    Command line argument C
findccommandlineargument     Command line argument C
findcstruct                  Struct in C
findcunion                   Union in C
findctypedef                 typedef in C
findcmalloc                  Dynamic memory allocation and free in C
findcmemory                  Dynamic memory allocation and free in C
findcconstant                Constant(ÂÆè) in C
findcfile                    File in C
findcreadfromfile            Read from file in C
findcreadfromfile             Write to file in C

==
findcppbegin                 C++ begin
findcompile                  Compile
findcompileseparate          Separate Compilation
findcomment                  Comments
findgooglestyle              Google C++ Style Guide
findcout                     cout
findcin                      cin 
findgetline                  getline
findmath                     Math operators
findpow                      power
findmax                      max
findmin                      min
findreadfromfile             Read from file and output to file
findwritetofile              Read from file and output to file
findio                       IO
findnamespace                Using Names from the Standard Library
findistream                  Example of using istream
findostream                  Example of using ostream
findcast                     Cast
findconvertdatatype          Convert data types
findtypeconversion           Convert data types
findfor                      Range for 
findrangefor                 Range for 
findstaticallytyped          Statically typed launage
findtype                     Data types
finddatatype                 Data types
findbool                     bool
findtypealias                Type alias
findtypedef                  typedef
finddecltype                 decltype
findauto                     auto
findliteral                  Literals
findvariable                 Variables
findidentifier               Identifiers
findscope                    Scope of a Name
findinitialization           Intialization
findlistinitialization       List Initialization
finddefaultinitialization    Default Initialization
findvalueinitialization      Value Initialization
finddirectinitialization1    Direct Initialization 1
findcopyinitialization1      Copy Initialization 1
finddirectinitialization2    Direct Initialization 2
findcopyinitialization2      Copy Initialization 2
finddeclaration              declaration 
finddefinition               definition
findmax                      max
findintmax                   INT_MAX
findmaxint                   INT_MAX
findintmin                   INT_MIN
findminint                   INT_MIN
findheader                   Headers
findinclude                  Headers
findpreprocessor             preprocessor
findreference                Reference
findpassbyvalue              Pass by value
findpassbyreference          Pass by reference
findpointer                  Pointer
findnull                     null pointer
findpointertoarray           Pointer to array & array of pointers
findreferencetoarray         Reference to array & array of references
findpointertofunction        Pointer to function
finddynamicmemory            Dynamic memory
findsharedptr                Smart pointer
findsmartpointer             Smart pointer
findnew                      The new operator
finddelete                   The delete operator
findfreememory               Free dynamic memory
finddynamicarray             Dynamic Arrays
findconst                    Constant
findconstparameter           const in function parameter
findconstantexpression       Constant expression
findconstexpr                Constant expression
findsleep                    Sleep
findescape                   Escape sequence
findstring                   string
findsubstring                Substring (get and find substring)
findsplit                    split a string
findfind                     find the position of a substring in a string
findtrim                     trim
finderase                    erase
findargs                     Command line argument 
findcommandlineargument      Command line argument 
findcontainer                Sequential containers
findsequentialcontainer      Sequential containers
findcontainerlibrary         Container functions
findcontainerfunctions       Container functions
findcontainermethods         Container functions
findvector                   vector
findsortvector               Sort a vector
findassociativecontainers    Associative Containers
findunorderedcontainers      Unordered associative containers
findunorderedset             unordered_set
findset                      set
findunorderedmap             unordered_map
findmap                      map
findcontaineradaptor         Container Adaptors (stack, queue, priority_queue)
findstack                    stack
findqueue                    queue
findpriorityqueue            priority_queue
finddeque                    deque
finddequeue                  deque
findalgorithm                Generic algorithms
findgenericalgorithm         Generic algorithms
findlambda                   Lambda Expressions
findforeach                  for_each
finditerator                 iterator
findreverseiterator          Reverse Iterators
findarray                    array
findand                      AND operator
findoperator                 operators
findincrement                ++ and -- operators
finddecrement                ++ and -- operators
find++                       ++ and -- operators
find--                       ++ and -- operators
findsizeof                   sizeof
commaoperator                Comma operator
findif                       if 
findswitch                   switch
findwhile                    while
findfor                      for
findbreak                    break
findcontinue                 continue
findgoto                     goto
findexception                Exception
findfunction                 function
findparameter1               Examples of function input parameters from Leetcode
findreturn1                  return
findparameter2               Pass parameter uses copy constructor
findreturn2                  Return value uses copy constructor
findreturnvector             Return a vector from function
findreturnpointer            Return pointer from a function
findreturnreference          Return reference from a function
findstatic                   Static variables
findoverload                 Overloaded Functions
findinlinefunctions          Inline Functions
findconstexprfunctions       constexpr Functions
findassert                   assert
findndebug                   NDEBUG
findstruct                   struct
findclass                    class
findpublic                   public
findprivate                  private
findmemberfunction           member function
findconstmemberfunction      const member functions
findfriend                   friend
findstaticmember             static Class Members
findconstructor              constructor
finddefaultconstructor       Default Constructor
findsynthesizeddefaultconstructor Synthesized Default Constructor
findcopycontrol              Copy control
findcopyconstructor          Copy constructor
finddestructor               Destructor
finddestroy                  Destroy
finddefault                  Using = default
findoverload                 Overloaded Operations
findinheritance              inheritance
findobjectorientedprogramming Object-Oriented Programming
findoop                      Object-Oriented Programming
findtemplate                 Template

=============
(findcbegin)
C begins

//Sample C program, printf example:

#include<stdio.h>

void main() {
	int i, sum = 0;	
	for(i = 1; i <= 100; i++) 
		sum = sum + i;	
	printf("sum = %d\n", sum);		
}

printf("%d, %d", a, b + c);

Format:
d: int
f: float
e,E: exponential
c: single character
s: string

==
(findcscanf)
scanf in C:

scanf is also in stdio.h

scanf("%d, %d, %d", &x, &y, &z); <- Input should be deliminated by ,
scanf("%d%d%d", &x, &y, &z); <- Input should be deliminated by any number of white spaces
s = max(x, y, z);
printf("max = %d\n", s);

Format is the same as printf

==
(findcdatatype)
Data types in C

type   number of bytes
char       1

==
(findcstring)
No string type in C:

There is no String variable type in C, but there is String constant type in C (eg, "abc").

The length of "ab" is 3, because it is stored as "ab\0"

string and char array:

char a[15];
char a[5] = {"BOY"}; 
char a[5] = "BOY";
char a[] = {"string!"};
char a[] = "string";
char a[4][8] = {"ZHANG", "ZHONG", "HUANG", "LIANG"};

char *hostname = "localhost";

//a is a string:
scanf("%s", a);
printf("%s\n", a);

The following string functions are in <string.h>:

strcat(s1, s2):  Catenate s1 and s2, return the address of the first element of the new char array. s1 can not be a string constant.

strcpy(s1, s2): Copy s2 into s1. s1 can not be a string constant.

strcmp(s1, s2): Compare two strings. Note that "s1 == s2" is wrong. Should use "strcmp(s1, s2) == 0".

strlen(s): Return the length of s, excluding the "\0" at end.

strlwr(s): Replace the uppercase chars in s to lowercase.

strupr(s): Replace the lowercase chars in s to uppercase.

==
(findcbool)
There is no bool type in C, it uses 1 to represent true, 0 to represent false.

==
(findcinclude)
(findcheader)
(findcmath)
Include in C
Headers in C
math.h in C

stdio.h, math.h, string.h:

math.h has the following functions:

cos(0.2), exp(0.2), fabs(0.2), log(0.2), log10(0.2), 
pow(0.2, 3.0) <- 0.2^3.0, 
sin(0.2), sqrt(0.2), tan(0.2)

--
When to use header files: when many programs use some common constants, data, etc, can put them into .h files.

Difference between the following two:
#include <xxx.h>
#include "xxx.h"

The difference is that: 
If use <xxx.h>, then the system will only search for the header file in the designated directory for header files (the include directory). For the header files provided by C, it saves searching time to use this way.
If use "xxx.h", then the system will first search for the header file in the current directory, then in the designated directory for header files (the include directory).

==
(findcif)
if in C

if(a < b) a = b;

if(...) {
	...
} else {
	...
}

--
string finalgrade = (grade < 60) ? "fail" : "pass";

==
(findcswitch)
Switch in C

switch(grade) {
	case 'A': printf("Excellent\n");
	case 'B': printf("Good\n");
	case 'C': printf("Pass\n");
	case 'D': printf("Fail\n");
	default: printf("Invalid input.\n");
}

==
(findcwhile)
While in C

while(x > 0) printf("Helo\n");

--
do {
	i--;
	printf("a");
} while(i >= 0);

==
(findcfor)
for in C

for(i = 1; i <= 100; i++) 
	sum = sum + i;	

==
(findccontinue)
(findcbreak)

C has "continue" and "break"

==
(findcgoto)
goto in C

s = 0.0;
goto cal;
s = 0.5 * 2;
cal: printf("a");

==
(findcarray)
Array in C

int a[10];
a[0] = 1;
int x[3] = {1, 2, 3};
int x[] = {1, 2, 3}; //Can omit the length

int x[3] = {0, 0, 0}; 
can be written as 
int x[3] = {0};

double s[5][5]

int x[2][4] = {{1,2,3,4}, {6,7,8,9}};
is equivalent as
int x[2][4] = {1,2,3,4,5,6,7,8,9};

Array name is the address of the 0-th element
These two expressions are equivalent: a, &a[0]
These two expressions are equivalent: a[i], *(a+i)

2-D array name is the address of the 0-th row.

==
(findcfunction)
Function in C

int max(int a, int b) {
    if(a > b) return a;
    else return b;
}

If no returned value, use void. 
If no parameters, use ():

void func() {
    printf("a");
}

main function usually has no parameters, unlike Java.

Function parameters are often passed by value. But for array names, it passes its address, so it is passed by reference.

For array as parameter, can define an empty array (tao: in the parameter parenthesis). If need to operate on its elemets, can use another parameter to denote its length:

void sort_string(char str[], int n) {
    ...
}

// Call the above function in another functin:
char str[30]=‚ÄùABCDEFGHIJKLMNOPQRSTUVWXYZ‚Äù;
int i=26;
sort_string(str, i);

==
(findcstatic)
(findcextern)
static & extern in C

Static variable: 
Static variable in a function will have their values kept even after this function is been called.
Exmaple: 
static int i;

Extern variable: 
Can be used in two cases:
1. In a file, can define a variable as extern and use this variable before its definition. Before using it, need to declare it using "extern". 
2. In a file, can define a variable as extern and use this variable in another file. Before using it, need to declare it using "extern". 
Example: none.

Static function:
Can only be used in the same file.
Example: none.

Extern function:
Can be used in other files. If a function definition has no keyword "extern", then it is still extern by default. Before using extern function in another file, need to declare it using "extern". 
Example: none.

==
(findcpointer)
Pointer in C

int *p = &i;
// Pointer p equals the address of i
// Then *p is i, *p = 100 is equivalent to i = 100

If a pointer = 0, it means it does not point to anything.

Print the address of a variable:
printf("%p\n",(void*)&a);

Pointers must be initialized.

int a[20], *p;
p = &a[0]; // p points to the address of a[0]
p += 2; // p points to the address of a[2]

a = &a[1];
b = &a[3];
Then (b - a) equals 2

int* p[3]: p is an array of pointers (can be easily understood)
int (*p)[3]: p is a pointer which points to an array (because the above is array of pointers, so here it is a pointer which...)

Pointer to functions can be rememebered in the save way as above:
int* f(int x); //f is a function which returns pointer
int (*f)(int x); //f is a pointer which points to a function

int func(int x);
int (*f)(int x);
f = func; <- func has no (), no parameters. Function name is the address of the entrance of function.
(*f) is equivalent as func, eg (*f)(x)

Array name as function parameter (in a similar way as Java):

// Tao remembers online says this way passes by copying the array and this way should be avoided, needs to confirm
void sort(int x[], int n) {
	...
}

void main() {
	int a[10];
	...
	sort(a, 10);
}

A pointer to a string is the address of the first character in the string.

==
(findcargs)
(findccommandlineargument)
Convert command line argument to string in C

#include <iostream>
#include <string>
#include <vector>

int main(int argc, char *argv[]) // Don't forget first integral argument 'argc', which is count of arguments plus the current exec file.
{
  std::string current_exec_name = argv[0]; // Name of the current exec program
  std::string first_arge;
  std::vector<std::string> all_args;

  if (argc > 1) {
    first_arge = argv[1];
    all_args.assign(argv + 1, argv + argc);
  }
}


==
(findcstruct)
Struct in C

From online:
Should struct definitions go in .h or .c file?
Private structures for that file should go in the .c file, 
with a declaration in the .h file if they are used by any functions in the .h .
Public structures should go in the .h file.

struct date {
    int year;
    int month;
    int day;
}; // Don't forget the ;

struct date d;

The above two statements can be written together:

struct date {
    int year;
    int month;
    int day;
} d;

Initialize struct:

struct date {
    int year;
    int month;
    int day;
} d = {1977, 11, 14};

int y = date.year;

struct array (every element is a struct type):

struct date d[3];
struct date d[3] = {{1977, 11, 14}, {1980, 3, 5};
struct date d[] = {{1977, 11, 14}, {1980, 3, 5}; //Can omit the length

A pointer to a struct points to the initial address of the struct.

struct date d;
struct date *p;
p = &d;
(*p).year
p->year

Linked list node (note the next pointer):

struct student {
    char name[8];
    float score;
    struct student *next;
}

==
(findcunion)
Union in C

union utag {
    int i;
    float f;
    char c;
};

The definition of union is the same as struct.
The reference to memebers of union (including pointers) is also the same as struct.

The difference between struct and union:
The members in a struct have their own memory units. The size of a struct is the sum of the size of its members.
The members in a union share the same memory unit. The size of a union is the size of its largest member. Tao's understanding is that a union can be different types (any of its member type) at different times. Just like Á≤æÁ•ûÂàÜË£ÇÁóá.

Can only initialize the first member of a union, can not initialize all members:

Correct:

union utag {
    int i;
    float f;
    char c;
} u1 = {100};

Wrong:

union utag u2 = {100, 31.6, 'a'};

==
(findctypedef)
typedef in C

typedef defines new type which is equivalent as original types, like an alias:

typedef int INTEGER;
INTEGER x, y;

typedef char *POINTER;
POINTER p;
//Equivalent as: char *p;

typedef struct {
    int year;
    int month;
    int day;
} DATE;

DATE birthday;

//Equivalent as:

struct {
    int year;
    int month;
    int day;
} birthday;

typedef char STRING[50];
STRING s1, s2;
//Equivalent to: char s1[50], s2[50];

Good:
Steps to use typedef:
1. Write down the ordinary definition of a variale, like: char str[50];
2. Replace the variable name with new type name, like replace "str" with "STRING" -> char STRING[50];
3. Add "typedef" in front, like: typedef char STRING[50];
4. Then can use the new type name to define variables, like: STRING s1, s2;


==
(findcmalloc)
(findcmemory)
Dynamic memory allocation and free in C

#include <stdlib.h>

int *p;
p = (int *) malloc(sizeof(int)); //Allocates a memory of size int type, p points to this memory

struct date {
    int year;
    int month;
    int day;
} *q;

q = (struct date *) malloc(sizeof(struct date));

free(p); //Free the memory pointed by p

==
(findcconstant)
Constant in C
ÂÆè in C

#define PI 3.14
int a = PI;

==
(findcfile)
(findcreadfromfile)
(findwritetofilec)
File in C
Read from file in C
Write to file in C

All the following should include:
#include "sdio.h"

//Open a file:
FILE *fp;
fp = fopen("file1", "r");

//Close a file:
fclose(fp); //Now fp no longer points to this file

//Close all files:
fcloseall();

//Get a character from file:
ch = fgetc(fp);

//Returns whether fp points to the end of file:
feof(fp);

//Write a character to file at location pointed by fp:
fputc("a", fp);
fputc(c, stdout)//Outputs character c to terminal (screen), no "" around c.

//Read a string:
fgets()

//Write a string:
fputs()

//Read and print to file
fscanf(), fprintf()

//Read binary files:
fread(), fwrite()

//Foce the pointer fp to point to the beginning of file:
rewind(fp);

//Set the pointer position
fseek(file-pinter, offset, start-point)

*** C all recorded ***

====
(findcppbegin)
C++ begins

Most of this note is from the book "C++ Primer (Fifth Edition)", by Stanley B. Lippman, Josee Lajoie, Barbara E. Moo.

Whenever it says the new standard, it means the C++ 11 standard.

==
Program files are normally referred to as a source files. Different compilers use different suffix conventions; the most common include .cc, .cxx, .cpp, .cp, and .C.

--
(findcompile)
Compile

g++ -o file_name file_name.cc

Using C++ 11, in my Thinkpad (recommended to always compile in this way in my Thinkpad):
g++ -std=c++0x -o file_name file_name.cc

When writing leetcode, I can still compile using -std=c++11 in my Thinkpad.

Using C++ 11, in Mac:
g++ -std=c++11 -o file_name file_name.cc

Simpler way to compile and run:
g++ foo.c
./a.out

--
$ g++ -o prog1 prog1.cc

The -o prog1 is an argument to the compiler and names the file in which to put the executable file. This command generates an executable file named prog1. On UNIX, executable files have no suffix; If the -o prog1 is omitted, the compiler generates an executable named a.out on UNIX systems.

--
UNIX compilers tend to put their executables in files named a.out.

To run an executable on UNIX, we use the full file name, including the file extension:
$ a.out

If we need to specify the file‚Äôs location, we‚Äôd use a ‚Äú.‚Äù followed by a forward slash to indicate that our executable is in the current directory:
$ ./a.out

--
Compilers usually include options to generate warnings about problematic constructs. It is usually a good idea to use these options. Our preference is to use -Wall with the GNU compiler.

--
Often a single error can have a cascading effect and cause a compiler to report more errors than actually are present.

--
Some languages, such as Smalltalk and Python, check types at run time. In contrast, C++ is a statically typed language; type checking is done at compile time. As a consequence, the compiler must know the type of every name used in the program.

Key Concept: Static Typing

C++ is a statically typed language, which means that types are checked at compile time. The process by which types are checked is referred to as type checking.

As we‚Äôve seen, the type of an object constrains the operations that the
object can perform. In C++, the compiler checks whether the operations we write are supported by the types we use. If we try to do things that the type does not support, the compiler generates an error message and does not produce an executable file.

As our programs get more complicated, we‚Äôll see that static type checking can help find bugs. However, a consequence of static checking is that the type of every entity we use must be known to the compiler. As one example, we must declare the type of a variable before we can use that variable.

==
Sample C++ program:

#include<iostream>
using namespace std;
//using std::cout; <- can also use this

int main() {
    double a = 2.6;
    cout << a << endl;
    return 0;
}

Note that the main() function should be outside any class, which is opposite to Java.

--
On most systems, the value returned from main is a status indicator. A return value of 0 indicates success. A nonzero return has a meaning that is defined by the system. Ordinarily a nonzero return indicates what kind of error occurred.

A return value of -1 is often treated as an indicator that the program failed.

--
(findcomment)
Comments

There are two kinds of comments in C++: single-line and paired. A single-line comment starts with a double slash (//) and ends with a newline.

The other kind of comment uses two delimiters (/* and */) that are inherited from C.

Our style is to begin each line in the comment with an asterisk, thus indicating that the entire range is part of a multiline comment.

#include <iostream>
/*
 * Simple main function:
 * Read two numbers and write their sum
 */
int main()
{
    ...
}

When you change your code, be sure to update the comments, too!

A comment that begins with /* ends with the next */. As a result, one comment pair cannot appear inside another. The compiler error messages that result from this kind of mistake can be mysterious and confusing.

We often need to comment out a block of code during debugging. Because that code might contain nested comment pairs, the best way to comment a block of code is to insert single-line comments at the beginning of each line in the section we want to ignore.

==
(findgooglestyle)
Google C++ Style Guide:

https://google.github.io/styleguide/cppguide.html

==
Google's naming conventions:

(https://google.github.io/styleguide/cppguide.html#General_Naming_Rules)

Naming
The most important consistency rules are those that govern naming. The style of a name immediately informs us what sort of thing the named entity is: a type, a variable, a function, a constant, a macro, etc., without requiring us to search for the declaration of that entity. The pattern-matching engine in our brains relies a great deal on these naming rules.

Naming rules are pretty arbitrary, but we feel that consistency is more important than individual preferences in this area, so regardless of whether you find them sensible or not, the rules are the rules.

General Naming Rules
Names should be descriptive; avoid abbreviation.

Give as descriptive a name as possible, within reason. Do not worry about saving horizontal space as it is far more important to make your code immediately understandable by a new reader. Do not use abbreviations that are ambiguous or unfamiliar to readers outside your project, and do not abbreviate by deleting letters within a word. Abbreviations that would be familiar to someone outside your project with relevant domain knowledge are OK. As a rule of thumb, an abbreviation is probably OK if it's listed in Wikipedia.

int price_count_reader;    // No abbreviation.
int num_errors;            // "num" is a widespread convention.
int num_dns_connections;   // Most people know what "DNS" stands for.
int lstm_size;             // "LSTM" is a common machine learning abbreviation.
int n;                     // Meaningless.
int nerr;                  // Ambiguous abbreviation.
int n_comp_conns;          // Ambiguous abbreviation.
int wgc_connections;       // Only your group knows what this stands for.
int pc_reader;             // Lots of things can be abbreviated "pc".
int cstmr_id;              // Deletes internal letters.
FooBarRequestInfo fbri;    // Not even a word.
Note that certain universally-known abbreviations are OK, such as i for an iteration variable and T for a template parameter.

For some symbols, this style guide recommends names to start with a capital letter and to have a capital letter for each new word (a.k.a. "Camel Case" or "Pascal case"). When abbreviations or acronyms appear in such names, prefer to capitalize the abbreviations or acronyms as single words (i.e StartRpc(), not StartRPC()).

Template parameters should follow the naming style for their category: type template parameters should follow the rules for type names, and non-type template parameters should follow the rules for variable names.

File Names

Filenames should be all lowercase and can include underscores (_) or dashes (-). Follow the convention that your project uses. If there is no consistent local pattern to follow, prefer "_".

Examples of acceptable file names:

my_useful_class.cc
my-useful-class.cc
myusefulclass.cc
myusefulclass_test.cc // _unittest and _regtest are deprecated.

C++ files should end in .cc and header files should end in .h. Files that rely on being textually included at specific points should end in .inc (see also the section on self-contained headers).

Do not use filenames that already exist in /usr/include, such as db.h.

In general, make your filenames very specific. For example, use http_server_logs.h rather than logs.h. A very common case is to have a pair of files called, e.g., foo_bar.h and foo_bar.cc, defining a class called FooBar.

Type Names

Type names start with a capital letter and have a capital letter for each new word, with no underscores: MyExcitingClass, MyExcitingEnum.

The names of all types ‚Äî classes, structs, type aliases, enums, and type template parameters ‚Äî have the same naming convention. Type names should start with a capital letter and have a capital letter for each new word. No underscores. For example:

// classes and structs
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedefs
typedef hash_map<UrlTableProperties *, string> PropertiesMap;

// using aliases
using PropertiesMap = hash_map<UrlTableProperties *, string>;

// enums
enum UrlTableErrors { ...

Variable Names

The names of variables (including function parameters) and data members are all lowercase, with underscores between words. Data members of classes (but not structs) additionally have trailing underscores. For instance: a_local_variable, a_struct_data_member, a_class_data_member_.

Common Variable names

For example:

string table_name;  // OK - uses underscore.
string tablename;   // OK - all lowercase.
string tableName;   // Bad - mixed case.

Class Data Members

Data members of classes, both static and non-static, are named like ordinary nonmember variables, but with a trailing underscore.

class TableInfo {
  ...
 private:
  string table_name_;  // OK - underscore at end.
  string tablename_;   // OK.
  static Pool<TableInfo>* pool_;  // OK.
};

Struct Data Members

Data members of structs, both static and non-static, are named like ordinary nonmember variables. They do not have the trailing underscores that data members in classes have.

struct UrlTableProperties {
  string name;
  int num_entries;
  static Pool<UrlTableProperties>* pool;
};
See Structs vs. Classes for a discussion of when to use a struct versus a class.

Constant Names

Variables declared constexpr or const, and whose value is fixed for the duration of the program, are named with a leading "k" followed by mixed case. Underscores can be used as separators in the rare cases where capitalization cannot be used for separation. For example:

const int kDaysInAWeek = 7;
const int kAndroid8_0_0 = 24;  // Android 8.0.0
All such variables with static storage duration (i.e. statics and globals, see Storage Duration for details) should be named this way. This convention is optional for variables of other storage classes, e.g. automatic variables, otherwise the usual variable naming rules apply.

Function Names

Regular functions have mixed case; accessors and mutators may be named like variables.

Ordinarily, functions should start with a capital letter and have a capital letter for each new word.

AddTableEntry()
DeleteUrl()
OpenFileOrDie()

(The same naming rule applies to class- and namespace-scope constants that are exposed as part of an API and that are intended to look like functions, because the fact that they're objects rather than functions is an unimportant implementation detail.)

Accessors and mutators (get and set functions) may be named like variables. These often correspond to actual member variables, but this is not required. For example, int count() and void set_count(int count).

==
(findtype)
(finddatatype)                 
Data types

C++ defines a set of primitive types that include the arithmetic types and a special type named void. The arithmetic types represent characters, integers, boolean values, and floating-point numbers. The void type has no associated values and can be used in only a few circumstances, most commonly as the return type for functions that do
not return a value.

Arithmetic Types

The arithmetic types are divided into two categories: integral types (which include character and boolean types, tao: should also include int) and floating-point types.

Tao: integral types means: int, character, boolean types. The concept of integral types will be used later.

The size of‚Äîthat is, the number of bits in‚Äîthe arithmetic types varies across machines. The standard guarantees minimum sizes as listed in the following table. However, compilers are allowed to use larger sizes for these types. 

Type         Meaning                            Minimum Size   
bool         boolean                            NA
char         character                          8 bits
wchar_t      wide character                     16 bits
char16_t     Unicode character                  16 bits
char32_t     Unicode character                  32 bits
short        short integer                      16 bits
int          integer                            16 bits
long         long integer                       32 bits
long long    long integer                       64 bits
float        single-precision floating-point    6 significant digits
double       double-precision floating-point    10 significant digits
long double  exteneded-precision floating-point 10 significant digits

A simpler version of the above table:

Type     Minimum Size
bool     NA
char     8 bits
int      16 bits
long     32 bits
float    6 significant digits
double   10 siginifcant digits

1 byte = 8 bits
On most machines a byte contains 8 bits and a word is either 32 or 64 bits.
(Remember: "byte" is longer than "bit")

A char is the same size as a single machine byte.

Unicode is a standard for representing characters used in essentially any natural language.

Typically, floats are represented in one word (32 bits), doubles in two words (64 bits).

--
Tao: the following is very helpful on understanding how data types are stored in memory:

Machine-Level Representation of the Built-in Types

Computers store data as a sequence of bits, each holding a 0 or 1, such as

00011011011100010110010000111011 ...

Most computers deal with memory as chunks of bits of sizes that are powers of 2. The smallest chunk of addressable memory is referred to as a ‚Äúbyte.‚Äù The basic unit of storage, usually a small number of bytes, is referred to as a ‚Äúword.‚Äù In C++ a byte has at least as many bits as are needed to hold a character in the machine‚Äôs basic character set. On most machines a byte contains 8 bits and a word is either 32 or 64 bits, that is, 4 or 8 bytes. Tao: So we know the size of byte and word is machine dependent.

Most computers associate a number (called an ‚Äúaddress‚Äù) with each byte in memory. On a machine with 8-bit bytes and 32-bit words, we might view a word of memory as follows

736424: 0 0 1 1 1 0 1 1
736425: 0 0 0 1 1 0 1 1
736426: 0 1 1 1 0 0 0 1
736427: 0 1 1 0 0 1 0 0 

Here, the byte‚Äôs address is on the left, with the 8 bits of the byte following the address.

We can use an address to refer to any of several variously sized collections of bits starting at that address. It is possible to speak of the word at address 736424 or the byte at address 736427. To give meaning to memory at a given address, we must know the type of the value stored there. The type determines how many bits are used and how to interpret those bits.

If the object at location 736424 has type float and if floats on this
machine are stored in 32 bits, then we know that the object at that address spans the entire word. The value of that float depends on the details of how the machine stores floating-point numbers. Alternatively, if the object at location 736424 is an unsigned char on a machine using the ISO-Latin-1 character set, then the byte at that address represents a semicolon.

--
Signed and Unsigned Types

Except for bool and the extended character types, the integral types may be signed or unsigned. A signed type represents negative or positive numbers (including zero); an unsigned type represents only values greater than or equal to zero.

The types int, short, long, and long long are all signed. We obtain the
corresponding unsigned type by adding unsigned to the type, such as unsigned long. The type unsigned int may be abbreviated as unsigned.

Unlike the other integer types, there are three distinct basic character types: char, signed char, and unsigned char. In particular, char is not the same type as signed char. Although there are three character types, there are only two representations: signed and unsigned. The (plain) char type uses one of these representations. Which of the other two character representations is equivalent to char depends on the compiler.

In an unsigned type, all the bits represent the value. For example, an 8-bit unsigned char can hold the values from 0 through 255 inclusive.

Tao: 

 11,111,111 = 255
100,000,000 = 256 (2^8)

The standard does not define how signed types are represented, but does specify that the range should be evenly divided between positive and negative values. Hence, an 8-bit signed char is guaranteed to be able to hold values from ‚Äì127 through 127; most modern machines use representations that allow values from ‚Äì128 through 127.

--
Advice: Deciding which Type to Use

C++, like C, is designed to let programs get close to the hardware when
necessary. 

A few rules of thumb can be useful in deciding which type to use:

‚Ä¢ Use an unsigned type when you know that the values cannot be negative.

‚Ä¢ Use int for integer arithmetic. short is usually too small and, in practice, long often has the same size as int. If your data values are larger than the minimum guaranteed size of an int, then use long long.

‚Ä¢ Do not use plain char or bool in arithmetic expressions. Use them only to hold characters or truth values. Computations using char are especially problematic because char is signed on some machines and unsigned on others. If you need a tiny integer, explicitly specify either signed char or unsigned char.

‚Ä¢ Use double for floating-point computations; float usually does not have enough precision, and the cost of double-precision calculations versus single-precision is negligible. In fact, on some machines, double-precision operations are faster than single. The precision offered by long double usually is unnecessary and often entails considerable run-time cost.

--
(findbool)
bool:

bool test = false; // The words true and false are literals of type bool

bool b = 42;
int i = b; // i has value 1

When we assign one non-bool types to a bool, the result is false if the value is 0, and true otherwise.

When we use a bool in an arithmetic expression, its value always converts to either 0 or 1.

The word nullptr is a pointer literal.

It is usually a bad idea to use the boolean literals true and false as operands in a comparison. For example:
if (val == true) { /* ...   */ }

Better way:
if (val)  { /*  ...  */ }

--
(findcast)
(findconvertdatatype)
(findtypeconversion)
Cast
Convert data types

//string -> int
#include <string>  
string str1 = "45";
int myint1 = stoi(str1); // myint1 = 45

//int -> string
int a = std::to_string(28); // a = "28"

//string -> double
string stest = "0.21";
double dtest = stod(stest);

//double -> string
string pi = std::to_string(3.1415926); // pi = "3.1415926" 

//int -> double
int a = 2;
double b = (double) a;

//double -> int
double a = 3.0;
double b = (int) a;

//char -> string
//constructor string s(int n, char x): Create a string of size n and fill the string with character x.
string s(1, 'a'); //s = "a"

--
cast:

The above "(int) a" is the old-style C++ casts. New styles are followings.

Although necessary at times, casts are inherently dangerous constructs.

Named Casts

A named cast has the following form:
cast-name<type>(expression);

where type is the target type of the conversion, and expression is the value to be cast. The cast-name may be one of static_cast, dynamic_cast, const_cast, and reinterpret_cast.

Old-style casts are less visible than are named casts. Because they are easily overlooked, it is more difficult to track down a rogue(ÊµÅÊ∞ì) cast.

==
Type Conversions

bool b = 42; // b is true

When we assign one of the nonbool arithmetic types to a bool object, the result is false if the value is 0 and true otherwise.

--
int i = b; // i has value 1

When we assign a bool to one of the other arithmetic types, the resulting value is 1 if the bool is true and 0 if the bool is false.

--
i = 3.14; // i has value 3

When we assign a floating-point value to an object of integral type, the value is truncated. The value that is stored is the part before the decimal point.

--
double pi = i; // pi has value 3.0

When we assign an integral value to an object of floating-point type, the fractional part is zero. Precision may be lost if the integer has more bits than the floating-point object can accommodate.

--
unsigned char c = -1; // assuming 8-bit chars, c has value 255

If we assign an out-of-range value to an object of unsigned type, the result is the remainder of the value modulo the number of values the target type can hold. For example, an 8-bit unsigned char can hold values from 0 through 255, inclusive. If we assign a value outside this range, the compiler assigns the remainder of that value modulo 256. Therefore, assigning ‚Äì1 to an 8-bit unsigned char gives that object the value 255.

--
signed char c2 = 256; // assuming 8-bit chars, the value of c2 is undefined

If we assign an out-of-range value to an object of signed type, the result is undefined. The program might appear to work, it might crash, or it might produce garbage values.

--
The compiler applies these same type conversions when we use a value of one arithmetic type where a value of another arithmetic type is expected.

int i = 42;
if (i) // condition will evaluate as true
    i = 0;

By the same token, when we use a bool in an arithmetic expression, its value always converts to either 0 or 1. As a result, using a bool in an arithmetic expression is almost surely incorrect.

// WRONG: u can never be less than 0; the condition will always succeed
for (unsigned u = 10; u >= 0; --u)
    std::cout << u << std::endl;

Caution: Don‚Äôt Mix Signed and Unsigned Types

Expressions that mix signed and unsigned values can yield surprising results when the signed value is negative. It is essential to remember that signed values are automatically converted to unsigned.

--
Programs usually should avoid implementation-defined behavior, such as assuming that the size of an int is a fixed and known value. Such programs are said to be nonportable.

==
(findtypealias)
(findtypedef)
Type alias
typedef

A type alias is a name that is a synonym(ÂêåÁæ©Ë©û) for another type. Type aliases let us simplify complicated type definitions, making those types easier to use. 

We can define a type alias in one of two ways. Traditionally, we use a typedef:

typedef double wages; // wages is a synonym for double
typedef wages base, *p; // base is a synonym for double, p for double*

The new standard introduced a second way to define a type alias, via an alias declaration:

using SI = Sales_item; // SI is a synonym for Sales_item

wages hourly, weekly; // same as double hourly, weekly;
SI item; // same as Sales_item item

using pos = std::string::size_type; // pos is a synonym for std::string::size_type

--
(findauto)
auto

(Tao deliberately put auto in front of decltype)

It is not uncommon to want to store the value of an expression in a variable. To declare the variable, we have to know the type of that expression. When we write a program, it can be surprisingly difficult‚Äîand sometimes even impossible‚Äîto
determine the type of an expression. Under the new standard, we can let the compiler figure out the type for us by using the auto type specifier. Unlike type specifiers, such as double, that name a specific type, auto tells the compiler to deduce the type from the initializer. By implication, a variable that uses auto as its type specifier must have an initializer:

auto item = val1 + val2; // the type of item is deduced from the type of the result of adding val1 and val2, item initialized to the result of val1 + val2

Here the compiler will deduce the type of item from the type returned by applying + to val1 and val2. If val1 and val2 are Sales_item objects, item will have type Sales_item. If those variables are type double, then item has type double, and so on.

As with any other type specifier, we can define multiple variables using auto. Because a declaration can involve only a single base type, the initializers for all the variables in the declaration must have types that are consistent with each other:

auto i = 0, *p = &i; // ok: i is int and p is a pointer to int
auto sz = 0, pi = 3.14; // error: inconsistent types for sz and pi

when we use a reference as an initializer, the initializer is the corresponding object. The compiler uses that object‚Äôs type for auto‚Äôs type deduction:

int i = 0, &r = i;
auto a = r; // a is an int (r is an alias for i, which has type int)

Second, auto ordinarily ignores top-level consts. As usual in
initializations, low-level consts, such as when an initializer is a pointer to const, are kept:

const int ci = i, &cr = ci;
auto b = ci; // b is an int (top-level const in ci is dropped)
auto c = cr; // c is an int (cr is an alias for ci whose const is top-level)
auto d = &i; // d is an int*(& of an int object is int*)
auto e = &ci; // e is const int*(& of a const object is low-level const)

If we want the deduced type to have a top-level const, we must say so explicitly:

const auto f = ci; // deduced type of ci is int; f has type const int

--
(finddecltype)
decltype

Sometimes we want to define a variable with a type that the compiler deduces from an expression but do not want to use that expression to initialize the variable. For such cases, the new standard introduced a second type specifier, decltype, which
returns the type of its operand. The compiler analyzes the expression to determine its type but does not evaluate the expression:

decltype(f()) sum = x; // sum has whatever type f returns

Here, the compiler does not call f, but it uses the type that such a call would return as the type for sum. That is, the compiler gives sum the same type as the type that would be returned if we were to call f.

The way decltype handles top-level const and references differs subtly from the way auto does. When the expression to which we apply decltype is a variable, decltype returns the type of that variable, including top-level const and references:

const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x has type const int
decltype(cj) y = x; // y has type const int& and is bound to x
decltype(cj) z; // error: z is a reference and must be initialized

Because cj is a reference, decltype(cj) is a reference type. Like any other reference, z must be initialized.

It is worth noting that decltype is the only context in which a variable defined as a reference is not treated as a synonym for the object to which it refers.

decltype and References

When we apply decltype to an expression that is not a variable, we get the type that that expression yields. As we‚Äôll see later, some expressions will cause decltype to yield a reference type. Generally speaking, decltype returns a reference type for expressions that yield objects that can stand on the left-hand side of the assignment:

// decltype of an expression can be a reference type
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; // ok: addition yields an int; b is an (uninitialized) int
decltype(*p) c; // error: c is int& and must be initialized. Tao: note &i means the address of i, &i has nothing to do with reference.

Here r is a reference, so decltype(r) is a reference type. If we want the type to which r refers, we can use r in an expression, such as r + 0, which is an expression that yields a value that has a nonreference type.

On the other hand, the dereference operator is an example of an expression for which decltype returns a reference. As we‚Äôve seen, when we dereference a pointer, we get the object to which the pointer points. Moreover, we can assign to that object.
Thus, the type deduced by decltype(*p) is int&, not plain int.

Another important difference between decltype and auto is that the deduction done by decltype depends on the form of its given expression. What can be confusing is that enclosing the name of a variable in parentheses affects the type returned by decltype. When we apply decltype to a variable without any parentheses, we get the type of that variable. If we wrap the variable‚Äôs name in one or more sets of parentheses, the compiler will evaluate the operand as an expression. A variable is an expression that can be the left-hand side of an assignment. As a result, decltype on such an expression yields a reference:

// decltype of a parenthesized variable is always a reference
decltype((i)) d; // error: d is int& and must be initialized
decltype(i) e; // ok: e is an (uninitialized) int

Remember that decltype((variable)) (note, double parentheses) is always a reference type, but decltype(variable) is a reference type only if variable is a reference.

==
(findliteral)
Literals

A value, such as 42, is known as a literal because its value self-evident. Every literal has a type. The form and value of a literal determine its type.

Integer and Floating-Point Literals

We can write an integer literal using decimal(ÂçÅÈÄ≤Âà∂), octal(ÂÖ´ÈÄ≤Âà∂), or hexadecimal(ÂçÅÂÖ≠ÈÄ≤Âà∂) notation (Ê≥®ÊÑèÊ≤íÊúâ‰∫åÈÄ≤Âà∂!). Integer literals that begin with 0 (zero) are interpreted as octal. Those that begin with either 0x or 0X are interpreted as hexadecimal. For example, we can write the value 20 in any of the following three ways:

20: decimal 
024: octal
0x14: hexadecimal

The type of an integer literal depends on its value and notation. By default, decimal literals are signed whereas octal and hexadecimal literals can be either signed or unsigned types. A decimal literal has the smallest type of int, long, or long long (i.e., the first type in this list) in which the literal‚Äôs value fits. We‚Äôll see in the following table that we can override these defaults by using a suffix.

Specifying the Type of a Literal

Character and Character String Literals (tao: note it is prefix, not suffix):

Prefix  Type       Meaning     
u       char16_t   Unicode 16 character
U       char32_t   Unicode 32 character
L       wchar_t    wide character
u8      char       utf-8 (string literals only)

Integer Literals:

Suffix     Minimum Type
u or U     unsinged
l or L     long
ll or LL   long long

Floating-Point Literals:

Suffix     Type
f or F     float
l or L     long double

Although integer literals may be stored in signed types, technically speaking, the value of a decimal literal is never a negative number. If we write what appears to be a negative decimal literal, for example, -42, the minus sign is not part of the literal. The minus sign is an operator that negates the value of its (literal) operand.

Floating-point literals include either a decimal point or an exponent specified using scientific notation. Using scientific notation, the exponent is indicated by either E or e:

3.14159   3.14159E0   0.   0e0   .001

By default, floating-point literals have type double. We can override the default using a suffix from the above table.

--
Character and Character String Literals

A character enclosed within single quotes is a literal of type char. Zero or more characters enclosed in double quotation marks is a string literal:

'a' // character literal
"Hello World!" // string literal

The type of a string literal is array of constant chars (tao: not a library string type!), a type we‚Äôll discuss later. The compiler appends a null character (‚Äô\0‚Äô) (tao: not a null pointer) to every string literal. Thus, the actual size of a string literal is one more than its apparent size. For example, the literal 'A' represents the single character A, whereas the string literal "A" represents an array of two characters, the letter A and the null character.

Two string literals that appear adjacent to one another and that are separated only by spaces, tabs, or newlines are concatenated into a single literal. We use this form of literal when we need to write a literal that would otherwise be too large to fit comfortably on a single line:

// multiline string literal
std::cout << "a really, really long string literal "
             "that spans two lines" << std::endl;

--
(findescape)
Escape Sequences

Some characters, such as backspace or control characters, have no visible image. Such characters are nonprintable. Other characters (single and double quotation marks, question mark, and backslash) have special meaning in the language. Our programs cannot use any of these characters directly. Instead, we use an escape sequence to represent such characters. An escape sequence begins with a backslash. The language
defines several escape sequences:

newline \n 
horizontal tab \t 
alert (bell) \a
vertical tab \v 
backspace \b 
double quote \"
backslash \\ 
question mark \? 
single quote \'
carriage return \r 
formfeed \f

We use an escape sequence as if it were a single character:

std::cout << '\n'; // prints a newline
std::cout << "\tHi!\n"; // prints a tab followd by "Hi!" and a newline

We can also write a generalized escape sequence, which is \x followed by one or more hexadecimal digits or a \ followed by one, two, or three octal digits. The value represents the numerical value of the character. Some examples (assuming the Latin-1 character set):

\7 (bell) \12 (newline) \40 (blank)
\0 (null) \115 ('M') \x4d ('M')

--
Boolean and Pointer Literals

The words true and false are literals of type bool:

bool test = false;

The word nullptr is a pointer literal. We‚Äôll have more to say about pointers and nullptr later.

==
(findvariable)
Variables

A variable provides us with named storage that our programs can manipulate. Each variable in C++ has a type. The type determines the size and layout of the variable‚Äôs memory, the range of values that can be stored within that memory, and the set of operations that can be applied to the variable. C++ programmers tend to refer to variables as ‚Äúvariables‚Äù or ‚Äúobjects‚Äù interchangeably.

C++ programmers tend to be cavalier in their use of the term object. Most generally, an object is a region of memory that can contain data and has a type.

In this book, we‚Äôll follow the more general usage that an object is a region of memory that has a type. We will freely use the term object regardless of whether the object has built-in or class type, is named or unnamed, or can be read or written.

// string is a library type, representing a variable-length sequence of characters
std::string book("0-201-78345-X"); // book initialized from string
literal

The string library gives us several ways to initialize string objects. One of these ways is as a copy of a string literal.

==
(findidentifier)
Identifiers

Identifiers in C++ can be composed of letters, digits, and the underscore character. The language imposes no limit on name length. Identifiers must begin with either a letter or an underscore. Identifiers are case-sensitive; upper- and lowercase letters are
distinct:

// defines four different int variables
int somename, someName, SomeName, SOMENAME;

The identifiers we define in our own programs may not contain two consecutive underscores, nor can an identifier begin with an underscore followed immediately by an uppercase letter. In addition, identifiers defined outside a function may not begin with an underscore.

The language reserves a set of names for its own use. These names may not be used as identifiers.

Conventions for Variable Names

There are a number of generally accepted conventions for naming variables. Following these conventions can improve the readability of a program.

‚Ä¢ An identifier should give some indication of its meaning.
‚Ä¢ Variable names normally are lowercase‚Äîindex, not Index or INDEX.
‚Ä¢ Like Sales_item, classes we define usually begin with an uppercase letter.
‚Ä¢ Identifiers with multiple words should visually distinguish each word, for example, student_loan or studentLoan, not studentloan.

==
(findscope)
Scope of a Name

A scope is a part of the program in which a name has a particular meaning. Most scopes in C++ are delimited by curly braces.

The same name can refer to different entities in different scopes. Names are visible from the point where they are declared until the end of the scope in which the declaration appears.

(Some code here)

The name main‚Äîlike most names defined outside a function‚Äîhas global scope. Once declared, names at the global scope are accessible throughout the program. The name sum is defined within the scope of the block that is the body of the main function. It is accessible from its point of declaration throughout the rest of the main function but not outside of it. The variable sum has block scope.

Scopes can contain other scopes. The contained (or nested) scope is referred to as an inner scope, the containing scope is the outer scope.
Once a name has been declared in a scope, that name can be used by scopes nested inside that scope. Names declared in the outer scope can also be redefined in an inner scope.

It is almost always a bad idea to define a local variable with the same name as a global variable that the function uses or might use.

==
(findinitialization)
Intialization:

An object that is initialized gets the specified value at the moment it is created. The values used to initialize a variable can be arbitrarily complicated expressions.

Initialization in C++ is a surprisingly complicated topic and one we will return to again and again. Many programmers are confused by the use of the = symbol to initialize a variable. It is tempting to think of initialization as a form of assignment, but initialization and assignment are different operations in C++. This concept is particularly confusing because in many languages the distinction is irrelevant and can be ignored. Moreover, even in C++ the distinction often doesn‚Äôt matter. Nonetheless, it is a crucial concept and one we will reiterate throughout the text.

Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object‚Äôs current value and replaces that value with a new one.

--
(findlistinitialization)
List Initialization

One way in which initialization is a complicated topic is that the language defines several different forms of initialization. For example, we can use any of the following four different ways to define an int variable named a and initialize it to 0:

int a = 0;
int a = {0}; // tao: list initialization (confirmed)
int a{0}; // tao: list initialization (confirmed)
int a(0);

The generalized use of curly braces for initialization was introduced as part of the new standard. This form of initialization previously had been allowed only in more restricted ways. For reasons we‚Äôll learn about later, this form of initialization is referred to as list initialization (tao: see example below). Braced lists of initializers can now be used whenever we initialize an object and in some cases when we assign a new value
to an object.

When used with variables of built-in type, this form of initialization has one important property: The compiler will not let us list initialize variables of built-in type if the initializer might lead to the loss of information:

long double ld = 3.1415926536;
int a{ld}, b = {ld}; // error: narrowing conversion required
int c(ld), d = ld; // ok: but value will be truncated

--
(finddefaultinitialization)
Default Initialization

When we define a variable without an initializer, the variable is default initialized. Such variables are given the ‚Äúdefault‚Äù value. What that default value is depends on the type of the variable and may also depend on where the variable is defined.

The value of an object of built-in type that is not explicitly initialized depends on where it is defined. Variables defined outside any function body are initialized to zero. With one exception, which we cover later, variables of built-in type defined inside a function are uninitialized. The value of an uninitialized variable of built-in type is undefined. It is an error to copy or otherwise try to access the value of a variable whose value is undefined.

Each class controls how we initialize objects of that class type. In particular, it is up to the class whether we can define objects of that type without an initializer. If we can, the class determines what value the resulting object will have.

Most classes let us define objects without explicit initializers. Such classes supply an appropriate default value for us. For example, as we‚Äôve just seen, the library string class says that if we do not supply an initializer, then the resulting string is the empty string:

std::string empty; // empty implicitly initialized to the empty string
Sales_item item; // default-initialized Sales_item object

Some classes require that every object be explicitly initialized. The compiler will complain if we try to create an object of such a class with no initializer.

Tao's practice:

If we create an array of built-in type inside a function using new as below (remember we must use new if we want to return the array or its elments, recored in this note), the values of the elements are also undefined:

bool *res = new bool[n];

//Note that the following initialization to res[i] is necessary, otherwise the values of res[i] is not defined (values are different in my computer and Leetcode OJ)
for(int i = 1; i <= n; ++i) res[i] = false;

For the above, I later used vector:
vector<bool> res(n, false);

--
If we do not initialize a string, then it is an empty string. (Seems different from Java).

--
We recommend initializing every object of built-in type. It is not always necessary, but it is easier and safer to provide an initializer until you can be certain it is safe to omit the initializer.

--
(findvalueinitialization)
Value Initialization

Tao: from the following, I conclude that value initialization is just another name of default initialization.

Copied from elsewhere in this note:

If a local static has no explicit initializer, it is value initialized, meaning that local statics of built-in type are initialized to zero.

The default constructor is used automatically whenever an object is default or value initialized.

--
(finddirectinitialization1)
(findcopyinitialization1)
Direct and copy initialization 1

Sales_data item1(null_book); // direct initialization
Sales_data item2 = null_book; // the copy form of initialization 

Tao: for the direct initialization of primitive types: a(2), think about the initialization via constructor in the direct initialization example above: item1(null_book)

Summary from below (it is a waste of time to suspect this summary):

Direct initialization means to use (), eg: a(b)
Copy initialization means to =, eg: a = b

Copied from "find string":

Direct and Copy Forms of Initialization 

Earlier we saw that C++ has several different forms of initialization. Using strings, we can start to understand how these forms differ from one another. When we initialize a variable using =, we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created. Otherwise, when we omit the =, we use direct initialization.

When we have a single initializer, we can use either the direct or copy form of initialization. When we initialize a variable from more than one value, such as in the initialization of s4 above, we must use the direct form of initialization:

string s5 = "hiya"; // copy initialization
string s6("hiya"); // direct initialization
string s7(10, 'c'); // direct initialization; s7 is cccccccccc

==
(finddeclaration)
(finddefinition)
declaration
definition

Separate compilation lets us split our programs into several files, each of which can be compiled independently.

An uninitialized variable has an indeterminate value. Trying to use the value of an uninitialized variable is an error that is often hard to debug.

To support separate compilation, C++ distinguishes between declarations and definitions. A declaration makes a name known to the program. A file that wants to use a name defined elsewhere includes a declaration for that name. A definition creates the associated entity.

Every name used in a C++ program must be declared before it is used.

A variable declaration specifies the type and name of a variable. A variable definition is a declaration. In addition to specifying the name and type, a definition also allocates storage and may provide the variable with an initial value.

To obtain a declaration that is not also a definition, we add the extern keyword and may not provide an explicit initializer:

extern int i; // declares but does not define i
int j; // declares and defines j

Any declaration that includes an explicit initializer is a definition. We can provide an initializer on a variable defined as extern, but doing so overrides the extern. An extern that has an initializer is a definition:

extern double pi = 3.1416; // definition

It is an error to provide an initializer on an extern inside a function.

Variables must be defined exactly once but can be declared many times.

The distinction between a declaration and a definition may seem obscure at this point but is actually important. To use a variable in more than one file requires declarations that are separate from the variable‚Äôs definition. To use the same variable in multiple files, we must define that variable in one‚Äîand only one‚Äîfile. Other files that use that variable must declare‚Äîbut not define‚Äîthat variable.

It is usually a good idea to define an object near the point at which the object is first used. Doing so improves readability by making it easy to find the definition of the variable. More importantly, it is often easier to give the variable a useful initial value when the variable is defined close to where it is first used.

==
(findmax)
max

#include <algorithm>  

max(1, 2)

==
(findintmax)
(findmaxint)
(findintmin)
(findminint)
INT_MAX and INT_MIN

From geeksforgeeks:

Most of the times, in competitive programming, there is a need to assign the variable, the maximum or minimum value that data type can hold, but remembering such a large and precise number comes out to be a difficult job. Therefore, C++ has certain macros to represent these numbers, so that these can be directly assigned to the variable without actually typing the whole number.

INT_MAX is a macro that specifies that an integer variable cannot store any value beyond this limit.
INT_MIN specifies that an integer variable cannot store any value below this limit.

Values of INT_MAX and INT_MIN may vary from compiler to compiler. Following are typical values in a compiler where integers are stored using 32 bits.

Value of INT_MAX is +2147483647.
Value of INT_MIN is -2147483648.

// C++ program to print values of INT_MAX 
// and INT_MIN 

#include <climits> 

int main() { 
   printf("%d\n", INT_MAX); //Output: 2147483647, which equals 2^31 ‚àí 1
   printf("%d", INT_MIN); //Output: -2147483648, which equals ‚àí2^31
   return 0; 
} 

==
(findheader)
(findinclude)
Headers

Need to include when use:

#include <iostream>
#include <string>
#include <vector>
#include <iterator>
cctype //islower(c), tolower(c)
container header
container adaptor
iterator
algorithm
tuple
bind

using namespace std;

--
Although as we‚Äôll see later, we can define a class inside a function, such classes have limited functionality. As a result, classes ordinarily are not defined inside functions. When we define a class outside of a function, there may be only one
definition of that class in any given source file. In addition, if we use a class in several different files, the class‚Äô definition must be the same in each file.

In order to ensure that the class definition is the same in each file, classes are usually defined in header files. Typically, classes are stored in headers whose name derives from the name of the class. For example, the string library type is defined in
the string header. Similarly, as we‚Äôve already seen, we will define our Sales_data class in a header file named Sales_data.h.

Headers (usually) contain entities (such as class definitions and const and constexpr variables) that can be defined only once in any given file. However, headers often need to use facilities from other headers. For example, because our Sales_data class has a string member, Sales_data.h must #include the string header. As we‚Äôve seen, programs that use Sales_data also need to include the string header in order to use the bookNo member. As a result, programs that use Sales_data will include the string header twice: once directly and once as a side effect of including Sales_data.h. Because a header might be included more than once, we need to write our headers in a way that is safe even if the header is included multiple times (tao: the solution is to use the preprocessor, search for "find preprocessor").

Whenever a header is updated, the source files that use that header must be recompiled to get the new or changed declarations.

--
Advice: Use the C++ Versions of C Library Headers

In addition to facilities defined specifically for C++, the C++ library incorporates the C library. Headers in C have names of the form name .h. The C++ versions of these headers are named c name‚Äîthey remove the .h suffix and precede the name with the letter c. The c indicates that the header is part of the C library.

Hence, cctype has the same contents as ctype.h, but in a form that is appropriate for C++ programs. In particular, the names defined in the cname headers are defined inside the std namespace, whereas those defined in the .h versions are not.

Ordinarily, C++ programs should use the cname versions of headers and not the name .h versions. That way names from the standard library are consistently found in the std namespace. Using the .h headers puts the burden on the programmer to remember which library names are inherited from C and which are unique to C++.

--
(findpreprocessor)
preprocessor

The most common technique for making it safe to include a header multiple times relies on the preprocessor. The preprocessor is a program that runs before the compiler and changes the source text of our programs. Our programs already rely on one preprocessor facility, #include. When the preprocessor sees a #include, it replaces the #include with the contents of the specified header.

C++ programs also use the preprocessor to define header guards. Header guards rely on preprocessor variables. Preprocessor variables have one of two possible states: defined or not defined. The #define directive takes a name and defines that name as a preprocessor variable. There are two other directives that test whether a given preprocessor variable has or has not been defined: #ifdef is true if the variable has been defined, and #ifndef is true if the variable has not been defined. If the test is true, then everything following the #ifdef or #ifndef is processed up to the matching #endif.

We can use these facilities to guard against multiple inclusion as follows:

tao: the following is the .h file which defines Sales_data. The benefit of the preprocessor in this .h file is that this .h file can be included in multiple files, and there will be no conflict, because SALES_DATA_H will be defined in the first file that includes this .h file, other files will have ifndef = false and will not execute this .h file.

#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
#endif

Warning: Preprocessor variable names do not respect C++ scoping rules.

Preprocessor variables, including names of header guards, must be unique throughout the program. To avoid name clashes with other entities in our programs, preprocessor variables usually are written in all uppercase.

Headers should have guards, even if they aren‚Äôt (yet) included by another header. Header guards are trivial to write, and by habitually defining them you don‚Äôt need to decide whether they are needed.

--
#include <iostream>
#include "Sales_item.h"

This program starts with two #include directives. Headers from the standard library are enclosed in angle brackets (< >). Those that are not part of the library are enclosed in double quotes (" ")

--
As we‚Äôve seen, to use a library facility, we must include the associated header. Similarly, we use headers to access classes defined for our own applications. Conventionally, header file names are derived from the name of a class defined in that header. Header files that we write usually have a suffix of .h, but some programmers use .H, .hpp, or .hxx. The standard library headers typically have no suffix at all.
Compilers usually don‚Äôt care about the form of header file names, but IDEs sometimes do.

--
#include <iostream>
#include "Sales_item.h"

Headers from the standard library are enclosed in <>
Headers that are not part of the library are enclosed in ""

The standard library headers typically have no suffix.
Header files that we write usually have a suffix of .h

Headers (usually) contain entities (such as class definitions and const variables) that can be defined only once in any given file.

Code inside headers ordinarily should not use "using declarations". The reason is that the contents of a header are copied into the including program‚Äôs text. If a header has a using declaration, then every program that includes that header gets that same using declaration. As a result, a program that didn‚Äôt intend to use the specified library name might encounter unexpected name conflicts.

In addition to facilities defined specifically for C++, the C++ library incorporates the C library. Headers in C have names of the form name .h. The C++ versions of these headers are named c name‚Äîthey remove the .h suffix and precede the name with the letter c. The c indicates that the header is part of the C library. Hence, cctype has the same contents as ctype.h, but in a form that is appropriate for C++ programs. In particular, the names defined in the cname headers are defined inside the std namespace, whereas those defined in the .h versions are not. Ordinarily, C++ programs should use the cname versions of headers and not the name .h versions.

--
How to include header in another folder (from online):

Just inlcude the path as well:

#include "../../Header/class1.h"

--
Whether to compile header files (from online):

Do I need to compile the header files (.h) in a C program?
No, there's no reason to "compile" these header files independently. 
Header files are intended to be included into implementation files, 
not fed to the compiler as independent translation units.

--
How to compile the files in the following example:

Suppose the files are organized in the following folders:

code
  - main.cpp

utils  
  - Time.h
  - Time.cpp 

Then in folder code, type the followings (list all the other cpp files after main.cpp.):
g++ main.cpp ../utils/Time.cpp 

This makes a compiled file in the same folder as main.cpp: a.out

In file Time.cpp, in the implementation of the Time member functions, it can use the other Time members directly without adding class name, note that the Time class is defined in another file Time.h

--
Separate Header and Implementation Files (from online, tao changed the path in the include for illustration)

How to compile the following files? See above.

In this section, we demonstrate how to make class reusable by separating it into another files.

Header File
Class declarations are stored in a separate file. A file that contains a class declaration is called header file. The name of the class is usually the same as the name of the class, with a .h extension. For example, the Time class would be declared in the file Time .h.

#ifndef TIME_H
#define TIME_H

class Time
{
     private :
          int hour;
          int minute;
          int second;
     public :
          //with default value
          Time(const int h = 0, const int m  = 0, const int s = 0);
          //    setter function
          void setTime(const int h, const int m, const int s);
          // Print a description of object in " hh:mm:ss"
          void print() const;
          //compare two time object
          bool equals(const Time&);
};
 
#endif
 
Implementation File

The member function definitions for a class are stored in a separate .cpp file, which is called the class implementation file. The file usually has the same name as the class, with the .cpp extension. For example the Time class member functions would be defined in the file Time.cpp.

#include <iostream>
#include <iomanip>
#include "Time.h" <- tao: since Time.cpp is in the same folder as Time.h, so no need to include path
using namespace std;
 
Time :: Time(const int h, const int m, const int s) 
  : hour(h), minute (m), second(s)
{}
 
void Time :: setTime(const int h, const int m, const int s) 
{
     hour = h;
     minute = m;
     second = s;     
}       
 
void Time :: print() const
{
     cout << setw(2) << setfill('0') << hour << ":"
    << setw(2) << setfill('0') << minute << ":"
    << setw(2) << setfill('0') << second << "\n";   
 
}
 
bool Time :: equals(const Time &otherTime)
{
     if(hour == otherTime.hour 
          && minute == otherTime.minute 
          && second == otherTime.second)
          return true;
     else
          return false;
}
 
Client Code

client code, is the one that includes the main function. This file should be stored by the name main.cpp
 
#include <iostream>
using namespace std;
#include "../utils/Time.h" <- tao: since main.cpp is in a different folder from Time.h, so need to include path

int main()
{
     Time t1(10, 50, 59);
     t1.print();   // 10:50:59
     Time t2;
     t2.print(); // 06:39:09
     t2.setTime(6, 39, 9);
     t2.print();  // 06:39:09
   
     if(t1.equals(t2))
          cout << "Two objects are equal\n";
     else
          cout << "Two objects are not equal\n";    
  
     return 0;
}
The advanages of storing class definition in separate file are

1. The class is reusable

2. The clients of the class know what member functions the class provides, how to call them and what return types to expect

3. The clients do not know how the class's member functions are implemented.

--
(findcompileseparate)
Separate Compilation

As our programs get more complicated, we‚Äôll want to store the various parts of the program in separate files. For example, we might store the functions we wrote in one file and store code that uses these functions in other source files. To allow programs to be written in logical parts, C++ supports what is commonly known as separate compilation. Separate compilation lets us split our programs into several files, each of which can be compiled independently.

As an example, assume that the definition of our fact function is in a file named fact.cc and its declaration is in a header file named Chapter6.h. Our fact.cc file, like any file that uses these functions, will include the Chapter6.h header. We‚Äôll store a main function that calls fact in a second file named factMain.cc. We might compile these files as follows:

g++ factMain.cc fact.cc -o main // generates main

If we have changed only one of our source files, we‚Äôd like to recompile only the file that actually changed. Most compilers provide a way to separately compile each file. This process usually yields a file with the .o file extension, indicating that the file contains object code.
 
The compiler lets us link object files together to form an executable. On the system we use, we would separately compile our program as follows:
 
g++ -c factMain.cc     // generates factMain.o
g++ -c fact.cc         // generates fact.o
g++ factMain.o fact.o -o main // generates main

==
(findcout)
(findcin)
cout, cin 

remember: t looks like <, n can be put into >

The left-hand operand of << must be an ostream object. The operator writes the given value on the given ostream. The result of the output operator is its left-hand operand (the ostream). The following example uses << twice, because << returns ostream.

Writing endl has the effect of ending the current line and flushing the buffer asociated with that device. Flusing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.

Buffer: a region of storage used to hold data. IO facilities often store input (or output) in a buffer and read or write the buffer independently from actions in the program. Output buffers can be explicitly flushed to force the buffer to be written. By default, reading cin flushes cout; cout is also flushed when the program ends normally.

//cout:
#include<iostream>
using namespace std;
//using std::cout; <- can also use this

int main() {
    double a = 2.6;
    cout << a << endl;
    return 0;
}

//cin:
#include<iostream>
using namespace std;

int main() {
    int a = 0;
    cin >> a; //tao: read input into a
    return 0;
}

while(cin >> value) sum += value;

The input operator returns its left operand, which in this case is cin. This condition, therefore, tests cin.

When we use an istream as a condition, the effect is to test the state of the stream. If the stream is valid‚Äîthat is, if the stream hasn‚Äôt encountered an error‚Äîthen the test succeeds. An istream becomes invalid when we hit end-of-file (tao: ctrl+d) or encounter an invalid input, such as reading a value that is not an integer (tao: because "value" is int type). An istream that is in an invalid state will cause the condition to yield false.

The input operator (the >> operator) behaves analogously to the output operator. It takes an istream as its left-hand operand and an object as its right-hand operand. It reads data from the given istream and stores what was read in the given object. Like the output operator, the input operator returns its left-hand operand as its result. 

cout << v1 + v2 << endl; //Tao: expressions can be in cout.

--
s is a string:

os << s: Writes s onto output stream os. Returns os.
is >> s: Reads whitespace-seperated string from is into s. Returns s.
getline(is, s): Reads a line of input from is into s. Returns s.

string s; // empty string
cin >> s; // read a whitespace-separated string into s. Tao: note that this code does not end with endl.
cout << s << endl; // write s to the output

The string input operator (tao eg: cin) reads and discards any leading whitespace (e.g., spaces, newlines, tabs). It then reads
characters until the next whitespace character is encountered.
So, if the input to this program is Hello World! (note leading and trailing spaces), then the output will be Hello with no extra spaces.

We can chain together multiple reads or writes:

string s1, s2;
cin >> s1 >> s2; // read first input into s1, second into s2
cout << s1 << s2 << endl; // write both strings

If we give this version of the program the same input, Hello World!, our output would
be ‚ÄúHelloWorld!‚Äù

Reading an Unknown Number of strings

string word;
while (cin >> word) // read until end-of-file
cout << word << endl; // write each word followed by a new line

--
(findgetline)
getline

Sometimes we do not want to ignore the whitespace in our input. In such cases, we can use the getline function instead of the >> operator.

int main()
{
	string line;
	// read input a line at a time until end-of-file
	while (getline(cin, line))
		cout << line << endl;
	return 0;
}

Because line does not contain a newline, we must write our own (tao: endl). As usual, we use endl to end the current line and flush the buffer.

--
Printing numbers in binary format:

#include <bitset>
using namespace std;
int v = 5;
cout << bitset<32>(v); //32 means outputs 32 bits

--
Most operating systems support file redirection, which lets us associate a named file with the standard input and the standard output:

$ addItems <infile >outfile

Asuuming our addition program has been compiled into an executable file named addItem. This command will read transactions from a file named infile and write its output to a file named outfile in the current directory.

==
(findio)
IO

The C++ language does not define any statements to do input or output (IO). Instead, C++ includes an extensive standard library that provides IO (and many other facilities).

Most of the examples in this book use the iostream library. Fundamental to the iostream library are two types named istream and ostream, which represent input and output streams, respectively. A stream is a sequence of characters read from or written to an IO device. The term stream is intended to suggest that the characters are generated, or consumed, sequentially over time.

Standard Input and Output Objects

The library defines four (tao: note four) IO objects. To handle input, we use an object of type istream named cin (pronounced see-in). This object is also referred to as the standard input. For output, we use an ostream object named cout (pronounced see-out). This object is also known as the standard output. The library also defines two other ostream objects, named cerr and clog (pronounced see-err and see-log, respectively). We typically use cerr, referred to as the standard error, for warning and error messages and clog for general information about the execution of the program.

Ordinarily, the system associates each of these objects with the window in which the program is executed. So, when we read from cin, data are read from the window in which the program is executing, and when we write to cout, cerr, or clog, the output is written to the same window.

--
#include <iostream> tells the compiler that we want to use the iostream library. The name inside angle brackets (iostream in this case) refers to a header. Every program that uses a library facility must include its associated header. The #include directive must be written on a single line‚Äîthe name of the header and the #include must appear on
the same line. In general, #include directives must appear outside any function. Typically, we put all the #include directives for a program at the beginning of the source file.

--
In C++ an expression yields a result and is composed of one or more operands and (usually) an operator. The expressions in this statement use the output operator (the << operator) to print a message on the standard output:

std::cout << "Enter two numbers:" << std::endl;

The << operator takes two operands: The left-hand operand must be an ostream object; the right-hand operand is a value to print. The operator writes the given value on the given ostream. The result of the output operator is its left-hand operand. That is, the result is the ostream on which we wrote the given value.

Our output statement uses the << operator twice. Because the operator returns its left-hand operand.

endl, which is a special value called a manipulator. Writing endl has the effect of ending the current line and flushing the buffer associated with that device. Flushing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.

Programmers often add print statements during debugging. Such statements
should always flush the stream. Otherwise, if the program crashes, output may be left in the buffer, leading to incorrect inferences about where the program crashed.

--
(findnamespace)
Using Names from the Standard Library

Careful readers will note that this program uses std::cout and std::endl rather than just cout and endl. The prefix std:: indicates that the names cout and endl are defined inside the namespace named std. Namespaces allow us to avoid inadvertent collisions between 'the names we define' and 'uses of those same names inside a library'. All the names defined by the standard library are in the std namespace.

One side effect of the library's use of a namespace is that when we use a name from the library, we must say explicitly that we want to use the name from the std namespace. Writing std::cout uses the scope operator (the :: operator) to say that we want to use the name cout that is defined in the namespace std. Later will show a simpler way to access names from the library.

A using declaration lets us use a name from a namespace without qualifying the name with a namespace_name:: prefix. A using declaration has the form

using namespace::name;

Once the using declaration has been made, we can access name directly:

using std::cin;
cin >> i; // ok: cin is a synonym for std::cin

Code inside headers ordinarily should not use using declarations. The reason is that the contents of a header are copied into the including program‚Äôs text.

--
The C++ language does not deal directly with input and output. Instead, IO is handled by a family of types defined in the standard library.

Our programs have already used many IO library facilities:
‚Ä¢ istream (input stream) type, which provides input operations
‚Ä¢ ostream (output stream) type, which provides output operations
‚Ä¢ cin, an istream object that reads the standard input
‚Ä¢ cout, an ostream object that writes to the standard output
‚Ä¢ cerr, an ostream object, typically used for program error messages, that writes to the standard error
‚Ä¢ The >> operator, which is used to read input from an istream object
‚Ä¢ The << operator, which is used to write output to an ostream object
‚Ä¢ The getline function, which reads a line of input from a given istream into a given string

To support these different kinds of IO processing, the library defines a collection of IO types in addition to the istream and ostream types that we have already used.

These types are defined in three separate headers: iostream defines the basic types used to read from and write to a stream, fstream defines the types used to read and write named files, and sstream defines the types used to read and write in-memory strings.

The library lets us ignore the differences among these different kinds of streams by using inheritance. Ordinarily, we can use an object of an inherited class as if it were an object of the same type as the class from which it inherits.

The types ifstream and istringstream inherit from istream. Thus, we can use objects of type ifstream or istringstream as if they were istream objects. We can use objects of these types in the same ways as we have used cin. For example, we can call getline on an ifstream or istringstream object, and we can use the >> to read data from an ifstream or istringstream. Similarly, the types ofstream and ostringstream inherit from ostream. Therefore, we can use objects of these types in the same ways that we have used cout.

Everything that we cover in the remainder of this section applies equally to plain streams, file streams, and string streams and to the char or widecharacter stream versions.

we cannot copy or assign objects of the IO types:

ofstream out1, out2;
out1 = out2; // error: cannot assign stream objects
ofstream print(ofstream); // error: can't initialize the ofstream parameter. Tao: print is a variable
out2 = print(out2); // error: cannot copy stream objects. Tao: print is a variable

Because we can‚Äôt copy the IO types, we cannot have a parameter or return type that is one of the stream types. Functions that do IO typically pass and return the stream through references. Reading or writing an IO object changes its state, so the reference must NOT be const.

--
Condition States

Inherent in doing IO is the fact that errors can occur. Some errors are recoverable; others occur deep within the system and are beyond the scope of a program to correct. The IO classes define functions and flags, listed in Table below, that let us access and manipulate the condition state of a stream.

strm::iostate: strm is one of (iostream, fstream, sstream) IO types. iostate is a machine-dependent integral type that represents the condition state of a stream.

strm::badit: strm::iostate value used to indicate that a stream is corrupted.

strm::failbit: strm::iostate value used to indicate that an IO operation failed.

strm::eofbit: strm::iostate value used to indicate that a stream hit end-of-file.

strm::goodbit: strm::iostate value used to indicate that a stream is not in an error state. The value is guaranteed to be zero.

s.eof(): true if eofbit in the stream s is set.

s.fail(): true if failbit or badbit in the stream s is set.

s.bad(): true if badbit in the stream s is set.

s.good(): true if the stream s is in a valid state.

s.clear(): Reset all condition values in the stream s to valid state. Returns void.

s.clear(flags): Reset the condition of s to flags. Type of flags is strm:iostate. Returns void.

s.setstate(flags): Adds specified conditions(s) to s. Type of flags is strm::iostate. Returns void.

s.rdstate(): Returns curent condition of s as a strm::iostate value.

As an example of an IO error, consider the following code:

int ival;
cin >> ival;

If we enter Boo on the standard input, the read will fail. The input operator expected to read an int but got the character B instead. As a result, cin will be put in an error state. Similarly, cin will be in an error state if we enter an end-of-file. 

Once an error has occurred, subsequent IO operations on that stream will fail. We can read from or write to a stream only when it is in a non-error state. Because a stream might be in an error state, code ordinarily should check whether a stream is okay before attempting to use it. The easiest way to determine the state of a stream
object is to use that object as a condition:

while (cin >> word) // ok: read operation successful . . .

The while condition checks the state of the stream returned from the >> expression. If that input operation succeeds, the state remains valid and the condition will succeed.

Interrogating the State of a Stream

Using a stream as a condition tells us only whether the stream is valid. It does not tell us what happened. Sometimes we also need to know why the stream is invalid. For example, what we do after hitting end-of-file is likely to differ from what we‚Äôd do if we encounter an error on the IO device.

The IO library defines a machine-dependent integral type named iostate that it uses to convey information about the state of a stream. This type is used as a collection of bits, in the same way that we used the quiz1 variable in ¬ß 4.8 (p. 154). The IO classes define four constexpr values (¬ß 2.4.4, p. 65) of type iostate that represent particular bit patterns. These values are used to indicate particular kinds of IO conditions. They can be used with the bitwise operators (¬ß 4.8, p. 152) to test or set multiple flags in one operation.

The badbit indicates a system-level failure, such as an unrecoverable read or write error. It is usually not possible to use a stream once badbit has been set. The failbit is set after a recoverable error, such as reading a character when numeric data was expected. It is often possible to correct such problems and continue using the stream. Reaching end-of-file sets both eofbit and failbit. The goodbit, which is guaranteed to have the value 0, indicates no failures on the stream. If any of badbit, failbit, or eofbit are set, then a condition that evaluates that stream will fail.

The library also defines a set of functions to interrogate the state of these flags. The good operation returns true if none of the error bits is set. The bad, fail, and eof operations return true when the corresponding bit is on. In addition, fail returns true if bad is set. By implication, the right way to determine the overall state of a stream is to use either good or fail. Indeed, the code that is executed when we use a stream as a condition is equivalent to calling !fail(). The eof and bad operations reveal only whether those specific errors have occurred.

Managing the Condition State

The rdstate member returns an iostate value that corresponds to the current state of the stream. The setstate operation turns on the given condition bit(s) to indicate that a problem occurred. The clear member is overloaded: One version takes no arguments and a second version takes a single argument of type iostate.

The version of clear that takes no arguments turns off all the failure bits. After clear(), a call to good returns true. We might use these members as follows:

// remember the current state of cin
auto old_state = cin.rdstate(); // remember the current state of cin
cin.clear(); // make cin valid
process_input(cin); // use cin
cin.setstate(old_state); // now reset cin to its old state

The version of clear that takes an argument expects an iostate value that represents the new state of the stream. To turn off a single condition, we use the rdstate member and the bitwise operators to produce the desired new state.

For example, the following turns off failbit and badbit but leaves eofbit untouched:

// turns off failbit and badbit but all other bits unchanged
cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit);

--
Managing the Output Buffer

Each output stream manages a buffer, which it uses to hold the data that the program reads and writes. For example, when the following code is executed

os << "please enter a value: ";

the literal string might be printed immediately, or the operating system might store the data in a buffer to be printed later. Using a buffer allows the operating system to combine several output operations from our program into a single system-level write.

Because writing to a device can be time-consuming, letting the operating system combine several output operations into a single write can provide an important performance boost.

There are several conditions that cause the buffer to be flushed‚Äîthat is, to be written‚Äîto the actual output device or file:

‚Ä¢ The program completes normally. All output buffers are flushed as part of the return from main.

‚Ä¢ At some indeterminate time, the buffer can become full, in which case it will be flushed before writing the next value.

‚Ä¢ We can flush the buffer explicitly using a manipulator such as endl (¬ß 1.2, p.7).

‚Ä¢ We can use the unitbuf manipulator to set the stream‚Äôs internal state to empty the buffer after each output operation. By default, unitbuf is set for cerr, so that writes to cerr are flushed immediately.

‚Ä¢ An output stream might be tied to another stream. In this case, the buffer of the tied stream is flushed whenever the tied stream is read or written. By default, cin and cerr are both tied to cout. Hence, reading cin or writing to cerr flushes the buffer in cout.

Flushing the Output Buffer

Our programs have already used the endl manipulator, which ends the current line and flushes the buffer. There are two other similar manipulators: flush and ends. flush flushes the stream but adds no characters to the output; ends inserts a null character into the buffer and then flushes it:

cout << "hi!" << endl; // writes hi and a newline, then flushes the buffer
cout << "hi!" << flush; // writes hi, then flushes the buffer; adds no data
cout << "hi!" << ends; // writes hi and a null, then flushes the buffer

The unitbuf Manipulator

If we want to flush after every output, we can use the unitbuf manipulator. This manipulator tells the stream to do a flush after every subsequent write. The nounitbuf manipulator restores the stream to use normal, system-managed buffer flushing:

cout << unitbuf; // all writes will be flushed immediately // any output is flushed immediately, no buffering

cout << nounitbuf; // returns to normal buffering

Caution: Buffers Are Not Flushed If the Program Crashes

Output buffers are not flushed if the program terminates abnormally. When a program crashes, it is likely that data the program wrote may be sitting in an output buffer waiting to be printed.

When you debug a program that has crashed, it is essential to make sure
that any output you think should have been written was actually flushed.
Countless hours of programmer time have been wasted tracking through code that appeared not to have executed when in fact the buffer had not been flushed and the output was pending when the program crashed.

Tying Input and Output Streams Together

When an input stream is tied to an output stream, any attempt to read the input stream will first flush the buffer associated with the output stream. The library ties cout to cin, so the statement

cin >> ival;

causes the buffer associated with cout to be flushed.

Note

Interactive systems usually should tie their input stream to their output stream. Doing so means that all output, which might include prompts to the user, will be written before attempting to read the input.

There are two overloaded versions of tie: One version takes no argument and returns a pointer to the output stream, if any, to which this object is currently tied. The function returns the null pointer if the stream is not tied.

The second version of tie takes a pointer to an ostream and ties itself to that ostream. That is, x.tie(&o) ties the stream x to the output stream o. We can tie either an istream or an ostream object to another ostream:

cin.tie(&cout); // illustration only: the library ties cin and cout for us
// old_tie points to the stream (if any) currently tied to cin
ostream *old_tie = cin.tie(nullptr); // cin is no longer tied
// ties cin and cerr; not a good idea because cin should be tied to cout
cin.tie(&cerr); // reading cin flushes cerr, not cout
cin.tie(old_tie); // reestablish normal tie between cin and cout

To tie a given stream to a new output stream, we pass tie a pointer to the new stream. To untie the stream completely, we pass a null pointer. Each stream can be tied to at most one stream at a time. However, multiple streams can tie themselves to the same ostream.

--
(findreadfromfile)
(findwritetofile)
Read from file and output to file

The following function reads all contents in the input file, and write them into output file. Note that if in my Thinkpad, it needs to be compiled in C++ 11.

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
using namespace std;

// g++ -std=c++0x -o convert convert.cc
void process_one_file(string input_stream_name, string output_file) { 
    ifstream input_stream(input_stream_name);
    ofstream output_file(output_file_name);

    string line;

    while(getline(input_stream, line)) {
        output_file << line << endl;
    }

    output_file.close();
    input_stream.close();
}

--
File Input and Output

The fstream header defines three types to support file IO: ifstream to read from a given file, ofstream to write to a given file, and fstream, which reads and writes a given file. 

These types provide the same operations as those we have previously used on the objects cin and cout. In particular, we can use the IO operators (<< and >>) to read and write files, we can use getline to read an ifstream.

In addition to the behavior that they inherit from the iostream types, the types defined in fstream add members to manage the file associated with the stream. These operations, listed in the following table, can be called on objects of fstream, ifstream, or ofstream but not on the other IO types.

fstream fstrm: Creates an unbound file stream. fstream is one of the types (ifstream, ofstream, fstream) defined in the fstream header.

fstream fstrm(s): Creates an fstream and opens the file named s. s can have type string or can be a pointer to a C-style character string. These constructors are explicit. The default file mode depends on the type of fstream.

fstream fstrm(s, mode): Like the previous constructor, but opens s in the given mode.

fstrm.open(s), fstrm.open(s, mode): Opens the file named by the s and binds that file to fstrm. s can be a string or a pointer to a C-style character string. The default file mode depends on the type of f stream. Returns void.

fstrm.close(): Closes the file to which fstrm is bound. Returns void.

fstrm.is_open(): Returns a bool indicating whether the file associated with fstrm was successfully opened and has not been closed.

Using an fstream in Place of an iostream&

As we noted before, we can use an object of an inherited type in places
where an object of the original type is expected. This fact means that functions that are written to take a reference (or pointer) to one of the iostream types can be called on behalf of the corresponding fstream (or sstream) type. That is, if we have a function that takes an ostream&, we can call that function passing it an ofstream object, and similarly for istream& and ifstream.

ifstream in(ifile); // construct an ifstream and open the given file
ofstream out; // output file stream that is not associated with any file

ifstream in(ifile); // construct an ifstreamand open the given file
ofstream out; // output file stream that is not associated with any file
out.open(ifile + ".copy"); // open the specified file

If a call to open fails, failbit is set. Because a call to open might fail, it is usually a good idea to verify that the open succeeded:

if (out) // check that the open succeeded 

Once a file stream has been opened, it remains associated with the specified file. Indeed, calling open on a file stream that is already open will fail and set failbit. Subsequent attempts to use that file stream will fail. To associate a file stream with a different file, we must first close the existing file. Once the file is closed, we can open
a new one:

in.close(); // close the file
in.open(ifile + "2"); // open another file

If the open succeeds, then open sets the stream‚Äôs state so that good() is true.

// for each file passed to the program
for (auto p = argv + 1; p != argv + argc; ++p) {
	ifstream input(*p); // create input and open the file
	if (input) { // if the file is ok, ''process'' this file
	process(input);
} else
	cerr << "couldn't open: " + string(*p);
} // input goes out of scope and is destroyed on each iteration

Because input is local to the while, it is created and destroyed on each iteration. When an fstream object goes out of scope, the file it is bound to is automatically closed. On the next iteration, input is created anew.

When an fstream object is destroyed, close is called automatically.

--
File Modes

Each stream has an associated file mode that represents how the file may be used:

in: Open for input
out: Open for output
app: Seek to the end before every write
ate: Seet to the end immediately after the open
trunc: Truncate the file
binary: Do IO operations in binary mode

We can supply a file mode whenever we open a file‚Äîeither when we call open or when we indirectly open the file when we initialize a stream from a file name. The modes that we can specify have the following restrictions:

‚Ä¢ out may be set only for an ofstream or fstream object.
‚Ä¢ in may be set only for an ifstream or fstream object.
‚Ä¢ trunc may be set only when out is also specified.
‚Ä¢ app mode may be specified so long as trunc is not. If app is specified, the file is always opened in output mode, even if out was not explicitly specified.
‚Ä¢ By default, a file opened in out mode is truncated even if we do not specify trunc. To preserve the contents of a file opened with out, either we must also specify app, in which case we can write only at the end of the file, or we must also specify in, in which case the file is open for both input and output will cover using the same file for input and output).
‚Ä¢ The ate and binary modes may be specified on any file stream object type and in combination with any other file modes.

Each file stream type defines a default file mode that is used whenever we do not otherwise specify a mode. Files associated with an ifstream are opened in in mode; files associated with an ofstream are opened in out mode; and files associated with an fstream are opened with both in and out modes.

Opening a File in out Mode Discards Existing Data

By default, when we open an ofstream, the contents of the file are discarded. The only way to prevent an ostream from emptying the given file is to specify app.

// to preserve the file's contents, we must explicitly specify app mode
ofstream app("file2", ofstream::app); // out is implicit
ofstream app2("file2", ofstream::out | ofstream::app);

File Mode Is Determined Each Time open Is Called

ofstream out; // no file mode is set
out.open("scratchpad"); // mode implicitly out and trunc
out.close(); // close out so we can use it for a different file
out.open("precious", ofstream::app); // mode is out and app
out.close();

When we open the file named precious, we ask for append mode. Any data in the file remains, and all writes are done at the end of the file.

--
string Streams

The sstream header defines three types to support in-memory IO; these types read from or write to a string as if the string were an IO stream.

The istringstream type reads a string, ostringstream writes a string, and stringstream reads and writes the string. Like the fstream types, the types defined in sstream inherit from the types we have used from the iostream header. In addition to the operations they inherit, the types defined in sstream add members to manage the string associated with the stream. These operations are listed in the following table. They may be called on stringstream objects but not on the other IO types.

sstream strm: strm is an unbounded stringstream. sstream is one of the types defined in the sstream header.

sstream strm(s): strm is an sstream that holds a copy of the string s. This constructor is explicit.

strm.str(): Returns a copy of the string that strm holds.

strm.str(s): Copies the string s into strm. Returns void.

An istringstream is often used when we have some work to do on an entire line, and other work to do with individual words within a line

// members are public by default; see ¬ß 7.2 (p. 268)
struct PersonInfo {
	string name;
	vector<string> phones;
};

string line, word; // will hold a line and word from input, respectively

vector<PersonInfo> people; // will hold all the records from the input
// read the input a line at a time until cin hits end-of-file (or another error)
while (getline(cin, line)) {
	PersonInfo info; // create an object to hold this record's data
	istringstream record(line); // bind record to the line we just read
	record >> info.name; // read the name
	while (record >> word) // read the phone numbers
		info.phones.push_back(word); // and store them
	people.push_back(info); // append this record to people

--
Using ostringstreams

An ostringstream is useful when we need to build up our output a little at a time but do not want to print the output until later.

For example, we might want to validate and reformat the phone numbers we read in the previous example. If all the numbers are valid, we want to print a new file containing the reformatted numbers. If a person
has any invalid numbers, we won‚Äôt put them in the new file. Instead, we‚Äôll write an error message containing the person‚Äôs name and a list of their invalid numbers.

Because we don‚Äôt want to include any data for a person with an invalid number, we can‚Äôt produce the output until we‚Äôve seen and validated all their numbers. We can, however, ‚Äúwrite‚Äù the output to an in-memory ostringstream:

for (const auto &entry : people) { // for each entry in people
	ostringstream formatted, badNums; // objects created on each loop
	for (const auto &nums : entry.phones) { // for each number
		if (!valid(nums)) {
			badNums << " " << nums; // string in badNums
		} else
			// ''writes'' to formatted's string
			formatted << " " << format(nums);
	}
	if (badNums.str().empty()) // there were no bad numbers
		os << entry.name << " " // print the name
		   << formatted.str() << endl; // and reformatted numbers
	else // otherwise, print the name and bad numbers
		cerr << "input error: " << entry.name
			 << " invalid number(s) " << badNums.str() << endl;
}

==
(findmath)
(findpow)
Math operators:

Absolute value:
#include <cmath>
abs(-10.6) //Tao: yes we can use abs for double, no need to use fabs.

--
power:

#include <cmath>
pow(3.4, 4.4) // Returns: 3.4^4.4 = 218.025

--
std::pow in the <cmath> header has these overloads:

pow(float, float);
pow(float, int);
pow(double, double); // taken over from C
pow(double, int);
pow(long double, long double);
pow(long double, int);

Now you can't just do
pow(2, N)
with N being an int, because it doesn't know which of float, double or long double version it should take, and you would get an ambiguity error. All three would need a conversion from int to floating point, and all three are equally costly!

Therefor, be sure to have the first argument typed so it matches one of those three perfectly. I usually use double

pow(2.0, N)
Some lawyer crap from me again. I've often fallen in this pitfall myself, so i'm going to warn you about it.

==
(findmax)
(findmin)
The algorithm header:
max, min

include <iostream>     // std::cout
#include <algorithm>    // std::max, std::min

int main () {
  std::cout << "max(1,2)==" << std::max(1,2) << '\n';
  std::cout << "max(2,1)==" << std::max(2,1) << '\n';
  std::cout << "max('a','z')==" << std::max('a','z') << '\n';
  std::cout << "max(3.14,2.73)==" << std::max(3.14,2.73) << '\n';

  std::cout << "min(1,2)==" << std::min(1,2) << '\n';
  std::cout << "min(2,1)==" << std::min(2,1) << '\n';
  std::cout << "min('a','z')==" << std::min('a','z') << '\n';
  std::cout << "min(3.14,2.72)==" << std::min(3.14,2.72) << '\n';

  return 0;
}

==
(findstaticallytyped)
Type checking (statically typed launage):

Some languages, such as Smalltalk and Python, check types at run time. In contrast, C++ is a statically typed language; type checking is done at compile time.

In C++, if we try to do things that the type does not support, the compiler generates an error message and does not produce an executable file.

==
(findreference)
Reference

A compound type is a type that is defined in terms of another type. C++ has several compound types, two of which‚Äîreferences and pointers‚Äîwe‚Äôll cover in this chapter.

Defining variables of compound type is more complicated than the declarations we‚Äôve seen so far. We said that simple declarations consist of a type followed by a list of variable names. More generally, a declaration is a base type followed by a list of declarators. Each declarator names a variable and gives the variable a type that is related to the base type.

A reference defines an alternative name for an object. A reference type ‚Äúrefers to‚Äù another type. We define a reference type by writing a declarator of the form &d, where d is the name being declared:

int ival = 1024;
int &refVal = ival; // refVal refers to (is another name for) ival
int &refVal2; // error: a reference must be initialized

Ordinarily, when we initialize a variable, the value of the initializer is copied into the object we are creating. When we define a reference, instead of copying the initializer‚Äôs value, we bind the reference to its initializer. Once initialized, a reference remains bound to its initial object. There is no way to rebind a reference to refer to a different object. Because there is no way to rebind a reference, references must be initialized (tao: same as const).

Because references are not objects, they don‚Äôt have addresses. Hence, we may not define a pointer to a reference.

A Reference Is an Alias

A reference is not an object. Instead, a reference is just another name for an already existing object. 

After a reference has been defined, all operations on that reference are actually operations on the object to which the reference is bound.

int ival = 1024;
int &refVal = ival;

int &refVal3 = refVal;// ok: refVal3 is bound to the object to which refVal is bound, i.e., to ival

int i = refVal; // ok: initializes i to the same value as ival

Reference Definition

int i = 1024, i2 = 2048; // i and i2 are both ints
int &r = i, r2 = i2; // r is a reference bound to i; r2 is an int

With two exceptions that we‚Äôll cover later, the type of a reference and the object to which the reference refers must match exactly.
Moreover, for reasons we‚Äôll explore later, a reference may be bound only to an object, not to a literal or to the result of a more general expression.

==
(findpassbyvalue)              
(findpassbyreference)          
Pass by value vs Pass by reference

From online:

C++ Passing by value vs. passing by reference

First of all, this article is NOT going to explain C++ references and pointers. If you are not clear on what these are then this is quite probably the wrong article for you and you really should probably go read here, here or here.

In C++ all arguments are passed to functions by value. In other words, a copy of the value is taken and that is what the function has to work with. If you want to modify the original value you must either pass a pointer or reference to the original value you wish to modify. Of course, even the pointer or reference are still passed by value. Pointers and references are just another C++ type and when they are passed around you do so by value.

Now, what about the case where we don't want to modify the value? There's no need to pass by reference or pointer, right? Wrong! Now, in the case of fundemental types it probably doesn't make a huge deal of difference since these are unlikely to be any more complicated that a pointer or reference type; howver, in the case of fully blown class objects, such as string, vector, map, set or any other (including your own class objects) it can make a huge difference. You see, passing by value can be very expensive both in terms of memory usage and performance (time / space complexity)

Classes have copy constructors, which are defined to facilitate the correct copying semantics for a class. Now in C++ there are two types of copy, shallow and deep. A shallow copy is where all the values of the class are copied but pointers are not followed. A deep copy is where pointers are followed and all the objects that they point to are also copied, thus creating a copy of all the "deep" objects, too. Any class that contains references to other objects should (unless there is a very good reason not to) provide both an assignment and copy constructor such that the class is always copied deeply.

Consider the std::vector class. This class contains an internal buffer of memory that is managed by the vector. In reality, we can assume that the vector contains a pointer that points to memory allocated on the heap. The vector class implements a copy constructor that will perform a deep copy on a vector object if a copy is taken. This is the only sane thing to do, otherwise we have two objects referencing the same memory and then we have issues of ownership. In other words, which of the vectors is now responsible for managing and freeing that memory and what happens to the other vector if that memory is released? Of course, it'll be left with a dangling pointer that is referencing invalid memory! Bad mojo for all!!!

Now, imagine we have a vector class that contains thousands of items. If we pass this object to a function by value the whole of the internal buffer will be copied. Not only is this really very inefficient in terms of the time it will take to allocate the memory and copy the values from the original vector to the copy it also increases memory usage greatly and, as a side effect, the risk of memory fragmentation. Imagine if this same vector is copied around again and again (maybe in a loop); it should be pretty clear just how inefficient this is.

The solution is to pass things around by const reference (or const pointer in C). The cost of passing things around by const reference is trivial and about as expensive as passing around an int value. Not only is it so much more efficient to pass objects in this way, but the semantics of your function become way clearer. Just looking at the function prototype tells us that the value being passed is never meant to be modified by this function. You are helping to enforce your objects interface contract.

Let's see a trivial example. 
#include <vector>
#include <chrono>
#include <iostream>

void foo(std::vector<int> byValue)
{
// do nothing
}

void bar(std::vector<int> const & byRef)
{
// do nothing
}

int main()
{
   auto && v = std::vector<int>(0x7FFFFFF);

   auto && x1 = std::chrono::steady_clock::now();
   foo(v);
   auto && x2 = std::chrono::steady_clock::now();
   bar(v);
   auto && x3 = std::chrono::steady_clock::now();

   auto && d1 = std::chrono::duration_cast<std::chrono::nanoseconds>(x2 - x1);
   auto && d2 = std::chrono::duration_cast<std::chrono::nanoseconds>(x3 - x2);

   std::cout
         << "Time to call foo: " << d1.count() << std::endl
         << "Time to call bar: " << d2.count() << std::endl;
}

When running this on my Windows 7 laptop, build with Visual Studio 2013 and executed in as a Release build the call by value takes approximately 1 second whilst the call by reference takes less than a nanosecond. That makes the pass by value a billion times slower! Of course, this is a contrived example and on different machines with different compilers YMMV, but hopefully it serves to demonstrate just how slow passing by value can, when compared to passing by reference!

In the case of passing by value the cost in terms of both time and space complexity is O(N), where N is the number of bytes to be copied. Passing by reference will cost O(1), which is a significant improvement. Okay, the pedants amongst you may wish to argue that even for a reference it's O(N), because a reference is composed of bytes. True, but the big (massive) difference that the size of a reference is always constant and will be in the order of a few bytes (4 on a 32 bit machine, 8 on a 64 bit machine) and not hundreds, thousands, millions or even billion in the case of non-fundamental objects.

Note: that some compilers may optimize out the calls to the functions foo and bar due to the fact they don't do anything. This is most likely to happen if you have aggressive optimisation enabled on your compiler. You can either disable this or add some code to these functions to make use of the passed references. Whilst disabling optimisation may skew the results in an absolute sense, the relative comparison should still hold up because what we're truly interested in here is the asymtoptic variance (Big O) rather than wall clock time!

==
(findpointer)
Pointer

   declaration  operator
&  reference    obtain address
*  pointer      yield object

A pointer is a compound type that ‚Äúpoints to‚Äù another type. Like references, pointers are used for indirect access to other objects. Unlike a reference, a pointer is an object in its own right. Pointers can be assigned and copied; a single pointer can point to several different objects over its lifetime. Unlike a reference, a pointer need NOT be initialized at the time it is defined. Like other built-in types, pointers defined at block scope have undefined value if they are not initialized.

Pointers are often hard to understand. Debugging problems due to pointer
errors bedevil even experienced programmers.

We define a pointer type by writing a declarator of the form *d, where d is the name being defined. The * must be repeated for each pointer variable:

ListNode *walker, *runner //tao's example from LC, both walker and runner are pointers to ListNode. From this we can see why some people like to write ListNode *p instead of ListNode* p. Note that ListNode *p is the default style in LC problems.
int *ip1, *ip2; // both ip1 and ip2 are pointers to int
double dp, *dp2; // dp2 is a pointer to double; dp is a double
int* p1, p2; //Tao: practice shows this is wrong, should define different pointers in different lines.

A pointer holds the address of another object. We get the address of an object by usin the address-of operator (the & operator):

int ival = 42;
int *p = &ival; // p holds the address of ival; p is a pointer to ival

Because references are not objects, they don‚Äôt have addresses. Hence, we may not define a pointer to a reference.

With two exceptions, which we cover later, the types of the pointer and the object to which it points must match:

double *pd = &dval; // ok: initializer is the address of a double
double *pd2 = pd; // ok: initializer is a pointer to double

--
Pointer Value

The value (i.e., the address) stored in a pointer can be in one of four states:

1. It can point to an object.

2. It can point to the location just immediately past the end of an object.

3. It can be a null pointer, indicating that it is not bound to any object.

4. It can be invalid; values other than the preceding three are invalid.
It is an error to copy or otherwise try to access the value of an invalid pointer.

--
When a pointer points to an object, we can use the dereference operator (the * operator) to access that object:

int ival = 42;
int *p = &ival; // p holds the address of ival; p is a pointer to ival
int v = *p; //v = 42, dereference operator *

Dereferencing a pointer yields the object to which the pointer points. We can assign to that object by assigning to the result of the dereference:

*p = 0; //Assign new value to ival

We may dereference only a valid pointer that points to an object. 

--
(findnull)
A null pointer does not point to any object. There are several ways to obtain a null pointer:

//Null pointer. The following three lines are equivalent, to assign null pointer to p.
int *p = 0;
int *p = nullptr; // equivalent to int *p = 0. See more below.
int *p = NULL;//// equivalent to int *p = 0. See more below.

nullptr:
The most direct approach is to initialize the pointer using the literal nullptr, which was introduced by the new standard. nullptr is a literal that has a special type that can be converted to any other pointer type.

NULL:
Modern C++ programs generally should avoid using NULL and use nullptr instead. Older programs sometimes use a preprocessor variable named NULL, which the cstdlib header defines as 0. Must #include<cstdlib>.  Tao: practice confirms that cstdlib is also included in std namespace, so if we already wrote "using namespace std;", then we do not need to #include<cstdlib>

We‚Äôll describe the preprocessor in a bit more detail later. What‚Äôs useful to know now is that the preprocessor is a program that runs before the compiler. Preprocessor variables are managed by the preprocessor, and are not part of the std namespace. As a result, we refer to them directly without the std:: prefix.

When we use a preprocessor variable, the preprocessor automatically replaces the variable by its value. Hence, initializing a pointer to NULL is equivalent to initializing it to 0. Modern C++ programs generally should avoid using NULL and use nullptr instead.

It is illegal to assign an int variable to a pointer, even if the variable‚Äôs value happens to be 0.

Our recommendation to initialize all variables is particularly important for pointers. If possible, define a pointer only after the object to which it should point has been defined. If there is no object to bind to a pointer, then initialize the pointer to nullptr or zero.

--
pi = &ival; //we assign a new value to pi, which changes the address that pi holds.
*pi = 0; // value in ival is changed; pi is unchanged

--
We can use a pointer in a condition. If the pointer is 0, then the condition is false. Any nonzero pointer evaluates as true. Tao: for example: if(p) {...}, which is often used in leetcode.

if(p) {...} is equivalent to if(p != NULL) {...}. If p == 0, then p = false. Any nonzero pointer evaluates as true. This is consistent with converting int to bool.

if(!p) is equivalent to if(p == NULL) <- Remember: if p buxin, ie p == NULL
if(p) is equivalent to if(p != NULL) <- Rememebr: if p xin, ie p != NULL

--
Two pointers are equal (using ==) if they hold the same address and unequal otherwise.

--
void* Pointers

The type void* is a special pointer type that can hold the address of any object. Like any other pointer, a void* pointer holds an address, but the type of the object at that address is unknown:

double obj = 3.14, *pd = &obj;

void *pv = &obj; // ok: void* can hold the address value of any data pointer type. obj can be an object of any type

pv = pd; // pv can hold a pointer to any type

There are only a limited number of things we can do with a void* pointer: We can compare it to another pointer, we can pass it to or return it from a function, and we can assign it to another void* pointer. We cannot use a void* to operate on the object it addresses‚Äîwe don‚Äôt know that object‚Äôs type (tao: so we do not know how many bytes to read from memory for the object), and the type determines what operations we can perform on the object.

Generally, we use a void* pointer to deal with memory as memory, rather than using the pointer to access the object stored in that memory. We‚Äôll cover using void* pointers in this way later. Later will show how we can retrieve the address stored in a void* pointer.

--
double obj = 3.14;
void *pv = &obj; // The type void* is a special pointer type that can hold the address of any object.

Avadoles:
Variables defined inside a function ordinarily are not stored at a fixed address.
Tao: this is also the reason why my program did something wrong when I tried to return a pointer to a variable defined inside a function (see more below).

--
Understanding Compound Type Declaration

// i is an int; p is a pointer to int; r is a reference to int
int i = 1024, *p = &i, &r = i;

//tao: the follwing is equivalent to int *p;
int* p; // legal but might be misleading

Pointers to Pointers

In general, there are no limits to how many type modifiers (tao: & and *) can be applied to a declarator. We indicate each pointer level by its own *. That is, we write ** for a pointer to a pointer.

int ival = 1024;
int *pi = &ival; // pi points to an int
int **ppi = &pi; // ppi points to a pointer to an int

ppi -> pi -> ival (has value 1024)

Tao: pointer also has addess.

Dereferencing a pointer to a pointer yields a pointer.

References to Pointers

A reference is not an object. Hence, we may not have a pointer to a reference. However, because a pointer is an object, we can define a reference to a pointer:

int *p; // p is a pointer to int
int *&r = p; // r is a reference to the pointer p

The easiest way to understand the type of r is to read the definition right to left. The symbol closest to the name of the variable (in this case the & in &r) is the one that has the most immediate effect on the variable‚Äôs type. Thus, we know that r is a reference.

--
(findpointertoarray)
(findreferencetoarray)
Pointer to array & array of pointers
Reference to array & array of references

//Principle: the symbol that is closest to the variable name comes to the first in the type name

int* parr[42]; // parr is an array of 42 pointers to int. From this, tao sees why tao likes to write "int*" rather than "int *"
int (*parr)[10] = &arr; // parr is a pointer, which points to an array of ten ints

int& refs[10] = ... // error: no arrays of references
int (&arrRef)[10] = arr; // arrRef is a reference, which refers to an array of ten ints

int* (&arry)[10] = ptrs; // arry is a reference to an array of ten pointers

As with vector, arrays hold objects. Thus, there are no arrays of references. Because an array is an object, we can define both pointers and references to arrays.

When we use an array, the compiler ordinarily converts the array to a pointer.

--
Pointer to vector: vector<int> *t; t->push_back(10);
Vector of pointers: vector<int*> movies = ...

--
Reference to a vector: vector<int>& = ...
There is no vector of references. 

--
(findpointertofunction)
Pointer to function

A function pointer is just that‚Äîa pointer that denotes a function rather than an object. Like any other pointer, a function pointer points to a particular type. A function‚Äôs type is determined by its return type and the types of its parameters. The function‚Äôs name is not part of its type. For example:

// compares lengths of two strings
bool lengthCompare(const string &, const string &);

has type 

bool(const string&, const string&). 

To declare a pointer that can point at this function, we declare a pointer in place of the function name:

// pf points to a function returning bool that takes two const string references
bool (*pf)(const string &, const string &); // uninitialized

// declares a function named pf that returns a bool*
bool *pf(const string &, const string &);

Using Function Pointers

When we use the name of a function as a value, the function is automatically converted to a pointer. For example, we can assign the address of lengthCompare to pf as follows:

pf = lengthCompare; // pf now points to the function named lengthCompare
pf = &lengthCompare; // equivalent assignment: address-of operator is optional

Moreover, we can use a pointer to a function to call the function to which the pointer points. We can do so directly‚Äîthere is no need to dereference the pointer:

bool b1 = pf("hello", "goodbye"); // calls lengthCompare
bool b2 = (*pf)("hello", "goodbye"); // equivalent call

Function Pointer Parameters

Just as with arrays, we cannot define parameters of function type but can have a parameter that is a pointer to function. As with arrays, we can write a parameter that looks like a function type, but it will be treated as a pointer:

// third parameter is a function type and is automatically treated as a pointer to function
void useBigger(const string &s1, const string &s2, bool pf(const string &, const string &));

// equivalent declaration: explicitly define the parameter as a pointer to function
void useBigger(const string &s1, const string &s2, bool (*pf)(const string &, const string &));

Returning a Pointer to Function

As with arrays, we can‚Äôt return a function type but can return a
pointer to a function type.

Using auto or decltype for Function Pointer Types

If we know which function(s) we want to return, we can use decltype to simplify writing a function pointer return type. 

string::size_type sumLength(const string&, const string&);

decltype(sumLength) *getFcn(const string &);

The only tricky part in declaring getFcn is to remember that when we apply decltype to a function, it returns a function type, not a pointer to function type. We must add a * to indicate that we are returning a pointer, not a function.

==
(finddynamicmemory)            
Dynamic memory

Tao: dynmaic memory is allocated by "new" operator, and freed by "delete" operator.

The programs we‚Äôve written so far have used objects that have well-defined lifetimes. Global objects are allocated at program start-up and destroyed when the program ends. Local, automatic objects are created and destroyed when the block in which they are defined is entered and exited. Local static objects are allocated before their first use and are destroyed when the program ends.

In addition to supporting automatic and static objects, C++ lets us allocate objects dynamically. Dynamically allocated objects have a lifetime that is independent of where they are created; they exist until they are explicitly freed (tao: note explicitly freed).

Properly freeing dynamic objects turns out to be a surprisingly rich source of bugs. To make using dynamic objects safer, the library defines two smart pointer types that manage dynamically allocated objects. Smart pointers ensure that the objects to which they point are automatically freed when it is appropriate to do so.

Warning: Although necessary at times, dynamic memory is notoriously tricky to manage correctly.

In C++, dynamic memory is managed through a pair of operators: new, which allocates, and optionally initializes, an object in dynamic memory and returns a pointer to that object; and delete, which takes a pointer to a dynamic object, destroys that
object, and frees the associated memory. Dynamic memory is problematic because it is surprisingly hard to ensure that we
free memory at the right time. Either we forget to free the memory‚Äîin which case we have a memory leak‚Äîor we free the memory when there are still pointers referring to that memory‚Äîin which case we have a pointer that refers to memory that is no longer valid.

To make using dynamic memory easier (and safer), the new library provides two smart pointer types that manage dynamic objects. A smart pointer acts like a regular pointer with the important exception that it automatically deletes the object to
which it points. The new library defines two kinds of smart pointers that differ in how they manage their underlying pointers: shared_ptr, which allows multiple pointers to
refer to the same object, and unique_ptr, which ‚Äúowns‚Äù the object to which it points. The library also defines a companion class named weak_ptr that is a weak reference to an object managed by a shared_ptr. All three are defined in the memory header.

--
(findsharedptr)
(findsmartpointer)

The shared_ptr Class

A counter keeps track of how many shared_ptrs point to the same
object and automatically frees that object when appropriate.

Like vectors, smart pointers are templates. Therefore, when we create a smart pointer, we must supply additional information‚Äîin this case, the type to which the pointer can point. As with vector, we supply that type inside angle brackets that follow the name of the kind of smart pointer we are defining:

shared_ptr<string> p1; // shared_ptr that can point at a string
shared_ptr<list<int>> p2; // shared_ptr that can point at a list of ints

A default initialized smart pointer holds a null pointer. Later we‚Äôll cover additional ways to initialize a smart pointer. We use a smart pointer in ways that are similar to using a pointer. Dereferencing a smart pointer returns the object to which the pointer points. When we use a smart pointer in a condition, the effect is to test whether the pointer is null.

Those that are particular to shared_ptr are listed in Table below.

--
Operations Common to shared_ptr and unique_ptr:

shared_ptr<T> sp, unique_ptr<T> up: Null smart pointer that can point to objects of type T.

p: Use p as a condition; true if p points to an object.

*p: Dereference to get the object to which p points.

p->mem: Synonym for (*p).mem

p.get(): Returns the pointer in p. Used with caution; the object to which the returned pointer points will disappear when the smart pointer deletes it.

swap(p, q), p.swap(q): Swaps the pointers in p and q.

--
Operations Specific to shared_ptr:

make_shared<T> (args): Returns a shared_ptr pointing to a dynamically allocated object of type T. Uses args to initialize that object.

shared_ptr<T> p(q): p is a copy of the shared_ptr q; increments the count in q. The pointer in q must be convertible to T*.

p = q: p and q are shared_ptrs holding pointers that can be converted to one another. Decrements p's reference count and increments q's count; deletes p's existing memory if p's count goes to 0.

p.use_count(): Returns the number of objects sharing with p; may be a slow operation, intended primarily for debugging purposes.

p.unique(): Returns true if p.use_count() is one; false otherwise.

--
The make_shared Function

The safest way to allocate and use dynamic memory is to call a library function named make_shared. This function allocates and initializes an object in dynamic memory and returns a shared_ptr that points to that object. Like the smart pointers,
make_shared is defined in the memory header.

When we call make_shared, we must specify the type of object we want to create. We do so in the same way as we use a template class, by following the function name with a type enclosed in angle brackets:

// shared_ptr that points to an int with value 42
shared_ptr<int> p3 = make_shared<int>(42);

// p4 points to a string with value 9999999999
shared_ptr<string> p4 = make_shared<string>(10, '9');

// p5 points to an int that is value initialized to 0
shared_ptr<int> p5 = make_shared<int>();

Of course, ordinarily we use auto to make it easier to define an
object to hold the result of make_shared:

// p6 points to a dynamically allocated, empty vector<string>
auto p6 = make_shared<vector<string>>();

--
Copying and Assigning shared_ptrs

When we copy or assign a shared_ptr, each shared_ptr keeps track of how many other shared_ptrs point to the same object:

auto p = make_shared<int>(42); // object to which p points has one user

auto q(p); // p and q point to the same object // object to which p and q point has two users

We can think of a shared_ptr as if it has an associated counter, usually referred to as a reference count. Whenever we copy a shared_ptr, the count is incremented.

For example, the counter associated with a shared_ptr is incremented when we use it to initialize another shared_ptr, when we use it as the right-hand operand of an assignment, or when we pass it to or return it from a function by value. The counter is decremented when we assign a new value to the shared_ptr and when the shared_ptr itself is destroyed, such as when a local shared_ptr goes out of scope. Once a shared_ptr‚Äôs counter goes to zero, the shared_ptr automatically frees
the object that it manages:

auto r = make_shared<int>(42); // int to which r points has one user
r = q; // assign to r, making it point to a different address, increase the use count for the object to which q points, reduce the use count of the object to which r had pointed, the object r had pointed to has no users; that object is automatically freed

--
shared_ptrs Automatically Destroy Their Objects ...

When the last shared_ptr pointing to an object is destroyed, the shared_ptr class automatically destroys the object to which that shared_ptr points. It does so through another special member function known as a destructor. Analogous to its constructors, each class has a destructor. Just as a constructor controls initialization, the destructor controls what happens when objects of that class type are destroyed.

Destructors generally free the resources that an object has allocated. For example, the string constructors (and other string members) allocate memory to hold the characters that compose the string. The string destructor frees that memory.
Similarly, several vector operations allocate memory to hold the elements in the vector. The destructor for vector destroys those elements and frees the memory used for the elements.

The destructor for shared_ptr decrements the reference count of the object to which that shared_ptr points. If the count goes to zero, the shared_ptr destructor destroys the object to which the shared_ptr points and frees the memory used by that object.

...and Automatically Free the Associated Memory

The fact that the shared_ptr class automatically frees dynamic objects when they are no longer needed makes it fairly easy to use dynamic memory. For example, we might have a function that returns a shared_ptr to a dynamically allocated object of a type named Foo that can be initialized by an argument of type T:

// factory returns a shared_ptr pointing to a dynamically allocated object
shared_ptr<Foo> factory(T arg)
{
    // process arg as appropriate
    // shared_ptr will take care of deleting this memory
    return make_shared<Foo>(arg);
}

Because factory returns a shared_ptr, we can be sure that the object allocated by factory will be freed when appropriate. For example, the following function stores the shared_ptr returned by factory in a local variable:

void use_factory(T arg)
{
    shared_ptr<Foo> p = factory(arg);
    // use p
} // p goes out of scope; the memory to which p points is automatically freed

Because p is local to use_factory, it is destroyed when use_factory ends. When p is destroyed, its reference count is decremented and checked. In this case, p is the only object referring to the memory returned by factory. Because p is about to go away, the object to which p points will be destroyed and the memory in which that object resides will be freed.

The memory will not be freed if there is any other shared_ptr pointing to it:

shared_ptr<Foo> use_factory(T arg)
{
    shared_ptr<Foo> p = factory(arg);
    // use p
    return p; // reference count is incremented when we return p
} // p goes out of scope; the memory to which p points is not freed

In this version, the return statement in use_factory returns a copy of p to its caller. Copying a shared_ptr adds to the reference count of that object. Now when p is destroyed, there will be another user for the memory to which p points. The shared_ptr class ensures that so long as there are any shared_ptrs attached to that memory, the memory itself will not be freed.

Note: If you put shared_ptrs in a container, and you subsequently need to use some, but not all, of the elements, remember to erase the elements you no longer need.

Classes with Resources That Have Dynamic Lifetime

Programs tend to use dynamic memory for one of three purposes:
    1. They don‚Äôt know how many objects they‚Äôll need
    2. They don‚Äôt know the precise type of the objects they need
    3. They want to share data between several objects

The container classes are an example of classes that use dynamic memory for the first purpose and we‚Äôll see examples of the second later. In this section, we‚Äôll define a class that uses dynamic memory in order to let several objects share the
same underlying data.

--
(findnew)                      
new operator

Managing Memory Directly

The language itself defines two operators that allocate and free dynamic memory. The new operator allocates memory, and delete frees memory allocated by new.

For reasons that will become clear as we describe how these operators work, using these operators to manage memory is considerably more error-prone than using a smart pointer. Moreover, classes that do manage their own memory‚Äîunlike those that use smart pointers‚Äîcannot rely on the default definitions for the members that copy, assign, and destroy class objects. As a result, programs that use smart pointers are likely to be easier to write and debug.

Warning: Until you have read Chapter 13 (Chapter 13: Copy Control, in Part III Tools for Class Authors, read by tao and copied in this note), your classes should allocate dynamic memory only if they use smart pointers to manage that memory.

--
Using new to Dynamically Allocate and Initialize Objects

Objects allocated on the free store are unnamed, so "new" offers no way to name the objects that it allocates. Instead, "new" returns a pointer to the object it allocates:

//pi points to a dynamically allocated, unnamed, uninitialized int:
//Tao: remember to delete pi, see later.
int *pi = new int; 

This new expression constructs an object of type int on the free store and returns a pointer to that object. 

By default, dynamically allocated objects are default initialized, which means that objects of built-in or compound type have undefined value; objects of class type are initialized by their default constructor.

string *ps = new string; // initialized to empty string
int *pi = new int; // pi points to an uninitialized int

We can initialize a dynamically allocated object using direct initialization. We can use traditional construction (using parentheses), and under the new standard, we can also use list initialization (with curly braces):

int *pi = new int(1024); // object to which pi points has value 1024
string *ps = new string(10, '9'); // *ps is "9999999999"

// vector with ten elements with values from 0 to 9
vector<int> *pv = new vector<int>{0,1,2,3,4,5,6,7,8,9};

We can also value initialize a dynamically allocated object by following the type name with a pair of empty parentheses:

string *ps1 = new string; // default initialized to the empty string
string *ps = new string(); // value initialized to the empty string
int *pi1 = new int; // default initialized; *pi1 is undefined
int *pi2 = new int(); // value initialized to 0; *pi2 is 0

Best Practices: For the same reasons as we usually initialize variables, it is also a good idea to initialize dynamically allocated objects.

When we provide an initializer inside parentheses, we can use auto to deduce the type of the object we want to allocate from that initializer. However, because the compiler uses the initializer‚Äôs type to deduce the type to allocate, we can use auto only with a single initializer inside parentheses:

auto p1 = new auto(obj); // p points to an object of the type of obj that object is initialized from obj
auto p2 = new auto{a,b,c}; // error: must use parentheses for the initializer

--
Dynamically Allocated const Objects

It is legal to use new to allocate const objects:

// allocate and initialize a const int
const int *pci = new const int(1024);

// allocate a default-initialized const empty string
const string *pcs = new const string;

Like any other const, a dynamically allocated const object must be initialized. A const dynamic object of a class type that defines a default constructor may be initialized implicitly. Objects of other types must be explicitly initialized. Because the allocated object is const, the pointer returned by new is a pointer to const.

--
Memory Exhaustion

Although modern machines tend to have huge memory capacity, it is always possible that the free store will be exhausted. Once a program has used all of its available memory, new expressions will fail. By default, if new is unable to allocate the requested storage, it throws an exception of type bad_alloc. We can prevent new from throwing an exception by using a different form of new:

// if allocation fails, new returns a null pointer
int *p1 = new int; // if allocation fails, new throws std::bad_alloc
int *p2 = new (nothrow) int; // if allocation fails, new returns a null pointer

This form of new is referred to as placement new. A placement new expression lets us pass additional arguments to new. In this case, we pass an object named nothrow that is defined by the  library (tao: the "new" library). When we pass nothrow to new, we tell new that it must not throw an exception. If this form of new is unable to allocate the requested storage, it will return a null pointer. Both bad_alloc and nothrow are defined in the new header.

--
(finddelete)
(findfreememory)
Freeing Dynamic Memory

In order to prevent memory exhaustion, we must return dynamically allocated memory to the system once we are finished using it. We return memory through a delete expression. A delete expression takes a pointer to the object we want to free:

delete p; // p must point to a dynamically allocated object or be null

--
Pointer Values and delete

Like new, a delete expression performs two actions: It destroys the object to which its given pointer points, and it frees the corresponding memory.

Although the value of a const object cannot be modified, the object itself can be destroyed.

--
Dynamically Allocated Objects Exist until They Are Freed

As we saw earlier, memory that is managed through a shared_ptr is automatically deleted when the last shared_ptr is destroyed. The same is not true for memory we manage using built-in pointers. A dynamic object managed through a built-in pointer exists until it is explicitly deleted.

Functions that return pointers (rather than smart pointers) to dynamic memory put burden on their callers‚Äîthe caller must remember to delete the memory:

// factory returns a pointer to a dynamically allocated object
Foo* factory(T arg) {
    // process arg as appropriate
    return new Foo(arg); // caller is responsible for deleting this memory
}

Like our earlier factory function, this version of factory allocates an object but does not delete it. Callers of factory are responsible for freeing this memory when they no longer need the allocated object. Unfortunately, all too often the caller forgets to do so:

void use_factory(T arg) {
    Foo *p = factory(arg);
    // use p but do not delete it
} // p goes out of scope, but the memory to which p points is not freed!

Here, our use_factory function calls factory, which allocates a new object of type Foo. When use_factory returns, the local variable p is destroyed. That variable is a built-in pointer, not a smart pointer.

Unlike class types, nothing happens when objects of built-in type are destroyed. In particular, when a pointer goes out of scope, nothing happens to the object to which the pointer points. If that pointer points to dynamic memory, that memory is not automatically freed.

Warning: Dynamic memory managed through built-in pointers (rather than smart pointers) exists until it is explicitly freed.

In this example, p was the only pointer to the memory allocated by factory. Once use_factory returns, the program has no way to free that memory. Depending on the logic of our overall program, we should fix this bug by remembering to free the memory inside use_factory:

void use_factory(T arg) {
    Foo *p = factory(arg);
    // use p
    delete p; // remember to free the memory now that we no longer need it
}

or, if other code in our system needs to use the object allocated by use_factory, we should change that function to return a pointer to the memory it allocated:

Foo* use_factory(T arg) {
    Foo *p = factory(arg);
    // use p
    return p; // caller must delete the memory
}

Caution: Managing Dynamic Memory Is Error-Prone

There are three common problems with using new and delete to manage dynamic memory:

1. Forgetting to delete memory. Neglecting to delete dynamic memory is known as a ‚Äúmemory leak,‚Äù because the memory is never returned to the free store. Testing for memory leaks is difficult because they usually cannot be detected until the application is run for a long enough time to actually
exhaust memory.

2. Using an object after it has been deleted. This error can sometimes be detected by making the pointer null after the delete.

3. Deleting the same memory twice. This error can happen when two
pointers address the same dynamically allocated object. If delete is applied to one of the pointers, then the object‚Äôs memory is returned to the free store. If we subsequently delete the second pointer, then the free store may be corrupted.
These kinds of errors are considerably easier to make than they are to find and fix.

Best Practices: You can avoid all of these problems by using smart pointers exclusively. The smart pointer will take care of deleting the memory only when there are no remaining smart pointers pointing to that memory.

--
Resetting the Value of a Pointer after a delete ...

When we delete a pointer, that pointer becomes invalid. Although the pointer is invalid, on many machines the pointer continues to hold the address of the (freed) dynamic memory. After the delete, the pointer becomes what is referred to as a
dangling pointer. A dangling pointer is one that refers to memory that once held an object but no longer does so.

Dangling pointers have all the problems of uninitialized pointers (tao: like trying to accessing the object pointed by the dangling pointer). We can avoid the problems with dangling pointers by deleting the memory associated with a pointer just before the pointer itself goes out of scope. That way there is no chance to use the pointer after the memory associated with the pointer is freed. If we need to keep the pointer around, we can assign nullptr to the pointer after we use delete. Doing so makes it clear that the pointer points to no object.

...Provides Only Limited Protection

A fundamental problem with dynamic memory is that there can be several pointers that point to the same memory. Resetting the pointer we use to delete that memory lets us check that particular pointer but has no effect on any of the other pointers that still point at the (freed) memory. For example:

int *p(new int(42)); // p points to dynamic memory
auto q = p; // p and q point to the same memory
delete p; // invalidates both p and q
p = nullptr; // indicates that p is no longer bound to an object

Here both p and q point at the same dynamically allocated object. We delete that memory and set p to nullptr, indicating that the pointer no longer points to an object. However, resetting p has no effect on q, which became invalid when we deleted the memory to which p (and q!) pointed. In real systems, finding all the pointers that point to the same memory is surprisingly difficult.

--
Using shared_ptrs with new

As we‚Äôve seen, if we do not initialize a smart pointer, it is initialized as a null pointer. As described in Table below, we can also initialize a smart pointer from a pointer returned by new:

shared_ptr<int> p2(new int(42)); // p2 points to an int with value 42

Other Ways to Define and Change shared_ptrs:

shared_ptr<T> p(q): p manages the object to which the buil-in pointer q points; q must point to memory allocated by new and must be convertible to T*

shared_ptr<T> p(u): p assumes ownership from the unique_ptr u; makes u null.

shared_ptr<T> p(q, d): p assumes ownership for the object to which the built-in pointer q points. q must be convertible to T*. p will use the callable object d in place of delete to free q.

shared_ptr<T> p(p2, d): p is a copy of the shared_ptr p2 except that p uses the callable object d in place of delete.

p.reset(), p.reset(q), p.reset(q, d): If p is the only shared_ptr pointing at its object, reset frees p's existing object. If the optional built-in pointer q is passed, makes point to q, otherwise makes p null. If d is supplied, will call d to free q otherwise uses delete to free q.

The smart pointer constructors that take pointers are explicit. Hence, we cannot implicitly convert a built-in pointer to a smart pointer; we must use the direct form of initialization to initialize a smart pointer:

shared_ptr<int> p1 = new int(1024); // error: must use direct
initialization
shared_ptr<int> p2(new int(1024)); // ok: uses direct initialization

For the same reason, a function that returns a shared_ptr cannot implicitly convert a plain pointer in its return statement:

shared_ptr<int> clone(int p) {
    return new int(p); // error: implicit conversion to shared_ptr<int>
}

We must explicitly bind a shared_ptr to the pointer we want to return:

shared_ptr<int> clone(int p) {
    // ok: explicitly create a shared_ptr<int> from int*
    return shared_ptr<int>(new int(p));
}

--
Don‚Äôt Mix Ordinary Pointers and Smart Pointers ...

A shared_ptr can coordinate destruction only with other shared_ptrs that are copies of itself. Indeed, this fact is one of the reasons we recommend using make_shared rather than new. That way, we bind a shared_ptr to the object at the same time that we allocate it. There is no way to inadvertently(Êº´‰∏çÁ∂ìÂøÉÁöÑ) bind the same memory to more than one independently created shared_ptr.

--
...and Don‚Äôt Use get to Initialize or Assign Another Smart Pointer

The smart pointer types define a function named "get" that returns a built-in pointer to the object that the smart pointer is managing. This function is intended for cases when we need to pass a built-in pointer to code that can‚Äôt use a smart pointer. The code that uses the return from get must not delete that pointer.

Although the compiler will not complain, it is an error to bind another smart pointer to the pointer returned by get:

shared_ptr<int> p(new int(42)); // reference count is 1

int *q = p.get(); // ok: but don't use q in any way that might delete its pointer

{ // new block
    // undefined: two independent shared_ptrs point to the same memory
    shared_ptr<int>(q);
} // block ends, q is destroyed, and the memory to which q points is freed

int foo = *p; // undefined; the memory to which p points was freed

In this case, both p and q point to the same memory. Because they were created independently from each other, each has a reference count of 1. When the block in which q was defined ends, q is destroyed. Destroying q frees the memory to which q
points. That makes p into a dangling pointer, meaning that what happens when we attempt to use p is undefined. Moreover, when p is destroyed, the pointer to that memory will be deleted a second time.

Warning: Use "get" only to pass access to the pointer to code that you know will not delete the pointer. In particular, never use get to initialize or assign to another smart pointer.

--
Other shared_ptr Operations

The shared_ptr class gives us a few other operations, which are listed in Tables above. We can use reset to assign a new pointer to a shared_ptr:

p = new int(1024); // error: cannot assign a pointer to a shared_ptr
p.reset(new int(1024)); // ok: p points to a new object

Like assignment, reset updates the reference counts and, if appropriate, deletes the object to which p points. The reset member is often used together with unique to control changes to the object shared among several shared_ptrs. Before changing
the underlying object, we check whether we‚Äôre the only user. If not, we make a new copy before making the change:

if (!p.unique())
    p.reset(new string(*p)); // we aren't alone; allocate a new copy
*p += newVal; // now that we know we're the only pointer, okay to change this object

--
Smart Pointers and Exceptions

Earlier we noted that programs that use exception handling to continue processing after an exception occurs need to ensure that resources are properly freed if an exception occurs. One easy way to make sure resources are freed is to use smart pointers.

When we use a smart pointer, the smart pointer class ensures that memory is freed when it is no longer needed even if the block is exited prematurely:

void f()
{
    shared_ptr<int> sp(new int(42)); // allocate a new object
    // code that throws an exception that is not caught inside f
} // shared_ptr freed automatically when the function ends

When a function is exited, whether through normal processing or due to an exception, all the local objects are destroyed. In this case, sp is a shared_ptr, so destroying sp checks its reference count. Here, sp is the only pointer to the memory it manages; that memory will be freed as part of destroying sp.

In contrast, memory that we manage directly is not automatically freed when an exception occurs. If we use built-in pointers to manage memory and an exception occurs after a new but before the corresponding delete, then that memory won‚Äôt be freed:

//Tao: this is one big problem of using built-in pointers

void f()
{
    int *ip = new int(42); // dynamically allocate a new object
    // code that throws an exception that is not caught inside f
    delete ip; // free the memory before exiting
}

If an exception happens between the new and the delete, and is not caught inside f, then this memory can never be freed. There is no pointer to this memory outside the function f. Thus, there is no way to free this memory.

--
Smart Pointers and Dumb Classes

Many C++ classes, including all the library classes, define destructors that take care of cleaning up the resources used by that object. However, not all classes are so well behaved. In particular, classes that are designed to be used by both (tao: note both) C and C++ generally require the user to specifically free any  resources that are used.

Classes that allocate resources‚Äîand that do not define destructors to free those resources‚Äîcan be subject to the same kind of errors that arise when we use dynamic memory. It is easy to forget to release the resource. Similarly, if an exception happens between when the resource is allocated and when it is freed, the program will leak that resource.

We can often use the same kinds of techniques we use to manage dynamic memory to manage classes that do not have well-behaved destructors. 

--
Caution: Smart Pointer Pitfalls

Smart pointers can provide safety and convenience for handling dynamically allocated memory only when they are used properly. To use smart pointers correctly, we must adhere to a set of conventions:

‚Ä¢ Don‚Äôt use the same built-in pointer value to initialize (or reset) more than one smart pointer.

‚Ä¢ Don‚Äôt delete the pointer returned from get().

‚Ä¢ Don‚Äôt use get() to initialize or reset another smart pointer.

‚Ä¢ If you use a pointer returned by get(), remember that the pointer will become invalid when the last corresponding smart pointer goes away.

‚Ä¢ If you use a smart pointer to manage a resource other than memory allocated by new, remember to pass a deleter.

--
unique_ptr

A unique_ptr ‚Äúowns‚Äù the object to which it points. Unlike shared_ptr, only one unique_ptr at a time can point to a given object. The object to which a unique_ptr points is destroyed when the unique_ptr is destroyed. Table below lists the operations specific to unique_ptrs. The operations common to both were covered in a Table before.

unique_ptr Operations:

unique_ptr<T> u1, unique_ptr<T, D> u2: Null unique_ptrs that can point to objects of type T. u1 will use delete to free its pointer; u2 will use a callable object of type D to free its pointer.

unique_ptr<T, D> u(d): Null unique_ptr that points to object of type T that uses d, which must be an object of type D in place of delete.

u = nullptr: Deletes the object to which u points; makes u null.

u.release(): Relinquishes(ÊîæÊ£Ñ) control of the pointer u had held; returns the pointer u had held and makes u null.

u.reset(), u.reset(q), u.reset(nullptr): Deletes the object to which u points. If the built-in pointer q is supplied, makes u point to that object. Otherwise makes u null.

Unlike shared_ptr, there is no library function comparable to make_shared that returns a unique_ptr. Instead, when we define a unique_ptr, we bind it to a pointer returned by new. As with shared_ptrs, we must use the direct form of initialization:

unique_ptr<double> p1; // unique_ptr that can point at a double
unique_ptr<int> p2(new int(42)); // p2 points to int with value 42

Because a unique_ptr owns the object to which it points, unique_ptr does not support ordinary copy or assignment:

unique_ptr<string> p1(new string("Stegosaurus"));
unique_ptr<string> p2(p1); // error: no copy for unique_ptr
unique_ptr<string> p3;
p3 = p2; // error: no assign for unique_ptr

Although we can‚Äôt copy or assign a unique_ptr, we can transfer ownership from one (nonconst) unique_ptr to another by calling release or reset:

// Tao: using release:
// transfers ownership from p1 (which points to the string Stegosaurus) to p2
unique_ptr<string> p2(p1.release()); // release makes p1 null

// Tao: using reset:
unique_ptr<string> p3(new string("Trex"));
// transfers ownership from p3 to p2
p2.reset(p3.release()); // reset deletes the memory to which p2 had pointed

The release member returns the pointer currently stored in the unique_ptr and makes that unique_ptr null. Thus, p2 is initialized from the pointer value that had been stored in p1 and p1 becomes null.

The reset member takes an optional pointer and repositions the unique_ptr to point to the given pointer. If the unique_ptr is not null, then the object to which the unique_ptr had pointed is deleted. The call to reset on p2, therefore, frees the memory used by the string initialized from "Stegosaurus", transfers p3‚Äôs
pointer to p2, and makes p3 null.

--
Passing and Returning unique_ptrs

There is one exception to the rule that we cannot copy a unique_ptr: We can copy or assign a unique_ptr that is about to be destroyed. The most common example is when we return a unique_ptr from a function:

unique_ptr<int> clone(int p) {
    // ok: explicitly create a unique_ptr<int> from int*
    return unique_ptr<int>(new int(p));
}

Alternatively, we can also return a copy of a local object:

unique_ptr<int> clone(int p) {
    unique_ptr<int> ret(new int (p));
    // . . .
    return ret;
}

In both cases, the compiler knows that the object being returned is about to be destroyed. In such cases, the compiler does a special kind of ‚Äúcopy‚Äù which we‚Äôll discuss later.

Backward Compatibility: auto_ptr

Earlier versions of the library included a class named auto_ptr that had some, but not all, of the properties of unique_ptr. In particular, it was not possible to store an auto_ptr in a container, nor could we return one from a function.

Although auto_ptr is still part of the standard library, programs should use unique_ptr instead.

--
Passing a Deleter to unique_ptr

Like shared_ptr, by default, unique_ptr uses delete to free the object to which a unique_ptr points. As with shared_ptr, we can override the default deleter in a unique_ptr. However, for reasons we‚Äôll describe later, the way unique_ptr manages its deleter is differs from the way shared_ptr does.

Overridding the deleter in a unique_ptr affects the unique_ptr type as well as how we construct (or reset) objects of that type. Similar to overriding the comparison operation of an associative container, we must supply the deleter type inside the angle brackets along with the type to which the unique_ptr can point. We supply a callable object of the specified type when we create or reset an object of this type:

// p points to an object of type objT and uses an object of type delT to free that object. It will call an object named fcn of type delT
unique_ptr<objT, delT> p (new objT, fcn);

--
weak_ptr

A weak_ptr is a smart pointer that does not control the lifetime of the object to which it points. Instead, a weak_ptr points to an object that is managed by a shared_ptr. Binding a weak_ptr to a shared_ptr does not change the reference count of that shared_ptr. Once the last shared_ptr pointing to the object goes away, the object itself will be deleted. That object will be deleted even if there are weak_ptrs pointing to it‚Äîhence the name weak_ptr, which captures the idea that a weak_ptr shares its object ‚Äúweakly.‚Äù

weak_ptrs:

weak_ptr<T> w: Null weak_ptr that can point at object of type T.

weak_ptr<T> w(sp): weak_ptr that points to the same object as the shared_ptr sp. T must be convertible to the type to which sp points.

w = p: p can be shared_ptr or a weak_ptr. After the assignment w shared ownership with p.

w = use_count(): The number of shared_ptrs that share ownership with w.

w.expired(): Returns true if w. use_count() is zero, false otherwise.

w.lock(): If expired is true, returns a null shared_ptr; otherwise returns a shared_ptr to the object to which w points.

When we create a weak_ptr, we initialize it from a shared_ptr:

auto p = make_shared<int>(42);
weak_ptr<int> wp(p); // wp weakly shares with p; use count in p is unchanged

Here both wp and p point to the same object. Because the sharing is weak, creating wp doesn‚Äôt change the reference count of p; it is possible that the object to which wp points might be deleted.

Because the object might no longer exist, we cannot use a weak_ptr to access its object directly. To access that object, we must call lock. The lock function checks whether the object to which the weak_ptr points still exists. If so, lock returns a
shared_ptr to the shared object. As with any other shared_ptr, we are guaranteed that the underlying object to which that shared_ptr points continues to exist at least as long as that shared_ptr exists. For example:

if (shared_ptr<int> np = wp.lock()) { // true if np is not null
    // inside the if, np shares its object with p
}

Here we enter the body of the if only if the call to lock succeeds. Inside the if, it is safe to use np to access that object.

--
(finddynamicarray)
Dynamic Arrays

The new and delete operators allocate objects one at a time. Some applications, need the ability to allocate storage for many objects at once. For example, vectors and strings store their elements in contiguous memory and must allocate several elements at once whenever the container has to be reallocated.

To support such usage, the language and library provide two ways to allocate an array of objects at once. The language defines a second kind of new expression that allocates and initializes an array of objects. The library includes a template class named allocator that lets us separate allocation from initialization. For reasons we‚Äôll explain later, using an allocator generally provides better performance and more flexible memory management.

Many, perhaps even most, applications have no direct need for dynamic arrays. When an application needs a varying number of objects, it is almost always easier, faster, and safer to do as we did with StrBlob: use a vector (or other library container). For reasons we‚Äôll explain later, the advantages of using a library container are even more pronounced under the new standard. Libraries that support the new standard tend to be dramatically faster than previous releases. Tao: remember in my PhD C++, I used a lot of allocate, and at that time I did not know vectors.

Best Practices: Most applications should use a library container rather than dynamically allocated arrays. Using a container is easier, less likely to contain memory-management bugs, and is likely to give better performance.

As we‚Äôve seen, classes that use the containers can use the default versions of the operations for copy, assignment, and destruction. Classes that allocate dynamic arrays must define their own versions of these operations to manage the associated memory when objects are copied, assigned, and destroyed.

Warning: Do not allocate dynamic arrays in code inside classes until you have read Chapter 13 (Chapter 13: Copy Control, in Part III Tools for Class Authors, read by tao and copied in this note).

--
new and Arrays

We ask "new" to allocate an array of objects by specifying the number of objects to allocate in a pair of square brackets after a type name. In this case, "new" allocates the requested number of objects and (assuming the allocation succeeds) returns a pointer to the first one:

// call get_size to determine how many ints to allocate
int *pia = new int[get_size()]; // pia points to the first of these ints

The size inside the brackets must have integral type but need not be a constant. We can also allocate an array by using a type alias to represent an array type. In this case, we omit the brackets:

typedef int arrT[42]; // arrT names the type array of 42 ints
int *p = new arrT; // allocates an array of 42 ints; p points to the first one

Here, new allocates an array of ints and returns a pointer to the first one. Even though there are no brackets in our code, the compiler executes this expression using new[]. That is, the compiler executes this expression as if we had written

int *p = new int[42];

--
Allocating an Array Yields a Pointer to the Element Type

Although it is common to refer to memory allocated by new T[] as a ‚Äúdynamic array,‚Äù this usage is somewhat misleading. When we use new to allocate an array, we do not get an object with an array type. Instead, we get a pointer to the element type of the array. Even if we use a type alias to define an array type, new does not allocate an object of array type. In this case, the fact that we‚Äôre allocating an array is not even visible; there is no [num]. Even so, new returns a pointer to the element type.

Because the allocated memory does not have an array type, we cannot call begin or end on a dynamic array. These functions use the array dimension (which is part of an array‚Äôs type) to return pointers to the first and one past the last elements, respectively. For the same reasons, we also cannot use a range for to process the elements in a (so-called) dynamic array.

Warning: It is important to remember that what we call a dynamic array does not have an array type.

--
Initializing an Array of Dynamically Allocated Objects

By default, objects allocated by new‚Äîwhether allocated as a single object or in an array‚Äîare default initialized. We can value initialize the elements in an array by following the size with an empty pair of parentheses.

int *pia = new int[10]; // block of ten uninitialized ints
int *pia2 = new int[10](); // block of ten ints value initialized to 0
string *psa = new string[10]; // block of ten empty strings
string *psa2 = new string[10](); // block of ten empty strings

Under the new standard, we can also provide a braced list of element initializers:

// block of ten ints each initialized from the corresponding initializer
int *pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9};

// block of ten strings; the first four are initialized from the given initializers, remaining elements are value initialized
string *psa3 = new string[10]{"a", "an", "the", string(3,'x')};

As when we list initialize an object of built-in array type, the
initializers are used to initialize the first elements in the array. If there are fewer initializers than elements, the remaining elements are value initialized. If there are more initializers than the given size, then the new expression fails and no storage is allocated. In this case, new throws an exception of type bad_array_new_length. Like bad_alloc, this type is defined in the new header.

Although we can use empty parentheses to value initialize the elements of an array, we cannot supply an element initializer inside the parentheses. The fact that we cannot supply an initial value inside the parentheses means that we cannot use auto to allocate an array.

--
It Is Legal to Dynamically Allocate an Empty Array

We can use an arbitrary expression to determine the number of objects to allocate:

size_t n = get_size(); // get_size returns the number of elements needed
int* p = new int[n]; // allocate an array to hold the elements
for (int* q = p; q != p + n; ++q)
    /* process the array */ ;

An interesting question arises: What happens if get_size returns 0? The answer is that our code works fine. Calling new[n] with n equal to 0 is legal even though we cannot create an array variable of size 0:

char arr[0]; // error: cannot define a zero-length array
char *cp = new char[0]; // ok: but cp can't be dereferenced

When we use new to allocate an array of size zero, new returns a valid, nonzero pointer. That pointer is guaranteed to be distinct from any other pointer returned by new. This pointer acts as the off-the-end pointer for a zero-element array. We can use this pointer in ways that we use an off-the-end iterator. The pointer can be compared as in the loop above. We can add zero to (or subtract zero from) such a pointer and can subtract the pointer from itself, yielding zero. The pointer cannot be dereferenced‚Äîafter all, it points to no element.

--
Freeing Dynamic Arrays

To free a dynamic array, we use a special form of delete that includes an empty pair of square brackets:

delete p; // p must point to a dynamically allocated object or be null
delete [] pa; // pa must point to a dynamically allocated array or be null

The second statement destroys the elements in the array to which pa points and frees the corresponding memory. Elements in an array are destroyed in reverse order. That is, the last element is destroyed first, then the second to last, and so on.

When we delete a pointer to an array, the empty bracket pair is essential: It indicates to the compiler that the pointer addresses the first element of an array of objects. If we omit the brackets when we delete a pointer to an array (or provide them when we delete a pointer to an object), the behavior is undefined.

Recall that when we use a type alias that defines an array type, we can allocate an array without using [] with new. Even so, we must use brackets when we delete a pointer to that array:

typedef int arrT[42]; // arrT names the type array of 42 ints
int *p = new arrT; // allocates an array of 42 ints; p points to the first
one
delete [] p; // brackets are necessary because we allocated an array

Despite appearances, p points to the first element of an array of objects, not to a single object of type arrT. Thus, we must use [] when we delete p.

Warning: The compiler is unlikely to warn us if we forget the brackets when we delete a pointer to an array or if we use them when we delete a pointer to an object. Instead, our program is apt to misbehave without warning during execution.

--
Smart Pointers and Dynamic Arrays:

The library provides a version of unique_ptr that can manage arrays allocated by new. To use a unique_ptr to manage a dynamic array, we must include a pair of empty brackets after the object type:

// up points to an array of ten uninitialized ints
unique_ptr<int[]> up(new int[10]);
up.release(); // automatically uses delete[] to destroy its pointer

The brackets in the type specifier (<int[]>) say that up points not to an int but to an array of ints. Because up points to an array, when up destroys the pointer it manages, it will automatically use delete[].

unqiue_ptrs that point to arrays provide slightly different operations than those we used earlier. These operations are described in Table below. When a unique_ptr points to an array, we cannot use the dot and arrow member access operators. After all, the unqiue_ptr points to an array, not an object so these operators would be meaningless. On the other hand, when a unqiue_ptr points to an array, we can use the subscript operator to access the elements in the array:

for (size_t i = 0; i != 10; ++i)
    up[i] = i; // assign a new value to each of the elements

unique_ptrs to Arrays:

Member access operators (doe and arrow) are not supported for unique_ptrs to arays. Other unique_ptr operations unchanged.

unique_ptr<T[]> u: u can point to a dynamically allocated array of type T.

unique_ptr<T[]> u(p): u points to the dynamically allocated array to which the built-in pointer p oints. p must be convertible to T*.

u[i]: Returns the object at position i in the array that u owns. u must point to an array.

Unlike unique_ptr, shared_ptrs provide no direct support for managing a dynamic array. If we want to use a shared_ptr to manage a dynamic array, we must provide our own deleter:

// to use a shared_ptr we must supply a deleter
shared_ptr<int> sp(new int[10], [](int *p) { delete[] p; });
sp.reset(); // uses the lambda we supplied that uses delete[] to free the array

Here we pass a lambda that uses delete[] as the deleter. Had we neglected to supply a deleter, this code would be undefined. By default, shared_ptr uses delete to destroy the object to which it points. If that object is a dynamic array, using delete has the same kinds of problems that arise if we forget to use [] when we delete a pointer to a dynamic array.

The fact that shared_ptr does not directly support managing arrays affects how we access the elements in the array:

// shared_ptrs don't have subscript operator and don't support pointer arithmetic
for (size_t i = 0; i != 10; ++i)
    *(sp.get() + i) = i; // use get to get a built-in pointer

There is no subscript operator for shared_ptrs, and the smart pointer types do not support pointer arithmetic. As a result, to access the elements in the array, we must use get to obtain a built-in pointer, which we can then use in normal ways.

--
The allocator Class

An aspect of new that limits its flexibility is that new combines allocating memory with constructing object(s) in that memory. Similarly, delete combines destruction with deallocation. Combining initialization with allocation is usually what we want when we allocate a single object. In that case, we almost certainly know the value the object should have.

When we allocate a block of memory, we often plan to construct objects in that memory as needed. In this case, we‚Äôd like to decouple memory allocation from object construction. Decoupling construction from allocation means that we can allocate memory in large chunks and pay the overhead of constructing the objects only when we actually need to create them.

In general, coupling allocation and construction can be wasteful. For example:

string *const p = new string[n]; // construct n empty strings
string s;
string *q = p; // q points to the first string

while (cin >> s && q != p + n)
    *q++ = s; // assign a new value to *q

const size_t size = q - p; // remember how many strings we read

// use the array
delete[] p; // p points to an array; must remember to use delete[]

This new expression allocates and initializes n strings. However, we might not need n strings; a smaller number might suffice. As a result, we may have created objects that are never used. Moreover, for those objects we do use, we immediately assign new values over the previously initialized strings. The elements that are used are written twice: first when the elements are default initialized, and subsequently when we assign to them.

More importantly, classes that do not have default constructors cannot be dynamically allocated as an array.

--
The allocator Class

The library allocator class, which is defined in the memory header, lets us separate allocation from construction. It provides type-aware allocation of raw, unconstructed, memory. Table below outlines the operations that allocator supports. In this section, we‚Äôll describe the allocator operations. Later we‚Äôll see an example of how this class is typically used.

Standard allocator Class and Customized Algorithms:

allocator<T> a: Defines an allocator object named a that can allocate memory for obejcts of type T.

a.allocate(n): Allocates raw, unconstructed memory to hold n objects of type T.

a.deallocate(p, n): Deallocates memeory that held n objects of type T starting at the address in the T* pointer p; p must be a pointer previously returned by allcoate, and n must be the size requested when p was created. The user must run destroy on any obejcts that were constructed in this memory before calling deallocate.

a.construct(p, args): p must be a pointer to type T that points to raw memory; args are passed to a constructor for type T, which is used to construct an object in the memory pointed to by p.

a.destroy(p): Runs the destructor on the object pointed to by the T* pointer p.

Like vector, allocator is a template. To define an allocator we
must specify the type of objects that a particular allocator can allocate. When an allocator object allocates memory, it allocates memory that is appropriately sized and aligned to hold objects of the given type:

allocator<string> alloc; // object that can allocate strings
auto const p = alloc.allocate(n); // allocate n unconstructed strings

This call to allocate allocates memory for n strings.

--
allocators Allocate Unconstructed Memory

The memory an allocator allocates is unconstructed. We use this memory by constructing objects in that memory. In the new library the construct member takes a pointer and zero or more additional arguments; it constructs an element at the given location. The additional arguments are used to initialize the object being constructed.

Like the arguments to make_shared, these additional arguments
must be valid initializers for an object of the type being constructed. In particular, if the, object is a class type, these arguments must match a constructor for that class:

auto q = p; // q will point to one past the last constructed element
alloc.construct(q++); // *q is the empty string
alloc.construct(q++, 10, 'c'); // *q is cccccccccc
alloc.construct(q++, "hi"); // *q is hi!

In earlier versions of the library, construct took only two arguments: the pointer at which to construct an object and a value of the element type. As a result, we could only copy an element into unconstructed space, we could not use any other constructor for the element type.

It is an error to use raw memory in which an object has not been constructed:

cout << *p << endl; // ok: uses the string output operator
cout << *q << endl; // disaster: q points to unconstructed memory!

Warning: We must construct objects in order to use memory returned by allocate. Using unconstructed memory in other ways is undefined.

When we‚Äôre finished using the objects, we must destroy the elements we constructed, which we do by calling destroy on each constructed element. The destroy function takes a pointer and runs the destructor on the pointed-to object:

while (q != p)
    alloc.destroy(--q); // free the strings we actually allocated

At the beginning of our loop, q points one past the last constructed element. We decrement q before calling destroy. Thus, on the first call to destroy, q points to the last constructed element. We destroy the first element in the last iteration, after which q will equal p and the loop ends.

Warning: We may destroy only elements that are actually constructed.

Once the elements have been destroyed, we can either reuse the memory to hold other strings or return the memory to the system. We free the memory by calling deallocate:

alloc.deallocate(p, n);

The pointer we pass to deallocate cannot be null; it must point to memory allocated by allocate. Moreover, the size argument passed to deallocate must be the same size as used in the call to allocate that obtained the memory to which the pointer points.

--
Algorithms to Copy and Fill Uninitialized Memory

As a companion to the allocator class, the library also defines two algorithms that can construct objects in uninitialized memory. These functions, described in Table below, are defined in the memory header.

allocator Algorithms:

These functions constructed elements in the destination, rather than assigning to them.

uninitialized_copy(b, e, b2): Copies elements from the input range denoted by iterators b and e into unconstructed, raw memory denoted by the iterator b2. The memory denoted by b2 must be large enough to hold a copy of the elements in the input range.

uninitialized_copy_n(b, n, b2): Copies n elements starting from the one denoted by the iterator b into raw memory starting at b2.

uninitialized_fill(b, e, t): Constructs objects in the range of raw memory denoted by iterators b and e as a copy of it.

uninitialized_fill_n(b, n, t): Construtcts an unsigned number n objects starting at b. b must denote unconstructed, raw memory large enough to hold the given number of objects.

As an example, assume we have a vector of ints that we want to copy into dynamic memory. We‚Äôll allocate memory for twice as many ints as are in the vector. We‚Äôll construct the first half of the newly allocated memory by copying elements from the original vector. We‚Äôll construct elements in the second half by filling them with a given value:

// allocate twice as many elements as vi holds
auto p = alloc.allocate(vi.size() * 2);

// construct elements starting at p as copies of elements in vi
auto q = uninitialized_copy(vi.begin(), vi.end(), p);

// initialize the remaining elements to 42
uninitialized_fill_n(q, vi.size(), 42);

Like the copy algorithm, uninitialized_copy takes three iterators. The first two denote an input sequence and the third denotes the destination into which those elements will be copied. The destination iterator passed to uninitialized_copy must denote unconstructed memory. Unlike copy, uninitialized_copy constructs elements in its destination.

Like copy, uninitialized_copy returns its (incremented) destination iterator. Thus, a call to uninitialized_copy returns a pointer positioned one element past the last constructed element. In this example, we store that pointer in q, which we pass to uninitialized_fill_n. This function, like fill_n, takes a pointer to a destination, a count, and a value. It will construct the given number of objects from the given value at locations starting at the given destination.

==
(findconst)
const

We can make a variable unchangeable by defining the variable‚Äôs type as const. 

Because we can‚Äôt change the value of a const object after we create it, it must be initialized (tao: same as reference). As usual, the initializer may be an arbitrarily complicated expression.

const int bufSize = 512; 

Any attempt to assign to bufSize is an error:

bufSize = 512; // error: attempt to write to const object

--
Reference to const

As with any other object, we can bind a reference to an object of a const type. To do so we use a reference to const, which is a reference that refers to a const type. Unlike an ordinary reference, a reference to const cannot be used to change the object to which the reference is bound:

const int ci = 1024;
const int &r1 = ci; // ok: both reference and underlying object are const
r1 = 42; // error: r1 is a reference to const
int &r2 = ci; // error: non const reference to a const object

See following summary for remember.

we can bind a reference to const to a nonconst object, a literal, or a more general expression:

int i = 42;
const int &r1 = i; // we can bind a const int& to a plain int object
const int &r2 = 42; // ok: r1 is a reference to const
const int &r3 = r1 * 2; // ok: r3 is a reference to const
int &r4 = r * 2; // error: r4 is a plain, non const reference

A Reference to const May Refer to an Object That Is Not const

int i = 42;
int &r1 = i; // r1 bound to i
const int &r2 = i; // r2 also bound to i; but cannot be used to change i
r1 = 0; // r1 is not const; i is now 0
r2 = 0; // error: r2 is a reference to const

Binding r2 to the (nonconst) int i is legal. However, we cannot use r2 to change i. Even so, the value in i still might change. We can change i by assigning to it directly, or by assigning to another reference bound to i, such as r1.

--
const refrence: no such thing

--
Pointer to const:

We may store the address of a const object only in a pointer to const:

onst double pi = 3.14; // pi is const; its value may not be changed
double *ptr = &pi; // error: ptr is a plain pointer
const double *cptr = &pi; // ok: cptr may point to a double that is const
*cptr = 42; // error: cannot assign to *cptr

See following summary for remember.

We can use a pointer to const to point to a nonconst object:

double dval = 3.14; // dval is a double; its value can be changed
cptr = &dval; // ok: but can't change dval through cptr

--
const pointer:

Unlike references, pointers are objects. Hence, as with any other object type, we can have a pointer that is itself const. Like any other const object, a const pointer must be initialized, and once initialized, its value (i.e., the address that it holds) may not be changed. We indicate that the pointer is const by putting the const after the *.

int errNumb = 0;
int *const curErr = &errNumb; // curErr will always point to errNumb
const double pi = 3.14159;
const double *const pip = &pi; // pip is a const pointer to a const
object

See following summary for remember.

The fact that a pointer is itself const says nothing about whether we can use the pointer to change the underlying object.

--
Summary from the above:
1. int is always on the left of *, like int *
2. const can be on the left or right of int *, like: const int *, int * const
3. Principle: the symbol that is closest to the variable name is comes to the first in the type name: 
   const double *cptr = &pi: cptr is a pointer to const
   int *const curErr = &errNumb: curErr is a const pointer

--
Top-Level const

We use the term top-level const to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a low-level const. More generally, top-level const indicates that an object itself is const. Low-level const appears in the base type of compound types such as pointers or references.

int i = 0;
int *const p1 = &i; // we can't change the value of p1; const is top-level
const int ci = 42; // we cannot change ci; const is top-level
const int *p2 = &ci; // we can change p2; const is low-level
const int *const p3 = p2; // right-most const is top-level, left-most is not
const int &r = ci; // const in reference types is always low-level

The distinction between top-level and low-level matters when we copy an object. When we copy an object, top-level consts are ignored. Example:

const int ci = i;
auto b = ci; // b is an int (top-level const in ci is dropped)

On the other hand, low-level const is never ignored. When we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects. In general, we can convert a nonconst to const but not the other way round.

--
const in multiple files

When we split a program into multiple files, every file that uses the const must have access to its initializer. In order to see the initializer, the variable must be defined in every file that wants to use the variable‚Äôs value. To support this usage, yet avoid multiple definitions of the same variable, const variables are defined as local to the file. When we define a const with the same name in multiple files, it is as if we had written definitions for separate variables in each file.

Sometimes we have a const variable that we want to share across multiple files but whose initializer is not a constant expression. In this case, we don‚Äôt want the compiler to generate a separate variable in each file. Instead, we want the const object to behave like other (nonconst) variables. We want to define the const in one file, and declare it in the other files that use that object.

To define a single instance of a const variable, we use the keyword extern on both its definition and declaration(s):

// file_1.cc defines and initializes a const that is accessible to other files
extern const int bufSize = fcn();

// file_1.h
extern const int bufSize; // same bufSize as defined in file_1.cc

--
(findconstantexpression)
(findconstexpr)
Constant expression

A constant expression is an expression whose value cannot change and that can be evaluated at compile time. A literal is a constant expression. A const object that is initialized from a constant expression is also a constant expression. 

Whether a given object (or expression) is a constant expression depends on the types and the initializers. For example:

const int max_files = 20; // max_files is a constant expression
const int limit = max_files + 1; // limit is a constant expression
int staff_size = 27; // staff_size is not a constant expression
const int sz = get_size(); // sz is not a constant expression

Even though sz is a const, the value of its initializer is not known until run time. Hence, sz is not a constant expression.

constexpr Variables

Under the new standard, we can ask the compiler to verify that a variable is a constant expression by declaring the variable in a constexpr declaration. Variables declared as constexpr are implicitly const and must be initialized by constant expressions:

constexpr int mf = 20; // 20 is a constant expression
constexpr int limit = mf + 1; // mf + 1 is a constant expression
constexpr int sz = size(); // ok only if size is a constexpr function

Although we cannot use an ordinary function as an initializer for a constexpr variable, we‚Äôll see later that the new standard lets us define certain functions as constexpr. Such functions must be simple enough that the compiler can evaluate them at compile time. We can use constexpr functions in the initializer of a constexpr variable.

Generally, it is a good idea to use constexpr for variables that you intend to use as constant expressions.

--
Literal Types

Because a constant expression is one that can be evaluated at compile time, there are limits on the types that we can use in a constexpr declaration. The types we can use in a constexpr are known as ‚Äúliteral types‚Äù because they are simple enough to have literal values.

Of the types we have used so far, the arithmetic, reference, and pointer types are literal types. Our Sales_item class and the library IO and string types are not literal types. Hence, we cannot define variables of these types as constexprs. We‚Äôll see other kinds of literal types later.

Although we can define both pointers and reference as constexprs, the objects we use to initialize them are strictly limited. We can initialize a constexpr pointer from the nullptr literal or the literal (i.e., constant expression) 0. We can also point to (or bind to) an object that remains at a fixed address.

For reasons we‚Äôll cover later, variables defined inside a function
ordinarily are not stored at a fixed address. Hence, we cannot use a constexpr pointer to point to such variables. On the other hand, the address of an object defined outside of any function is a constant expression, and so may be used to initialize a constexpr pointer. We‚Äôll see later, that functions may define variables that exist across calls to that function. Like an object defined outside any function, these special local objects also have fixed addresses. Therefore, a constexpr
reference may be bound to, and a constexpr pointer may address, such variables.

--
Pointers and constexpr

It is important to understand that when we define a pointer in a constexpr declaration, the constexpr specifier applies to the pointer, not the type to which the pointer points:

const int *p = nullptr; // p is a pointer to a const int
constexpr int *q = nullptr; // q is a const pointer to int

Despite appearances, the types of p and q are quite different; p is a pointer to const, whereas q is a constant pointer. The difference is a consequence of the fact that constexpr imposes a top-level const on the objects it defines.

Like any other constant pointer, a constexpr pointer may point to a const or a nonconst type.

==
(findfor)
(findrangefor)

Range for in C++ 2011:

vector<int> v = {1, 3, 5, 7, 9};

for (auto x : v)
    cout << x << ' ';

string str("some string");
for (auto c : str) // tao: c is a char
	cout << c << endl; 

Using a Range for to Change the Characters in a string

If we want to change the value of the characters in a string, we must define the loop variable as a reference type. Remember that a reference is just another name for a given object. When we use a reference as our control variable, that variable is bound to each element in the sequence in turn. Using the reference,
we can change the character to which the reference is bound.

string s("Hello World!!!");
// convert s to uppercase
for (auto &c : s) // for every char in s (note: c is a reference)
	c = toupper(c); // c is a reference, so the assignment changes the char in s
cout << s << endl;	

==
(findsleep)
Sleep

Compile the following file:

g++ -o sleep sleep.cc -std=c++0x -D_GLIBCXX_USE_NANOSLEEP

--- File sleep.cc starts ---
#include <iostream>
#include <chrono>
#include <thread>
using namespace std;

int main() {
    std::this_thread::sleep_for(std::chrono::milliseconds(5000));
    cout << "Hello world" << endl;
}
--- File sleep.cc ends ---

==
(findstring)
string

A string literal, which is a sequence of characters enclosed in double quotation marks.

The string and vector types are abstractions of the more primitive built-in array type. Arrays are less convenient to use than the library string and vector types.

A string is a variable-length sequence of characters. To use the string type, we must include the string header.

#include <string>
using std::string;

--
string literal: the compiler appends a null character ('\0') to every string literal. Thus, the actual size of a string literal is one more than its apparent size.

s.empty() //Returns bool
s.size() //Returns number, which is a string::size_type, see below
s[3] //Returns a reference to the char. Type of index is string::size_type. Tao: index can also be int.
s[0] = 'a'; //So long as the string is not const, we can assign a new value to the character that the subscript operator returns.

--
string operations:

s.empty(): Returns true if s is empty; otherwise returns false.
s.size(): Returns the number of characters in s. Tao: returned type is string::size_type.
s[n]: Returns a reference to the char at position n in s; positions start at 0.
s1 + s2: Returns a string that is the concatenation of s1 and s2.
s1 += s2: Tao: equivalent to s1 = s1 + s2
s1 = s2: Replaces characters in s1 with a copy of s2.
s1 == s2, s1 != s2: s1 and s2 are equal if they contain the same characters. Equality is case-sensitive. 
<, <=, <, <=: Comparisons are case-sensitive and use dictionary ordering.

--
Operations to moidfy strings (modify in-place)

s.insert(pos, args): Insert characters specified by args before pos. pos can be an index or an iterator. Versions taking an index returns a reference to s; those taking an iterator return an interator denoting the first inserted character.

s.append(args): Append args to s. Returns a reference to s.

s.erase(pos, len): Remove len characters starting at position pos. If len is omitted. Removes characters from pos to the end of the s. Returns a reference to s.

s.replace(range, args): Remove range of characters form s and replace them with the characters formed by args. range is either an index and a length or a pair of iterators into s. Returns a reference to s.

s.assign(args): Replace characters in s according to args. Returns a reference to s.

args can be one of the following (append and assign can use all forms, str must be distinc from s and the iterators b and e may not refer to s):

str: The string str.

str, pos, len: Up to len characters from str starting at pos.

cp, len: Up to len charactres from the character array pointed to by cp.

cp: Null-terminated array pointed to by pointer cp.

n, c: n copies of character c.

b, e: Characters in the range formed by iterators b and e.

intializer list: Comma-separated list of characters enclosed in braces.

args for replace and insert depend on how range or pos is specified:

replace          replace      insert      insert       args can be
(pos,len,args)   (b,e,args)   (pos,args)  (iter,args)  
yes              yes          yes         no           str
yes              no           yes         no           str,pos,len
yes              yes          yes         no           cp,len
yes              yes          no          no           cp
yes              yes          yes         yes          n,c
no               yes          no          yes          b2,e2
no               yes          no          yes          initializer list

--
append

The append operation is a shorthand way of inserting at the end.
The append changes the contents of a string (tao: in-place).
The parameter of append() can only be string, it can not be char.

s2.append("helo"); 

--
insert

s.insert(s.size(), "helo"); //Inserts "helo" before position 0 in s.

s.insert(s.size(), 5, '!'); //Inserts five exclamatin points at the end of s

s.insert(0, s2, 0, s2.size()); //Inserts s2.size() characters from s2 starting at s2[0] before s[0].

--
replace:

The replace operations are a shorthand way of calling erase and insert: 

// equivalent way to replace "4th" by "5th"
s.erase(11, 3); // s == "C++ Primer Ed."
s.insert(11, "5th"); // s == "C++ Primer 5th Ed."

// starting at position 11, erase three characters and then insert "5th"
s2.replace(11, 3, "5th"); // equivalent: s == s2
s.replace(11, 3, "Fifth"); // s == "C++ Primer Fifth Ed."

--
(findfind)
string Search Operations

The string class provides six different search functions, each of which has four overloaded versions. Table 9.14 describes the search members and their arguments.

Each of these search operations returns a string::size_type value that is the index of where the match occurred. If there is no match, the function returns a static member named string::npos. The library defines npos as a const string::size_type initialized with the value -1. Because npos is an unsigned type, this initializer means npos is equal to the largest possible size any string could have

string search operations:

s.find(args): Find the first occurence of args in s.

s.rfind(args): Find the las occurence of args in s.

s.find_first_of(args): Find the first occurence of any character from args in s.

s.find_last_of(args): Find the last occurence of any character from args in s.

s.find_first_not_of(args): Find the first character in s that is not in args.

s.find_last_not_of(args): Find the last character in s that is not in args.

args must be one of:

c, pos: Look for the character c starting at position pos in s. pos defaults to 0.

s2, pos: Look for string s2 starting at position pos in s. pos default to 0.

cp, pos: Look for the C-style null-terminated string pointed to the pointer cp. Start looking at position pos in s. pos defaults to 0.

cp, pos, n: Look for the first n characters in the array pointed to by the pointer cp. Start looking at position pos in s. No default for pos or n.

Searching (and other string operations) are case sensitive.

The string search functions return string::size_type, which is an
unsigned type. As a result, it is a bad idea to use an int, or other signed type, to hold the return from these functions

string s = "helo"; //Tao's example
s.find("lo")// Returns: 2

while((pos = s.find(delimiter)) != string::npos) {...} //Tao's example of npos

string name("AnnaBelle");
auto pos1 = name.find("Anna"); // pos1 == 0

string numbers("0123456789"), name("r2d2");
auto pos = name.find_first_of(numbers); // returns 1, i.e., the index of the first digit (tao: 2) in name

string dept("03714p3");
auto pos = dept.find_first_not_of(numbers); // returns 5, which is the index to the character 'p'

Searching Backward

The find operations we‚Äôve used so far execute left to right. The library provides analogous operations that search from right to left. The rfind member searches for the last‚Äîthat is, right-most‚Äîoccurrence of the indicated substring:

string river("Mississippi");
auto first_pos = river.find("is"); // returns 1
auto last_pos = river.rfind("is"); // returns 4 (tao: 4 means the 4th character from left, not from right).

--
The compare Functions

In addition to the relational operators, the string library provides a set of compare functions that are similar to the C library strcmp function. Like strcmp, s.compare returns zero or a positive or negative value depending on whether s is equal to, greater than, or less than the string formed from the given arguments.

Possible Arguments to s.compare:

s2: Compares to s2.

pos1, n1, s2: Compares n1 characters starting at pos1 from s to s2.

pos1, n1, s2, pos2, n2: Compares n2 characters starting at pos1 from s to the n2 characters starting at pos2 in s2.

cp: Compares s to the null-terminated array pointed to by cp.

pos1, n1, cp: Compares n1 characters starting at pos1 from s to cp.

pos1, n1, cp, n2: Compares n1 characters starting at pos1 from s to n2 characters starting from the pointer cp.

--
Numeric Conversions

The new standard introduced several functions that convert between numeric data and library strings:

int i = 42;
string s = to_string(i); // converts the int i to its character representation
double d = stod(s); // converts the string s to floating-point

Conversions between strings and Numbers:

to_string(val): Overloaded functions returning the string representation of val. val can be any arithmetic type. There are versions of to_string for each floating-point type and integral type that is int or larger. Small integral types are promoted.

stoi(s, p, b), stol(s, p, b), stoul(s, p, b), stoll(s, p, b), stoull(s, p, b): Return the intial substring of s that has numeric content as an int, long, unsigned long, long long, unsigned long long, respectively. b indicates the numeric base to use for the conversion; b defaults to 10. p is a pointer to a size_t in which to put the index of the first nonnumeric character in s; p defaults to 0, in which case the function does not store the index.

stof(s, p), stod(s, p), stold(s, p): Return the intial numeric substring in s as a float, double, or long double, respectively. p has the same behavior as described for the integer conversions.

The first non-whitespace character in the string we convert to numeric value must be a character that can appear in a number.

The first non-whitespace character in the string must be a sign (+ or -) or a digit. The string can begin with 0x or 0X to indicate hexadecimal. For the functions that convert to floating-point the string may also start with a decimal point (.) and may contain an e or E to designate the exponent. For the functions that convert to integral type, depending on the base, the string can contain alphabetic characters corresponding to numbers beyond the digit 9.

If the string can‚Äôt be converted to a number, These functions throw an invalid_argument exception. If the conversion generates a value that can‚Äôt be represented, they throw out_of_range.

--
string::size_type:

s.size() returns a string::size_type value. This type requires a bit of explanation.

The string class‚Äîand most other library types‚Äîdefines several companion types. These companion types make it possible to use the library types in a machine-independent manner. The type size_type is one of these companion types. 

Although we don‚Äôt know the precise type of string::size_type, we do know that it is an unsigned type big enough to hold the size of any string. Any variable used to store the result from the string size operation should be of type string::size_type.

Admittedly, it can be tedious to type string::size_type. Under the new standard, we can ask the compiler to provide the appropriate type by using auto or decltype:

auto len = line.size(); // len has type string::size_type  

Because size returns an unsigned type, it is essential to remember that expressions that mix signed and unsigned data can have surprising results. For example, if n is an int that holds a negative value, then s.size() < n will almost surely evaluate as true. It yields true because the negative value in n will
convert to a large unsigned value. Tao: Avadoles.

You can avoid problems due to conversion between unsigned and int by not using ints in expressions that use size().

--
The string library lets us convert both character literals and character string literals to strings. Because we can use these literals where a string is expected, we can rewrite the previous program as follows:

string s1 = "hello", s2 = "world"; // no punctuation in s1 or s2
string s3 = s1 + ", " + s2 + '\n';

When we mix strings and string or character literals, at least one operand to each + operator must be of string type:

string s4 = s1 + ", "; // ok: adding a string and a literal
string s5 = "hello" + ", "; // error: no string operand (tao: both are string literals, which are not string type variables)
string s6 = s1 + ", " + "world"; // ok: each + has a string operand
string s7 = "hello" + ", " + s2; // error: can't add string liter

For historical reasons, and for compatibility with C, string literals are not standard library strings. It is important to remember that these types differ when you use string literals and library strings.

--
Dealing with the Characters in a string

The followings should include the "cctype" header:

//c is a character
isalnum(c) //true if c is a letter or a digit.
isalpha(c) //true if c is a letter
isdigit(c) //true if c is a digit
islower(c) //true if c is a lowercase letter
isupper(c) //true if c is an uppercase letter
tolower(c) //If c is an upercase letter, returns its lowercase equivalent, otherwise returns c unchanged
toupper(c) //If c is a lowercase letter, returns its upercase equivalent, otherwise returns c unchanged
isspace(c) //true if c is whitespace (ie, a space, tab, vertical tab, return, newline, or formfeed)

--
#include <string>
using std::string;

string s1; // default initialization; s1 is the empty string
string s2 = s1; //copy initialization, s2 is a copy of s1
string s3 = "hiya"; //direct initialization, s3 is a copy of the string literal. Tao: according to definition, this is copy initialization, this example is arbitrary and misleading, and it is a waste of time to jiujie this example.
string s4(10, 'c'); // s4 is cccccccccc

--
Ways to Initialize a string:

string s1: Default initialization; s1 is the empty string.
string s2(s1): s2 is a copy of s1.
string s2 = s1: Equivalent to s2(s1), s2 is a copy of s1.
string s3("value"): s3 is a copy of the string literal, not including the null (tao: the null at the end of the string).
string s3 = "value": Equivalent to s3("value"), s3 is a copy of the string literal.
string s4(n, 'c'): Initialize s4 with n copies of the character 'c'.

We can default initialize a string, which creates an empty string; that is, a string with no characters. When we supply a string literal, the characters from that literal‚Äîup to but not including the null character at the end of the literal‚Äîare copied into the newly created string. When we supply a count
and a character, the string contains that many copies of the given character.

Direct and Copy Forms of Initialization (tao: the followings are also copied to "find copyinitialization")

Earlier we saw that C++ has several different forms of initialization. Using strings, we can start to understand how these forms differ from one another. When we initialize a variable using =, we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created. Otherwise, when we omit the =, we use direct initialization.

When we have a single initializer, we can use either the direct or copy form of initialization. When we initialize a variable from more than one value, such as in the initialization of s4 above, we must use the direct form of initialization:

string s5 = "hiya"; // copy initialization
string s6("hiya"); // direct initialization
string s7(10, 'c'); // direct initialization; s7 is cccccccccc

When we want to use several values, we can indirectly use the copy form of initialization by explicitly creating a (temporary) object to copy:

string s8 = string(10, 'c'); // copy initialization; s8 is cccccccccc. Tao: note the "string" on the right hand side, it creates a temporary string.

The initializer of s8‚Äîstring(10, 'c')‚Äîcreates a string of the given size and character value and then copies that value into s8. It is as if we had written

string temp(10, 'c'); // temp is cccccccccc
string s8 = temp; // copy temp into s8

Although the code used to initialize s8 is legal, it is less readable and offers no compensating advantage over the way we initialized s7.

--
Addtional ways to construct strings

n, len2 and pos2 are all unsigned values

string s(cp, n): s is a copy of the first n characters in the array to which cp points. That array must have at least n characters.

string s(s2, pos2): s is a copy of the characters in the string s2 starting at the index pos2. Undefined if pos2 > s2.size().

string s(s2, pos2, len2): s is a copy of len2 characters from s2 starting at the index pos2. Undefined if pos2 > s2.size(). Regardless of the value of len2, copies at most s2.size() - pos2 characters.

--
In some computers (like my Thinkpad), some functions (like ifstream) needs the input to string to be defined as type: const char*, for example:

const char* filename = "helo";
ifstream input_file(filename);

However, I can use string instead of const char* if compile using std C++ 11.

In some computers (like the Mac), it can be written as:

string filename = "helo";
ifstream input_file(filename);

--
(findsubstring)
Substring (get and find)

Get a substring:

string s2 = s.substr(pos, n) // return a string containing n characters fro s starting at pos. pos defaults to 0. n defaults to a value that causes the library to copy all the characters in s starting from pos.

Find a substring in a string:

Use std::string::find as follows:

if (s1.find(s2) != std::string::npos) {
    std::cout << "found!" << '\n';
}
Note: "found!" will be printed if s2 is a substring of s1, both s1 and s2 are of type std::string. 

string test = "123";
string res = test.substr(1, 0);
res.size(); //returns: 0

--
(findsplit)
split a string

** Split by a char **

Problem: Split a string by a delim, and return a vector of strings containing no delim

Use stringstream getline
Signature istream& getline (istream&& is, string& str, char delim)

#include <sstream>

//tao: notice the function parameter uses reference to a string
vector<string> split(const string &s, char delim) {
    stringstream ss(s);
    string item;
    vector<string> tokens;
    while (getline(ss, item, delim)) {
        tokens.push_back(item);
    }
    return tokens;
}

Tao's example of using the above function split:

string test_str = "Helo,how,are,you";
vector<string> strs = split(test_str, ',');
for(int i = 0; i < strs.size(); i++) cout << strs[i] << " ";
cout << endl;

Output:
Helo how are you

** Split by a string **

You can use the string::find() function to find the position of your string delimiter, then use string::substr() to get a token.

Example:

string s = "scott>=tiger";
string delimiter = ">=";
string token = s.substr(0, s.find(delimiter)); // token is "scott"

The substr(size_t pos = 0, size_t n = npos) function returns a substring of the object, starting at position pos and of length npos.

The find(const string& str, size_t pos = 0) function returns the position of the first occurrence of str in the string, or npos if the string is not found.
Tao's example:
string s = "helo";
s.find("lo")// Returns: 2
while((pos = s.find(delimiter)) != string::npos) {...}

If you have multiple delimiters, after you have extracted one token, you can remove it (delimiter included) to proceed with subsequent extractions (if you want to preserve the original string, just use  s = s.substr(pos + delimiter.length());):

s.erase(0, s.find(delimiter) + delimiter.length());
This way you can easily loop to get each token.

Complete Example
string s = "scott>=tiger>=mushroom";
string delimiter = ">=";

size_t pos = 0;
string token;
while ((pos = s.find(delimiter)) != string::npos) {
    token = s.substr(0, pos);
    cout << token << endl;
    s.erase(0, pos + delimiter.length());
}
cout << s << endl;
Output:

scott
tiger
mushroom

--
C-style charater strings are null terminated char arrays. 

C-style charater string functions: 
strlen, strcmp, strcat, strcpy.

For most applications, in addition to being safer, it is also more efficient to use library strings rather than C-style strings.

tao: convert a char array to string (from online: Note that this only works for constant NULL-terminated C-strings.)
char a1[2] = {'a', 'b', '\0'};
string str1(a1);

from online: convert a string to char array:
string temp = "cat";
char * tab2 = new char [temp.length()+1];
strcpy (tab2, temp.c_str());

==
(findtrim)
trim

Tao: the simplest way to trim the spaces at beginning and end of a string is:

string str = "   35   ";

str.erase(0, str.find_first_not_of(' '));
str.erase(str.find_last_not_of(' ') + 1);

cout << str << endl; //Output: 35
cout << str.size() << endl; //Ouptut: 2

From online:

There is no standard way of trimming a string, but it‚Äôs possible to implement using the methods in the string class:

Left trim: Use find_first_not_of() to find the characters to erase
Right trim: Use find_first_of() to find the characters to erase
Trim: Do a right trim followed by a left trim (or vice-versa)
Use erase() to actually erase the characters.

Here is my implementation. It defaults to trimming whitespace characters but you can specify any string of characters as the second argument.

string& ltrim(string& str, const string& chars = "\t\n\v\f\r ") {
    str.erase(0, str.find_first_not_of(chars)); //tao: see erase() by searching "find erase"
    return str;
}
 
string& rtrim(string& str, const string& chars = "\t\n\v\f\r ") {
    str.erase(str.find_last_not_of(chars) + 1);
    return str;
}

string& trim(string& str, const string& chars = "\t\n\v\f\r ") {
    return ltrim(rtrim(str, chars), chars);
}

string extract_column_names(string line) {
    return line + "\n";
}

Example:

string str = " test ";
trim(str);

==
(finderase)
erase

std::string::erase in C++

string s2 = s.erase (pos, len); //Erases the portion of the string value that begins at the character position pos and spans len characters (or until the end of the string, from online)

The function erases a part of the string content, shortening the length of the string. The characters affected depend on the member function version used:
Return value : erase() returns *this.

string& string ::erase ()
Erases all characters in a string

string& string ::erase (size_type pos)
Erases all characters after position ‚Äòpos‚Äô. 
Throw out_of_range if idx > size().

string& string ::erase (size_type idx, size_type len ) 
Erases at most, len characters of *this, starting at index idx. 
If len is missing, all remaining characters are removed. 
Throw out_of_range if idx > size().
Example: 
string str("Hello World!");
str.erase(1, 4); //str = "H World!", tao: yes it is in-place, confirmed.
s.erase(s.size() - 5, 5); //Erase the last five characters from s.

string& string ::erase (iterator pos)
Erase the single character at iterator position pos.
Return the first character after the last character removed
If no such character is remaining then, returns 
string::end() i.e. position after the last character.

string& string ::erase (iterator beg, iterator end )
Erase the single character at iterator position pos.
Erases all characters of the range [ beg, end)
Returns end i.e. the first character after the last character removed.
If no such character is remaining then, returns 
string::end() i.e. position after the last character

==
(findargs)                    
(findcommandlineargument)      
Command line argument 

Note that if in my Thinkpad, the following should be compiled in C++ 11.

#include <string>
using namespace std;

int main(int argc, char** argv) {
    int nfiles = stoi(argv[1]); // If run as: ./main 5, then argv[1] = "5"
    cout << "nfiles = " << nfiles << endl;
    return 0;
}

Run the program:
./main 5

Then the output is:
nfiles = 5

==
(findcontainer)
(findsequentialcontainer)
Sequential containers

Associative and sequential containers differ from one another in a fundamental way: Elements in an associative container are stored and retrieved by a key. In contrast, elements in a sequential container are stored and accessed sequentially by their position in the container.

A container holds a collection of objects of a specified type. The sequential containers let the programmer control the order in which the elements are stored and accessed. That order does not depend on the values of the elements. Instead, the order corresponds to the position at which elements are put into the container. By contrast, the ordered and unordered associative containers, store their elements based on the value of a key.

The sequential containers, which are listed below, all provide fast sequential access to their elements. However, these containers offer different performance tradeoffs relative to

‚Ä¢ The costs to add or delete elements to the container
‚Ä¢ The costs to perform nonsequential access to elements of the container

vector: Flexible-size array. Supports fast random access. Inserting or deleting elements other than at the back may be slow.

deque: Double-ended queue. Supports fast random access. Fast insert/delete at front or back.

list: Doubly linked list. Supports only bidirectional sequential access. Fast inser/delete at any point in the list.

forward_list: Singly linked list. Supports only sequential access in one direction. Fast insert/delete at any point in the list.

array: Fixed-sied array. Supports fast random access. Cannot add or remove elements. Tao: note that this array means the library array, not the build-in array, as explained below.

string: A specialized container, similar to vector, that contains characters. Fast random access. Fast inser/delete at the back.

With the exception of array, which is a fixed-size container, the containers provide efficient, flexible memory management. We can add and remove elements, growing and shrinking the size of the container.

For example, string and vector hold their elements in contiguous memory.
Because elements are contiguous, it is fast to compute the address of an element from its index. However, adding or removing elements in the middle of one of these containers takes time: All the elements after the one inserted or removed have to be moved to maintain contiguity. Moreover, adding an element can sometimes require that additional storage be allocated. In that case, every element must be moved into
the new storage.

The list and forward_list containers are designed to make it fast to add or remove an element anywhere in the container. In exchange, these types do not support random access to elements: We can access an element only by iterating through the container. Moreover, the memory overhead for these containers is often substantial, when compared to vector, deque, and array.

A deque is a more complicated data structure. Like string and vector, deque supports fast random access. As with string and vector, adding or removing elements in the middle of a deque is a (potentially) expensive operation. However, adding or removing elements at either end of the deque is a fast operation, comparable to adding an element to a list or forward_list.

The forward_list and array types were added by the new standard. An array is a safer, easier-to-use alternative to built-in arrays. Like built-in arrays, library arrays have fixed size. As a result, array does not support operations to add and remove elements or to resize the container. A forward_list is intended to be comparable to the best handwritten, singly linked list. Consequently, forward_list does not have the size operation because storing or computing its size would entail overhead compared to a handwritten list. For the other containers, size is guaranteed to be a fast, constant-time operation.

There are a few rules of thumb that apply to selecting which container to use:

‚Ä¢ Unless you have a reason to use another container, use a vector.

‚Ä¢ If your program has lots of small elements and space overhead matters, don‚Äôt use list or forward_list.

‚Ä¢ If the program requires random access to elements, use a vector or a deque.

‚Ä¢ If the program needs to insert or delete elements in the middle of the container, use a list or forward_list.

‚Ä¢ If the program needs to insert or delete elements at the front and the back, but not in the middle, use a deque.

‚Ä¢ If the program needs to insert elements in the middle of the container only while reading input, and subsequently needs random access to the elements:
‚Äì First, decide whether you actually need to add elements in the middle of a container. It is often easier to append to a vector and then call the library sort function to reorder the container when you‚Äôre done with input.
‚Äì If you must insert into the middle, consider using a list for the input phase. Once the input is complete, copy the list into a vector.

--
Defining and intializing a container

Every container type defines a default constructor. With the exception of array, the default constructor creates an empty container of the specified type. Again excepting array, the other constructors take arguments that specify the size of the container and initial values for the elements.

Initializing a Container as a Copy of Another Container

There are two ways to create a new container as a copy of another one: We can directly copy the container, or (excepting array) we can copy a range of elements denoted by a pair of iterators.

To create a container as a copy of another container, the container and element types must match. When we pass iterators, there is no requirement that the container types be identical. Moreover, the element types in the new and original containers can differ as long as it is possible to convert the elements we‚Äôre copying to the element type of the container we are initializing:

// each container has three elements, initialized from the given initializers
list<string> authors = {"Milton", "Shakespeare", "Austen"};

vector<const char*> articles = {"a", "an", "the"};

list<string> list2(authors); // ok: types match

deque<string> authList(authors); // error: container types don't match

vector<string> words(articles); // error: element types must match

// ok: converts const char* elements to string
forward_list<string> words(articles.begin(), articles.end());

The constructor that takes two iterators uses them to denote a range of elements that we want to copy. As usual, the iterators mark the first and one past the last element to be copied. The new container has the same size as the number of elements in the range. Each element in the new container is initialized by the value of the corresponding element in the range.

Because the iterators denote a range, we can use this constructor to copy a subsequence of a container. For example, assuming it is an iterator denoting an element in authors, we can write

// copies up to but not including the element denoted by it
deque<string> authList(authors.begin(), it);

List Initialization

Under the new standard, we can list initialize a container:

list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};

Sequential Container Size-Related Constructors

we can also initialize the sequential containers (other than
array) from a size and an (optional) element initializer. If we do not supply an element initializer, the library creates a value-initialized one for us

vector<int> ivec(10, -1); // ten int elements, each initialized to
-1

list<string> svec(10, "hi!"); // ten strings; each element is "hi!"

forward_list<int> ivec(10); // ten elements, each initialized to 0

deque<string> svec(10); // ten elements, each an empty string

We can use the constructor that takes a size argument if the element type is a builtin type or a class type that has a default constructor. If the element type does not have a default constructor, then we must specify an explicit element initializer along with the size.

The constructors that take a size are valid only for sequential containers; they are not supported for the associative containers.

Library arrays Have Fixed Size

(Tao: library arrays are different from built-in arrays)

Just as the size of a built-in array is part of its type, the size of a library array is part of its type. When we define an array, in addition to specifying the element type, we also specify the container size:

array<int, 42> // type is: array that holds 42 ints

To use an array type we must specify both the element type and the size:

array<int, 10>::size_type i; // array type includes element type and size

Because the size is part of the array‚Äôs type, array does not support the normal container constructors.

Unlike the other containers, a default-constructed array is not
empty: It has as many elements as its size. These elements are default initialized just as are elements in a built-in array.

array<int, 10> ia1; // ten default-initialized ints

array<int, 10> ia2 = {0,1,2,3,4,5,6,7,8,9}; // list initialization

array<int, 10> ia3 = {42}; // ia3[0] is 42, remaining elements are 0

It is worth noting that although we cannot copy or assign objects of built-in array types, there is no such restriction on array:

int digs[10] = {0,1,2,3,4,5,6,7,8,9};

int cpy[10] = digs; // error: no copy or assignment for built-in arrays

array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};

array<int, 10> copy = digits; // ok: so long as array types match

--
Assignment and swap

The assignment operator replaces the entire range of elements in the lefthand container with copies of the elements from the right-hand operand:

c1 = c2; // replace the contents of c1 with a copy of the elements in c2

c1 = {a,b,c}; // after the assignment c1 has size 3

Container Assignment Operations

c1 = c2: Replace the elements in c1 with copies of the elements in c2. c1 and c2 must be the same type.

c = {a, b, c...}: Replace the elements in c1 with copies of the elements in the intializer list. (Not valide for array)

swap(c1, c2): Exchanges elements in c1 with those in c2. c1 and c2 must be the same type. swap is usually much faster than copying elements from c2 to c1.

Assign operations not valide for associative containers or array:

seq.asign(b, e): Replaces elements in seq with those in the range denoted by iterators b and e. The iterators b and e must not refer to elements in seq.

seq.assign(il): Replaces the elements in seq with those in the intializer list il.

seq.assign(n, t): Replaces the elements in seq with n elements with value t.

Unlike built-in arrays, the library array type does allow assignment. The left-and right-hand operands must have the same type:

array<int, 10> a1 = {0,1,2,3,4,5,6,7,8,9};

array<int, 10> a2 = {0}; // elements all have value 0

a1 = a2; // replaces elements in a1

a2 = {0}; // error: cannot assign to an array from a braced list. Tao: ?

Because the size of the right-hand operand might differ from the size of the left-hand operand, the array type does not support assign and it does not allow assignment from a braced list of values.

Using assign (Sequential Containers Only)

The assignment operator requires that the left-hand and right-hand operands have the same type. It copies all the elements from the right-hand operand into the left-hand operand. The sequential containers (except array) also define a member named assign that lets us assign from a different but compatible type, or assign from a subsequence of a container.

list<string> names;

vector<const char*> oldstyle;

names = oldstyle; // error: container types don't match

// ok: can convert from const char*to string
names.assign(oldstyle.cbegin(), oldstyle.cend());

Using swap

The swap operation exchanges the contents of two containers of the same type.

vector<string> svec1(10); // vector with ten elements

vector<string> svec2(24); // vector with 24 elements

swap(svec1, svec2);

After the swap, svec1 contains 24 string elements and svec2 contains ten. With the exception of arrays, swapping two containers is guaranteed to be fast‚Äîthe elements themselves are not swapped; internal data structures are swapped.

The fact that elements are not moved means that, with the exception of string, iterators, references, and pointers into the containers are not invalidated. They refer to the same elements as they did before the swap. However, after the swap, those elements are in a different container. For example, had iter denoted the string at position svec1 [3] before the swap, it will denote the element at position svec2[3] after the swap. Differently from the containers, a call to swap on a string may invalidate iterators, references and pointers.

Unlike how swap behaves for the other containers, swapping two arrays does exchange the elements. As a result, swapping two arrays requires time proportional to the number of elements in the array.

After the swap, pointers, references, and iterators remain bound to the same element they denoted before the swap. Of course, the value of that element has been swapped with the corresponding element in the other array.

In the new library, the containers offer both a member and nonmember version of swap. Earlier versions of the library defined only the member version of swap. The nonmember swap is of most importance in generic programs. As a matter of habit, it
is best to use the nonmember version of swap.

--
Container Size Operations

With one exception, the container types have three size-related operations. The size member returns the number of elements in the container; empty returns a bool that is true if size is zero and false otherwise; and max_size returns a number that is greater than or equal to the number of elements a container
of that type can contain. For reasons we‚Äôll explain in the next section, forward_list provides max_size and empty, but not size.

--
Relational Operators

Every container type supports the equality operators (== and !=); all the containers except the unordered associative containers also support the relational operators (>, >=, <, <=). The right- and left-hand operands must be the same kind of container and must hold elements of the same type. That is, we can compare a vector<int> only with another vector<int>. We cannot compare a vector<int> with a list<int> or a vector<double>.

Comparing two containers performs a pairwise comparison of the elements. These operators work similarly to the string relationals:

‚Ä¢ If both containers are the same size and all the elements are equal, then the two containers are equal; otherwise, they are unequal.

‚Ä¢ If the containers have different sizes but every element of the smaller one is equal to the corresponding element of the larger one, then the smaller one is less than the other.

‚Ä¢ If neither container is an initial subsequence of the other, then the comparison depends on comparing the first unequal elements.

We can use a relational operator to compare two containers only if the appropriate comparison operator is defined for the element type.

For example, the Sales_data type that we defined in Chapter 7
does not define either the == or the < operation. Therefore, we cannot compare two containers that hold Sales_data elements:

--
Sequential Container Operations

Adding Elements to a Sequential Container

Each of these operations will be explained with more details below.

c.push_back(t), c.emplace_back(args): Creates an element with value t or constructed from args at the end of c. Returns void.

c.push_front(t), c.emplace_front(args): Creates an element with value t or constructed from args on the front of c. Returns void.

c.insert(p, t), c.emplace(p, args): Creates an element with value t or constructed from args before the element denoted by iterator p. Returns an iterator referring to the element that was added.

c.insert(p, n, t): Inserts n elements with value t before the element denoted by iterator p. Returns an iterator to the first element inserted; if n is zero, returns p.

c.insert(p, b, e): Inserts the elements from the range denoted by iterators b and e before the element denoted by iterator p. b and e may not refer to elements in c. Returns an iterator to the first element inserted; if the range is empty, returns p.

c.insert(p, il): il is a braced list of element values. Inserts the given values before the element denoted by the iterator p. Returns an iterator to the first inserted elements; if the list is empty returns p.

Note that for container a, a[0] is front, a[size - 1] is back.

When we use an object to initialize a container, or insert an object into a container, a copy of that object‚Äôs value is placed in the container, not the object itself.

These operations change the size of the container, they are not supported by array. forward_list has special versions of insert and emplace. push_back and emplace_back not valid for foward_list. push_front and emplace_front not valid for vector or string.

Adding elements to a vector, string, or deque potentially invalidates all existing iterators, references, and pointers into the container.

--
Using push_front

In addition to push_back, the list, forward_list, and deque containers support an analogous operation named push_front. This operation inserts a new element at
the front of the container.

--
Adding Elements at a Specified Point in the Container

Each of the insert functions takes an iterator as its first argument. element(s) are inserted before the position denoted by the iterator.

slist.insert(iter, "Hello!"); // insert "Hello!" just before iter

Even though some containers do not have a push_front operation, there is no similar constraint on insert.

It is legal to insert anywhere in a vector, deque, or string. However, doing so can be an expensive operation.

--
Inserting a Range of Elements

svec.insert(svec.end(), 10, "Anna");

This code inserts ten elements at the end of svec and initializes each of those elements to the string "Anna".

The versions of insert that take a pair of iterators or an initializer list insert the elements from the given range before the given position:

vector<string> v = {"quasi", "simba", "frollo", "scar"};

// insert the last two elements of v at the beginning of slist
slist.insert(slist.begin(), v.end() - 2, v.end());

slist.insert(slist.end(), {"these", "words", "will",
"go", "at", "the", "end"});

// run-time error: iterators denoting the range to copy from
// must not refer to the same container as the one we are changing
slist.insert(slist.begin(), slist.begin(), slist.end());

Under the new standard, the versions of insert that take a count or a range return an iterator to the first element that was inserted. 

We can use the value returned by insert to repeatedly insert elements at a specified position in the container:

list<string> 1st;
auto iter = 1st.begin();
while (cin >> word)
iter = 1st.insert(iter, word); // same as calling push_front

--
Using the Emplace Operations

The new standard introduced three new members‚Äîemplace_front, emplace, and emplace_back‚Äîthat construct rather than copy elements. 

When we call a push or insert member, we pass objects of the element type and those objects are copied into the container. When we call an emplace member, we pass arguments to a constructor for the element type. The emplace members use
those arguments to construct an element directly in space managed by the container.

c.emplace_back("978-0590353403", 25, 15.99);

--
9.3.2. Accessing Elements

Operations to Access Elements in a Sequential Container

c.back(): Returns a reference to the last element in c. Undefined if c is empty.

c.front(): Returns a reference to the first element in c. Undefined if c is empty.

c[n]: Returns a reference to the element indexed by the unsigned integratal value n. Undefined if n >= c.size().

c.at[n]: Returns a reference to the element indexed by n. If the index is out of range, throws an out_of_range exception.

// check that there are elements before dereferencing an iterator or calling front or back
if (!c.empty()) {
	// val and val2 are copies of the value of the first element in c
	auto val = *c.begin(), val2 = c.front();
	// val3 and val4 are copies of the of the last element in c
	auto last = c.end();
	auto val3 = *(--last); // can't decrement forward_list iterators
	auto val4 = c.back(); // not supported by forward_list
}

Two things are noteworthy in this program: The end iterator refers to the (nonexistent) element one past the end of the container. To fetch the last element we must first decrement that iterator. The other important point is that before calling
front or back (or dereferencing the iterators from begin or end), we check that c isn‚Äôt empty.

The Access Members Return References

if (!c.empty()) {
	c.front() = 42; // assigns 42 to the first element in c
	auto &v = c.back(); // get a reference to the last element
	v = 1024; // changes the element in c
	auto v2 = c.back(); // v2 is not a reference; it's a copy of c.back()
	v2 = 0; // no change to the element in c
}

--
Subscripting and Safe Random Access

The subscript operator takes an index and returns a reference to the element at that position in the container. The subscript operator does not check whether the index is in range.

If we want to ensure that our index is valid, we can use the at member instead. The at member acts like the subscript operator, but if the index is invalid, at throws an out_of_range exception.

--
Erasing Elements (remove elements)

Erase operations on sequential containers

c.pop_back(): Removes last element in c. Undefined if c is empty. Returns void.

c.pop_front(): Removes first element in c. Undefined if c is empty. Returns void.

c.erase(p): Removes the element denoted by the iterator p and returns an iterator to the element after the one deleted or the off-the-end iterator if p denotes the last element. Undefined if p is the off-the-end iterator.

c.erase(b, e): Removes the range of elements denoted by the iterator b and e. Returns an iterator to the elements after the last one that was deleted, or an off-the-end iterator if e is itself and off-the-end iterator.

c.clear(): Removes all the elements in c. Returns void.

There operations change the size of the container and so are not supported by array. forward_list has a special version of erase pop_back not valid for foward_list; pop_front not valid for vector and string. Just as there is no push_front for vector and string, there is also no pop_front for those types. 

Specialized forward_list Operations

To add or remove an element, we need access to its predecessor in order to update that element‚Äôs links. However, forward_list is a singly linked list. In a singly linked list there is no easy way to get to an element‚Äôs predecessor. For this reason, the operations to add or remove elements in a forward_list operate by changing the element after the given element. forward_list does not define insert, emplace, or erase. Instead it defines members (listed in Table 9.8) named insert_after, emplace_after, and erase_after. 

--
Resizing a Container

With the usual exception of arrays, we can use resize, to
make a container larger or smaller. If the current size is greater than the requested size, elements are deleted from the back of the container; if the current size is less than the new size, elements are added to the back of the container:

list<int> ilist(10, 42); // ten ints: each has value 42

ilist.resize(15); // adds five elements of value 0 to the back of ilist

ilist.resize(25, -1); // adds ten elements of value -1 to the back of ilist

ilist.resize(5); // erases 20 elements from the back of ilist

Sequential Container Size Operations

c.resize(n): Resize c so that it has n elements. If n < c.size(), the excess elements are discarded. If new elements must be added, they are value initialized.

c.resize(n, t): Resize c to have n elements. Any elements added have value t.

--
Container Operations May Invalidate Iterators

Operations that add or remove elements from a container can invalidate pointers, references, or iterators to container elements. An invalidated pointer, reference, or iterator is one that no longer denotes an element. Using an invalidated pointer,
reference, or iterator is a serious programming error that is likely to lead to the same kinds of problems as using an uninitialized pointer.

When we add or remove elements in a vector or string, or add elements or remove any but the first element in a deque, the iterator returned by end is always invalidated. Don‚Äôt cache the iterator returned from end() in loops that insert or delete
elements in a deque, string, or vector. Rather than storing the end() iterator, we must recompute it after each insertion.

--
How a vector Grows

To support fast random access, vector elements are stored contiguously‚Äîeach element is adjacent to the previous element. Library implementors use allocation strategies that reduce the
number of times the container is reallocated. When they have to get new memory, vector and string implementations typically allocate capacity beyond what is immediately needed. The container holds this storage in reserve and uses it to allocate new elements as they are added. Thus, there is no need to reallocate the container for each new element.

The vector and string types provide members that let us
interact with the memory-allocation part of the implementation. The capacity operation tells us how many elements the container can hold before it must allocate more space. The reserve operation lets us tell the container how many elements it should be prepared to hold. reserve does not change the number of elements in the container; it affects only how much memory the vector preallocates. A call to reserve changes the capacity of the vector only if the requested space exceeds the current capacity. If the requested size is greater than the current
capacity, reserve allocates at least as much as (and may allocate more than) the requested amount. If the requested size is less than or equal to the existing capacity, reserve does
nothing. Similarly, the resize members change only the
number of elements in the container, not its capacity

capacity and size

It is important to understand the difference between capacity and size. The size of a container is the number of elements it already holds; its capacity is how many elements it can hold before more space must be allocated.

==
(findcontainerlibrary)
(findcontainerfunctions)
(findcontainermethods)
Container functions

Operations that are provided by all container types (sequential containers, associative containers, etc):

** Type Aliases **

iterator: Type of the iterator for this container type

const_iterator: Iterator type that can read but not change its elements

size_type: Unsigned integral type big enough to hold the size of the largest possible container of this container type. Tao: the 5 in a[5] is size_type, others can be understood in the samiliar way.

difference_type: Signed integral type big enough to hold the distance between two iterators.

value_type: Element type

reference: Element's lvalue type; synonym for value_type&

const_reference: Element's const lvalue type (i.e., const value_type&)

** Construction **

C c; Default constructor, empty containder (array: see later).

C c1(c2); Construct c1 as a copy of c2.

C c(b, e); Copy elmeents from the range denoted by iterators b and e (not valid for array)

C c{a, b, c...}; List initialize c

** Assignment and swap **

c1 = c2: Replace elements in c1 with those in c2

c1 = {a, b, c...}: Replace elements in c1 with those in the list (not valid for array)

a.swap(b): Swap elements in a with those in b

swap(a, b): Equivalent to a.swap(b)

** Size **

c.size(): Number of elements in c (not valide for forward_list)

c.max_size(): Maximum number of elements c can hold

c.empty(): false if c has any elments, true otherwise

** Add/Remove Elements (not valid for array) **

Note: the interface to these operations varies by container type

c.insert(args): Copy element(s) as specified by args into c

c.emplace(inits): Use inits to construct an element in c

c.erase(args): Remove element(s) specified by args

c.clear(): Remove all elements from c; returns void

** Equality and Relational Operations **

==, !=  Equality valid for all container types
<, <-, >, >=  Relations (not valid for unordered associative containers)

** Obtain Iterators **

c.begin(): Return iterator to the first element in c
c.end(): Return iterator to one past the last element in c
c.cbegin(), c.cend(): Return const_iterator

** Additional Members of Reversible Containers (not valid for forward_lsit) **

reverse_iterator: Iterator that addresses elements in reverse order
const_reverse_iterator: Reverse iterator that cannot write the elments
c.rbegin(): Return iterator to the last element in c
c.rend(): Return iterator to on past the first element in c
c.crbegin(), crend(): Return const_reverse_iterator

--
Operators that are speciic to the sequential containers:

Defining and Initializing Containers:

C c; Default constructor. If C is array, then the elements in c are default-initialized; otherwise c is empty.

C c1(c2), C c1 = c2: c1 is a copy of c2. c1 and c2 must have the same type (i.e., they must be the same container type and hold the same element type; for array must also have the same size).

C c{a, b, c...}, C c = {a, b, c...}: c is a copy of the element in the initializer list. Type of elements in the list must be compatible with the element type of C. For array, the list must have same number or fewer elements tha the size of the array, any missing elements are value-initialized.

C c(b, e): c is a copy of the elements in the range denoted by iterators b and e. Type of the elements must be compatile with the element type of C. (Not valid for array).

** Construction that take a size are valid for sequential containers (not including array) only **

C seq(n): seq has n value-initialized elements; this constructor is explicit. (Not valid for string).

C seq(n, t): seq has n elements with value t.

--
In this section, we‚Äôll cover aspects common to all of the containers. The remainder of this chapter will then focus solely on sequential containers; we‚Äôll cover operations specific to the associative containers in Chapter 11.

In general, each container is defined in a header file with the same name as the type. That is, deque is in the deque header, list in the list header, and so on.

The containers are class templates. As with vectors, we must supply additional information to generate a particular container type. For most, but not all, of the containers, the information we must supply is the element type:

list<Sales_data> // list that holds Sales_data objects
deque<double> // deque that holds doubles

Almost any type can be used as the element type of a sequential container. In particular, we can define a container whose element type is itself another container.

vector<vector<string>> lines; // vector of vectors

Older compilers may require a space between the angle brackets, for example, vector<vector<string> >.

Although we can store almost any type in a container, some container operations impose requirements of their own on the element type. We can define a container for a type that does not support an operation-specific requirement, but we can use an operation only if the element type meets that operation‚Äôs requirements.

As an example, the sequential container constructor that takes a size argument uses the element type‚Äôs default constructor. Some classes do not have a default constructor. We can define a container that holds objects of such types, but we cannot construct such containers using only an element count:

// assume noDefault is a type without a default constructor
vector<noDefault> v1(10, init); // ok: element initializer supplied
vector<noDefault> v2(10); // error: must supply an element initializer

==
(findvector)
vector

#include <vector>
using std::vector;

--
vector<int> v1; //v1 is empty (tao: ie, v1.size() = 0, proved by many practices)

vector<int> v2 = v1; //v2 is a copy of the elements in v1 (tao: copies the values of v1 to v2)

vector<int> v1(10); //v1 has n copies of a value-initialized object. 10 elements, each initialized to 0.

vector<string> v1(10); //10 elements, each an empty string

vector<int> v1(n, val); //v1 has n elements with value val

vector<vector<int>> v(10, vector<int>(10,1)); //From online. v is a 10*10 vector, all elements initialized to 1.

vector<int> v1 = {1, 2, 3};//C++11 standard.

vector<int> v1{1,2,3};//Define a vector with elements

--
Ways to initialize a vector:

vector<T> v1: vector that holds objects of type T. Default initialization; v1 is empty.

vector<T> v2(v1): v2 has a copy of each element in v1.

vector<T> v2 = v1: Equivalent to v2(v1), v2 is a copy of the elements in v1.

vector<T> v3(n, val): v3 has n elements with value val.

vector<T> v4(n): v4 has n copies of a value-initialized object. See more below.

vector<T> v5{a, b, c...}: v5 has many elements as there are initializers; elements are initialized by corresponding initializers.

vector<T> v5 = {a, b, c...}: Equivalent to v5{a, b, c...}.

Searched online, in the old C++ version, to initialize a vector, we can only use push_back(). 

--
vector<T> v4(n): v4 has n copies of a value-initialized object

A restrictions on this form of initialization is that some classes require that we always supply an explicit initializer. If our vector holds objects of a type that we cannot default initialize, then we must supply an initial element value; it is not possible to create vectors of such types by supplying only a size.

--
v.push_back(3) //Adds an element with value 3 to end of v

v.empty() //Returns a bool

v.size() //Returns a number, which is of type vector<int>::size_type

v[5] //Returns a reference to the element

v1 = v2 //Replaces the elements in v1 with a copy of the elements in v2

v1 == v2 //Equal if each element in v1 is equal to the corresponding element in v2. 

v1 != v2

v1 <= v2 //Have their normal meanings using dictionary ordering.
vec.clear() //Removes all elements from the vector (which are destroyed), leaving the container with a size of 0.

--
vector operations:

In addition to push_back, vector provides only a few other operations, most of which are similar to the corresponding operations on strings.

v.push_back(t): Adds an element with value t to end of v.

v.empty(): Returns true if v is empty; otherwise returns false.

v.size(): Returns the number of elements in v. Returns a value of the size_type, eg: vector<int>::size_type

v[n]: Returns a reference to the element at position n in v. Subscripts for vector start at 0; the type of a subscript is the
corresponding size_type, eg: vector<int>::size_type

v1 = v2: Replaces the elements in v1 with a copy of the elements in v2.

v1 = {a, b, c...}: Replaces the elements in v1 with a copy of the elements in the comma-sperated list.

v1 == v2, v1 != v2: v1 and v2 are equal if they have the same number of elements and each element in v1 is equal to the corresponding element in v2.

<, <=, >, >=: Have their normal meanings using dictionary ordering.

vector_name.insert(position, val): inserts new elements before the element at the specified position, effectively increasing the container size by the number of elements inserted.

--
vector<vector<double> > v1 //correct, note the space between > >
vector<vector<double>> v1 //wrong <- tao: in the Mac (or C++11?), this is also correct.

vector< vector<int> > a(n,vector<int>(n)); //a is an 2D (n*n) vector, from HackerRank

--
We can define vectors to hold objects of most any type. Because references are not objects, we cannot have a vector of references.

vector is a template, not a type. Types generated from vector must include the element type, for example, vector<int>.

We can define vectors to hold objects of most any type. Because references are not objects, we cannot have a vector of references.

The string and vector types are abstractions of the more primitive built-in array type. Arrays are less convenient to use than the library string and vector types.

Some compilers may require the old-style declarations for a vector of vectors, for example, vector<vector<int> > (tao: there is an extra space).

We cannot use a range for if the body of the loop adds elements to the vector. The body of a range for must not change the size of the sequence over which it is iterating.

Attempting to subscript elements that do not exist is, unfortunately, an extremely common and pernicious programming error. So-called buffer overflow errors are the result of subscripting elements that don‚Äôt exist. Such bugs are the most common cause of security problems in PC and other applications.

--
Traverse a vector (in C++ 11):

//vec is type vector<Person*>
for(auto p : vec) {
  cout << p->height << endl;
}

--
Vector iterator:

#include <iostream>
#include <vector>
using namespace std;

int main ()
{
  vector<int> myvector;
  for (int i=1; i<=5; i++) myvector.push_back(i);

  cout << "myvector contains:";
  for (vector<int>::iterator it = myvector.begin() ; it != myvector.end(); ++it)
    cout << ' ' << *it;
  cout << '\n';

  return 0;
}
Edit & Run

--
The following experiment shows that vectors are also saved contiguously in memory, same as array:

vector<int> vec = {1, 2, 3, 4, 5};
int n = vec.size();

for(int *p = &vec[0]; p < &vec[n]; ++p) cout << *p << " ";
cout << endl;

Output: 1 2 3 4 5

--
Vector of objects:

From my leetcode code:

vector<Interval> res;
res.push_back(*iterator); // *iterator is an object of Interval

--
How to find out if an item is present in a vector?

You can use std::find from <algorithm>:

std::find(vector.begin(), vector.end(), item) != vector.end()
This returns a bool (true if present, false otherwise). With your example:

#include <algorithm>

if ( std::find(vector.begin(), vector.end(), item) != vector.end() )
   do_this();
else
   do_that();

Tao's experiment shows that finding an element from a vector is much slower than from a set. 

--
(findsortvector)
Sort a vector:

// C++ program to sort a vector in non-decreasing 
// order. 
#include <iostream>
#include <vector>
using namespace std; 
  
int main() 
{ 
    vector<int> v{ 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 }; 
  
    sort(v.begin(), v.end()); 
  
    for (auto x : v) cout << x << " "; //Ouptut is sorted: 0 1 2 3 4 5 6 7 8 9
  
    return 0; 
} 

How to sort in descending order?
sort() takes a third parameter that is used to specify the order in which elements are to be sorted. We can pass ‚Äúgreater()‚Äù function to sort in descending order. This function does comparison in a way that puts greater element before.

// C++ program to sort a vector in non-increasing 
// order. 
#include <iostream>
#include <vector>
using namespace std; 
  
int main() 
{ 
    vector<int> v{ 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 }; 
  
    sort(v.begin(), v.end(), greater<int>()); 
  
    for (auto x : v) cout << x << " "; //Ouptut: 9 8 7 6 5 4 3 2 1 0
  
    return 0; 
} 

How to sort in particular order?
We can also write our own comparator function and pass it as a third parameter.

// A C++ program to sort vector using 
// our own comparator 
#include <iostream>
#include <vector>
using namespace std; 
  
// An interval has start time and end time 
struct Interval { 
    int start, end; 
}; 
 
// Tao: in the following compare function, if for i1 < i2 it returns true, then in the sort, smaller elements will be put in front.

// Tao's experience shows that the following function compareInterval should be defined outside of a class (it can be used either inside or outside a class). If I must put it inside a class, define it as a static function: static bool compareInterval(Interval i1, Interval i2) {...}
// Compares two intervals according to staring times. 
bool compareInterval(Interval i1, Interval i2) 
{ 
    return (i1.start < i2.start); 
} 
  
int main() 
{ 
    vector<Interval> v { { 6, 8 }, { 1, 9 }, { 2, 4 }, { 4, 7 } }; 
  
    // sort the intervals in increasing order of 
    // start time 
    sort(v.begin(), v.end(), compareInterval); 
  
    cout << "Intervals sorted by start time : \n"; 
    for (auto x : v) 
        cout << "[" << x.start << ", " << x.end << "] "; 
  
    return 0; 
} 

Output :

Intervals sorted by start time : 
[1, 9] [2, 4] [4, 7] [6, 8] 

--
Concatenating two vectors:

vector1.insert( vector1.end(), vector2.begin(), vector2.end() );

--
Convert array to vector:

#include <iterator>
#include <vector>
using namespace std;

int x[] = { 1, 2, 3, 4, 5 };
vector<int> v(begin(x), end(x));

--
vector<int> v;
for(vector<int>::size_type i = 0; i < 10; ++i) {
    v[i] = i; // Wrong. Segmentation fault: 11. Because v is always an empty vector, so can not assign.
    v.push_back(i); // Correct
}

--
From geeksforgeeks:

Certain functions associated with the vector are:
Iterators

begin() ‚Äì Returns an iterator pointing to the first element in the vector
end() ‚Äì Returns an iterator pointing to the theoretical element that follows the last element in the vector
rbegin() ‚Äì Returns a reverse iterator pointing to the last element in the vector (reverse beginning). It moves from last to first element
rend() ‚Äì Returns a reverse iterator pointing to the theoretical element preceding the first element in the vector (considered as reverse end)
cbegin() ‚Äì Returns a constant iterator pointing to the first element in the vector.
cend() ‚Äì Returns a constant iterator pointing to the theoretical element that follows the last element in the vector.
crbegin() ‚Äì Returns a constant reverse iterator pointing to the last element in the vector (reverse beginning). It moves from last to first element
crend() ‚Äì Returns a constant reverse iterator pointing to the theoretical element preceding the first element in the vector (considered as reverse end)

// C++ program to illustrate the 
// iterators in vector 
#include <iostream> 
#include <vector> 
  
using namespace std; 
  
int main() 
{ 
    vector<int> g1; 
  
    for (int i = 1; i <= 5; i++) 
        g1.push_back(i); 
  
    cout << "Output of begin and end: "; 
    for (auto i = g1.begin(); i != g1.end(); ++i) 
        cout << *i << " "; 
  
    cout << "\nOutput of cbegin and cend: "; 
    for (auto i = g1.cbegin(); i != g1.cend(); ++i) 
        cout << *i << " "; 
  
    cout << "\nOutput of rbegin and rend: "; //tao: reverse the vector, note it is ++ir, not --ir
    for (auto ir = g1.rbegin(); ir != g1.rend(); ++ir) 
        cout << *ir << " "; 
  
    cout << "\nOutput of crbegin and crend : "; 
    for (auto ir = g1.crbegin(); ir != g1.crend(); ++ir) 
        cout << *ir << " "; 
  
    return 0; 
} 

Output:
Output of begin and end: 1 2 3 4 5 
Output of cbegin and cend: 1 2 3 4 5 
Output of rbegin and rend: 5 4 3 2 1 
Output of crbegin and crend : 5 4 3 2 1

Capacity

size() ‚Äì Returns the number of elements in the vector.
max_size() ‚Äì Returns the maximum number of elements that the vector can hold.
capacity() ‚Äì Returns the size of the storage space currently allocated to the vector expressed as number of elements.
resize() ‚Äì Resizes the container so that it contains ‚Äòg‚Äô elements.
empty() ‚Äì Returns whether the container is empty.
shrink_to_fit() ‚Äì Reduces the capacity of the container to fit its size and destroys all elements beyond the capacity.
reserve() ‚Äì Requests that the vector capacity be at least enough to contain n elements. Tao: after calling reverse(vec.begin(),vec.end()), vector vec is reversed. reverse() does not return a vector, it reverses the original vector.

// C++ program to illustrate the 
// capacity function in vector 
#include <iostream> 
#include <vector> 
  
using namespace std; 
  
int main() 
{ 
    vector<int> g1; 
  
    for (int i = 1; i <= 5; i++) 
        g1.push_back(i); 
  
    cout << "Size : " << g1.size(); 
    cout << "\nCapacity : " << g1.capacity(); 
    cout << "\nMax_Size : " << g1.max_size(); 
  
    // resizes the vector size to 4 
    g1.resize(4); 
  
    // prints the vector size after resize() 
    cout << "\nSize : " << g1.size(); 
  
    // checks if the vector is empty or not 
    if (g1.empty() == false) 
        cout << "\nVector is not empty"; 
    else
        cout << "\nVector is empty"; 
  
    // Shrinks the vector 
    g1.shrink_to_fit(); 
    cout << "\nVector elements are: "; 
    for (auto it = g1.begin(); it != g1.end(); it++) 
        cout << *it << " "; 
  
    return 0; 
} 

Output:
Size : 5
Capacity : 8
Max_Size : 4611686018427387903
Size : 4
Vector is not empty
Vector elements are: 1 2 3 4

Element access:

reference operator [g] ‚Äì Returns a reference to the element at position ‚Äòg‚Äô in the vector
at(g) ‚Äì Returns a reference to the element at position ‚Äòg‚Äô in the vector
front() ‚Äì Returns a reference to the first element in the vector
back() ‚Äì Returns a reference to the last element in the vector
data() ‚Äì Returns a direct pointer to the memory array used internally by the vector to store its owned elements.

// C++ program to illustrate the 
// element accesser in vector 
#include <bits/stdc++.h> 
using namespace std; 
  
int main() 
{ 
    vector<int> g1; 
  
    for (int i = 1; i <= 10; i++) 
        g1.push_back(i * 10); 
  
    cout << "\nReference operator [g] : g1[2] = " << g1[2]; 
  
    cout << "\nat : g1.at(4) = " << g1.at(4); 
  
    cout << "\nfront() : g1.front() = " << g1.front(); 
  
    cout << "\nback() : g1.back() = " << g1.back(); 
  
    // pointer to the first element 
    int* pos = g1.data(); 
  
    cout << "\nThe first element is " << *pos; 
    return 0; 
} 

Output:
Reference operator [g] : g1[2] = 30
at : g1.at(4) = 50
front() : g1.front() = 10
back() : g1.back() = 100
The first element is 10
Modifiers:

assign() ‚Äì It assigns new value to the vector elements by replacing old ones
push_back() ‚Äì It push the elements into a vector from the back
pop_back() ‚Äì It is used to pop or remove elements from a vector from the back.
insert() ‚Äì It inserts new elements before the element at the specified position. (tao: online example: v1.insert(v1.begin()+i, v2[i]))
erase() ‚Äì It is used to remove elements from a container from the specified position or range. (tao: online example: vec.erase(vec.begin() + 1))
swap() ‚Äì It is used to swap the contents of one vector with another vector of same type and size.
clear() ‚Äì It is used to remove all the elements of the vector container
emplace() ‚Äì It extends the container by inserting new element at position
emplace_back() ‚Äì It is used to insert a new element into the vector container, the new element is added to the end of the vector
.

// C++ program to illustrate the 
// Modifiers in vector 
#include <bits/stdc++.h> 
#include <vector> 
using namespace std; 
  
int main() 
{ 
    // Assign vector 
    vector<int> v; 
  
    // fill the array with 10 five times 
    v.assign(5, 10); 
  
    cout << "The vector elements are: "; 
    for (int i = 0; i < v.size(); i++) 
        cout << v[i] << " "; 
  
    // inserts 15 to the last position 
    v.push_back(15); 
    int n = v.size(); 
    cout << "\nThe last element is: " << v[n - 1]; 
  
    // removes last element 
    v.pop_back(); 
  
    // prints the vector 
    cout << "\nThe vector elements are: "; 
    for (int i = 0; i < v.size(); i++) 
        cout << v[i] << " "; 
  
    // inserts 5 at the beginning 
    v.insert(v.begin(), 5); 
  
    cout << "\nThe first element is: " << v[0]; 
  
    // removes the first element 
    v.erase(v.begin()); 
  
    cout << "\nThe first element is: " << v[0]; 
  
    // inserts at the beginning 
    v.emplace(v.begin(), 5); 
    cout << "\nThe first element is: " << v[0]; 
  
    // Inserts 20 at the end 
    v.emplace_back(20); 
    n = v.size(); 
    cout << "\nThe last element is: " << v[n - 1]; 
  
    // erases the vector 
    v.clear(); 
    cout << "\nVector size after erase(): " << v.size(); 
  
    // two vector to perform swap 
    vector<int> v1, v2; 
    v1.push_back(1); 
    v1.push_back(2); 
    v2.push_back(3); 
    v2.push_back(4); 
  
    cout << "\n\nVector 1: "; 
    for (int i = 0; i < v1.size(); i++) 
        cout << v1[i] << " "; 
  
    cout << "\nVector 2: "; 
    for (int i = 0; i < v2.size(); i++) 
        cout << v2[i] << " "; 
  
    // Swaps v1 and v2 
    v1.swap(v2); 
  
    cout << "\nAfter Swap \nVector 1: "; 
    for (int i = 0; i < v1.size(); i++) 
        cout << v1[i] << " "; 
  
    cout << "\nVector 2: "; 
    for (int i = 0; i < v2.size(); i++) 
        cout << v2[i] << " "; 
} 

Output:
The vector elements are: 10 10 10 10 10 
The last element is: 15
The vector elements are: 10 10 10 10 10 
The first element is: 5
The first element is: 10
The first element is: 5
The last element is: 20
Vector size after erase(): 0

Vector 1: 1 2 
Vector 2: 3 4 
After Swap 
Vector 1: 3 4 
Vector 2: 1 2

==
(findassociativecontainers)
Associative Containers

Tao: Associative Containers appears after all the above contents in the book.
Tao: Associative Containers contains only map and set, no other things.

Associative and sequential containers differ from one another in a fundamental way: Elements in an associative container are stored and retrieved by a key. In contrast, elements in a sequential container are stored and accessed sequentially by their position in the container.

Although the associative containers share much of the behavior of the sequential containers, they differ from the sequential containers in ways that reflect the use of keys.

Associative containers support efficient lookup and retrieval by a key. The two primary associative-container types are map and set. The elements in a map are key‚Äìvalue pairs: The key serves as an index into the map, and the value represents the data associated with that index. A set element contains only a key; a set supports efficient queries as to whether a given key is present. We might use a set to hold words that we want to ignore during some kind of text processing. A dictionary would be a good use for a map: The word would be the key, and its definition would be the value.

The library provides eight associative containers, listed in Table below. These eight differ along three dimensions: Each container is (1) a set or a map, (2) requires unique keys or allows multiple keys, and (3) stores the elements in order or not. The containers that allow multiple keys include the word multi; those that do not keep their keys ordered start with the word unordered. Hence an unordered_multi_set is a set that allows multiple keys whose elements are not stored in order, whereas a set has unique keys that are stored in order. The
unordered containers use a hash function to organize their elements. We‚Äôll have more to say about the hash function in later.

The map and multimap types are defined in the map header; the set and multiset types are in the set header; and the unordered containers are in the unordered_map and unordered_set headers.

Associative Container Types:

** Elements Ordered by Key **

map: Associative array; holds key-value pairs

set: Container in which the key is the value

multimap: map in which a key can appear multiple times

multiset: set in which a key can appear multiple times

** Unordered Collections **

unordered_map: map organized by a hash function

unordered_set: set organized by a hash function

unordered_multimap: Hashed map; keys can appear multiple times

unordered_multiset: Hashed set; keys can appear mutliple times 

--
Overview of the Associative Containers

Associative containers (both ordered and unordered) support the general container operations. The associative containers do not support the sequential-container position-specific operations, such as push_front or back. Because the elements are stored based on their keys, these operations would be meaningless for the associative containers. Moreover, the associative containers do not support the constructors or insert operations that take an element value and a count.

In addition to the operations they share with the sequential containers, the associative containers provide some operations and type aliases that the sequential containers do not. In addition, the unordered containers provide operations for tuning their hash performance, which we‚Äôll cover later. The associative container iterators are bidirectional.

Defining an Associative Container

As we‚Äôve just seen, when we define a map, we must indicate both the key and value type; when we define a set, we specify only a key type, because there is no value type. Each of the associative containers defines a default constructor, which creates an empty container of the specified type. We can also initialize an associative container as a copy of another container of the same type or from a range of values, so long as those values can be converted to the type of the container. Under the new standard, we can also list initialize the elements:

map<string, size_t> word_count; // empty

// list initialization
set<string> exclude = {"the", "but", "and", "or", "an", "a", "The", "But", "And", "Or", "An", "A"};

// three elements; authors maps last name to first
map<string, string> authors = { {"Joyce", "James"},
{"Austen", "Jane"},

As usual, the initializers must be convertible to the type in the container. For set, the element type is the key type. When we initialize a map, we have to supply both the key and the value. We wrap each key‚Äìvalue pair inside curly braces:
{key, value} to indicate that the items together form one element in the map. The key is the first element in each pair, and the value is the second. Thus, authors maps last names to
first names, and is initialized with three elements.

Initializing a multimap or multiset

The keys in a map or a set must be unique; there can be only one element with a given key. The multimap and multiset containers have no such restriction; there can be several elements with the same key. For example, the map we used to count words must have only one element per given word. On the other hand, a dictionary could have several definitions associated with a particular word.

The following example illustrates the differences between the containers with unique keys and those that have multiple keys. First, we‚Äôll create a vector of ints named ivec that has 20 elements: two copies of each of the integers from 0 through 9
inclusive. We‚Äôll use that vector to initialize a set and a multiset:

// define a vector with 20 elements, holding two copies of each number from 0 to 9
vector<int> ivec;
for (vector<int>::size_type i = 0; i != 10; ++i) {
    ivec.push_back(i);
    ivec.push_back(i); // duplicate copies of each number
}

// iset holds unique elements from ivec; miset holds all 20 elements
set<int> iset(ivec.cbegin(), ivec.cend());
multiset<int> miset(ivec.cbegin(), ivec.cend());
cout << ivec.size() << endl; // prints 20
cout << iset.size() << endl; // prints 10
cout << miset.size() << endl; // prints 20

Even though we initialized iset from the entire ivec container, iset has only ten elements: one for each distinct element in ivec. On the other hand, miset has 20 elements, the same as the number of elements in ivec.

Requirements on Key Type

The associative containers place constraints on the type that is used as a key. We‚Äôll cover the requirements for keys in the unordered containers later. For the ordered containers‚Äîmap, multimap, set, and multiset‚Äîthe key type must define a way to compare the elements. By default, the library uses the < operator for the key type to compare the keys. In the set types, the key is the element type; in the map types, the key is the first type. Thus, the key type for word_count in is string. Similarly, the key type for exclude is string.

Key Types for Ordered Containers

Just as we can provide our own comparison operation to an algorithm, we can also supply our own operation to use in place of the < operator on keys. The specified operation must define a strict weak ordering over the key type. We can think of a strict weak ordering as ‚Äúless than,‚Äù although our function might use a more complicated procedure. 

If two keys are equivalent (i.e., if neither is ‚Äúless than‚Äù the other), the container treats them as equal. When used as a key to a map, there will be only one element associated with those keys, and either key can be used to access the corresponding
value.

Note: In practice, what‚Äôs important is that a type that defines a < operator that ‚Äúbehaves normally‚Äù can be used as a key.

Using a Comparison Function for the Key Type

The type of the operation that a container uses to organize its elements is part of the type of that container. To specify our own operation, we must supply the type of that operation when we define the type of an associative container. The operation type is specified following the element type inside the angle brackets that we use to say which type of container we are defining.

Each type inside the angle brackets is just that, a type. We supply a particular comparison operation (that must have the same type as we specified inside the angle brackets) as a constructor argument when we create a container.

For example, we can‚Äôt directly define a multiset of Sales_data because Sales_data doesn‚Äôt have a < operator. However, we can use the compareIsbn function from the exercises later to define a multiset. That function defines a strict weak ordering based on their ISBNs of two given Sales_data objects.

The compareIsbn function should look something like

bool compareIsbn(const Sales_data &lhs, const Sales_data
&rhs)
{
    return lhs.isbn() < rhs.isbn();
}

To use our own operation, we must define the multiset with two types: the key type, Sales_data, and the comparison type, which is a function pointer type that can point to compareIsbn. When we define objects of this type, we supply a pointer to the operation we intend to use. In this case, we supply a pointer
to compareIsbn:

// bookstore can have several transactions with the same ISBN
// elements in bookstore will be in ISBN order
multiset<Sales_data, decltype(compareIsbn)*>
    bookstore(compareIsbn);

Here, we use decltype to specify the type of our operation, remembering that when we use decltype to form a function pointer, we must add a * to indicate that we‚Äôre using a pointer to the given function type. We initialize bookstore from compareIsbn, which means that when we add elements to bookstore, those elements will be ordered by calling compareIsbn. That is, the elements in bookstore will be ordered by their ISBN members. We can write compareIsbn instead of &compareIsbn as the constructor argument because when we use the
name of a function, it is automatically converted into a pointer if needed. We could have written &compareIsbn with the same effect

==
The pair Type

Before we look at the operations on associative containers, we need to know about the library type named pair, which is defined in the utility header.

A pair holds two data members. Like the containers, pair is a template from which we generate specific types. We must supply two type names when we create a pair. The data members of the pair have the corresponding types. There is no requirement that the two types be the same:

pair<string, string> anon; // holds two strings
pair<string, size_t> word_count; // holds a string and an size_t
pair<string, vector<int>> line; // holds string and vector<int>

The default pair constructor value initializes the data members. Thus, anon is a pair of two empty strings, and line holds an empty string and an empty vector. The size_t value in word_count gets the value 0, and the string member is initialized to the empty string.

We can also provide initializers for each member

pair<string, string> author{"James", "Joyce"};

creates a pair named author, initialized with the values "James" and "Joyce".

Unlike other library types, the data members of pair are public.
These members are named first and second, respectively. We access these members using the normal member access notation, as, for example, we did in the output statement of our word-counting program:

// print the results
cout << w.first << " occurs " << w.second
    << ((w.second > 1) ? " times" : " time") << endl;

Here, w is a reference to an element in a map. Elements in a map are pairs. In this statement we print the first member of the element, which is the key, followed by the second member, which is the counter. The library defines only a limited number
of operations on pairs, which are listed in Table below.

Operations on pairs:

pair<T1, T2>p: ps is a pair with value initialized members of types T2 and T2, respectively.

pair<T1, T2> p(v1, v2): p is a pair with types T1 and T2; the first and second members are initialized from v1 and v2, respectively.

pair<T1, T2> p = {v1, v2}: Equivalent to p (v1, v2).

make_pair(v1, v2): Returns a pair initialized from v1 and v2. THe type of the pari is inferred from the types of v1 and v2.

p.first: Returns the (public) data member of p named first.

p.second: Returns the (public) data member of p named second.

p1 replop p2: Relationed operators (<, >, <=, >=). Relational operators are efined as dictionary ordering: For example, p1 < p2 is true if p1.first < p2.first or if !(p2.first < p1.first) && p1.second < p2.second. Uses the element's < operator.

p1 == p2, p1 != p2: Two paris are equal if their first and second members are respectively equal. Uses the elements's == operator.

A Function to Create pair Objects

Imagine we have a function that needs to return a pair. Under the new standard we can list initialize the return value.

pair<string, int> process(vector<string> &v)
{
    // process v
    if (!v.empty())
        return {v.back(), v.back().size()}; // list initialize
    else
        return pair<string, int>(); // explicitly constructed return value
}

Under earlier versions of C++, we couldn‚Äôt use braced initializers to return a type like pair. Instead, we might have written both returns to explicitly construct the return value:

if (!v.empty())
    return pair<string, int>(v.back(), v.back().size());

Alternatively, we could have used make_pair to generate a new pair of the appropriate type from its two arguments:

if (!v.empty())
    return make_pair(v.back(), v.back().size());

Operations on Associative Containers

In addition to the types listed in Table above, the associative containers define the types listed in Table below. These types represent the container‚Äôs key and value.

Associative Container Additional Type Aliases:

key_type: Type of the key for this container type.

mapped_type: Type associated with each key; map types only.

value_type: For sets, same as the key_type. For maps, pair<const key_type, mapped_type>.

Because we cannot change an element‚Äôs key, the key part of these pairs is const.

set<string>::value_type v1; // v1 is a string
set<string>::key_type v2; // v2 is a string
map<string, int>::value_type v3; // v3 is a pair<const string, int>
map<string, int>::key_type v4; // v4 is a string
map<string, int>::mapped_type v5; // v5 is an int

Associative Container Iterators

When we dereference an iterator, we get a reference to a value of the container‚Äôs value_type. In the case of map, the value_type is a pair in which first holds the const key and second holds the value:

// get an iterator to an element in word_count
auto map_it = word_count.begin();
// *map_it is a reference to a pair<const string, size_t> object
cout << map_it->first; // prints the key for this element
cout << " " << map_it->second; // prints the value of the element
map_it->first = "new key"; // error: key is const
++map_it->second; // ok: we can change the value through an iterator

Iterators for sets Are const.

When we use an iterator to traverse a map, multimap, set, or multiset, the iterators yield elements in ascending key order.

Associative Containers and Algorithms

In general, we do not use the generic algorithms with the associative containers. The fact that the keys are const means that we cannot pass associative container iterators to algorithms that write to or reorder container elements. Such
algorithms need to write to the elements. The elements in the set types are const, and those in maps are pairs whose first element is const.

Associative containers can be used with the algorithms that read elements.

In practice, if we do so at all, we use an associative container with the algorithms either as the source sequence or as a destination.

--
Adding Elements

The insert members add one element or a range of elements. Because map and set (and the corresponding unordered types) contain unique keys, inserting an element that is already present has no effect:

vector<int> ivec = {2,4,6,8,2,4,6,8}; // ivec has eight elements
set<int> set2; // empty set
set2.insert(ivec.cbegin(), ivec.cend()); // set2 has four elements
set2.insert({1,3,5,7,1,3,5,7}); // set2 now has eight elements

Associative Container insert Operations:

c.insert(v): v value_type object, args are used to construct an element. 

c.emplace(args): For map and set, the elements is not already in c. Returns a pair containing an iterator referring to the element with the given key and a bool indicating whether the element was inserted. For multimap and multiset, inserts (or constructs) the given element and returns an iterator to the new element.

c.insert(b, e): b and e are iterators that denote a reange of c::value_type values.

c.insert(il): il is a brached list of such values. Returns void.
c.insert(p, v): For map and set, inserts eht elements with keys that are not already in c. For multipma and multiset inserts, each element in the ragne.

c.emplace(p, args): Like insert(v) (or emplace(args)), but uses iterator p as a hint for where to begin the search for where the new element should be stored. Returns an iterator to the element with the given key.

Adding Elements to a map

When we insert into a map, we must remember that the element type is a pair. Often, we don‚Äôt have a pair object that we want to insert. Instead, we create a pair in the argument list to insert:

// four ways to add word to word_count
word_count.insert({word, 1});
word_count.insert(make_pair(word, 1));
word_count.insert(pair<string, size_t>(word, 1));
word_count.insert(map<string, size_t>::value_type(word, 1));

Testing the Return from insert

The value returned by insert (or emplace) depends on the container type and the parameters. For the containers that have unique keys, the versions of insert and emplace that add a single element return a pair that lets us know whether the insertion happened. The first member of the pair is an iterator to the element with the given key; the second is a bool indicating whether that element was inserted, or was already there. If the key is already in the container, then insert does nothing, and the bool portion of the return value is false. If the key isn‚Äôt present, then the element is inserted and the bool is true.

Adding Elements to multiset or multimap

Our word-counting program depends on the fact that a given key can occur only once. That way, there is only one counter associated with any given word.

Sometimes, we want to be able to add additional elements with the same key. For example, we might want to map authors to titles of the books they have written. In this case, there might be multiple entries for each author, so we‚Äôd use a multimap rather than a map. Because keys in a multi container need not be unique, insert on these types always inserts an element:

multimap<string, string> authors;
// adds the first element with the key Barth, John
authors.insert({"Barth, John", "Sot-Weed Factor"});
// ok: adds the second element with the key Barth, John
authors.insert({"Barth, John", "Lost in the Funhouse"});

--
Erasing Elements
The associative containers define three versions of erase, which are described in Table below.

Removing Elements from an Associative Container:

c.erase(k): Remvoes every element with key k from c. Returns size_type indicating the number of elements removed.

c.erase(p): Removes the element denoted by the iterator p from c. p must refer to an actual element in c; it must not be equal to c.end(). Returns an iterator to the element after p or c.end() if p denotes the last element in c.

c.erase(b, e): Removes the elements in the range denoted by the iterator pair b, e. Returns e.

--
Subscripting a map

The map and unordered_map containers provide the subscript operator and a corresponding at function, which are described in Table below. The set types do not support subscripting because there is no ‚Äúvalue‚Äù associated with a key in a set. The elements are themselves keys, so the operation of ‚Äúfetching the value associated with a key‚Äù is meaningless. We cannot subscript a multimap or an unordered_multimap because there may be more than one value associated with a given key.

c[k]: Returns the element with key k; if k is not in c, adds a new, value-initialized element with key k.

c.at(k): Checked access to the element with key k; throws an out_of_range exception if k is not in c.

Example:

map <string, size_t> word_count; // empty map

// insert a value-initialized element with key Anna; then assign 1 to its value
word_count["Anna"] = 1;

Note: Subscripting a map behaves quite differently from subscripting an array or vector: Using a key that is not already present adds an element with that key to the map.

Using the Value Returned from a Subscript Operation

Another way in which the map subscript differs from other subscript operators we‚Äôve used is its return type. Ordinarily, the type returned by dereferencing an iterator and the type returned by the subscript operator are the same. Not so for maps: when we subscript a map, we get a mapped_type object; when we dereference a map iterator,  we get a value_type object.

--
Accessing Elements

The associative containers provide various ways to find a given element, which are described in Table below.

Operations to Find Elements in an Associative Container:

lower_bound and upper_bound not valid for the unordered containers. Subscript and at operations only for map and unordered_map that are not const.

c.find(k): Returns an iterator to the (first) element with key k, or the off-the-end iterator if k is not in the container.

c.count(k): Returns the number of elements with key k. For the containers with unique keys, the result is always zero or one.

c.lower_bound(k): Returns an iterator to the first element with key not less than k.

c.upper_bound(k): Returns an iterator to the first element with key greater than k.

c.equal_range(k): Returns a pair of iterators denoting the  lements with key k. If k is not present, both members are c.end().

Using find Instead of Subscript for maps

For the map and unordered_map types, the subscript operator provides the simplest method of retrieving a value. However, as we‚Äôve just seen, using a subscript has an important side effect: If that key is not already in the map, then subscript inserts an element with that key. Whether this behavior is correct depends on our expectations.

Sometimes, we want to know if an element with a given key is present without changing the map. We cannot use the subscript operator to determine whether an element is present, because the subscript operator inserts a new element if the key is not already there. In such cases, we should use find:

if (word_count.find("foobar") == word_count.end())
    cout << "foobar is not in the map" << endl;

Finding Elements in a multimap or multiset

Finding an element in an associative container that requires unique keys is a simple matter‚Äîthe element is or is not in the container. For the containers that allow multiple keys, the process is more complicated: There may be many elements with the
given key. When a multimap or multiset has multiple elements of a given key, those elements will be adjacent within the container.

For example, given our map from author to titles, we might want to print all the books by a particular author. We can solve this problem in three different ways. The most obvious way uses find and count:

string search_item("Alain de Botton"); // author we'll look for
auto entries = authors.count(search_item); // number of elements
auto iter = authors.find(search_item); // first entry for this author

// loop through the number of entries there are for this author
while(entries) {
    cout << iter->second << endl; // print each title
    ++iter; // advance to the next title
    --entries; // keep track of how many we've printed
}

A Different, Iterator-Oriented Solution

Alternatively, we can solve our problem using lower_bound and upper_bound. Each of these operations take a key and returns an iterator. If the key is in the container, the iterator returned from lower_bound will refer to the first instance of that key and the iterator returned by upper_bound will refer just after the last instance of the key. If the element is not in the multimap, then lower_bound and upper_bound will return equal iterators; both will refer to the point at which the key can be inserted without disrupting the order.

// beg and end denote the range of elements for this author
for (auto beg = authors.lower_bound(search_item), end = authors.upper_bound(search_item); beg != end; ++beg)
    cout << beg->second << endl; // print each title

The equal_range Function

The remaining way to solve this problem is the most direct of the three approaches: Instead of calling upper_bound and lower_bound, we can call equal_range.

This function takes a key and returns a pair of iterators. If the key is present, then the first iterator refers to the first instance of the key and the second iterator refers one past the last instance of the key. If no matching element is found, then both the first and second iterators refer to the position where this key can be inserted.

We can use equal_range to modify our program once again:

// definitions of authors and search_item as above
// pos holds iterators that denote the range of elements for this key
for (auto pos = authors.equal_range(search_item); pos.first != pos.second; ++pos.first)
    cout << pos.first->second << endl; // print each title

==
(findunorderedcontainers)
Unordered associative containers

The Unordered Containers

The new standard defines four unordered associative containers. Rather than using a comparison operation to organize their elements, these containers use a hash function and the key type‚Äôs == operator. An unordered container is most useful when
we have a key type for which there is no obvious ordering relationship among the elements. These containers are also useful for applications in which the cost of maintaining the elements in order is prohibitive.

Using an Unordered Container

Aside from operations that manage the hashing, the unordered containers provide the same operations (find, insert, and so on) as the ordered containers. That means that the operations we‚Äôve used on map and set apply to unordered_map and unordered_set as well. Similarly for the unordered versions of the containers that allow multiple keys.

As a result, we can usually use an unordered container in place of the corresponding ordered container, and vice versa. However, because the elements are not stored in order, the output of a program that uses an unordered container will (ordinarily) differ from the same program using an ordered container.

// count occurrences, but the words won't be in alphabetical order
unordered_map<string, size_t> word_count;
string word;

while (cin >> word)
    ++word_count[word]; // fetch and increment the counter for word

for (const auto &w : word_count) // for each element in the map
    // print the results
    cout << w.first << " occurs " << w.second
    << ((w.second > 1) ? " times" : " time") << endl;

Managing the Buckets

The unordered containers are organized as a collection of buckets, each of which holds zero or more elements. These containers use a hash function to map elements to buckets. To access an element, the container first computes the element‚Äôs hash code, which tells which bucket to search. The container puts all of its elements with a given hash value into the same bucket. If the container allows multiple elements with a given key, all the elements with the same key will be in the same bucket. As a result, the performance of an unordered container depends on the quality of its hash function and on the number and size of its buckets.

The hash function must always yield the same result when called with the same argument. Ideally, the hash function also maps each particular value to a unique bucket. However, a hash function is allowed to map elements with differing keys to
the same bucket. When a bucket holds several elements, those elements are searched sequentially to find the one we want. Typically, computing an element‚Äôs hash code and finding its bucket is a fast operation. However, if the bucket has many elements, many comparisons may be needed to find a particular element.

The unordered containers provide a set of functions, listed in Table below, that let us manage the buckets. These members let us inquire about the state of the container and force the container to reorganize itself as needed. 

Unordered Container Management Operations:
(Ignored by tao)

Requirements on Key Type for Unordered Containers

By default, the unordered containers use the == operator on the key type to compare elements. They also use an object of type hash<key_type> to generate the hash code for each element. The library supplies versions of the hash template for the builtin
types, including pointers. It also defines hash for some of the library types, including strings and the smart pointer types that we will describe later. Thus, we can directly define  unordered containers whose key is one of the built-in types (including pointer types), or a string, or a smart pointer.

(Avadoles) However, we cannot directly define an unordered container that uses a our own class types for its key type. Unlike the containers, we cannot use the hash template directly. Instead, we must supply our own version of the hash template. We‚Äôll see how to do so later.

Instead of using the default hash, we can use a strategy similar to the one we used to override the default comparison operation on keys for the ordered containers. To use Sales_data as the key, we‚Äôll need to supply functions to replace both the == operator and to calculate a hash code. We‚Äôll start by defining these functions:

size_t hasher(const Sales_data &sd)
{
    return hash<string>()(sd.isbn());
}

bool eqOp(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() == rhs.isbn();
}

Our hasher function uses an object of the library hash of string type to generate a hash code from the ISBN member. Similarly, the eqOp funciton compares two Sales_data objects by comparing their ISBNs.

We can use these functions to define an unordered_multiset as follows

using SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>;

// arguments are the bucket size and pointers to the hash function and equality operator
SD_multiset bookstore(42, hasher, eqOp);

==
(findunorderedset)
unordered_set

Tao's impression: the functions of unordered_set are the same as set.

#include <iostream>
#include <unordered_set>
#include <algorithm>

From geeksforgeeks:

unorderd_set in C++ STL
unordered_set is implemented using hash table where keys are hashed into indices of this hash table so it is not possible to maintain an order. All operation on unordered_set takes constant time O(1) on an average which can go up to linear time in worst case which depends on the internally used hash function but practically they perform very well and generally provide constant time lookup operation.
The unordered-set can contain key of any type ‚Äì predefined or user-defined data structure but when we define key of type user define type, we need to specify our comparison function according to which keys will be compared.

set vs unordered_set
Set set is an ordered sequence of unique keys whereas unordered_set is a set in which key can be stored in any order, so unordered.
Set is implemented as balanced tree structure that is why it is possible to maintain an order between the elements (by specific tree traversal). Time complexity of set operations is O(Log n) while for unordered_set, it is O(1).

Methods on unordered_set
For unordered_set many function are defined among which most useful are size and empty for capacity, find for searching a key, insert and erase for modification.
The Unordered_set allows only unique keys, for duplicate keys unordered_multiset should be used.

Example of declaration, find, insert and iteration in unordered_set is given below :

// C++ program to demonstrate various function of unordered_set 
#include <bits/stdc++.h> 
using namespace std; 
  
int main() 
{ 
    // declaring set for storing string data-type 
    unordered_set<string> stringSet; 
  
    // inserting various string, same string will be stored 
    // once in set 
    stringSet.insert("code"); 
    stringSet.insert("in"); 
    stringSet.insert("c++"); 
    stringSet.insert("is"); 
    stringSet.insert("fast"); 
  
    string key = "slow"; 
  
    //     find returns end iterator if key is not found, 
    //  else it returns iterator to that key 
    if (stringSet.find(key) == stringSet.end()) 
        cout << key << " not found\n\n"; 
    else
        cout << "Found " << key << endl << endl; 
  
    key = "c++"; 
    if (stringSet.find(key) == stringSet.end()) 
        cout << key << " not found\n"; 
    else
        cout << "Found " << key << endl; 
  
    // now iterating over whole set and printing its 
    // content 
    cout << "\nAll elements : "; 
    unordered_set<string> :: iterator itr; 
    for (itr = stringSet.begin(); itr != stringSet.end(); itr++) 
        cout << (*itr) << endl; 
} 

==
(findset)
set

From geeksforgeeks:

Functions associated with Set:

pair <iterator, bool> insert(const g) ‚Äì Adds a new element ‚Äòg‚Äô to the set
find(const g) ‚Äì Returns an iterator to the element ‚Äòg‚Äô in the set if found, else returns the iterator to end
begin() ‚Äì Returns an iterator to the first element in the set
end() ‚Äì Returns an iterator to the theoretical element that follows last element in the set

size() ‚Äì Returns the number of elements in the set
empty() ‚Äì Returns whether the set is empty

iterator insert (iterator position, const g) ‚Äì Adds a new element ‚Äòg‚Äô at the position pointed by iterator
max_size() ‚Äì Returns the maximum number of elements that the set can hold
erase(iterator position) ‚Äì Removes the element at the position pointed by the iterator
erase(const g)- Removes the value ‚Äòg‚Äô from the set
clear() ‚Äì Removes all the elements from the set
key_comp() / value_comp() ‚Äì Returns the object that determines how the elements in the set are ordered (‚Äò<‚Äò by default)
count(const g) ‚Äì Returns 1 or 0 based on the element ‚Äòg‚Äô is present in the set or not.
lower_bound(const g) ‚Äì Returns an iterator to the first element that is equivalent to ‚Äòg‚Äô or definitely will not go before the element ‚Äòg‚Äô in the set
upper_bound(const g) ‚Äì Returns an iterator to the first element that is equivalent to ‚Äòg‚Äô or definitely will go after the element ‚Äòg‚Äô in the set

Example:

#include <iostream> 
#include <set> 
#include <iterator> 
  
using namespace std; 
  
int main() 
{ 
    // empty set container 
    set <int, greater <int> > gquiz1;         
  
    // insert elements in random order 
    gquiz1.insert(40); 
    gquiz1.insert(30); 
    gquiz1.insert(60); 
    gquiz1.insert(20); 
    gquiz1.insert(50); 
    gquiz1.insert(50); // only one 50 will be added to the set 
    gquiz1.insert(10); 
  
    // printing set gquiz1 
    set <int, greater <int> > :: iterator itr; 
    cout << "\nThe set gquiz1 is : "; 
    for (itr = gquiz1.begin(); itr != gquiz1.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
    cout << endl; 
  
    // assigning the elements from gquiz1 to gquiz2 
    set <int> gquiz2(gquiz1.begin(), gquiz1.end()); 
  
    // print all elements of the set gquiz2 
    cout << "\nThe set gquiz2 after assign from gquiz1 is : "; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
    cout << endl; 
  
    // remove all elements up to 30 in gquiz2 
    cout << "\ngquiz2 after removal of elements less than 30 : "; 
    gquiz2.erase(gquiz2.begin(), gquiz2.find(30)); 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
  
    // remove element with value 50 in gquiz2 
    int num; 
    num = gquiz2.erase (50); 
    cout << "\ngquiz2.erase(50) : "; 
    cout << num << " removed \t" ; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
  
    cout << endl; 
  
    //lower bound and upper bound for set gquiz1 
    cout << "gquiz1.lower_bound(40) : "
         << *gquiz1.lower_bound(40) << endl; 
    cout << "gquiz1.upper_bound(40) : "
         << *gquiz1.upper_bound(40) << endl; 
  
    //lower bound and upper bound for set gquiz2 
    cout << "gquiz2.lower_bound(40) : "
         << *gquiz2.lower_bound(40) << endl; 
    cout << "gquiz2.upper_bound(40) : "
         << *gquiz2.upper_bound(40) << endl; 
  
    return 0; 
  
} 

==
(findunorderedmap)
unordered_map

Tao's impression: the functions of unordered_map are the same as map.

From geeksforgeeks:

unordered_map in C++ STL
unordered_map is an associated container that stores elements formed by combination of key value and a mapped value. The key value is used to uniquely identify the element and mapped value is the content associated with the key. Both key and value can be of any type predefined or user-defined.

Internally unordered_map is implemented using Hash Table, the key provided to map are hashed into indices of hash table that is why performance of data structure depends on hash function a lot but on an average the cost of search, insert and delete from hash table is O(1).

// C++ program to demonstrate functionality of unordered_map 
#include <iostream> 
#include <unordered_map> 
using namespace std; 
  
int main() 
{ 
    // Declaring umap to be of <string, int> type 
    // key will be of string type and mapped value will 
    // be of double type 
    unordered_map<string, int> umap; 
  
    // inserting values by using [] operator 
    umap["GeeksforGeeks"] = 10; 
    umap["Practice"] = 20; 
    umap["Contribute"] = 30; 
  
    // Traversing an unordered map 
    for (auto x : umap) 
      cout << x.first << " " << x.second << endl; 
  
} 

==
(findmap)
map

Tao: the simplest way to insert into a map is the same as Python (ie, same way as updating an existing element value), no need to use insert function. At least two people in leetcode discussion did in this way.

unordered_map<Node*, Node*> mp;
Node* copy = new Node(node -> label);
mp[node] = copy;

From geeksforgeeks:

Functions associated with Map:

find(const g) ‚Äì Returns an iterator to the element with key value ‚Äòg‚Äô in the map if found, else returns the iterator to end
begin() ‚Äì Returns an iterator to the first element in the map
end() ‚Äì Returns an iterator to the theoretical element that follows last element in the map

size() ‚Äì Returns the number of elements in the map
empty() ‚Äì Returns whether the map is empty

pair insert(keyvalue,mapvalue) ‚Äì Adds a new element to the map
max_size() ‚Äì Returns the maximum number of elements that the map can hold
erase(iterator position) ‚Äì Removes the element at the position pointed by the iterator
erase(const g)‚Äì Removes the key value ‚Äòg‚Äô from the map
clear() ‚Äì Removes all the elements from the map
key_comp() / value_comp() ‚Äì Returns the object that determines how the elements in the map are ordered (‚Äò<' by default)
count(const g) ‚Äì Returns the number of matches to element with key value ‚Äòg‚Äô in the map
lower_bound(const g) ‚Äì Returns an iterator to the first element that is equivalent to mapped value with key value ‚Äòg‚Äô or definitely will not go before the element with key value ‚Äòg‚Äô in the map
upper_bound(const g) ‚Äì Returns an iterator to the first element that is equivalent to mapped value with key value ‚Äòg‚Äô or definitely will go after the element with key value ‚Äòg‚Äô in the map


Example:

#include <iostream> 
#include <map> 
#include <iterator> 
  
using namespace std; 
  
int main() 
{ 
    map <int, int> gquiz1;        // empty map container 
  
    // insert elements in random order 
    gquiz1.insert(pair <int, int> (1, 40)); 
    gquiz1.insert(pair <int, int> (2, 30)); 
    gquiz1.insert(pair <int, int> (3, 60)); 
    gquiz1.insert(pair <int, int> (4, 20)); 
    gquiz1.insert(pair <int, int> (5, 50)); 
    gquiz1.insert(pair <int, int> (6, 50));  
    gquiz1.insert(pair <int, int> (7, 10)); 
  
    // printing map gquiz1 
    map <int, int> :: iterator itr; 
    cout << "\nThe map gquiz1 is : \n"; 
    cout << "\tKEY\tELEMENT\n"; 
    for (itr = gquiz1.begin(); itr != gquiz1.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
    cout << endl; 
  
    // assigning the elements from gquiz1 to gquiz2 
    map <int, int> gquiz2(gquiz1.begin(), gquiz1.end()); 
  
    // print all elements of the map gquiz2 
    cout << "\nThe map gquiz2 after assign from gquiz1 is : \n"; 
    cout << "\tKEY\tELEMENT\n"; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
    cout << endl; 
  
    // remove all elements up to element with key=3 in gquiz2 
    cout << "\ngquiz2 after removal of elements less than key=3 : \n"; 
    cout << "\tKEY\tELEMENT\n"; 
    gquiz2.erase(gquiz2.begin(), gquiz2.find(3)); 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
  
    // remove all elements with key = 4 
    int num; 
    num = gquiz2.erase (4); 
    cout << "\ngquiz2.erase(4) : "; 
    cout << num << " removed \n" ; 
    cout << "\tKEY\tELEMENT\n"; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
  
    cout << endl; 
  
    //lower bound and upper bound for map gquiz1 key = 5 
    cout << "gquiz1.lower_bound(5) : " << "\tKEY = "; 
    cout << gquiz1.lower_bound(5)->first << '\t'; 
    cout << "\tELEMENT = " << gquiz1.lower_bound(5)->second << endl; 
    cout << "gquiz1.upper_bound(5) : " << "\tKEY = "; 
    cout << gquiz1.upper_bound(5)->first << '\t'; 
    cout << "\tELEMENT = " << gquiz1.upper_bound(5)->second << endl; 
      
    return 0; 
  
} 

==
(findcontaineradaptor)
Container Adaptors (stack, queue, priority_queue)

In addition to the sequential containers, the library defines three sequential container adaptors: stack, queue, and priority_queue. An adaptor is a general concept in the library. There are container, iterator, and function adaptors. Essentially, an adaptor is a mechanism for making one thing act like another. A container adaptor takes an existing container type and makes it act like a different type. For example, the stack adaptor takes a sequential container (other than array or
forward_list) and makes it operate as if it were a stack. Table below lists the operations and types that are common to all the container adaptors.

Operations and Types Common to the Container Adaptors:

A a: Create a new empty adaptor named a. Tao: an example of A is stack<int>

A a(c): Create a new adaptor named a with a copy of the container c.

Relational operations: Each adaptor supports all the relational operators: ==, !=, <, <=, >, >=. These operators return the result of comparing the underlying containers.

a.empty(): false if a has any elements, true otherwise.

a.size(): Number of elements in a.

swap(a, b), a.swap(b): Swaps the contents of a and b; a and b must have the same type, including the type of the container on which they are implemented.

size_type: Type large enough to hold the size of the largest object of this type.

value_type: Element type.

container_type: Type of the underlying container on which the adaptor is implemented.

By default both stack and queue are implemented in terms of deque, and a priority_queue is implemented on a vector. We can override the default container type by naming a sequential container as a second type argument when we create the adaptor:

stack<string, vector<string>> str_stk; // empty stack implemented on top of vector

stack<string, vector<string>> str_stk2(svec); // str_stk2 is implemented on top of vector and initially holds a copy of svec

There are constraints on which containers can be used for a given adaptor. All of the adaptors require the ability to add and remove elements. As a result, they cannot be built on an array. Similarly, we cannot use forward_list, because all of the
adaptors require operations that add, remove, or access the last element in the container. A stack requires only push_back, pop_back, and back operations, so we can use any of the remaining container types for a stack. The queue adaptor requires back, push_back, front, and push_front, so it can be built on a list or deque but not on a vector. A priority_queue requires random access in addition to the front, push_back, and pop_back operations; it can be built on a vector or a deque but not on a list.

Each container adaptor defines its own operations in terms of operations provided by the underlying container type. We can use only the adaptor operations and cannot use the operations of the underlying container type.

==
(findstack)
stack

Stack Operations in Addition to the above Table "Operations and Types Common to the Container Adaptors":

s.push(item), s.emplace(args): Creates a new top element on the stack by copying or moving item, or by constructing the element from args.

s.pop(): Removes, but does not return, the top element from the stack.

s.top(): Returns, but does not remove, the top element on the stack.

The stack type is defined in the stack header. 

stack uses deque by default, can be implemented on a list or vector as well.

The following program illustrates the use of stack:

stack<int> intStack; // empty stack

// fill up the stack
for (size_t ix = 0; ix != 10; ++ix)
    intStack.push(ix); // intStackholds 0 ... 9 inclusive

while (!intStack.empty()) { // while there are still values in intStack
    int value = intStack.top(); // code that uses value
    intStack.pop(); // pop the top element, and repeat
}

==
(findqueue)
(findpriorityqueue)
queue, priority_queue

queue, priority_queue Operations in Addition to the above Table "Operations and Types Common to the Container Adaptors":

q.push(item), q.emplace(args): Create an element with value item or constructed from args at the end of the queue or in its appropriate position in priority_queue.

q.pop(): Removes, but does not return, the front element or highest-priority element from the queu or priority_queue, respectively.

q.front(), q.back(): Returns, but does not remove, the front or back element of q. Valid only for queue.

q.top(): Valid only for priority_queue. Returns, but does not remove, the highest-priority element. 

The queue and priority_queue adaptors are defined in the queue header.

The library queue uses a first-in, first-out (FIFO) storage and retrieval policy. Objects entering the queue are placed in the back and objects leaving the queue are removed from the front. A restaurant that seats people in the order in which they arrive is an example of a FIFO queue.

A priority_queue lets us establish a priority among the elements held in the queue. Newly added elements are placed ahead of all the elements with a lower priority. A restaurant that seats people according to their reservation time, regardless of when they arrive, is an example of a priority queue. By default, the library uses the < operator on the element type to determine relative priorities. We‚Äôll learn how to override this default later.

By default queue uses deque and priority_queue uses vector; queue can use a list or vector as well, priority_queue cna use a deque.

Example:

// queue::push/pop
#include <iostream>       // std::cin, std::cout
#include <queue>          // std::queue

int main ()
{
  std::queue<int> myqueue;
  int myint;

  std::cout << "Please enter some integers (enter 0 to end):\n";

  do {
    std::cin >> myint;
    myqueue.push (myint);
  } while (myint);

  std::cout << "myqueue contains: ";
  while (!myqueue.empty())
  {
    std::cout << ' ' << myqueue.front();
    myqueue.pop();
  }
  std::cout << '\n';

  return 0;
}
==
(finddeque)
(finddequeue)
deque

Tao's summary:

#include <deque> 
deque<int> gquiz; 
gquiz.push_back(10); 
gquiz.push_front(20); 
ngquiz.front();
ngquiz.back();
ngquiz.pop_front();
ngquiz.pop_back();
ngquiz.clear();
ngquiz.erase();

1. dequename.erase(position)
2. dequename.erase(startingposition, endingposition)

Examples:

Input: mydeque{1, 2, 3, 4, 5}, pos= 2
mydeque.erase(pos);
Output : 1, 2, 4, 5

Input: mydeque{1, 2, 3, 4, 5, 6, 7, 8}, pos1= 3, pos2= 6
mydeque.erase(pos1, pos2);
Output : 1, 2, 3, 8

--
From geeksforgeeks:

Double ended queues are sequence containers with the feature of expansion and contraction on both the ends. They are similar to vectors, but are more efficient in case of insertion and deletion of elements at the end, and also the beginning. Unlike vectors, contiguous storage allocation may not be guaranteed.

The functions for deque are same as vector, with an addition of push and pop operations for both front and back.

#include <iostream> 
#include <deque> 
  
using namespace std; 
  
void showdq(deque <int> g) 
{ 
    deque <int> :: iterator it; 
    for (it = g.begin(); it != g.end(); ++it) 
        cout << '\t' << *it; 
    cout << '\n'; 
} 
  
int main() 
{ 
    deque <int> gquiz; 
    gquiz.push_back(10); 
    gquiz.push_front(20); 
    gquiz.push_back(30); 
    gquiz.push_front(15); 
    cout << "The deque gquiz is : "; 
    showdq(gquiz); 
  
    cout << "\ngquiz.size() : " << gquiz.size(); 
    cout << "\ngquiz.max_size() : " << gquiz.max_size(); 
  
    cout << "\ngquiz.at(2) : " << gquiz.at(2); 
    cout << "\ngquiz.front() : " << gquiz.front(); 
    cout << "\ngquiz.back() : " << gquiz.back(); 
  
    cout << "\ngquiz.pop_front() : "; 
    gquiz.pop_front(); 
    showdq(gquiz); 
  
    cout << "\ngquiz.pop_back() : "; 
    gquiz.pop_back(); 
    showdq(gquiz); 
  
    return 0;

The output of the above program is :

The deque gquiz is :     15    20    10    30

gquiz.size() : 4
gquiz.max_size() : 4611686018427387903
gquiz.at(2) : 10
gquiz.front() : 15
gquiz.back() : 30
gquiz.pop_front() :     20    10    30

gquiz.pop_back() :     20    10

Methods of Deque:

deque insert() function in C++ STL: Returns an iterator that points to the first of the newly inserted elements.
deque rbegin() function in C++ STL: Returns a reverse iterator which points to the last element of the deque (i.e., its reverse beginning).
deque rend() function in C++ STL: Returns a reverse iterator which points to the position before the beginning of the deque (which is considered its reverse end).
deque cbegin() in C++ STL: Returns an iterator pointing to the first element of the container.
deque max_size() function in C++ STL: Returns the maximum number of elements that a deque container can hold.
deque assign() function in C++ STL: Assign values to the same or different deque container.
deque resize() function in C++ STL: Function which changes the size of the deque.
deque::push_front() in C++ STL: This function is used to push elements into a deque from the front.
deque::push_back() in C++ STL: This function is used to push elements into a deque from the back.
deque::pop_front() and deque::pop_back() in C++ STL: pop_front() function is used to pop or remove elements from a deque from the front. pop_back() function is used to pop or remove elements from a deque from the back.
deque::front() and deque::back() in C++ STL: front() function is used to reference the first element of the deque container. back() function is used to reference the last element of the deque container.
deque::clear() and deque::erase() in C++ STL: clear() function is used to remove all the elements of the deque container, thus making its size 0. erase() function is used to remove elements from a container from the specified position or range.
deque::empty() and deque::size() in C++ STL: empty() function is used to check if the deque container is empty or not. size() function is used to return the size of the deque container or the number of elements in the deque container.
deque::operator= and deque::operator[] in C++ STL:
operator= operator is used to assign new contents to the container by replacing the existing contents. operator[] operator is used to reference the element present at position given inside the operator.
deque::at() and deque::swap() in C++ STL: at() function is used reference the element present at the position given as the parameter to the function. swap() function is used to swap the contents of one deque with another deque of same type and size.
deque::begin() and deque::end in C++ STL: begin() function is used to return an iterator pointing to the first element of the deque container. end() function is used to return an iterator pointing to the last element of the deque container.
deque::emplace_front() and deque::emplace_back() in C++ STL: emplace_front() function is used to insert a new element into the deque container, the new element is added to the beginning of the deque. emplace_back() function is used to insert a new element into the deque container, the new element is added to the end of the deque.

==
(findalgorithm)
(findgenericalgorithm)
Generic algorithms

The library containers define a surprisingly small set of operations. Rather than adding lots of functionality to each container, the library provides a set of algorithms, most of
which are independent of any particular container type. These algorithms are generic: They operate on different types of containers and on elements of various types.

Most of the algorithms are defined in the algorithm header. The library also defines a set of generic numeric algorithms that are defined in the numeric header.

In general, the algorithms do not work directly on a container. Instead, they operate by traversing a range of elements bounded by two iterators. Typically, as the algorithm traverses the range, it does something with each element. For example, suppose we have a vector of ints and we want to know if that vector holds a particular value. The easiest way to answer this question is to call the library find algorithm:

int val = 42; // value we'll look for

// result will denote the element we want if it's in vec, or vec.cend() if not. tao: vec.cend() is the one past the last element.
auto result = find(vec.cbegin(), vec.cend(), val);

// report the result
cout << "The value " << val << (result == vec.cend() ? " is not present" : " is present") << endl;

The first two arguments to find are iterators denoting a range of elements, and the third argument is a value. find compares each element in the given range to the given value. It returns an iterator to the first element that is equal to that value. If
there is no match, find returns its second iterator to indicate failure. Thus, we can determine whether the element was found by comparing the return value with the second iterator argument. 

Because find operates in terms of iterators, we can use the same find function to look for values in any type of container. For example, we can use find to look for a value in a list of strings.

Similarly, because pointers act like iterators on built-in arrays, we can use find to look in an array:

int ia[] = {27, 210, 12, 47, 109, 83};
int val = 83;
int* result = find(begin(ia), end(ia), val);

Here we use the library begin and end functions to pass a pointer
to the first and one past the last elements in ia.

We can also look in a subrange of the sequence by passing iterators (or pointers) to the first and one past the last element of that subrange. For example, this call looks for a match in the elements ia[1], ia[2], and ia[3]:

// search the elements starting from ia[1] up to but not including ia[4]
auto result = find(ia + 1, ia + 4, val);

So long as there is an iterator that can be used to access the elements, find doesn‚Äôt depend in any way on the container type (or even whether the elements are stored in a container).

Iterators Make the Algorithms Container Independent. But Algorithms Do Depend on Element-Type Operations.

Key Concept: Algorithms Never Execute Container Operations.

The generic algorithms do not themselves execute container operations. They operate solely in terms of iterators and iterator operations. The fact that the algorithms operate in terms of iterators and not container operations has a perhaps surprising but essential implication: Algorithms never change the size of the underlying container. Algorithms may change the values of the elements stored in the container, and they may move elements around within the container. They do not, however, ever add or remove elements directly.

With only a few exceptions, the algorithms operate over a range of elements. We‚Äôll refer to this range as the ‚Äúinput range.‚Äù The algorithms that take an input range always use their first two parameters to denote that range. These parameters are iterators denoting the first and one past the last elements to process.

Although most algorithms are similar in that they operate over an input range, they differ in how they use the elements in that range. The most basic way to understand the algorithms is to know whether they read elements, write elements, or rearrange
the order of the elements.

--
Read-Only Algorithms

(Tao: see the find function above)

A number of the algorithms read, but never write to, the elements in their input range. The find function is one such algorithm, as is the count function we used in the exercises.

Another read-only algorithm is accumulate, which is defined in the numeric header. The accumulate function takes three arguments. The first two specify a range of elements to sum. The third is an initial value for the sum. Assuming vec is a sequence of integers, the following sets sum equal to the sum of the elements in vec, using 0 as the starting point for the summation.

// sum the elements in vec starting the summation with the value 0
int sum = accumulate(vec.cbegin(), vec.cend(), 0);

The type of the third argument to accumulate determines which addition operator is used and is the type that accumulate returns.

The fact that accumulate uses its third argument as the starting point for the summation has an important implication: It must be possible to add the element type to the type of the sum. That is, the elements in the sequence must match or be convertible to the type of the third argument.

As another example, because string has a + operator, we can concatenate the elements of a vector of strings by calling accumulate:

string sum = accumulate(v.cbegin(), v.cend(), string(""));

This call concatenates each element in v onto a string that starts out as the empty string. Note that we explicitly create a string as the third parameter. Passing the empty string as a string literal would be a compile-time error:

// error: no + on const char*
string sum = accumulate(v.cbegin(), v.cend(), "");

Ordinarily it is best to use cbegin() and cend() with algorithms that read, but do not write, the elements. However, if you plan to use the iterator returned by the algorithm to change an element‚Äôs value, then you need to pass begin() and end().

Algorithms That Operate on Two Sequences

Another read-only algorithm is equal, which lets us determine whether two sequences hold the same values. It compares each element from the first sequence to the corresponding element in the second. It returns true if the corresponding elements are equal, false otherwise. The algorithm takes three iterators: The first two (as usual) denote the range of elements in the first sequence; the third denotes the first element in the second sequence:

// roster2 should have at least as many elements as roster1
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());

Because equal operates in terms of iterators, we can call equal to compare elements in containers of different types.

However, equal makes one critically important assumption: It assumes that the second sequence is at least as big as the first. This algorithm potentially looks at every element in the first sequence. It assumes that there is a corresponding element
for each of those elements in the second sequence.

Algorithms that take a single iterator denoting a second sequence assume that the second sequence is at least as large at the first.

--
Algorithms That Write Container Elements

Some algorithms assign new values to the elements in a sequence. When we use an algorithm that assigns to elements, we must take care to ensure that the sequence into which the algorithm writes is at least as large as the number of elements we ask the algorithm to write. Remember, algorithms do not perform container operations, so they have no way themselves to change the size of a container.

As one example, the fill algorithm takes a pair of iterators that denote a range and a third argument that is a value. fill assigns the given value to each element in the input sequence:

fill(vec.begin(), vec.end(), 0); // reset each element to 0

fill(vec.begin(), vec.begin() + vec.size()/2, 10); // set a subsequence of the container to 10

Some algorithms take an iterator that denotes a separate destination. These algorithms assign new values to the elements of a sequence starting at the element denoted by the destination iterator. For example, the fill_n function takes a single iterator, a count, and a value. It assigns the given value to the specified number of elements starting at the element denoted to by the iterator. We might use fill_n to assign a new value to the elements in a vector:

vector<int> vec; // empty vector

// use vec giving it various values
fill_n(vec.begin(), vec.size(), 0); // reset all the elements of vec to
0

It is a fairly common beginner mistake to call fill_n (or similar algorithms that write to elements) on a container that has no elements:

vector<int> vec; // empty vector

// disaster: attempts to write to ten (nonexistent) elements in vec
fill_n(vec.begin(), 10, 0);

Algorithms that write to a destination iterator assume the destination is large enough to hold the number of elements being written.

Introducing back_inserter

One way to ensure that an algorithm has enough elements to hold the output is to use an insert iterator. An insert iterator is an iterator that adds elements to a container. Ordinarily, when we assign to a container element through an iterator, we assign to the element that iterator denotes. When we assign through an insert iterator, a new element equal to the right-hand value is added to the container.

We‚Äôll have more to say about insert iterators later. However, in order to illustrate how to use algorithms that write to a container, we will use back_inserter, which is a function defined in the iterator header. 

back_inserter takes a reference to a container and returns an insert iterator bound to that container. When we assign through that iterator, the assignment calls push_back to add an element with the given value to the container:

vector<int> vec; // empty vector

auto it = back_inserter(vec); // assigning through it adds elements to vec

*it = 42; // vec now has one element with value 42

Copy Algorithms

The copy algorithm is another example of an algorithm that writes to the elements of an output sequence denoted by a destination iterator. This algorithm takes three iterators. The first two denote an input range; the third denotes the beginning of the destination sequence. This algorithm copies elements from its input range into elements in the destination. It is essential that the destination passed to copy be at least as large as the input range.

As one example, we can use copy to copy one built-in array to another:

int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)]; // a2 has the same size as a1
// ret points just past the last element copied into a2
auto ret = copy(begin(a1), end(a1), a2); // copy a1 into a2

The value returned by copy is the (incremented) value of its destination iterator. That is, ret will point just past the last element copied into a2.

Several algorithms provide so-called ‚Äúcopying‚Äù versions. These algorithms compute new element values, but instead of putting them back into their input sequence, the algorithms create a new sequence to contain the results.

For example, the replace algorithm reads a sequence and replaces every instance of a given value with another value. This algorithm takes four parameters: two iterators denoting the input range, and two values. It replaces each element that is equal to the first value with the second:

// replace any element with the value 0 with 42
replace(ilst.begin(), ilst.end(), 0, 42);

This call replaces all instances of 0 by 42. If we want to leave the original sequence unchanged, we can call replace_copy. That algorithm takes a third iterator argument denoting a destination in which to write the adjusted sequence:

// use back_inserter to grow destination as needed
replace_copy(ilst.cbegin(), ilst.cend(), back_inserter(ivec), 0, 42);

After this call, ilst is unchanged, and ivec contains a copy of ilst with the exception that every element in ilst with the value 0 has the value 42 in ivec.

--
Algorithms That Reorder Container Elements

Some algorithms rearrange the order of elements within a container. An obvious example of such an algorithm is sort. A call to sort arranges the elements in the input range into sorted order using the element type‚Äôs < operator.

As an example, suppose we want to analyze the words used in a set of children‚Äôs stories. We‚Äôll assume that we have a vector that holds the text of several stories. We‚Äôd like to reduce this vector so that each word appears only once, regardless of how many times that word appears in any of the given stories.

To eliminate the duplicated words, we will first sort the vector so that duplicated words appear adjacent to each other. Once the vector is sorted, we can use another library algorithm, named unique, to reorder the vector so that the unique elements appear in the first part of the vector. Because algorithms cannot do container operations, we‚Äôll use the erase member of vector to actually remove the elements:


void elimDups(vector<string> &words)
{
    // sort words alphabetically so we can find the duplicates
    sort(words.begin(), words.end());

    // unique reorders the input range so that each word appears once in the ront portion of the range and returns an iterator one past the unique range
    auto end_unique = unique(words.begin(), words.end());
    
    // erase uses a vector operation to remove the nonunique elements
    words.erase(end_unique, words.end());
}

The unique algorithm rearranges the input range to ‚Äúeliminate‚Äù adjacent duplicated entries, and returns an iterator that denotes the end of the range of the unique values. The size of words is unchanged; it still has ten elements. The order of those
elements is changed‚Äîthe adjacent duplicates have been ‚Äúremoved.‚Äù We put remove in quotes because unique doesn‚Äôt remove any elements. Instead, it overwrites adjacent duplicates so that the unique elements appear at the front of the sequence. The iterator returned by unique denotes one past the last unique element. The elements beyond that point still exist, but we don‚Äôt know what values they have. The library algorithms operate on iterators, not containers. Therefore, an algorithm cannot (directly) add or remove elements.

To actually remove the unused elements, we must use a container operation, which we do in the call to erase. We erase the range of elements from the one to which end_unique refers through the end of words.

--
Customizing Operations

Many of the algorithms compare elements in the input sequence. By default, such algorithms use either the element type‚Äôs < or == operator. The library also defines versions of these algorithms that let us supply our own operation to use in place of the default operator.

For example, the sort algorithm uses the element type‚Äôs < operator. However, we might want to sort a sequence into a different order from that defined by <, or our sequence might have elements of a type (such as Sales_data) that does not have a
< operator. In both cases, we need to override the default behavior of sort.

Passing a Function to an Algorithm

As one example, assume that we want to print the vector after we call elimDups. However, we‚Äôll also assume that we want to see the words ordered by their size, and then alphabetically within each size. To reorder the vector by length, we‚Äôll use a second, overloaded version of sort. This version of sort takes a third
argument that is a predicate.

Predicates

A predicate(Ë¨ÇË™û) is an expression that can be called and that returns a value that can be used as a condition. The predicates used by library algorithms are either unary predicates (meaning they have a single parameter) or binary predicates (meaning
they have two parameters). The algorithms that take predicates call the given predicate on the elements in the input range. As a result, it must be possible to convert the element type to the parameter type of the predicate.

The version of sort that takes a binary predicate uses the given predicate in place of < to compare elements. For now, what we need to know is that the operation must define a consistent order for all possible elements in the input sequence. Our isShorter function is an example of a function that meets these requirements, so we can pass isShorter to sort. Doing so will reorder the elements by size:

// comparison function to be used to sort by word length
bool isShorter(const string &s1, const string &s2)
{
    return s1.size() < s2.size();
}

// sort on word length, shortest to longest
sort(words.begin(), words.end(), isShorter);

Sorting Algorithms

When we sort words by size, we also want to maintain alphabetic order among the elements that have the same length. To keep the words of the same length in alphabetical order we can use the stable_sort algorithm. A stable sort maintains the original order among equal elements.

stable_sort(words.begin(), words.end(), isShorter);

Assuming words was in alphabetical order before this call, after the call, words will be sorted by element size, and the words of each length remain in alphabetical order.

--
Structure of Generic Algorithms

The most fundamental property of any algorithm is the list of operations it requires from its iterator(s). Some algorithms, such as find, require only the ability to access an element through the iterator, to increment the iterator, and to compare two iterators for equality. Others, such as sort, require the ability to read, write, and randomly access elements. The iterator operations required by the algorithms are grouped into five iterator categories listed in Table below. Each algorithm specifies what kind of iterator must be supplied for each of its iterator parameters.

Iterator Categories:

Input iterator: Read, but not write; single-pass, increment only.

Output iterator: Write, but not read; single-pass, increment only.

Forward iterator: Read and write; multi-pass, increment only.

Bidirectional iterator: Read and write; multi-pass, increment and decrement.

Random-access iterator: Read and write; multi=pass, full iterator arithmetic.

A second way is to classify the algorithms (as we did in the beginning of this chapter) is by whether they read, write, or reorder the elements in the sequence. Appendix A covers all the algorithms according to this classification.

The find and accumulate algorithms require input iterators; istream_iterators are input iterators.

Iterators used as a destination are typically output iterators. For example, the third parameter to copy is an output iterator. The ostream_iterator type is an output iterator.

The replace algorithm requires a forward iterator; iterators on
forward_list are forward iterators.

The reverse algorithm requires bidirectional iterators, and aside from forward_list, the library containers supply iterators that meet the requirements for a bidirectional iterator.

The sort algorithms require random-access iterators. Iterators for array, deque, string, and vector are random-access iterators, as are pointers when used to access elements of a built-in array.

--
Algorithm Parameter Patterns

Superimposed on any other classification of the algorithms is a set of parameter conventions. Understanding these parameter conventions can aid in learning new algorithms‚Äîby knowing what the parameters mean, you can concentrate on understanding the operation the algorithm performs. Most of the algorithms have one
of the following four forms:

alg(beg, end, other args);
alg(beg, end, dest, other args);
alg(beg, end, beg2, other args);
alg(beg, end, beg2, end2, other args);

where alg is the name of the algorithm, and beg and end denote the input range on which the algorithm operates.

Algorithms with a Single Destination Iterator

A dest parameter is an iterator that denotes a destination in which the algorithm can write its output. Algorithms assume that it is safe to write as many elements as needed.

Algorithms with a Second Input Sequence

Algorithms that take either beg2 alone or beg2 and end2 use those iterators to denote a second input range. These algorithms typically use the elements from the second range in combination with the input range to perform a computation.

When an algorithm takes both beg2 and end2, these iterators denote a second range. Such algorithms take two completely specified ranges: the input range denoted by [beg, end), and a second input range denoted by [beg2, end2).

Algorithms that take only beg2 (and not end2) treat beg2 as the first element in a second input range. The end of this range is not specified. Instead, these algorithms assume that the range starting at beg2 is at least as large as the one denoted by beg, end.

--
Algorithm Naming Conventions

Some Algorithms Use Overloading to Pass a Predicate

Algorithms that take a predicate to use in place of the < or == operator, and that do not take other arguments, typically are overloaded. One version of the function uses the element type‚Äôs operator to compare elements; the second takes an extra parameter that is a predicate to use in place of < or ==:

unique(beg, end); // uses the == operator to compare the elements
unique(beg, end, comp); // uses comp to compare the elements

Algorithms with _if Versions

Algorithms that take an element value typically have a second named (not overloaded) version that takes a predicate in place of the value. The algorithms that take a predicate have the suffix _if appended:

find(beg, end, val); // find the first instance of val in the input range
find_if(beg, end, pred); // find the first instance for which pred is true

Distinguishing Versions That Copy from Those That Do Not

By default, algorithms that rearrange elements write the rearranged elements back into the given input range. These algorithms provide a second version that writes to a specified output destination. As we‚Äôve seen, algorithms that write to a destination append _copy to their names:

reverse(beg, end); // reverse the elements in the input range
reverse_copy(beg, end, dest);// copy elements in reverse order into dest

Some algorithms provide both _copy and _if versions. These versions take a destination iterator and a predicate:

// removes the odd elements from v1
remove_if(v1.begin(), v1.end(), [](int i) { return i % 2; });

// copies only the even elements from v1 into v2; v1 is unchanged
remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [](int i) { return i % 2; });

--
Container-Specific Algorithms

Unlike the other containers, list and forward_list define several algorithms as members. In particular, the list types define their own versions of sort, merge, remove, reverse, and unique. The generic version of sort requires randomaccess iterators. As a result, sort cannot be used with list and forward_list because these types offer bidirectional and forward iterators, respectively.

The generic versions of the other algorithms that the list types define can be used with lists, but at a cost in performance. These algorithms swap elements in the input sequence. A list can ‚Äúswap‚Äù its elements by changing the links among its elements rather than swapping the values of those elements. As a result, the list-specific versions of these algorithms can achieve much better performance than the corresponding generic versions.

These list-specific operations are described in Table below. Generic algorithms not listed in the table that take appropriate iterators execute equally efficiently on lists and forward_listss as on other containers.

Best Practices: The list member versions should be used in preference to the generic algorithms for lists and forward_lists.

Algorithms That are Members of list and forward_list:

lst.merge(lst2), lst.merge(lst2, comp): Merges elements from list2 onto lst. Both lst and lst2 must be sorted. Elements are removed from lst2. After the merge, lst2 is empty. The first version uses the < operator; the second version uses the given comparison operation.

lst.remove(val), lst.remove_if(pred): Calls erase to remove each element that is == to the given value or for which the given unary predicate succeds.

lst.reverse(): Reverses the order of the elements in lst.

lst.sort(), lst.sort(comp): Sorts the elements of lst using < or the given comparison operation.

lst.unique(), lst.unique(pred): Calls erase to remove consecutive copies of the same value. The first version uses ==, the second uses the given binary preidcate.

The splice (Á≤òÊé•) Members

The list types also define a splice algorithm, which is described in Table below. This algorithm is particular to list data structures. Hence a generic version of this algorithm is not needed.

Arguments to the list and forward_list splice Members:

lst.splice(args) or flst.splice_after(args)

(p, lst2): p is an iterator to an element in lst or an iterator just before an element in flst. MOves all the elmement(s) from lst2 into lst just before p or into flst just after p. Removes the element(s) from lst2. lst2 must have the same type as lst or flst and many not be the same list.

(p, lst2, p2): p2 is a valid iterator into lst2. Moves the element denoted by p2 into lst or moves the element just after p2 into flst. lst2 can be the same list as lst or flst.

(p, lst2, b, e): b and e must denote a valid range in lst2. Moves the elements in the given range from lst2. lst2 and lst (or flst) can be the same list but p must not denote an element in the gien range.

The List-Specific Operations Do Change the Containers

Most of the list-specific algorithms are similar‚Äîbut not identical‚Äîto their generic counterparts. However, a crucially important difference between the list-specific and the generic versions is that the list versions change the underlying container. For example, the list version of remove removes the indicated elements. The list version of unique removes the second and subsequent duplicate elements. Similarly, merge and splice are destructive on their arguments.

--
(findlambda)
Lambda Expressions

The predicates we pass to an algorithm must have exactly one or two parameters, depending on whether the algorithm takes a unary or binary predicate, respectively. However, sometimes we want to do processing that requires more arguments than the algorithm‚Äôs predicate allows.

Our new problem is to find the first element in the vector that has the given size. Once we know that element, we can use its position to compute how many elements have that size or greater.

We can use the library find_if algorithm to find an element that has a particular size. Like find, the find_if algorithm takes a pair of iterators denoting a range. Unlike find, the third argument to find_if is a predicate. The find_if algorithm calls the given predicate on each element in the input range. It returns the first element for which the predicate returns a nonzero value, or its end iterator if no such element is found.

It would be easy to write a function that takes a string and a size and returns a bool indicating whether the size of a given string is greater than the given size. However, find_if takes a unary predicate‚Äîany function we pass to find_if must have exactly one parameter that can be called with an element from the input sequence. There is no way to pass a second argument representing the size. To solve this part of our problem we‚Äôll need to use some additional language facilities.

Introducing Lambdas

We can pass any kind of callable object to an algorithm. An object or expression is callable if we can apply the call operator to it. That is, if e is a callable expression, we can write e(args) where args is a comma-separated list of zero or
more arguments.

The only callables we‚Äôve used so far are functions and function pointers. There are two other kinds of callables: classes that overload the function-call operator, which we‚Äôll cover later, and lambda expressions.

A lambda expression represents a callable unit of code. It can be thought of as an unnamed, inline function. Like any function, a lambda has a return type, a parameter list, and a function body. Unlike a function, lambdas may be defined inside a function. A lamba expression has the form

[capture list] (parameter list) -> return type { function body }

where capture list is an (often empty) list of local variables defined in the enclosing function (tao: the function which encloses the lambda expression); return type, parameter list, and function body are the same as in any ordinary function.  owever, unlike ordinary functions, a lambda must use a trailing
return to specify its return type.

We can omit either or both of the parameter list and return type but must always include the capture list and function body:

auto f = [] { return 42; }; //tao: note the semicolon at end

Here, we‚Äôve defined f as a callable object that takes no arguments and returns 42.

We call a lambda the same way we call a function by using the call operator:

cout << f() << endl; // prints 42

Omitting the parentheses and the parameter list in a lambda is equivalent to specifying an empty parameter list. Hence, when we call f, the argument list is empty. If we omit the return type, the lambda has an inferred return type that depends on the code in the function body. If the function body is just a return
statement, the return type is inferred from the type of the expression that is returned. Otherwise, the return type is void.

Note: Lambdas with function bodies that contain anything other than a single return statement that do not specify a return type return void.

An example of a lambda that takes arguments:

[](const string &a, const string &b)
    { return a.size() < b.size();}

// sort words by size, but maintain alphabetical order for words of the same size
stable_sort(words.begin(), words.end(),
    [](const string &a, const string &b)
        { return a.size() < b.size();});

Using the Capture List

Although a lambda may appear inside a function, it can use variables local to that function (tao: the function which encloses the lambda) only if it specifies which variables it intends to use. A lambda specifies the variables it will use by including those local variables in its capture list. The capture list directs the lambda to include information needed to access those variables within the lambda itself.

In this case, our lambda will capture sz (tao: sz is a variable defined in the enclosing function) and will have a single string parameter. The body of our lambda will compare the given string‚Äôs size with the captured value of sz:

[sz](const string &a)
    { return a.size() >= sz; };

Inside the [] that begins a lambda we can provide a comma-separated list of names defined in the surrounding function. Because this lambda captures sz, the body of the lambda may use sz.

Note: A lambda may use a variable local to its surrounding function only if the lambda captures that variable in its capture list.

--
(findforeach)
The for_each Algorithm

The for_each algorithm. This algorithm takes a callable object and calls that object on each element in the input range:

//tao: wc is an iterator
for_each(wc, words.end(),
    [](const string &s){cout << s << " ";});

The capture list is empty, because we use the capture list only for (nonstatic) variables defined in the surrounding function. A lambda can use names that are defined outside the function in which the lambda appears. In this case, cout is not a name defined locally in biggies; that name is defined in the iostream header. So long as the iostream header is included in the scope in which biggies appears, our lambda can use cout.

Note: The capture list is used for local nonstatic variables only; lambdas can use local statics and variables declared outside the function directly.

--
Lambda Captures and Returns

When we define a lambda, the compiler generates a new (unnamed) class type that corresponds to that lambda. We‚Äôll see how these classes are generated later. For now, what‚Äôs useful to understand is that when we pass a lambda to a function, we are defining both a new type and an object of that type: The argument is an unnamed object of this compiler-generated class type. Similarly, when we use auto to define a variable initialized by a lambda, we are defining an object of the type generated from that lambda.

By default, the class generated from a lambda contains a data member corresponding to the variables captured by the lambda. Like the data members of any class, the data members of a lambda are initialized when a lambda object is created.

Capture by Value

Similar to parameter passing, we can capture variables by value or by reference. Table below covers the various ways we can form a capture list. So far, our lambdas have captured variables by value. As with a parameter passed by value, it must be possible to copy such variables. Unlike parameters, the value of a captured variable is copied when the lambda is created, not when it is called:

void fcn1()
{
    size_t v1 = 42; // local variable

    // copies v1 into the callable object named f
    auto f = [v1] { return v1; };

    v1 = 0;
    auto j = f(); // j is 42; f stored a copy of v1 when we created it
}

Lambda Capture List:

[]: Empty capture list. The lambda may not use variables from the enclosing function. A lambda may use local variables only if it captures them.

[names]: names is a comma-separated list of names local to the enclosing function. By default, variables in the capture list are copied. A name preceded by & is captured by reference.

[&]: Implicit by reference capture list. Entities from the enclosing function used in the lambda body are used by reference. Tao: will explain in detail later.

[=]: Implict by value capture list. Entities from the enclosing function used in the lambda body are copied into the lambda body. Tao: will explain in detail later.

[&, identifier_list]: identifier_list is a comma-separated list of zero or more variables from the enclosing function. These variables are captured by value; any implicity captured variables are captured by reference. The names in identifier_list must not be preceded by an &.

[=, refernece_list]: variable included in the refernece_list are captured by reference; any implicity captured variables are captured by value. The names in reference_list may not include this and must be preceded by an &.

Capture by Reference

We can also define lambdas that capture variables by reference. For example:

void fcn2()
{
    size_t v1 = 42; // local variable
    // the object f2 contains a reference to v1
    auto f2 = [&v1] { return v1; };
    v1 = 0;
    auto j = f2(); // j is 0; f2 refers to v1; it doesn't store it
}

Reference captures are sometimes necessary. For example, we might want our biggies function to take a reference to an ostream on which to write and a character to use as the separator:

void biggies(vector<string> &words, vector<string>::size_type sz, ostream &os = cout, char c = ' ')
{
    // code to reorder words as before
    // statement to print count revised to print to os
    for_each(words.begin(), words.end(),
    [&os, c](const string &s) { os << s << c; });
}

We cannot copy ostream objects; the only way to capture os is by reference (or through a pointer to os).

We can also return a lambda from a function. The function might directly return a callable object or the function might return an object of a class that has a callable object as a data member. If the function returns a lambda, then‚Äîfor the same reasons that a function must not return a reference to a local variable‚Äîthat lambda must not contain reference captures.

Advice: Keep Your Lambda Captures Simple

A lambda capture stores information between the time the lambda is created (i.e., when the code that defines the lambda is executed) and the time (or times) the lambda itself is executed. It is the programmer‚Äôs responsibility to ensure that whatever information is captured has the intended meaning each time the lambda is executed.

Capturing an ordinary variable‚Äîan int, a string, or other nonpointer type‚Äîby value is usually straightforward. In this case, we only need to care whether the variable has the value we need when we capture it.

If we capture a pointer or iterator, or capture a variable by reference, we must ensure that the object bound to that iterator, pointer, or reference still exists, whenever the lambda executes. Moreover, we need to ensure that the object has the intended value. Code that executes between when the lambda
is created and when it executes might change the value of the object to which the lambda capture points (or refers). The value of the object at the time the pointer (or reference) was captured might have been what we wanted. The value of that object when the lambda executes might be quite different.

As a rule, we can avoid potential problems with captures by minimizing the data we capture. Moreover, if possible, avoid capturing pointers or references.

Implicit Captures

Rather than explicitly listing the variables we want to use from the enclosing function, we can let the compiler infer which variables we use from the code in the lambda‚Äôs body. To direct the compiler to infer the capture list, we use an & or = in the capture list. The & tells the compiler to capture by reference, and the = says the values are captured by value. For example, we can rewrite the lambda that we passed to find_if as

// sz implicitly captured by value
wc = find_if(words.begin(), words.end(), [=](const string &s)
{ return s.size() >= sz; });

If we want to capture some variables by value and others by reference, we can mix implicit and explicit captures:

void biggies(vector<string> &words, vector<string>::size_type sz,
ostream &os = cout, char c = ' ')
{
    // other processing as before
    // os implicitly captured by reference; c explicitly captured by value
    for_each(words.begin(), words.end(), [&, c](const string &s) { os << s << c; });
    
    // os explicitly captured by reference; c implicitly captured by value
    for_each(words.begin(), words.end(), [=, &os](const string &s) { os << s << c; });
}

When we mix implicit and explicit captures, the first item in the capture list must be an & or =. That symbol sets the default capture mode as by reference or by value, respectively.

When we mix implicit and explicit captures, the explicitly captured variables must use the alternate form. That is, if the implicit capture is by reference (using &), then the explicitly named variables must be captured by value; hence their names may not be preceded by an &. Alternatively, if the implicit capture is by value (using =), then the explicitly named variables must be preceded by an & to indicate that they are to be captured by reference.

Mutable Lambdas

By default, a lambda may not change the value of a variable that it copies by value. If we want to be able to change the value of a captured variable, we must follow the parameter list with the keyword mutable. Lambdas that are mutable may not omit the parameter list:

void fcn3()
{
    size_t v1 = 42; // local variable
    // f can change the value of the variables it captures
    auto f = [v1] () mutable { return ++v1; };
    v1 = 0;
    auto j = f(); // j is 43
}

Whether a variable captured by reference can be changed (as usual) depends only on whether that reference refers to a const or nonconst type:

void fcn4()
{
    size_t v1 = 42; // local variable
    // v1 is a reference to a non const variable
    // we can change that variable through the reference inside f2
    auto f2 = [&v1] { return ++v1; };
    v1 = 0;
    auto j = f2(); // j is 1
}

Specifying the Lambda Return Type

The lambdas we‚Äôve written so far contain only a single return statement. As a result, we haven‚Äôt had to specify the return type. By default, if a lambda body contains any statements other than a return, that lambda is assumed to return void. Like other
functions that return void, lambdas inferred to return void may not return a value.

As a simple example, we might use the library transform algorithm and a lambda to replace each negative value in a sequence with its absolute value:

transform(vi.begin(), vi.end(), vi.begin(), [](int i) { return i < 0 ? -i : i; });

The transform function takes three iterators and a callable. The first two iterators denote an input sequence and the third is a destination. The algorithm calls the given callable on each element in the input sequence and writes the result to the destination. 

We need not specify the return type, because that type can be inferred from the type of the conditional operator.

However, if we write the seemingly equivalent program using an if statement, our code won‚Äôt compile:

// error: cannot deduce the return type for the lambda
transform(vi.begin(), vi.end(), vi.begin(), [](int i) 
{ if (i < 0) return -i; else return i;});

This version of our lambda infers the return type as void but we returned a value. When we need to define a return type for a lambda, we must use a trailing return type:

transform(vi.begin(), vi.end(), vi.begin(), [](int i) -> int { if (i < 0) return -i; else return i; });

In this case, the fourth argument to transform is a lambda with an empty capture list, which takes a single parameter of type int and returns a value of type int. Its function body is an if statement that returns the absolute value of its parameter.

--
Binding Arguments

Lambda expressions are most useful for simple operations that we do not need to use in more than one or two places. If we need to do the same operation in many places, we should usually define a function rather than writing the same lambda expression multiple times. Similarly, if an operation requires many statements, it is ordinarily better to use a function.

It is usually straightforward to use a function in place of a lambda that has an empty capture list.

However, it is not so easy to write a function to replace a lambda that captures local variables. For example, the lambda that we used in the call to find_if compared a string with a given size. We can easily write a function to do the same work:

// tao: remember check_size has two parameters, sz is no longer a variable in the enclosing function. It will be used later.
bool check_size(const string &s, string::size_type sz)
{
    return s.size() >= sz;
}

However, we can‚Äôt use this function as an argument to find_if. As we‚Äôve seen, find_if takes a unary predicate, so the callable passed to find_if must take a single argument. The lambda that biggies passed to find_if used its capture list to store sz. In order to use check_size in place of that lambda, we have to figure out how to pass an argument to the sz parameter.

The Library bind Function

We can solve the problem of passing a size argument to check_size by using a new library function named bind, which is defined in the functional header. The bind function can be thought of as a general-purpose function adaptor. It takes a callable object and generates a new callable that ‚Äúadapts‚Äù the parameter list of the original object.

The general form of a call to bind is:

auto newCallable = bind(callable, arg_list);

tao copied the example below here:
auto g = bind(f, a, b, _2, c, _1);
The calling g(X, Y)  is equivalent to
call ing f(a, b, Y, c, X)

where newCallable is itself a callable object and arg_list is a comma-separated list of arguments that correspond to the parameters of the given callable. That is, when we call newCallable, newCallable calls callable, passing the arguments in arg_list.

The arguments in arg_list may include names of the form _n, where n is an integer. These arguments are ‚Äúplaceholders‚Äù representing the parameters of newCallable(tao: note it is newCallable). They stand ‚Äúin place of‚Äù the arguments that will be passed to newCallable. The number n is the position of the parameter in the generated callable: _1 is the first parameter in newCallable(tao: note it is newCallable), _2 is the second, and so forth.

Binding the sz Parameter of check_size

As a simple example, we‚Äôll use bind to generate an object that calls check_size with a fixed value for its size parameter as follows:

// check6 is a callable object that takes one argument of type string
// and calls check_size on its given string and the value 6
// tao: example: check6("hello") calls check_size("hello", 6)
auto check6 = bind(check_size, _1, 6);

This call to bind has only one placeholder, which means that check6 takes a single argument. The placeholder appears first in arg_list, which means that the parameter in check6 corresponds to the first parameter of check_size. That parameter is a const string&, which means that the parameter in check6 is also a const
string&. Thus, a call to check6 must pass an argument of type string, which check6 will pass as the first argument to check_size.

The second argument in arg_list (i.e., the third argument to bind) is the value 6. That value is bound to the second parameter of check_size. Whenever we call check6, it will pass 6 as the second argument to check_size:

string s = "hello";
bool b1 = check6(s); // check6(s) calls check_size(s, 6)

Using bind, we can replace our original lambda-based call to find_if

auto wc = find_if(words.begin(), words.end(), [sz](const string &a)

with a version that uses check_size:

auto wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz));

This call to bind generates a callable object that binds the second argument of check_size to the value of sz. When find_if calls this object on the strings in words those calls will in turn call check_size passing the given string and sz. So, find_if (effectively) will call check_size on each string in the input range and compare the size of that string to sz.

Using placeholders Names

The _n names are defined in a namespace named placeholders. That namespace is itself defined inside the std namespace. To use these names, we must supply the names of both namespaces. As with our other examples, our calls to bind assume the existence of appropriate using declarations. For example, the using declaration for _1 is

using std::placeholders::_1;

This declaration says we‚Äôre using the name _1, which is defined in the namespace placeholders, which is itself defined in the namespace std.

We must provide a separate using declaration for each placeholder name that we use. Writing such declarations can be tedious and error-prone. Rather than separately declaring each placeholder, we can use a different form of using that we will cover in more detail later. This form:

using namespace namespace_name;

says that we want to make all the names from namespace_name accessible to our program. For example:

using namespace std::placeholders;

makes all the names defined by placeholders usable. Like the bind function, the placeholders namespace is defined in the functional header.

Arguments to bind

As we‚Äôve seen, we can use bind to fix the value of a parameter. More generally, we can use bind to bind or rearrange the parameters in the given callable. For example, assuming f is a callable object that has five parameters, the following call to bind:

// g is a callable object that takes two arguments
auto g = bind(f, a, b, _2, c, _1);

generates a new callable that takes two arguments, represented by the placeholders _2 and _1. The new callable will pass its own arguments as the third and fifth arguments to f. The first, second, and fourth arguments to f are bound to the given values, a, b, and c, respectively.

The arguments to g are bound positionally to the placeholders. That is, the first argument to g is bound to _1, and the second argument is bound to _2. Thus, when we call g, the first argument to g will be passed as the last argument to f; the second argument to g will be passed as g‚Äôs third argument. In effect, this call to bind maps
g(_1, _2)
to
f(a, b, _2, c, _1)

That is, calling g calls f using g‚Äôs arguments for the  placeholders along with the bound arguments, a, b, and c. For example, calling g(X, Y) calls
f(a, b, Y, c, X)

Using to bind to Reorder Parameters

As a more concrete example of using bind to reorder arguments, we can use bind to invert the meaning of isShorter by writing

// sort on word length, shortest to longest
sort(words.begin(), words.end(), isShorter);
// sort on word length, longest to shortest
sort(words.begin(), words.end(), bind(isShorter, _2, _1));

By default, the arguments to bind that are not placeholders are copied into the callable object that bind returns. However, as with lambdas, sometimes we have arguments that we want to bind but that we want to pass by reference or we might want to bind an argument that has a type that we cannot copy.

For example, to replace the lambda that captured an ostream by reference:

// os is a local variable referring to an output stream
// c is a local variable of type char
for_each(words.begin(), words.end(), [&os, c](const string &s) { os << s << c; });

We can easily write a function to do the same job:

ostream &print(ostream &os, const string &s, char c)
{
    return os << s << c;
}

However, we can‚Äôt use bind directly to replace the capture of os:

// error: cannot copy os
for_each(words.begin(), words.end(), bind(print, os, _1, ''));

because bind copies its arguments and we cannot copy an ostream. If we want to pass an object to bind without copying it, we must use the library ref function:

for_each(words.begin(), words.end(), bind(print, ref(os), _1, ' '));

The ref function returns an object that contains the given reference and that is itself copyable. There is also a cref function that generates a class that holds a reference to const. Like bind, the ref and cref functions are defined in the functional header.

Backward Compatibility: Binding Arguments

Older versions of C++ provided a much more limited, yet more complicated, set of facilities to bind arguments to functions. The library defined two functions named bind1st and bind2nd. Like bind, these functions take a function and generate a new callable object that calls the given function with one of its parameters bound to a given value. However, these functions can
bind only the first or second parameter, respectively. Because they are of much more limited utility, they have been deprecated in the new standard. A deprecated feature is one that may not be supported in future releases. Modern C++ programs should use bind.

==
(finditerator)
iterator

Although we can use subscripts to access the characters of a string or the elements in a vector, there is a more general mechanism‚Äîknown as iterators‚Äîthat we can use for the same purpose. 

In addition to vector, the library defines several other kinds of containers. All of the library containers have iterators, but only a few of them support the subscript operator.

Like pointers, iterators give us indirect access to an object. In the case of an iterator, that object is an element in a container or a character in a string.

Types that have iterators have members that return iterators. In particular, these types have members named begin and end. The begin member returns an iterator that denotes the first element (or first character).

auto b = v.begin(), e = v.end(); //Note that auto is C++11

   v.begin()                        v.end()
      |                                |
    |---|---|---|---|---|---|---|---|
  |                               |
v.rend()                    v.rbegin()

The iterator returned by end is an iterator positioned ‚Äúone past the end‚Äù of the associated container (or string). This iterator denotes a nonexistent element ‚Äúoff the end‚Äù of the container. It is used as a marker indicating when we have processed all the elements. The iterator returned by end is often referred to as the off-the-end iterator or abbreviated as ‚Äúthe end iterator.‚Äù If the container is empty, begin returns the same iterator as the one returned by end.

Iterators support only a few operations, which are listed below (tao: these operations are very similar to pointers):

(In the folllowng, an example of iter is: auto iter = v.begin())
*iter //Returns a reference to the element denoted by the iterator iter.

iter->mem //Dereferences iter and fetches the memeber named mem from the underlying element. Equivalent to (*iter).mem

++iter //Increments iter to refer to the next element in the container.

--iter //Decrements iter to refer to the previous element in the container.

iter1 == iter2 //Two iterators are equal if they denote the same element or if they are the off-the-end iterator for the same container.

iter1 != iter2

iter + n // Adding (substracting) an integral value n to (from) an iterator yields an iterator that many elements forward (backward) within the container.

iter - n
iter += n
iter -= n

iter1 - iter2 //Returns the distance between the iterators. The result type is a signed integral type named difference_type. Both vector and string define difference_type. This type is signed, because subtraction might have a negative result.

iter1 <= iter2 //One iterator is less than another if it refers to an element that appears in the container before the one referred to by the other iterator.

Example: capitalize the first character of a string:

string s("some string");
if (s.begin() != s.end()) { // make sure s is not empty
    auto it = s.begin(); // it denotes the first character in s
    *it = toupper(*it); // make that character uppercase, tao: note the characters in a string can be changed in C++
}

Example: capitalize the first word in a string:

for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
    *it = toupper(*it); // capitalize the current character

Programmers coming to C++ from C or Java might be surprised that we used != rather than < in our for loops. C++ programmers use != as a matter of habit. They do so for the same reason that they use iterators rather than subscripts: This coding style applies equally well to various kinds of containers provided by the library. As we‚Äôve seen, only a few library types, vector and string being among them, have the subscript operator. Similarly, all of the library containers have iterators that define the == and != operators. Most of those iterators do not have the < operator. By routinely using iterators and !=, we don‚Äôt have to worry about the precise type of container we‚Äôre processing.

As with size_type, the library types that have iterators define types named iterator and const_iterator that represent actual iterator types:

vector<int>::iterator it; // it can read and write vector<int> elements
string::iterator it2; // it2 can read and write characters in a string
vector<int>::const_iterator it3; // it3 can read but not write elements
string::const_iterator it4; // it4 can read but not write characters

A const_iterator behaves like a const pointer. Like a const pointer, a const_iterator may read but not write the element it denotes; an object of type iterator can both read and write. If a vector or string is const, we may use only its const_iterator type. With a nonconst vector or string, we can use either iterator or const_iterator.

The type returned by begin and end depends on whether the object on which they operator is const. If the object is const, then begin and end return a const_iterator; if the object is not const, they return iterator:

vector<int> v;
const vector<int> cv;
auto it1 = v.begin(); // it1 has type vector<int>::iterator
auto it2 = cv.begin(); // it2 has type vector<int>::const_iterator

It is important to realize that loops that use iterators should not add elements to the container to which the iterators refer.

If begin equals end, the range is empty.

while (begin != end) {
	*begin = val; // ok: range isn't empty so begin denotes an element
	++begin; // advance the iterator to get the next element
}

--
Reverse iterators:

In addition to the iterator types we‚Äôve already used, most containers provide reverse iterators. Briefly, a reverse iterator is an iterator that goes backward through a container and inverts the meaning of the iterator operations. For example, saying ++ on a reverse iterator yields the previous element.

There are several versions of begin and end: The versions with an r return reverse iterators. Those that start with a c return the const version of the related iterator:

list<string> a = {"Milton", "Shakespeare", "Austen"};
auto it1 = a.begin(); // list<string>::iterator
auto it2 = a.rbegin(); // list<string>::reverse_iterator
auto it3 = a.cbegin(); // list<string>::const_iterator
auto it4 = a.crbegin();// list<string>::const_reverse_iterator

When write access is not needed, use cbegin and cend.

--
Revisiting Iterators

In addition to the iterators that are defined for each of the containers, the library defines several additional kinds of iterators in the iterator header. These iterators include

‚Ä¢ Insert iterators: These iterators are bound to a container and can be used to insert elements into the container.

‚Ä¢ Stream iterators: These iterators are bound to input or output streams and can be used to iterate through the associated IO stream.

‚Ä¢ Reverse iterators: These iterators move backward, rather than forward. The library containers, other than forward_list, have reverse iterators.

‚Ä¢ Move iterators: These special-purpose iterators move rather than copy their elements. We‚Äôll cover move iterators later.

Insert Iterators

An inserter is an iterator adaptor that takes a container and yields an iterator that adds elements to the specified container. When we assign a value through an insert iterator, the iterator calls a container operation to add an element at
a specified position in the given container. The operations these iterators support are listed in Table below:

Insert Iterator Operations

it = t: Inserts the value t at the current position denoted by it. Depending on the kind of insert iterator, and assuming c is the container to which it is bound, calls c.push_back(t), c.push_front(t), or c.insert(t, p), where p is the iterator position given to inserter.

*it, ++it, it++: These operations exist but do nothing to it. Each operator returns it.

There are three kinds of inserters. Each differs from the others as to where elements are inserted:

‚Ä¢ back_inserter creates an iterator that uses push_back.
‚Ä¢ front_inserter creates an iterator that uses push_front.
‚Ä¢ inserter creates an iterator that uses insert. This function takes a second argument, which must be an iterator into the given container. Elements are inserted ahead of the element denoted by the given iterator.

Note: We can use front_inserter only if the container has push_front. Similarly, we can use back_inserter only if it has push_back.

It is important to understand that when we call inserter(c, iter), we get an iterator that, when used successively (tao: not successfully), inserts elements ahead of the element originally denoted by iter. (Tao: c is container). That is, if it is an iterator generated by inserter, then an assignment such as

* it = va1;

behaves as

it = c.insert(it, val); // (tao: it is not inserter). it points to the newly added element
++it; // increment it so that it denotes the same element as before

The iterator generated by front_inserter behaves quite differently from the one created by inserter. When we use front_inserter, elements are always inserted ahead of the then first element in the container. Even if the position we pass to inserter initially denotes the first element, as soon as we insert an element in front of that element, that element is no longer the one at the beginning of the container:

list<int> 1st = {1,2,3,4};
list<int> lst2, lst3; // empty lists

// after copy completes, 1st2 contains 4 3 2 1
copy(1st.cbegin(), 1st.cend(), front_inserter(lst2));

// after copy completes, 1st3 contains 1 2 3 4
copy(1st.cbegin(), 1st.cend(), inserter(lst3, lst3.begin()));

When we call front_inserter(c), we get an insert iterator that successively calls push_front. As each element is inserted, it becomes the new first element in c. Therefore, front_inserter yields an iterator that reverses the order of the sequence that it inserts; inserter and back_inserter don‚Äôt.

--
iostream Iterators

Even though the iostream types are not containers, there are iterators that can be used with objects of the IO types. An istream_iterator reads an input stream, and an ostream_iterator
writes an output stream. These iterators treat their corresponding stream as a sequence of elements of a specified type. Using a stream iterator, we can use the generic algorithms to read data from or write data to stream objects.

istream_iterator Operations:

istream_iterator<T> in(is): in reads values of type T from input stram is.

istream_iterator<T> end: Off-the-end iterator for an istream_iterator that reads values of type T.

in1 == in2, in1 != in2: in1 and in2 must read the same type. They are equal if they are both the end value or are bound to the same input stream.

*in: Returns the value read from the stream.

in->mem: Synoym for (*in).mem

++in, in++: Reads the next value from the input stream using the >> operator for the element type. As usual, the prefix version returns a reference to the incremented iterator. The postfix version returns the old value.

ostream Iterator Operations:

ostream_iterator<T> out(os): out writes values of type T to output stream os.

ostream_iterator<T> out(os, d): out writes values of type T followed by d to output stream os. d points to a null-terminated character array.

out = val: Wrties val to the ostream to which out is bound using the << operator. val must have a type that is compatibel with the type that out can write.

*out, ++out, out++: These operations exist but do nothing to out. Each operator returns out.

Operations on istream_iterators

When we create a stream iterator, we must specify the type of objects that the iterator will read or write. An istream_iterator uses >> to read a stream.

Therefore, the type that an istream_iterator reads must have an input operator defined. When we create an istream_iterator, we can bind it to a stream.

Alternatively, we can default initialize the iterator, which creates an iterator that we can use as the off-the-end value.

istream_iterator<int> int_it(cin); // reads ints from cin
istream_iterator<int> int_eof; // end iterator value. It was defined as the empty istream_iterator, which is used as the end iterator.
ifstream in("afile");
istream_iterator<string> str_it(in); // reads strings from "afile"

As an example, we can use an istream_iterator to read the standard input into a vector:

istream_iterator<int> in_iter(cin); // read ints from cin
istream_iterator<int> eof;

while (in_iter != eof) // while there's valid input to read
    // postfix increment reads the stream and returns the old value of the iterator
    // we dereference that iterator to get the previous value read from the stream
    vec.push_back(*in_iter++);

This loop reads ints from cin, storing what was read in vec. On each iteration, the loop checks whether in_iter is the same as eof. That iterator was defined as the empty istream_iterator, which is used as the end iterator. An iterator bound to a stream is equal to the end iterator once its associated stream hits end-of-file or encounters an IO error.

Using Stream Iterators with the Algorithms

Because algorithms operate in terms of iterator operations, and the stream iterators support at least some iterator operations, we can use stream iterators with at least some of the algorithms.
We‚Äôll see later how to tell which algorithms can be used with the stream iterators. As one example, we can call accumulate with
a pair of istream_iterators:

istream_iterator<int> in(cin), eof;
cout << accumulate(in, eof, 0) << endl;

This call will generate the sum of values read from the standard input.

Operations on ostream_iterators

An ostream_iterator can be defined for any type that has an output operator (the << operator). When we create an ostream_iterator, we may (optionally) provide a second argument that specifies a character string to print following each element. That string must be a C-style character string (i.e., a string literal or a pointer to a null-terminated array). We must bind an ostream_iterator to a specific stream. There is no empty or off-the-end ostream_iterator.

We can use an ostream_iterator to write a sequence of values:

ostream_iterator<int> out_iter(cout, " ");
for (auto e : vec)
    *out_iter++ = e; // the assignment writes this element to cout
cout << endl;

This program writes each element from vec onto cout following each element with a space. Each time we assign a value to out_iter, the write is committed.

It is worth noting that we can omit the dereference and the increment when we assign to out_iter. That is, we can write this loop equivalently as

for (auto e : vec)
    out_iter = e; // the assignment writes this element to cout
cout << endl;

The * and ++ operators do nothing on an ostream_iterator, so omitting them has no effect on our program. However, we prefer to write the loop as first presented. That loop uses the iterator consistently with how we use other iterator types. We can easily change this loop to execute on another iterator type. Moreover, the behavior of this loop will be clearer to readers of our code.

Rather than writing the loop ourselves, we can more easily print the elements in vec by calling copy:

copy(vec.begin(), vec.end(), out_iter);
cout << endl;

Using Stream Iterators with Class Types

We can create an istream_iterator for any type that has an input operator (>>). Similarly, we can define an ostream_iterator so long as the type has an output operator (<<). 

--
(findreverseiterator)
Reverse Iterators

A reverse iterator is an iterator that traverses a container backward, from the last element toward the first. A reverse iterator inverts the meaning of increment (and decrement). Incrementing (++it) a reverse iterator moves the iterator to the previous element; derementing (--it) moves the iterator to the next element.

The containers, aside from forward_list, all have reverse iterators. We obtain a reverse iterator by calling the rbegin, rend, crbegin, and crend members. These members return reverse iterators to the last element in the container and one ‚Äúpast‚Äù
(i.e., one before) the beginning of the container. As with ordinary iterators, there are both const and nonconst reverse iterators.

Figure below illustrates the relationship between these four iterators on a hypothetical vector named vec.

  v.cbegin()                        v.cend()
      |                                |
    |---|---|---|---|---|---|---|---|
  |                               |
v.crend()                    v.crbegin()

As an example, the following loop prints the elements of vec in reverse order:

vector<int> vec = {0,1,2,3,4,5,6,7,8,9};

// reverse iterator of vector from back to front
for (auto r_iter = vec.crbegin(); r_iter != vec.crend(); ++r_iter) 
    cout << *r_iter << endl; // prints 9, 8, 7,... 0

Although it may seem confusing to have the meaning of the increment and decrement operators reversed, doing so lets us use the algorithms transparently to process a container forward or backward. For example, we can sort our vector in descending order by passing sort a pair of reverse iterators:

sort(vec.begin(), vec.end()); // sorts vec in ''normal'' order
// sorts in reverse: puts the smallest element at the end of vec
sort(vec.rbegin(), vec.rend());

Reverse Iterators Require Decrement Operators

(Tao: the following explains why we need reverse iterators)
Not surprisingly, we can define a reverse iterator only from an iterator that supports -- as well as ++. After all, the purpose of a reverse iterator is to move the iterator backward through the sequence. Aside from forward_list, the iterators on the standard containers all support decrement as well as increment. However, the stream iterators do not, because it is not possible to move backward through a stream. Therefore, it is not possible to create a reverse iterator from a forward_list or a stream iterator.

Relationship between Reverse Iterators and Other Iterators

Suppose we have a string named line that contains a comma-separated list of words, and we want to print the first word in line. Using find, this task is easy:

// find the first element in a comma-separated list
auto comma = find(line.cbegin(), line.cend(), ',');
cout << string(line.cbegin(), comma) << endl;

If we wanted the last word, we can use reverse iterators instead:

// find the last element in a comma-separated list
auto rcomma = find(line.crbegin(), line.crend(), ',');

The interesting part comes when we try to print the word we found. The seemingly obvious way

// WRONG: will generate the word in reverse order
cout << string(line.crbegin(), rcomma) << endl;

generates bogus output. For example, had our input been

FIRST,MIDDLE,LAST 

then this statement would print TSAL!

==
(findarray)
array

int a[10]; // array of 10 ints. The elements are default initialized.
int a[3] = {0,1,2};
int a[] = {0,1,2};
unsigned scores[11] = {}; // 11 buckets, all value initialized to 0
int *p = a;

int arr[3][4];
int arr[2][3] = {{1,2},{3,4},{5,6}};

Fill in an array with the same values:
int arr[5];
std::fill_n(arr, 5, 2); //Now arr = {2, 2, 2, 2, 2}

As in the case of string or vector, it is best to use a range for when we want to traverse the entire array.

for (auto i : scores)
    cout << i << " ";  

--
tao: practice shows that the type of the array size can be int, but it should be const:
const int aSize = 3;
char a[aSize] = {'A', 'B', 'C'};

The number of elements in an array is part of the array‚Äôs type. As a result, the dimension must be known at compile time, which means that the dimension must be a constant expression. 

Because arrays have fixed size, they sometimes offer better run-time performance for specialized applications. However, that run-time advantage comes at the cost of lost flexibility.

Tao: in C++, there is no function to find array size (different from Java). So if need to use size, should not use array in the beginning, use vector instead. <- Confirmed later from online (including recommending using vector). If you must use the size of an array, you can do it as below:

int num_files = sizeof(file_names) / sizeof(file_names[0]);

Character arrays have an additional form of initialization: We can initialize such arrays from a string literal. When we use this form of initialization, it is important to remember that string literals end with a null character. That null character is copied into the array along with the characters in the literal:

char a1[] = {'C', '+', '+'}; // size = 3. 
char a2[] = {'C', '+', '+', '\0'}; // size = 4
char a3[] = "C++"; // size = 4, null terminator added automatically

--
When we use a variable to subscript an array, we normally should define that variable to have type size_t. size_t is a machine-specific unsigned type that is guaranteed to be large enough to hold the size of any object in memory. The size_t type is defined in the cstddef header.


--
Although we can compute an off-the-end pointer, doing so is error-prone. To make it easier and safer to use pointers, the new library includes two functions, named begin and end.

int *beg = begin(ia); // pointer to the first element in ia
int *last = end(ia);  // pointer one past the last element in ia

These functions are defined in the iterator header.

A pointer ‚Äúone past‚Äù the end of a built-in array behaves the same way as the iterator returned by the end operation of a vector.

As with iterators, subtracting two pointers gives us the distance between those pointers. 

The result of subtracting two pointers is a library type named ptrdiff_t. Like size_t,the ptrdiff_t type is a machine-specific type and is defined in the cstddef header. Because subtraction might yield a negative distance, ptrdiff_t is a signed integral type.

We can use the subscript operator on any pointer, as long as that pointer points to an element (or one past the last element) in an array:

int *p = &ia[2];  // p points to the element indexed by 2
int j = p[1];     // p[1] is equivalent to *(p + 1),
                  // p[1] is the same element as ia[3]
int k = p[-2];    // p[-2] is the same element as ia[0]

--
string *p = &nums[0];   // p points to the first element in nums

When we use an array, the compiler automatically substitutes a pointer to the first element:

string *p2 = nums;      // equivalent to p2 = &nums[0]

when we use an array as an
initializer for a variable defined using auto (¬ß 2.5.2, p. 68), the deduced type is a
pointer, not an array:

int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia is an array of ten ints
auto ia2(ia); // ia2 is an int* that points to the first element in ia

It is worth noting that this conversion does not happen when we use decltype. The type returned by decltype(ia) is array of ten ints:

decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9}; //Tao: decltype(ia) returns a type name
ia3[4] = i; // ok: assigns the value of i to an element in ia3

Pointers to array elements support the same operations as iterators on vectors or strings. For example, we can use the increment operator to move from one element in an array to the next:
  
int arr[] = {0,1,2,3,4,5,6,7,8,9};
int *p = arr; // p points to the first element in arr
++p;          // p points to arr[1]

--
Using an Array to Initialize a vector
 
We noted that we cannot initialize a built-in array from another array. Nor can we initialize an array from a vector. However, we can use an array to initialize a vector. To do so, we specify the address of the first element and one past the last element that we wish to copy:

int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));

The specified range can be a subset of the array:
vector<int> subVec(int_arr + 1, int_arr + 4);

--
Modern C++ programs should use vectors and iterators instead of built-in arrays and pointers, and use strings rather than C-style array-based character strings.

--
Multidimensional Arrays

Strictly speaking, there are no multidimensional arrays in C++. What are commonly referred to as multidimensional arrays are actually arrays of arrays.

int ia[3][4]; // array of size 3; each element is an array of ints of size 4

int arr[10][20][30] = {0}; // initialize all elements to 0

In a two-dimensional array, the first dimension is usually referred to as the row and the second as the column.

Multidimensional arrays may be initialized by specifying bracketed values for each row:

int ia[3][4] = {    
    {0, 1, 2, 3},   
    {4, 5, 6, 7},   
    {8, 9, 10, 11}  
};

The nested braces are optional. The following initialization is equivalent, although considerably less clear:

int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};

Under the new standard we can simplify the previous loop by using a range for:

size_t cnt = 0;

for (auto &row : ia)        
    for (auto &col : row) { 
        col = cnt;          
        ++cnt;            
    }

In the previous example, we used references as our loop control variables because we wanted to change the elements in the array. However, there is a deeper reason for using references.

Had we neglected the reference and written these loops as:
 
for (auto row : ia)
    for (auto col : row)
 
our program would not compile. As before, the first for iterates through ia, whose elements are arrays of size 4. As a result, in this loop the type of row is int*. The inner for loop is illegal, it attempts to iterate over an int*

As with any array, when we use the name of a multidimensional array, it is automatically converted to a pointer to the first element in the array (tao: note this is not an actual element, but an inner array):

int ia[3][4]
int (*p)[4] = ia; // p points to an array of four ints

The result of *p is an array of four ints. As usual, when we use an array, it is converted automatically to a pointer to its first element.

--
Return array from function

Tao: practice shows that we should do the following even returning an element from a local array:

bool *res = new bool[5]; //Correct way
// bool res[5]; <- wrong way, returned res[2] value will be random
return res[2];

From geeksforgeeks:

How to return a local array from a C/C++ function?

Consider the below C++ program. Is it right way of returning array from a function?

brightness_4
#include<iostream> 
using namespace std; 
  
int *fun() 
{ 
   int arr[100]; 
  
   /* Some operations on arr[] */
   arr[0] = 10; 
   arr[1] = 20; 
     
   return arr; 
} 
  
int main() 
{ 
    int *ptr = fun(); 
    cout << ptr[0] << " " << ptr[1]; 
    return 0; 
} 

In function 'int* fun()':
6:8: warning: address of local variable 'arr' returned [-Wreturn-local-addr]
    int arr[100];
        ^
The above program is WRONG. It may produce values 10 20 as output or may produce garbage values or may crash. The problem is, we return address of a local variable which is not advised as local variables may not exist in memory after function call is over.

Following are some correct ways of returning array:

Using Dynamically Allocated Array :

Dynamically allocated memory (allocated using new or malloc()) remains their until we delete it using delete or free(). So we can create a dynamically allocated array and we can delete it once we come out of function.

#include<iostream> 
using namespace std; 
  
int *fun() 
{ 
   int *arr = new int[100]; 
  
   /* Some operations on arr[] */
   arr[0] = 10; 
   arr[1] = 20; 
     
   return arr; 
} 
  
int main() 
{ 
    int *ptr = fun(); 
    cout << ptr[0] << " " << ptr[1]; 
    return 0; 
} 

Output :

10 20

Using static array:

Lifetime of a static variable is throughout the program. So we can always create a local static array and return it.

#include<iostream> 
using namespace std; 
  
int *fun() 
{ 
   static int arr[100]; 
  
   /* Some operations on arr[] */
   arr[0] = 10; 
   arr[1] = 20; 
     
   return arr; 
} 
  
int main() 
{ 
    int *ptr = fun(); 
    cout << ptr[0] << " " << ptr[1]; 
    return 0; 
} 

Output :

10 20

Using struct:

We can wrap array in a structure/class and return an instance of the struct/class. The reason for this work is, array members of structures are deeply copied. In below program deep copy happens when we returned instance is copied in main.

#include<iostream> 
using namespace std; 
  
struct arrWrap 
{ 
   int arr[100]; 
}; 
  
struct arrWrap fun() 
{ 
   struct arrWrap x; 
  
   x.arr[0] = 10; 
   x.arr[1] = 20; 
     
   return x; 
} 
  
int main() 
{ 
   struct arrWrap x = fun(); 
   cout << x.arr[0] << " " << x.arr[1]; 
   return 0; 
} 

Output :

10 20

==
(findoperator)
(findand)
Operators

Logical operators:
AND: &&
OR:  ||
NOT: !

--
Bitwise operators:
AND: &
OR:  |
XOR: ^ (a^b is equivalent to a != b)
NOT: ~ (eg: ~expr) 
Left shift: << (eg: expr1 << expr2)
Right shift: >> (eg: expr1 >> expr2)

The left-shift operator (the << operator) inserts 0-valued bits on the right. The behavior of the right-shift operator (the >> operator) depends on the type of the left-hand operand: If that operand is unsigned, then the operator inserts 0-valued bits on the left; if it is a signed type, the result is implementation defined‚Äîeither copies of the sign bit or 0-valued bits are inserted on the left.

The bitwise NOT operator (the ~ operator) generates a new value with the bits of its operand inverted. Each 1 bit is set to 0; each 0 bit is set to 1.

Because there are no guarantees for how the sign bit is handled, we strongly recommend using unsigned types with the bitwise operators.

Overloaded versions of these operators for IO: 
cout << "Helo" << endl;

--
Remainder (modulus) operator: %

--
Compound assignments:
+=   -=   *=   /=   %=   (arithmetic operators)
<<=  >>=   &=   ^=   |=  (bitwise operators)

--
Order of Evaluation

Rember: ->|

--
C++ uses = for assignment and == for equality. Both operators can appear
inside a condition. It is a common mistake to write = when you mean ==
inside a condition.

--
Lvalues and Rvalues

Every expression in C++ is either an rvalue or an lvalue. lvalues could stand on the left-hand side of an assignment whereas rvalues could not. In C++, the distinction is less simple. Roughly speaking, when we use an object as an rvalue, we use the object‚Äôs value (its contents). When we use an object as an lvalue, we use
the object‚Äôs identity (its location in memory).

--
In assignment, if the types of the left and right operands differ, the right-hand operand is converted to the type of the left.

--
(findincrement)
(finddecrement)
(find++)
(find--)
The increment (++) and decrement (--) operators

int i = 0;
++i; // i = 1. Prefix returns new value 1 (remeber: ee)
i++; // i = 1. Postfix returns old value 0 (remember: oo)

Readers from a C background might be surprised that we use the prefix increment in the programs we‚Äôve written. The reason is simple: The prefix version avoids unnecessary work. It increments the value and returns the incremented version. The postfix operator must store the original value so that it can return the unincremented value as its result. If we don‚Äôt need the
unincremented value, there‚Äôs no need for the extra work done by the postfix operator.

--
p->size() is equivalent to (*p).size()

--
(findsizeof)
sizeof

The sizeof operator returns the size, in bytes, of an expression or a type name. The result of sizeof is a constant expression of type size_t. The operator takes one of two forms:
 
sizeof (type)
sizeof expr
 
In the second form, sizeof returns the size of the type returned by the given expression. The sizeof operator is unusual in that it does not evaluate its operand:

sizeof an array is the size of the entire array. It is equivalent to taking the sizeof the element type times the number of elements in the array. Note that sizeof does not convert the array to a pointer.

sizeof a string or a vector returns only the size of the fixed part of these types; it does not return the size used by the object‚Äôs elements. Tao's understanding: think of how vector and string is implememted using array and doubles its size when reached maximum, sizeof only takes the fixed part and may not return the correct size of a vector or string.

Example:

constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr2[sz];  // ok sizeof returns a constant expression 

Because sizeof returns a constant expression, we can use the result of a sizeof expression to specify the dimension of an array.

==
(commaoperator)
Comma operator

The comma operator takes two operands, which it evaluates from left to right. Like
the logical AND and logical OR and the conditional operator, the comma operator
guarantees the order in which its operands are evaluated.

The left-hand expression is evaluated and its result is discarded. The result of a
comma expression is the value of its right-hand expression.

Example:

for(vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
ivec[ix] = cnt;

This loop increments ix and decrements cnt in the expression in the for header. Both ix and cnt are changed on each trip through the loop.

==
The simplest statement is the empty statement, also known as a null statement. A null statement is a single semicolon:
; // null statement

A null statement is useful where the language requires a statement but the program‚Äôs logic does not. Such usage is most common when a loop‚Äôs work can be done within its condition.

while (cin >> s && s != sought)
	; // null statement

Null statements should be commented. That way anyone reading the code can see that the statement was omitted intentionally.

An empty block is equivalent to a null statement:

while (cin >> s && s != sought)
	{ } // empty block

==
(findif)
if 

int a;

if (grade < 60)
	a = 1;
else
	a = 2;


if (grade == 2) {
	a = 5;
} else if (grade == 9) {
	a = 8;
}

It is a common mistake to forget the curly braces when multiple statements must be executed as a block. To avoid such problems, some coding styles recommend always using braces after an if or an else (and also around the bodies of while and for statements).
Doing so avoids any possible confusion. It also means that the braces are already in place if later modifications of the code require adding statements.

==
(findswitch)
switch

A switch statement provides a convenient way of selecting among a (possibly large) number of fixed alternatives.

unsigned aCnt = 0, eCnt = 0, otherCunt = 0;

char ch;

switch (ch) {
	case 'a':
		++aCnt;
		break;
	case 'e':
		++eCnt;
		break;
 	default:
 		++otherCunt;
 		break;
}

In this case, the break transfers control out of the switch. Forgetting a break Is a Common Source of Bugs.

The case keyword and its associated value together are known as the case label. case labels must be integral constant expressions.

char ch = getVal();
int ival = 42;
switch(ch) {
	case 3.14: // error: noninteger as case label
	case ival: // error: nonconstant as case label
// . . .

It can be useful to define a default label even if there is no work for the default case. Defining an empty default section indicates to subsequent readers that the case was considered. If a switch ends with a default case that has no work to do, then the default label must be followed by a null statement or an empty block.

==
(findwhile)
while

while(a > 3) {
	cout << a << endl;
}

A condition is an expression that yields a result that is either true or false.

A block is a sequence of zero or more statements enclosed by curly braces.

--
do while

A do while statement is like a while but the condition is tested after the statement body completes. Regardless of the value of the condition, we execute the loop at least once.

A do while ends with a semicolon after the parenthesized condition.

Variables used in condition must be defined outside the body of the do while statement.

// repeatedly ask the user for a pair of numbers to sum
string rsp;  // used in the condition; can't be defined inside the do

do {
    cout << "please enter two values: ";
    int val1 = 0, val2 = 0;
    cin  >> val1 >> val2;
    cout << "The sum of " << val1 << " and " << val2
         << " = " << val1 + val2 << "\n\n"
         << "More? Enter yes or no: ";
    cin  >> rsp;
} while (!rsp.empty() && rsp[0] != 'n');

==
(findfor)
for

for(int i = 0; i < 5; ++i) {
	cout << i << endl;
}

The variable i exists only inside the for; it is not possible to use i after this loop terminates.


for (decltype(v.size()) i = 0, sz = v.size(); i != sz; ++i)
    v.push_back(v[i]);

--
Range for (in C++11):

If we want to write to the elements in the sequence, the
loop variable must be a reference type.

vector<int> v = {0,1,2,3,4,5,6,7,8,9};

// range variable must be a reference so we can write to the elements
for (auto &r : v)   // for each element in v
    r *= 2; // double the value of each element in v

we cannot use a range for to add elements to a vector (or
other container). 

==
(findbreak)
break

A break statement terminates the nearest enclosing while, do while, for, or switch statement. Execution resumes at the statement immediately following the terminated statement.

for (auto it = buf.begin()+1; it != buf.end(); ++it) {
	  if (*it == ' ')
	       break; // leaves the for loop
}

==
(findcontinue)
continue

A continue statement terminates the current iteration of the nearest enclosing loop and immediately begins the next iteration. A continue can appear only inside a for, while, or do while loop. 

In the case of a while or a do while, execution continues by evaluating the condition. In a traditional for loop, execution continues at the expression inside the for header.

==
(findgoto)
goto

A goto statement provides an unconditional jump from the goto to a another statement in the same function. Programs should not use gotos. gotos make programs hard to understand and hard to modify.


goto label;
 
where label is an identifier that identifies a statement. A labeled statement is any statement that is preceded by an identifier followed by a colon:

end: return;  // labeled statement; may be the target of a goto

Label identifiers are independent of names used for variables and other identifiers.

==
(findexception)
Exception

Exceptions are run-time anomalies‚Äîsuch as losing a database connection or encountering unexpected input‚Äîthat exist outside the normal functioning of a program. Dealing with anomalous behavior can be one of the most difficult parts of designing any system.

Exception handling is generally used when one part of a program detects a problem that it cannot resolve and the problem is such that the detecting part of the program cannot continue. In such cases, the detecting part needs a way to signal that something happened and that it cannot continue. Moreover, the detecting part needs a way to signal the problem without knowing what part of the program will deal with the exceptional condition. Having signaled what happened, the detecting part stops processing.
 
A program that contains code that might raise an exception (usually) has another part to handle whatever happened. For example, if the problem is invalid input, the handling part might ask the user to provide correct input. If the database was lost, the handling part might alert an operator.
 
Exception handling supports this cooperation between the detecting and handling parts of a program. In C++, exception handling involves
 
- throw expressions, which the detecting part uses to indicate that it encountered something it can‚Äôt handle. We say that a throw raises an exception.
 
- try blocks, which the handling part uses to deal with an exception. A try block starts with the keyword try and ends with one or more catch clauses.Exceptions thrown from code executed inside a try block are usually handled by one of the catch clauses. Because they ‚Äúhandle‚Äù the exception, catch clauses are also known as exception handlers.

- A set of exception classes that are used to pass information about what happened between a throw and an associated catch.

--
A throw Expression:

// first check that the data are for the same item
if (item1.isbn() != item2.isbn())
    throw runtime_error("Data must refer to same ISBN");
// if we're still here, the ISBNs are the same
cout << item1 + item2 << endl;
 
In this code, if the ISBN s differ, we throw an expression that is an object of type runtime_error. Throwing an exception terminates the current function and transfers control to a handler that will know how to handle this error.

The type runtime_error is one of the standard library exception types and is defined in the stdexcept header. We must initialize a runtime_error by giving it a string or a C-style character string. That string provides additional information about the problem.

--
The try Block:

The general form of a try block is
 
try {
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
} // . . .

When a catch is selected to handle an exception, the associated block is executed. Once the catch finishes, execution continues with the statement immediately following the last catch clause of the try block.

The program-statements inside the try constitute the normal logic of the program. Like any other blocks, they can contain any C++ statement, including declarations. As with any block, variables declared inside a try block are inaccessible outside the block ‚Äî in particular, they are not accessible to the catch clauses.

--
Writing a Handler:\
while (cin >> item1 >> item2) {
    try {
        // execute code that will add the two Sales_items
        // if the addition fails, the code throws a runtime_error exception
    } catch (runtime_error err) {
        // remind the user that the ISBNs must match and prompt for another pair
        cout << err.what()
             << "\nTry Again?  Enter y or n" << endl;
        char c;
        cin >> c;
        if (!cin || c == 'n')
            break;      // break out of the while loop
    }
}

The prompt to the user prints the return from err.what(). We know that err has type runtime_error. Each of the library exception classes defines a member function named what. These functions take no arguments and return a C-style character string (i.e., a const char*). The what member of runtime_error
returns a copy of the string used to initialize the particular object.

If no appropriate catch is found, execution is transferred to a library function named terminate. The behavior of that function is system dependent but is guaranteed to stop further execution of the program.

--
Standard Exceptions:

The C++ library defines several classes that it uses to report problems encountered in the functions in the standard library. These classes are defined in four headers:
 
- The "exception" header defines the most general kind of exception class named "exception". It communicates only that an exception occurred but provides no additional information.

- The "stdexcept" header defines several general-purpose exception classes, which are listed below.

- The "new" header dfines the "bad_alloc" exception type.

- The "type_info" header defines the "bad_cast" exception type. 

Standard exception classes defined in <stdexcetp>:

exception: The most general kind of problem

runtime_error: Problem that can be deteced only at run time.

range_error: Run-time error: result generatd outside the range of values that are meaningful.

overflow_error: Run-time error: computation that overflowed.

underflow_error: Run-time error: computation that underflowed.

logic_error: Error in the logic of the program.

domain_error: Logic error: argument for which no result exists.

invalid_argument: Logic error: inappropriate argument.

length_error: Logic error: attempt to create an object larger than the maximum size for that type.

out_of_range: logic error: used a value outside the valid range.

We can only default initialize exception, bad_alloc, and bad_cast objects; it is not possible to provide an initializer for objects of these exception types.
 
The other exception types have the opposite behavior: We can initialize those objects from either a string or a C-style string, but we cannot default initialize them. When we create objects of any of these other exception types, we must supply an
initializer. That initializer is used to provide additional information about the error that occurred.
 
The exception types define only a single operation named what. That function takes no arguments and returns a const char* that points to a C-style character string. The purpose of this C-style character string is to provide some sort of textual description of the exception thrown.

==
(findfunction)
function

Example:

int fact(int val) {
  int ret = 1; 
  while (val > 1)
    ret *= val--; 
  return ret;
}

The statements after the return statement will not be executed (tao's practice).

--
void function example (from Leetcode OJ):

    void deleteNode(ListNode* node) {
      ...    
    }

--
For compatibility with C, we also can use the keyword void to indicate that there are no parameters:

int f1(){ /* ... */ } // implicit void parameter list

int f2(void){ /* ... */ } // explicit void parameter list

--
The return type can be void, which means that the function does not return a value.

The return type may not be an array type or a function type. However, a function may return a pointer to an array or a function. 

--
(findparameter1)

Examples of function input parameters from Leetcode:

Summary of parameter type

string: string
vector: reference to vector
object: pointer or reference to object

** string **

bool isAnagram(string s, string t) {
    
}

int myAtoi(string str) {
    
}

int strStr(string haystack, string needle) {
    
}

** vector **

int firstMissingPositive(vector<int>& nums) {
    
}

vector<vector<string>> groupAnagrams(vector<string>& strs) {
    
}

void rotate(vector<vector<int>>& matrix) {
    
}

** object ** 

vector<int> inorderTraversal(TreeNode* root) {
    
}

UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
    
}

struct Interval {
    int start;
    int end;
    Interval() : start(0), end(0) {}
    Interval(int s, int e) : start(s), end(e) {}
};

vector<Interval> merge(vector<Interval>& intervals) {
    
}

--
Argument Passing

If the parameter is a reference, then the parameter is bound to its argument. Otherwise, the argument‚Äôs value is copied.

When a parameter is a reference, we say that its corresponding argument is ‚Äúpassed by reference‚Äù or that the function is ‚Äúcalled by reference.‚Äù The parameter is an alias for its corresponding argument.
 
When the argument value is copied, the parameter and argument are independent objects. We say such arguments are ‚Äúpassed by value‚Äù or alternatively that the function is ‚Äúcalled by value.‚Äù

-- 
Passing Arguments by Value

Nothing the function does to the parameter can affect the argument.

Pointer Parameters
 
Pointers behave like any other nonreference type. When we copy a
pointer, the value of the pointer is copied. After the copy, the two pointers are distinct. However, a pointer also gives us indirect access to the object to which that pointer points.

(Avadoles) Programmers accustomed to programming in C often use pointer parameters to access objects outside a function. In C++, programmers generally use reference parameters instead.

--
Passing Arguments by Reference

void reset(int &i)  // i is just another name for the object passed to reset
{
    i = 0;  // changes the value of the object to which i refers
}

int j = 42;
reset(j);  // j is passed by reference; the value in j is changed
cout << "j = " << j  << endl;  // prints j = 0

Using References to Avoid Copies
 
It can be inefficient to copy objects of large class types or large containers. Moreover, some class types (including the IO types) cannot be copied. Functions must use reference parameters to operate on objects of a type that cannot be copied.

(findconstparameter)
As an example, we‚Äôll write a function to compare the length of two strings. Because strings can be long, we‚Äôd like to avoid copying them, so we‚Äôll make our parameters references. Because comparing two strings does not involve changing the strings, we‚Äôll make the parameters references to const. Reference parameters that are not changed inside a function should be references to const.

// compare the length of two strings
bool isShorter(const string &s1, const string &s2) {
    return s1.size() < s2.size();
}

Tao did not see any functions returning a const. If I see it, record it here.

Use Reference to const When Possible

It is a somewhat common mistake to define parameters that a function does not change as (plain) references. Doing so gives the function‚Äôs caller the misleading impression that the function might change its argument‚Äôs value.

Using Reference Parameters to Return Additional Information
 
A function can return only a single value. However, sometimes a function has more than one value to return. Reference parameters let us effectively return multiple results.

// returns the index of the first occurrence of c in s
// the reference parameter occurs counts how often c occurs
string::size_type find_char(const string &s, char c, string::size_type &occurs) {
    auto ret = s.size();   // position of the first occurrence, if any
    occurs = 0;            // set the occurrence count parameter
    for (decltype(ret) i = 0; i != s.size(); ++i) {
        if (s[i] == c) {
            if (ret == s.size())
                ret = i;   // remember the first occurrence of c
            ++occurs;      // increment the occurrence count
         }
    }
    return ret;            // count is returned implicitly in occurs
}

auto index = find_char(s, 'o', ctr);
 
After the call, the value of ctr will be the number of times o occurs.

--
Array Parameters

Arrays have two special properties that affect how we define and use functions that operate on arrays: We cannot copy an array, and when we use an array it is (usually) converted to a pointer. Because we cannot copy an array, we cannot pass an array by value. Because arrays are converted to pointers, when we pass an array to a function, we are actually passing a pointer to the array‚Äôs first element.

Even though we cannot pass an array by value, we can write a parameter that looks like an array:

// despite appearances, these three declarations of print are equivalent:

// each function has a single parameter of type const int*
void print(const int*);
void print(const int[]);   // shows the intent that the function takes an array
void print(const int[10]); // dimension for documentation purposes (at best)

int j[2] = {0, 1};
print(j);  // ok: j is converted to an int* that points to j[0]

Because arrays are passed as pointers, functions ordinarily don‚Äôt know the size of the array they are given. They must rely on additional information provided by the caller. There are three common techniques used to manage pointer parameters.

Using a Marker to Specify the Extent of an Array

The first approach to managing array arguments requires the array itself to contain an end marker. C-style character strings are an example of this approach. C-style strings are stored in character arrays in which the last character of the string is followed by a null character. Functions that deal with C-style strings stop processing the array when they see a null character.

Using the Standard Library Conventions
 
A second technique used to manage array arguments is to pass pointers to the first and one past the last element in the array.

Using this approach, we‚Äôll print the elements in an array as follows:

void print(const int *beg, const int *end) {
    // print every element starting at beg up to but not including end
    while (beg != end)
        cout << *beg++ << endl; // print the current element and advance the pointer
}

To call this function, we pass two pointers:

int j[2] = {0, 1};

print(begin(j), end(j));

Explicitly Passing a Size Parameter

A third approach for array arguments, which is common in C programs and older C++ programs, is to define a second parameter that indicates the size of the array.

// const int ia[] is equivalent to const int* ia
// size is passed explicitly and used to control access to elements of ia

void print(const int ia[], size_t size) {
    for (size_t i = 0; i != size; ++i) {
        cout << ia[i] << endl;
    }
}

int j[] = { 0, 1 };  // int array of size 2
print(j, end(j) - begin(j));

--
Array Parameters and const
 
Note that all three versions of our print function defined their array parameters as pointers to const. The discussion in ¬ß 6.2.3 applies equally to pointers as to references. When a function does not need write access to the array elements, the array parameter should be a pointer to const. A parameter should be
a plain pointer to a nonconst type only if the function needs to change element values.

--
Array Reference Parameters
 
Just as we can define a variable that is a reference to an array, we can define a parameter that is a reference to an array.

void print(int (&arr)[10]) {
    for (auto elem : arr)
        cout << elem << endl;
}

Because the size of an array is part of its type, it is safe to rely on the dimension in the body of the function. However, the fact that the size is part of the type limits the usefulness of this version of print. We may call this function only for an array of exactly ten ints:

j[2] = {0, 1};
int k[10] = {0,1,2,3,4,5,6,7,8,9};

print(j);    // error: argument is not an array of ten ints
print(k);    // ok: argument is an array of ten ints

--
Passing a Multidimensional Array

As with any array, a multidimensional array is passed as a pointer to its first element. Because we are dealing with an array of arrays, that element is an array, so the pointer is a pointer to an array. The size of the second (and any subsequent) dimension is part of the element type and must be specified:

// matrix points to the first element in an array whose elements are arrays of ten ints
void print(int (*matrix)[10], int rowSize) { /* . . . */ }

declares matrix as a pointer to an array of ten ints.

We can also define our function using array syntax. As usual, the compiler ignores the first dimension, so it is best not to include it:

// equivalent definition
void print(int matrix[][10], int rowSize) { /* . . . */ }

--
Returning a Pointer to an Array

Because we cannot copy an array, a function cannot return an array. However, a function can return a pointer or a reference to an array Unfortunately, the syntax used to define functions that return pointers or references to arrays can be intimidating. Fortunately, there are ways to simplify such declarations. The most straightforward way is to use a type alias

typedef int arrT[10];  // arrT is a synonym for the type array of ten ints

using arrtT = int[10]; // equivalent declaration of arrT; 

arrT* func(int i);     // func returns a pointer to an array of five ints

Declaring a Function That Returns a Pointer to an Array
 
To declare func without using a type alias, we must remember that the dimension of an array follows the name being defined:
  
int arr[10];          // arr is an array of ten ints
int *p1[10];          // p1 is an array of ten pointers
int (*p2)[10] = &arr; // p2 points to an array of ten ints
 
As with these declarations, if we want to define a function that returns a pointer to an array, the dimension must follow the function‚Äôs name. However, a function includes a parameter list, which also follows the name. The parameter list precedes the
dimension. Hence, the form of a function that returns a pointer to an array is:

Type (*function(parameter_list))[dimension]

As a concrete example, the following declares func without using a type alias:

int (*func(int i))[10];

Using a Trailing Return Type (C++11)

Under the new standard, another way to simplify the declaration of func is by using a trailing return type.

A trailing return type follows the parameter list and is preceded by ->. To signal that the return follows the parameter list, we use auto where the return type ordinarily appears:

// fcn takes an int argument and returns a pointer to an array of ten ints
auto func(int i) -> int(*)[10];

Using decltype

As another alternative, if we know the array(s) to which our function can return a pointer, we can use decltype to declare the return type.

int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
// returns a pointer to an array of five int elements
decltype(odd) *arrPtr(int i)
{
    return (i % 2) ? &odd : &even; // returns a pointer to the array
}

--
Functions with Varying Parameters

Sometimes we do not know in advance how many arguments we need to pass to a function.

The new standard provides two primary ways to write a function that takes a varying number of arguments: If all the arguments have the same type, we can pass a library type named initializer_list. If the argument types vary, we can write a special kind of function, known as a variadic template.

C++ also has a special parameter type, ellipsis, that can be used to pass a varying number of arguments.

--
initializer_list Parameters (C++11)

We can write a function that takes an unknown number of arguments of a single type by using an initializer_list parameter. An initializer_list is a library type that represents an array of values of the specified type. This type is defined in the initializer_list header. The operations that initializer_list provides are listed below:

initializer_list<T> lst: Default initialization, an empty list of element sof type T.

initializer_list<T> lst(a, b, c...): lst has as many elements as there are initializers, elements are copies of the corresponding initializers. Elements in the list are const.

lst2(lst), lst2 = lst: Copying or assigning an initializer_list does not copy the elements in the list. After the copy, the original and the copy share the elements.

lst.size(): Number of elements in the list.

lst.begin(), lst.end(): Returns a pointer to the first and one past the last elments in the lst.

Example:

initializer_list<int> li;    // initializer_list of ints

Unlike vector, the elements in an initializer_list are always const values; there is no way to change the value of an element in an initializer_list.

void error_msg(initializer_list<string> il) {
    for (auto beg = il.begin(); beg != il.end(); ++beg)
        cout << *beg << " " ;
    cout << endl;
}

When we pass a sequence of values to an initializer_list parameter, we must enclose the sequence in curly braces:

error_msg({"functionX", "okay"});

A function with an initializer_list parameter can have other parameters as well.

void error_msg(ErrCode e, initializer_list<string> il)

error_msg(ErrCode(0), {"functionX", "okay"});

--
Ellipsis Parameters

Ellipsis parameters are in C++ to allow programs to interface to C code that uses a C library facility named varargs. Generally an ellipsis parameter should not be used for other purposes.

Ellipsis parameters should be used only for types that are common to both C and C++. In particular, objects of most class types are not copied properly when passed to an ellipsis parameter.

An ellipsis parameter may appear only as the last element in a parameter list and may take either of two forms:
 
void foo(parm_list, ...);
void foo(...);

==
(findreturn1)
Return:

--
(findreturnvector)
Return a vector from function (from online):

In leetcode, the default code follows this pattern:
Input parameter is a reference to vector, output is a vector:

vector<vector<int>> permute(vector<int>& nums) { 
    vector<vector<int>> res;
    ...
    return res; //Practice shows it is OK to return a vector defined inside a function (unlike pointer).
}

vector<Interval> merge(vector<Interval>& intervals) {
    ...
    return intervals; //Practice shows it is OK to return the input reference.
}

Question:

Efficient way to return a std::vector in c++

How much data is copied, when returning a std::vector in a function and how big an optimization will it be to place the std::vector in free-store (on the heap) and return a pointer instead i.e. is:

std::vector *f()
{
  std::vector *result = new std::vector();
  /*
    Insert elements into result
  */
  return result;
} 
more efficient than:

std::vector f()
{
  std::vector result;
  /*
    Insert elements into result
  */
  return result;
} 

Answer:

In C++11, this is the preferred way:

std::vector<X> f();

That is, return by value.

With C++11, std::vector has move-semantics, which means the local vector declared in your function will be moved on return and in some cases even the move can be elided by the compiler.

Question:

Why is it OK to return vector from function?

Please consider this code. I have seen this type of code several times. words is a local vector. How is it possible to return it from a function? Can we guarantee it will not die?

 std::vector<std::string> read_file(const std::string& path)
 {
    std::ifstream file("E:\\names.txt");

    if (!file.is_open())
    {
        std::cerr << "Unable to open file" << "\n";
        std::exit(-1);
    }

    std::vector<string> words;//this vector will be returned 
    std::string token;

    while (std::getline(file, token, ','))
    {
        words.push_back(token);
    }

    return words;
}

Pre C++11:
The function will not return the local variable but rather a copy of it. Your compiler might however perform an optimization where no actual copy action is made.

See this question & answer for further details

C++11:
The function will move the value, see this answer for further details

Question:

What is std::move(), and when should it be used?

What is it?
What does it do?
When should it be used?
Good links are appreciated.

Answer:

Wikipedia Page on C++11 R-value references and move constructors

1. In C++11, in addition to copy constructors, objects can have move constructors.
(And in addition to copy assignment operators, they have move assignment operators.)

2. The move constructor is used instead of the copy constructor, if the object has type "rvalue-reference" (Type &&).

3. std::move() is a cast that produces an rvalue-reference to an object, to enable moving from it. It's a new C++ way to avoid copies. For example, using a move constructor, a std::vector could just copy its internal pointer to data to the new object, leaving the moved object in an incorrect state, avoiding to copy all data. This would be C++-valid.

Try googling for move semantics, rvalue, perfect forwarding.

--
(findreturnpointer)
Return pointer from a function (from tutorialspoint):

Tao's summary from below:
1. It is not good idea to return the address of a local variable to outside of the function, so you would have to define the local variable as static variable.
2. Can return a pointer created by the "new" operator. Extracted from "find new": Dynamically allocated objects have a lifetime that is independent of where they are created; they exist until they are explicitly freed. Functions that return pointers (rather than smart pointers) to dynamic memory put burden on their callers‚Äîthe caller must remember to delete the memory. We returned pointer created by "new" in leetcode, like pr_133 (leetcode discussion also did this).

As we have seen in last chapter how C++ allows to return an array from a function, similar way C++ allows you to return a pointer from a function. To do so, you would have to declare a function returning a pointer as in the following example ‚àí

int * myFunction() {
   .
   .
   .
}

Second point to remember is that, it is not good idea to return the address of a local variable to outside of the function, so you would have to define the local variable as static variable. Tao: if return the address of a local variable, the caller function would get a pointer containing wrong address value (from practice).

Now, consider the following function, which will generate 10 random numbers and return them using an array name which represents a pointer i.e., address of first array element.

 Live Demo
#include <iostream>
#include <ctime>
 
using namespace std;
 
// function to generate and retrun random numbers.
int * getRandom( ) {
   static int  r[10];
 
   // set the seed
   srand( (unsigned)time( NULL ) );
   
   for (int i = 0; i < 10; ++i) {
      r[i] = rand();
      cout << r[i] << endl;
   }
 
   return r;
}
 
// main function to call above defined function.
int main () {
   // a pointer to an int.
   int *p;
 
   p = getRandom();
   for ( int i = 0; i < 10; i++ ) {
      cout << "*(p + " << i << ") : ";
      cout << *(p + i) << endl;
   }
 
   return 0;
}
When the above code is compiled together and executed, it produces result something as follows ‚àí

624723190
1468735695
807113585
976495677
613357504
1377296355
1530315259
1778906708
1820354158
667126415
*(p + 0) : 624723190
*(p + 1) : 1468735695
*(p + 2) : 807113585
*(p + 3) : 976495677
*(p + 4) : 613357504
*(p + 5) : 1377296355
*(p + 6) : 1530315259
*(p + 7) : 1778906708
*(p + 8) : 1820354158
*(p + 9) : 667126415

--
(findreturnreference)
Return reference from a function (from tutorialspoint):

Tao's summary from below
1. Using (not limited to returning) reference is recommended rather than using pointer.
2. It is not legal to return a reference to local var. But you can always return a reference on a static variable.

A C++ program can be made easier to read and maintain by using references rather than pointers. A C++ function can return a reference in a similar way as it returns a pointer.

When a function returns a reference, it returns an implicit pointer to its return value. This way, a function can be used on the left side of an assignment statement. For example, consider this simple program ‚àí

#include <iostream>
#include <ctime>
 
using namespace std;
 
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double& setValues( int i ) {
   return vals[i];   // return a reference to the ith element
}
 
// main function to call above defined function.
int main () {
 
   cout << "Value before change" << endl;
   for ( int i = 0; i < 5; i++ ) {
      cout << "vals[" << i << "] = ";
      cout << vals[i] << endl;
   }
 
   setValues(1) = 20.23; // change 2nd element
   setValues(3) = 70.8;  // change 4th element
 
   cout << "Value after change" << endl;
   for ( int i = 0; i < 5; i++ ) {
      cout << "vals[" << i << "] = ";
      cout << vals[i] << endl;
   }
   return 0;
}
When the above code is compiled together and executed, it produces the following result ‚àí

Value before change
vals[0] = 10.1
vals[1] = 12.6
vals[2] = 33.1
vals[3] = 24.1
vals[4] = 50
Value after change
vals[0] = 10.1
vals[1] = 20.23
vals[2] = 33.1
vals[3] = 70.8
vals[4] = 50

When returning a reference, be careful that the object being referred to does not go out of scope. So it is not legal to return a reference to local var. But you can always return a reference on a static variable.

int& func() {
   int q;
   //! return q; // Compile time error
   static int x;
   return x;     // Safe, x lives outside this scope
}

--
A return statement terminates the function that is currently executing and returns control to the point from which the function was called. There are two forms of return statements:
 
return;
return expression;

Functions with No Return Value

A return with no value may be used only in a function that has a return type of void. Functions that return void are not required to contain a return. In a void function, an implicit return takes place after the function‚Äôs last statement.
  
Typically, void functions use a return to exit the function at an intermediate point. This use of return is analogous to the use of a break statement to exit a loop.

Functions That Return a Value

Every return in a function with a return type other than void must return a value.

Never Return a Reference or Pointer to a Local Object

When a function completes, its storage is freed. After a function terminates, references to local objects refer to memory that is no longer valid:

// disaster: this function returns a reference to a local object
const string &manip() {
    string ret;
   // transform ret in some way
   if (!ret.empty())
       return ret;     // WRONG: returning a reference to a local object!
   else
       return "Empty"; // WRONG: "Empty" is a local temporary string
}

If a function returns a pointer, reference or object of class type, we can use the result of a call to call a member of the resulting object:

auto sz = shorterString(s1, s2).size();

Reference Returns Are Lvalues. we can assign to the result of a function that returns a reference to nonconst:

char &get_val(string &str, string::size_type ix) {
    return str[ix]; // get_val assumes the given index is valid
}

get_val(s, 0) = 'A'; // changes s[0] to A

It may be surprising to see a function call on the left-hand side of an assignment. However, nothing special is involved.

--
List Initializing the Return Value (C++11)

Under the new standard, functions can return a braced list of values.

vector<string> process() {
    // . . .
    return {"functionX", expected, actual};
}

--
Return from main

There is one exception to the rule that a function with a return type other than void must return a value: The main function is allowed to terminate without a return. If control reaches the end of main and there is no return, then the compiler implicitly
inserts a return of 0.

The value returned from main is treated as a status indicator. A zero return indicates success; most other values indicate failure. A nonzero value has a machine-dependent meaning. To make return values machine independent, the cstdlib header defines two preprocessor variables that we can use to indicate success or failure:

int main() {
    if (some_failure)
        return EXIT_FAILURE;  // defined in cstdlib
    else
        return EXIT_SUCCESS;  // defined in cstdlib
}
 
Because these are preprocessor variables, we must not precede them with std::, nor may we mention them in using declarations.

--
Recursion

A function that calls itself, either directly or indirectly, is a recursive function.

// calculate val!, which is 1 * 2 * 3 . . . * val
int factorial(int val) {
    if (val > 1)
        return factorial(val-1) * val;
    return 1;
}

There must always be a path through a recursive function that does not involve a recursive call; otherwise, the function will recurse ‚Äúforever‚Äù.

The main function may not call itself.

--
(findstatic)
Local static objects
Static variables

It can be useful to have a local variable whose lifetime continues across calls to the function. We obtain such objects by defining a local variable as static. Each local static object is initialized before the first time execution passes through the object‚Äôs definition. Local statics are not destroyed when a function ends; they are destroyed when the program terminates.

As a trivial example, here is a function that counts how many times it is called. This program will print the numbers from 1 through 10 inclusive.
 
size_t count_calls() {
    static size_t ctr = 0;  // value will persist across calls
    return ++ctr;
}

int main() {
    for (size_t i = 0; i != 10; ++i)
        cout << count_calls() << endl;
    return 0;
}
 
If a local static has no explicit initializer, it is value initialized, meaning that local statics of built-in type are initialized to zero.

--
Function Declarations

Like any other name, the name of a function must be declared before we can use it. As with variables, a function may be defined only once but may be declared multiple times.

A function declaration is just like a function definition except that a declaration has no function body. In a declaration, a semicolon replaces the function body.
 
Because a function declaration has no body, there is no need for parameter names. Hence, parameter names are often omitted in a declaration. Although parameter names are not required, they can be used to help users of the function understand what the function does:
 
void print(vector<int>::const_iterator beg, vector<int>::const_iterator end);

Function declarations are also known as the function prototype.

Function Declarations Go in Header Files
 
Recall that variables are declared in header files and defined in source files. For the same reasons, functions should be declared in header files and defined in source files.

It may be tempting‚Äîand would be legal‚Äîto put a function declaration directly in each source file that uses the function. However, doing so is tedious and error-prone. When we use header files for our function declarations, we can ensure that all the
declarations for a given function agree. The source file that defines a function should include the header that contains that function‚Äôs declaration.

--
(findoverload)
Overloaded Functions

Functions that have the same name but different parameter lists and that appear in the same scope are overloaded.

Examples:

void print(const char *cp);
void print(const int *beg, const int *end);
void print(const int ia[], size_t size);

When we call these functions, the compiler can deduce which function we want based on the argument type we pass:

print("Hello World");        // calls print(const char*)
print(j, end(j) - begin(j)); // calls print(const int*, size_t)
print(begin(j), end(j));     // calls print(const int*, const int*)

Function overloading eliminates the need to invent‚Äîand remember‚Äînames that exist only to help the compiler figure out which function to call.

The main function may not be overloaded.

Overloaded functions must differ in the number or the type(s) of their parameters.

It is an error for two functions to differ only in terms of their return types.
 
Two parameter lists can be identical, even if they don‚Äôt look the same.

Although overloading lets us avoid having to invent (and remember) names for common operations, we should only overload operations that actually do similar things. There are some cases where providing different function names adds information that makes the program easier to understand.

Function matching (also known as overload resolution) is the process by which a particular function call is associated with a
specific function from a set of overloaded functions.

Names do not overload across scopes.

--
Default Arguments

string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');
 
Here we‚Äôve provided a default for each parameter. A default argument is specified as an initializer for a parameter in the parameter list. We may define defaults for one or more parameters. However, if a parameter has a default argument, all the parameters that follow it must also have default arguments.

If we want to use the default argument, we omit that argument when we call the function.

window = screen();  // equivalent to screen(24,80,' ')

window = screen(66);// equivalent to screen(66,80,' ')
window = screen(66, 256);      // screen(66,256,' ')
window = screen(66, 256, '#'); // screen(66,256,'#')
 
Arguments in the call are resolved by position. 

The default arguments are used for the trailing (right-most) arguments of a call:

window = screen(, , '?'); // error: can omit only trailing arguments
window = screen('?');     // calls screen('?',80,' ')

Part of the work of designing a function with default arguments is ordering the parameters so that those least likely to use a default value appear first and those most likely to use a default appear last.

Default Argument Declarations
 
Although it is normal practice to declare a function once inside a header, it is legal to redeclare a function multiple times. However, each parameter can have its default specified only once in a given scope. Thus, any subsequent declaration can add a
default only for a parameter that has not previously had a default specified. As usual, defaults can be specified only if all parameters to the right already have defaults.

Local variables may not be used as a default argument.

--
(findinlinefunctions)
Inline Functions

We can define shorterString as an inline function by putting the keyword inline before the function‚Äôs return type:

// inline version: find the shorter of two strings
inline const string & shorterString(const string &s1, const string &s2) {
	return s1.size() <= s2.size() ? s1 : s2;
}

A function specified as inline (usually) is expanded ‚Äúin line‚Äù at each call. If shorterString were defined as inline, then this call

cout << shorterString(s1, s2) << endl;

(probably) would be expanded during compilation into something like

cout << (s1.size() < s2.size() ? s1 : s2) << endl;

The run-time overhead of making shorterString a function is thus removed.

The inline specification is only a request to the compiler. The compiler may choose to ignore this request.

In general, the inline mechanism is meant to optimize small, straight-line functions that are called frequently. Many compilers will not inline a recursive function. A 75-line function will almost surely not be expanded inline.

--
(findconstexprfunctions)
constexpr Functions

A constexpr function is a function that can be used in a constant expression. A constexpr function is defined like any other function but must meet certain restrictions: The return type and the type of each parameter in a must be a literal type, and the function body must contain exactly one return statement:

constexpr int new_sz() { return 42; }
constexpr int foo = new_sz(); // ok: foo is a constant expression

When it can do so, the compiler will replace a call to a constexpr function with its resulting value. In order to be able to expand the function immediately, constexpr functions are implicitly inline.

A constexpr function body may contain other statements so long as those
statements generate no actions at run time. For example, a constexpr function may contain null statements, type aliases (¬ß 2.5.1, p. 67), and using declarations.

A constexpr function is permitted to return a value that is not a constant:

// scale(arg) is a constant expression if arg is a constant expression
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }

Put inline and constexpr Functions in Header Files 

Unlike other functions, inline and constexpr functions may be defined multiple times in the program. After all, the compiler needs the definition, not just the declaration, in order to expand the code. However, all of the definitions of a given inline or constexpr must match exactly. As a result, inline and constexpr functions normally are defined in headers.

--
(findassert)
The assert Preprocessor Macro

C++ programmers sometimes use a technique similar to header guards to conditionally execute debugging code. The idea is that the program will contain debugging code that is executed only while the program is being developed. When the application is completed and ready to ship, the debugging code is turned off. This approach uses two preprocessor facilities: assert and NDEBUG.

The assert Preprocessor Macro assert is a preprocessor macro. A preprocessor macro is a preprocessor variable that acts somewhat like an inline function. The assert macro takes a single expression, which it uses as a condition:

assert(expr);

evaluates expr and if the expression is false (i.e., zero), then assert writes a message and terminates the program. If the expression is true (i.e., is nonzero), then assert does nothing.

The assert macro is defined in the cassert header. As we‚Äôve seen, preprocessor names are managed by the preprocessor not the compiler. As a result, we use preprocessor names directly and do not provide a using declaration for them. That is, we refer to assert, not std::assert, and provide no using declaration for assert. 

As with preprocessor variables, macro names must be unique within the program. Programs that include the cassert header may not define a variable, function, or other entity named assert. In practice, it is a good idea to avoid using the name assert for our own purposes even if we don‚Äôt include cassert. Many headers include the cassert header, which means that even if you don‚Äôt directly include that file, your programs are likely to have it included anyway.

The assert macro is often used to check for conditions that ‚Äúcannot happen.‚Äù For example, a program that does some manipulation of input text might know that all words it is given are always longer than a threshold. That program might contain a statement such as

assert(word.size() > threshold);

--
(findndebug)
The NDEBUG Preprocessor Variable

The behavior of assert depends on the status of a preprocessor variable named NDEBUG. If NDEBUG is defined, assert does nothing. By default, NDEBUG is not defined, so, by default, assert performs a run-time check.

We can ‚Äúturn off‚Äù debugging by providing a #define to define NDEBUG.
Alternatively, most compilers provide a command-line option that lets us define preprocessor variables:

g++ -D NDEBUG main.C 

has the same effect as writing #define NDEBUG at the beginning of main.C.

In addition to using assert, we can write our own conditional debugging code using NDEBUG. If NDEBUG is not defined, the code between the #ifndef and the #endif is executed. If NDEBUG is defined, that code is ignored:

void print(const int ia[], size_t size) {
	#ifndef NDEBUG

	// _ _func_ _ is a local static defined by the compiler that holds the function's name

	cerr << _ _func_ _ << ": array size is " << size << endl;

	#endif
	// ...
}

Here we use a variable named _ _func_ _ to print the name of the function we are debugging. The compiler defines _ _func_ _ in every function. It is a local static array of const char that holds the name of the function.

In addition to _ _func_ _, which the C++ compiler defines, the preprocessor defines four other names that can be useful in debugging:

_ _FILE_ _ string literal containing the name of the file
_ _LINE_ _ integer literal containing the current line number
_ _TIME_ _ string literal containing the time the file was compiled
_ _DATE_ _ string literal containing the date the file was compiled

We might use these constants to report additional information in error messages:

if (word.size() < threshold)
	cerr << "Error: " << _ _FILE_ _
		 << " : in function " << _ _func_ _
		 << " at line " << _ _LINE_ _ << endl
		 << " Compiled on " << _ _DATE_ _
		 << " at " << _ _TIME_ _ << endl
		 << " Word read was \"" << word
		 << "\": Length too short" << endl;

If we give this program a string that is shorter than the threshold, then the following error message will be generated:

Error: wdebug.cc : in function main at line 27
Compiled on Jul 11 2012 at 20:50:03
Word read was "foo": Length too short

==
(findstruct)
Struct

struct Sales_data {
    string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
}; //Tao: don't forget the ;

We‚Äôll assume that our Sales_data class is defined inside Sales_data.h.

#include <iostream>
#include <string>
#include "Sales_data.h"
int main()
{
	Sales_data data1, data2;
	Sales_data* salesptr;
	// code to read into data1 and data2
	// code to check whether data1 and data2 have the same ISBN
	// and if so print the sum of data1 and data2

	std::cin >> data1.bookNo >> data1.units_sold >> price;
}

Our new program includes the string header. We need that header because our code will have to manage the bookNo member, which has type string.

Under the new standard, we can supply an in-class initializer (tao: like the "double revenue = 0.0" above) for a data member. When we create objects, the in-class initializers will be used to initialize the data members. Members without an initializer are default initialized

Each object has its own copy of the class data members. Modifying the data members of one object does not change the data in any other Sales_data object.

To see the difference between struct and class, search for "find public", and look at the end of that part.

--
From Google C++ Style Guide:

Structs vs. Classes

Use a struct only for passive objects that carry data; everything else is a class.

structs should be used for passive objects that carry data, and may have associated constants, but lack any functionality other than access/setting the data members. The accessing/setting of fields is done by directly accessing the fields rather than through method invocations. Methods should not provide behavior but should only be used to set up the data members, e.g., constructor, destructor, Initialize(), Reset(), Validate().

If more functionality is required, a class is more appropriate. If in doubt, make it a class.

==
(findclass)
class

A class defines a type along with a collection of operations that are related to that type.

Perhaps the most important feature in C++ is the class, which lets programmers define their own types. In C++ such types are sometimes called ‚Äúclass types‚Äù to distinguish them from the types that are built into the language.

Every class defines a type. The type name is the same as the name of the class. Hence, our Sales_item class defines a type named Sales_item. As with the builtin types, we can define a variable of a class type. When we write

Sales_item item;

we are saying that item is an object of type Sales_item.

In general, the class author determines all the operations that can be used on objects of the class type.

#include <iostream>
#include "Sales_item.h"
int main()
{
    Sales_item item1, item2;
    std::cin >> item1 >> item2; // read a pair of transactions
    std::cout << item1 + item2 << std::endl; // print their sum
    return 0;
}

Instead of reading and printing the sum of two integers, we‚Äôre reading and printing the sum of two Sales_item objects. Moreover, the whole idea of ‚Äúsum‚Äù is different.

item1.isbn() == item2.isbn()
calls a member function named isbn. A member function is a function that is defined as part of a class. Member functions are sometimes referred to as methods.

The dot operator applies only to objects of class type. The left-hand operand must be an object of class type, and the right-hand operand must
name a member of that type. We call a function using the call operator (the () operator).

--
Classes ordinarily are not defined inside functions.

In order to ensure that the class definition is the same in each file, classes are usually defined in header files.

Tao: don't foreget the ; at the end of a class!

Tao: note public and private has no identitation. There is no identiation in this book, and in leetcode default code, in online examples, and sublime also removes these identitaction automatically.


class Sales_data {
public:
    Sales_data() = default; // default constructor
    Sales_data(string &s, double p) : bookNo(s), revenue(p) {}  

private:
    string bookNo;
    double revenue = 0.0;
    
    double price() {
        ...
    }
};

If our class does not explicitly define any constructors, the compiler will implicitly define the default constructor for us (know as the synthesized default constructor).

Sales_data item;
Screen myScreen(5, 3);
Screen myScreen = Screen(5, 3);//Added by Tao, works in practice.

Sales_data obj(); // oops! declares a function, not an object
Sales_data obj2; // ok: obj2 is an object, not a function

--
(findpublic)
(findprivate)

Access specifiers (public & private)

public:

Members defined after a public specifier are accessible to all parts of the program. The public members define the interface to the class.

private:

Members defined after a private specifier are accessible to the member functions of the class but are not accessible to code that uses the class. The private sections encapsulate (i.e., hide) the implementation.

Example:

class Sales_data {
public: // tao: this line has no identation (same in leetcode)
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
    Sales_data(const std::string &s): bookNo(s) { }
    Sales_data(std::istream&);
    std::string isbn() const { return bookNo; }
    Sales_data &combine(const Sales_data&);

private: // tao: this line has no identation (same in leetcode)
    double avg_price() const { 
        return units_sold ? revenue/units_sold : 0; 
    }
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

A class may contain zero or more access specifiers, and there are no restrictions on how often an access specifier may appear. Each access specifier specifies the access level of the succeeding members. The specified access level remains in effect until the next access specifier or the end of the class body.

We also made another, more subtle, change: We used the class keyword rather than struct to open the class definition. This change is strictly stylistic; we can define a class type using either keyword. The only difference between struct and class is
the default access level.

If we use the struct keyword, the members defined before the first access specifier are public; if we use class, then
the members are private.

As a matter of programming style, when we define a class intending for all of its members to be public, we use struct. If we intend to have private members, then we use class.

--
(findmemberfunction)
member function

We define and declare member functions similarly to ordinary functions. Member functions must be declared inside the class. Member
functions may be defined inside the class itself or outside the class body. Nonmember functions that are part of the interface, such as add, read, and print, are declared and defined outside the class.

struct Sales_data {
	// new members: operations on Sales_data objects
	std::string isbn() const { return bookNo; } //Tao: will explain const later
	Sales_data& combine(const Sales_data&);
	double avg_price() const;

	// data members:
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};

// nonmember Sales_data interface functions
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);

Note: Functions defined in the class are implicitly inline

Member functions access the object on which they were called through an extra, implicit parameter named this. When we call a member function, this is initialized with the address of the object on which the function was invoked. For example, when we call

total.isbn() //tao: total is an object of Sales_data

the compiler passes the address of total to the implicit this parameter in isbn. It is as if the compiler rewrites this call as

// pseudo-code illustration of how a call to a member function is translated
Sales_data::isbn(&total)

which calls the isbn member of Sales_data passing the address of total.

Inside a member function, we can refer directly to the members of the object on which the function was called. We do not have to use a member access operator to use the members of the object to which this points. Any direct use of a member of the class is assumed to be an implicit reference through this. That is, when isbn uses bookNo, it is implicitly using the member to which this points. It is as if we had written this->bookNo.

The this parameter is defined for us implicitly. Indeed, it is illegal for us to define a parameter or variable named this. Inside the body of a member function, we can use this. It would be legal, although unnecessary, to define isbn as

std::string isbn() const { return this->bookNo; }

Because this is intended to always refer to ‚Äúthis‚Äù object, this is a const pointer. We cannot change the address that this holds.

It is worth noting that isbn can use bookNo even though bookNo is defined after isbn. The compiler processes classes in two steps‚Äî
the member declarations are compiled first, after which the member function bodies, if any, are processed. Thus, member function bodies may use other members of their class regardless of where in the class those members appear.

Defining a Member Function outside the Class

As with any other function, when we define a member function outside the class body, the member‚Äôs definition must match its declaration. If the member was declared as a const member function (search for find constmemberfunction), then the definition must also specify const after the parameter list. The name of a member defined outside the class must include the name of the class of which it is a member:

double Sales_data::avg_price() const {
	if (units_sold)
		return revenue/units_sold;
	else
		return 0;
}

The function name, Sales_data::avg_price, uses the scope operator to say that we are defining the function named avg_price that is declared in the scope of the Sales_data class. Once the compiler sees the function name, the rest of the code is interpreted as being inside the scope of the class. Thus, when avg_price refers to revenue and units_sold, it is implicitly referring to the members of Sales_data.

As with nonmember functions, member functions may be overloaded so long as the functions differ by the number and/or types of parameters.

--
(findconstmemberfunction)
const member functions

Tao's summary:
1. const member function is like the following (note the const)
   string isbn() const { return bookNo; }
2. Purpose of const member function:
   non-const member function can not be called by a const object.
   const member function can be called by a const object.
   
Tao: this was the quesion asked by Teacher Ma's son.
Tao: copied all the content of this topic (const member functions) to the followings.

The other important part about the isbn function is the keyword const that follows the parameter list. The purpose of that const is to modify the type of the implicit this pointer.

By default, the type of this is a const pointer to the nonconst version of the class type. For example, by default, the type of this in a Sales_data member function is Sales_data *const. Although this is implicit, it follows the normal initialization rules, which means that (by default) we cannot bind this to a const object. This fact, in turn, means that we cannot call an ordinary member function on a const object.

If isbn were an ordinary function and if this were an ordinary pointer parameter, we would declare this as const Sales_data *const. After all, the body of isbn doesn‚Äôt change the object to which this points, so our function would be more flexible if this were a pointer to const.

However, this is implicit and does not appear in the parameter list. There is no place to indicate that this should be a pointer to const. The language resolves this problem by letting us put const after the parameter list of a member function. A const following the parameter list indicates that this is a pointer to const. Member functions that use const in this way are const member functions.

We can think of the body of isbn as if it were written as

// pseudo-code illustration of how the implicit this pointer is used
// this code is illegal: we may not explicitly define the this pointer ourselves
// note that this is a pointer to const because isbn is a const member
std::string Sales_data::isbn(const Sales_data *const this)
{ return this->isbn; }

The fact that this is a pointer to const means that const member functions cannot change the object on which they are called. Thus, isbn may read but not write to the data members of the objects on which it is called.

Note: Objects that are const, and references or pointers to const objects, may call only const member functions.

--
Defining a Function to Return ‚ÄúThis‚Äù Object

The combine function is intended to act like the compound assignment operator, +=. The object on which this function is called represents the left-hand operand of the assignment. The right-hand operand is passed as an explicit argument:

Sales_data& Sales_data::combine(const Sales_data &rhs) {
	units_sold += rhs.units_sold; // add the members of rhs into
	revenue += rhs.revenue; // the members of ''this'' object
	return *this; // return the object on which the function was called
}

When our transaction-processing program calls

total.combine(trans); // update the running total

the address of total is bound to the implicit this parameter and rhs is bound to trans. Thus, when combine executes

units_sold += rhs.units_sold; // add the members of rhs into

the effect is to add total.units_sold and trans.units_sold, storing the result back into total.units_sold.

The interesting part about this function is its return type and the return statement. Ordinarily, when we define a function that operates like a built-in operator, our function should mimic the behavior of that operator. The built-in assignment operators return their left-hand operand as an lvalue. To return an lvalue, our combine function must return a reference. Because the left-hand operand is a Sales_data object, the return type is Sales_data&.

As we‚Äôve seen, we do not need to use the implicit this pointer to access the members of the object on which a member function is executing. However, we do need to use this to access the object as a whole:

return *this; // return the object on which the function was called

Here the return statement dereferences this to obtain the object on which the function is executing. That is, for the call above, we return a reference to total.

--
Defining Nonmember Class-Related Functions

Class authors often define auxiliary functions, such as our add, read, and print functions. Although such functions define operations that are conceptually part of the interface of the class, they are not part of the class itself.

We define nonmember functions as we would any other function. As with any other function, we normally separate the declaration of the function from its definition. Functions that are conceptually part of a class, but not defined inside the class, are typically declared (but not defined) in the same header as the class itself. That way users need to include only one file to use any part of the interface.

The read and print functions do the same job as the code in xxx and not surprisingly, the bodies of our functions look a lot like the code presented there:

(findistream)
(findostream)

// input transactions contain ISBN, number of copies sold, and sales price
istream &read(istream &is, Sales_data &item) {
	double price = 0;
	is >> item.bookNo >> item.units_sold >> price;
	item.revenue = price * item.units_sold;
	return is;
}

ostream &print(ostream &os, const Sales_data &item) {
	os << item.isbn() << " " << item.units_sold << " "
	   << item.revenue << " " << item.avg_price();
	return os;
}

The read function reads data from the given stream into the given object. The print function prints the contents of the given object on the given stream.

However, there are two points worth noting about these functions. First, both read and write take a reference to their respective IO class types. The IO classes are types that cannot be copied, so we may only pass them by reference. Moreover, reading or writing to a stream changes that stream, so both functions take ordinary references, not references to const.

The second thing to note is that print does not print a newline. Ordinarily, functions that do output should do minimal formatting. That way user code can decide whether the newline is needed.

==
(findfriend)                   
friend

A class can allow another class or function to access its nonpublic members by making that class or function a friend. A class makes a function its friend by including a declaration for that function preceded by the keyword friend. Friend declarations may appear only inside a class definition; they may appear anywhere in the class. Ordinarily it is a good idea to group friend declarations together at the beginning or end of the class definition.

Example:

class Sales_data {

// friend declarations for nonmember Sales_data operations added
// tao: the following friend lines have no identation in the book
friend Sales_data add(const Sales_data&, const Sales_data&);
friend std::istream &read(std::istream&, Sales_data&);
friend std::ostream &print(std::ostream&, const Sales_data&);

// other members and access specifiers as before

public:
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
    Sales_data(const std::string &s): bookNo(s) { }
    Sales_data(std::istream&);
    std::string isbn() const { return bookNo; }
    Sales_data &combine(const Sales_data&);

private:
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

// declarations for nonmember parts of the Sales_data interface

Sales_data add(const Sales_data&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);

A class can also make another class its friend or it can declare specific member functions of another (previously defined) class as friends. In addition, a friend function can be defined inside the class body. Such functions are implicitly inline.

As an example of class friendship, our Window_mgr class will have members that will need access to the internal data of the Screen objects it manages. To allow this access, Screen can designate Window_mgr as its friend: 

class Screen {
	// Window_mgr members can access the private parts of class Screen
	friend class Window_mgr;
	// ... rest of the Screen class
};

The member functions of a friend class can access all the members, including the nonpublic members, of the class granting friendship. 

It is important to understand that friendship is not transitive. That is, if class Window_mgr has its own friends, those friends have no special access to Screen.

Rather than making the entire Window_mgr class a friend, Screen can instead specify that only the clear member is allowed access. When we declare a member function to be a friend, we must specify the class of which that function is a member:

class Screen {
	// Window_mgr::clear must have been declared before class Screen
	friend void Window_mgr::clear(ScreenIndex);
	// ... rest of the Screen class
};

Making a member function a friend requires careful structuring of our programs to accommodate interdependencies among the declarations and definitions.

Overloaded Functions and Friendship

Although overloaded functions share a common name, they are still different functions. Therefore, a class must declare as a friend each function in a set of overloaded functions that it wishes to make a friend.

Classes and nonmember functions need not have been declared before they are used in a friend declaration. When a name first appears in a friend declaration, that name is implicitly assumed to be part of the surrounding scope.

Even if we define the function inside the class, we must still provide a declaration outside of the class itself to make that function visible. A declaration must exist even if we only call the friend from members of the friendship granting class.

It is important to understand that a friend declaration affects access but is not a declaration in an ordinary sense.

--
Type Member

In addition to defining data and function members, a class can define its own local names for types. Type names defined by a class are subject to the same access controls as any other member and may be either public or private:

Unlike ordinary members, members that define types must appear before they are used. As a result, type members usually appear at the beginning of the class.

Example:

class Screen {
public:
    typedef std::string::size_type pos;
private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};

We defined pos in the public part of Screen because we want users to use that name.

We can equivalently use a type alias:

class Screen {
public:
    // alternative way to declare a type member using a type alias
    using pos = std::string::size_type;
    // other members as before
};

--
Making Members inline

class Screen {
public:
    typedef std::string::size_type pos;
    Screen() = default; // needed because Screen has another constructor
    // cursor initialized to 0 by its in-class initializer
    Screen(pos ht, pos wd, char c): height(ht), width(wd),
    contents(ht * wd, c) { }

    // get the character at the cursor
    // implicitly inline
    char get() const {
      return contents[cursor]; 
    } 

    inline char get(pos ht, pos wd) const; // explicitly inline
    Screen &move(pos r, pos c); // can be made inline later

private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};

Classes often have small functions that can benefit from being inlined. As we‚Äôve seen, member functions defined inside the class are automatically inline. Thus, Screen‚Äôs constructors and the version of get that returns the character denoted by the cursor are inline by default.

We can explicitly declare a member function as inline as part of its declaration inside the class body. Alternatively, we can specify inline on the function definition that appears outside the class body:

inline // we can specify inline on the definition
Screen &Screen::move(pos r, pos c) {
    pos row = r * width; // compute the row location
    cursor = row + c ; // move cursor to the column within that row
    return *this; // return this object as an lvalue
}

//tao: checked and it has no inline specifier
char Screen::get(pos r, pos c) const { // declared as inline in the class 
    pos row = r * width; // compute row location
    return contents[row + c]; // return character at the given column
}

Although we are not required to do so, it is legal to specify inline on both the declaration and the definition. However, specifying inline only on the definition outside the class can make the class easier to read.

For the same reasons that we define inline functions in headers, inline member functions should be defined in the same header as the corresponding class definition.

--
mutable Data Members

A mutable data member is never const, even when it is a member of a const object. Accordingly, a const member function may change a mutable member.

class Screen {
public:
    void some_member() const;

private:
    mutable size_t access_ctr; // may change even in a const object
    // other members as before
};

void Screen::some_member() const {
    ++access_ctr; // keep a count of the calls to any member function
    // whatever other work this member needs to do
}

--
Initializers for Data Members of Class Type

class Window_mgr {
private:
    std::vector<Screen> screens{Screen(24, 80, ' ') };
};

As we‚Äôve seen, in-class initializers must use either the = form of initialization (which we used when we initialized the the data members of Screen) or the direct form of initialization using curly braces (as we do for screens).

--
Functions That Return *this

class Screen {
public:
    Screen &set(char);
    Screen &set(pos, pos, char);
    // other members as before
};

inline Screen &Screen::set(char c) {
    contents[cursor] = c; // set the new value at the current cursor location
    return *this; // return this object as an lvalue
}

inline Screen &Screen::set(pos r, pos col, char ch) {
    contents[r*width + col] = ch; // set specified location to given value
    return *this; // return this object as an lvalue
}

Our set members return a reference to the object on which
they are called. Functions that return a reference are lvalues, which means that they return the object itself, not a copy of the object. If we concatenate a sequence of these actions into a single expression:

// tao: the move function also returns *this
// move the cursor to a given position, and set that character

myScreen.move(4,0).set('#');

these operations will execute on the same object. 

--
Returning *this from a const Member Function

Tao: first search for "find constmemberfunction"

We‚Äôll add an operation, which we‚Äôll name display, to print the contents of the Screen. If display is a const member, then this (tao: the this pointer is returned by display) is a pointer to const and *this is a const object. if display returns a reference to const, we won‚Äôt be able to embed display into a series of actions (tao: see reason after the following code): 

Screen myScreen;
// if display returns a const reference, the call to set is an error
myScreen.display(cout).set('*');

we can only call const member functions on a const object. We can call either version on a nonconst object, but the nonconst version will be a better match.

In the following example, we‚Äôll define a private member named do_display to do the actual work of printing the Screen. Each of the display operations will call this function and then return the object on which it is executing:

class Screen {
public:
    // display overloaded on whether the object is const or not
    Screen &display(std::ostream &os) { 
        do_display(os); return *this; 
    }

    const Screen &display(std::ostream &os) const { 
        do_display(os); return *this; 
    }

private:
    // function to do the work of displaying a Screen
    void do_display(std::ostream &os) const {
        os << contents;
    }
    // other members as before
};

When we call display on an object, whether that object is const determines which version of display is called:

Screen myScreen(5,3);
const Screen blank(5, 3);
myScreen.set('#').display(cout); // calls non const version
blank.display(cout); // calls const version

--
Benefits of Encapsulation:

Encapsulation provides two important advantages:

- User code cannot inadvertently corrupt the state of an encapsulated object.

- The implementation of an encapsulated class can change over time without requiring changes in user-level code.

By defining data members as private, the class author is free to make changes in the data. If the implementation changes, only the class code needs to be examined to see what effect the change may have. User code needs to change only when the interface changes. If the data are public, then any code that used the old data members might be broken. It would be
necessary to locate and rewrite any code that relied on the old representation before the program could be used again.

Another advantage of making data members private is that the data are protected from mistakes that users might introduce. If there is a bug that corrupts an object‚Äôs state, the places to look for the bug are localized: Only code that is part of the implementation could be responsible for the error. The search for the mistake is limited, greatly easing the problems of
maintenance and program correctness.

--
Class type

Just as we can declare a function apart from its definition, we can also declare a class without defining it:

class Screen; // declaration of the Screen class

After a declaration and before a definition is seen, the type Screen is an incomplete type‚Äîit‚Äôs known that Screen is a class type but not known what members that type contains.

We can use an incomplete type in only limited ways: We can define pointers or references to such types, and we can declare (but not define) functions that use an incomplete type as a parameter or return type.

A class must be defined‚Äînot just declared‚Äîbefore we can write code that creates objects of that type. Otherwise, the compiler does not know how much storage such objects need. Similarly, the class must be defined before a reference or pointer is used
to access a member of the type.

A class cannot have data members of its own type. A class can have data members that are pointers or references to its own type.

--
Implicit Class-Type Conversions

The language defines several automatic conversions among the built-in types. We also noted that classes can define implicit conversions as well. Every constructor that can be called with a single argument defines an implicit conversion to a class type. Such constructors are sometimes referred to as converting constructors. A constructor that can be called with a single argument defines an implicit conversion from the constructor‚Äôs parameter type to the class type. The Sales_data constructors that take a string and that take an istream both define implicit conversions from those types to Sales_data. That is, we can use a
string or an istream where an object of type Sales_data is expected.

Suppressing Implicit Conversions Defined by Constructors
 
We can prevent the use of a constructor in a context that requires an implicit conversion by declaring the constructor as explicit:

class Sales_data {
public:
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p):
               bookNo(s), units_sold(n), revenue(p*n) { }
    explicit Sales_data(const std::string &s): bookNo(s) { }
    explicit Sales_data(std::istream&);
    // remaining members as before
};
 
Now, neither constructor can be used to implicitly create a Sales_data object. 

The explicit keyword is meaningful only on constructors that can be called with a single argument. Constructors that require more arguments are not used to perform an implicit conversion, so there is no need to designate such constructors as explicit. The explicit keyword is used only on the constructor declaration inside the class.

explicit Constructors Can Be Used Only for Direct Initialization

Sales_data item1 (null_book); // ok: direct initialization
Sales_data item2 = null_book; // error: cannot use the copy form of initialization with an explicit constructor

--
Aggregate Classes

An aggregate class gives users direct access to its members and has special initialization syntax. A class is an aggregate if
 
‚Ä¢ All of its data members are public
‚Ä¢ It does not define any constructors
‚Ä¢ It has no in-class initializers 
‚Ä¢ It has no base classes or virtual functions, which are class-related features that we‚Äôll cover in Chapter 15

For example, the following class is an aggregate:
 
struct Data {
    int ival;
    string s;
};
 
We can initialize the data members of an aggregate class by providing a braced list of member initializers:
 
// val1.ival = 0; val1.s = string("Anna")
Data val1 = { 0, "Anna" };
 
The initializers must appear in declaration order of the data members.

It is worth noting that there are three significant drawbacks to explicitly initializing (tao: in the above way) the members of an object of class type:

1. ... public ...
2. ... error-prone ...
3. ... member added or removed ...

--
Literal Classes

We noted that the parameters and return type of a constexpr
function must be literal types. In addition to the arithmetic types, references, and pointers, certain classes are also literal types. Unlike other classes, classes that are
literal types may have function members that are constexpr. Such members must meet all the requirements of a constexpr function. These member functions are implicitly const

An aggregate class whose data members are all of literal type is a literal class. A nonaggregate class, that meets the following restrictions, is also a literal class:
 
‚Ä¢ The data members all must have literal type.
‚Ä¢ The class must have at least one constexpr constructor.
‚Ä¢ If a data member has an in-class initializer, the initializer for a member of built-in type must be a constant expression, or if the member has class type, the initializer must use the member‚Äôs own constexpr constructor.
‚Ä¢ The class must use default definition for its destructor, which is the member that destroys objects of the class type.

constexpr Constructors
 
Although constructors can‚Äôt be const, constructors in a literal class can be constexpr functions. Indeed, a literal class must provide at least one constexpr constructor.
 
A constexpr constructor can be declared as = default (or as a
deleted function, which we cover later). Otherwise, a constexpr
constructor must meet the requirements of a constructor‚Äîmeaning it can have no return statement‚Äîand of a constexpr function‚Äîmeaning the only executable statement it can have is a return statement. As a result, the body of a constexpr constructor is typically empty. We define a constexpr constructor by preceding its declaration with the keyword constexpr:

class Debug {
public:
    constexpr Debug(bool b = true): hw(b), io(b), other(b) {
}
    constexpr Debug(bool h, bool i, bool o):
                                    hw(h), io(i), other(o) {
}
    constexpr bool any() { return hw || io || other; }
    void set_io(bool b) { io = b; }
    void set_hw(bool b) { hw = b; }
    void set_other(bool b) { hw = b; }
private:
    bool hw;    // hardware errors other than IO errors
    bool io;    // IO errors
    bool other; // other errors
};

 
A constexpr constructor must initialize every data member. The initializers must either use a constexpr constructor or be a constant expression.

A constexpr constructor is used to generate objects that are constexpr and for parameters or return types in constexpr functions.

--
(findstaticmember)
static Class Members

Classes sometimes need members that are associated with the class, rather than with individual objects of the class type. For example, a bank account class might need a data member to represent the current prime interest rate. In this case, we‚Äôd want to associate the rate with the class, not with each individual object. From an efficiency standpoint, there‚Äôd be no reason for each object to store the rate. Much more importantly, if the rate changes, we‚Äôd want each object to use the new value.

Declaring static Members
 
We say a member is associated with the class by adding the keyword static to its declaration. Like any other member, static members can be public or private. The type of a static data member can be const, reference, array, class type, and
so forth.

As an example, we‚Äôll define a class to represent an account record at a bank:
 
class Account {
public:
    void calculate() { amount += amount * interestRate; }
    static double rate() { return interestRate; }
    static void rate(double);
private:
    std::string owner;
    double amount;
    static double interestRate;
    static double initRate();
};
 
The static members of a class exist outside any object. Objects do not contain data associated with static data members. Thus, each Account object will contain two data members‚Äîowner and amount. There is only one interestRate object that will be shared by all the Account objects.

Similarly, static member functions are not bound to any object; they do not have a this pointer. As a result, static member functions may not be declared as const, and we may not refer to this in the body of a static member. This restriction applies both to explicit uses of this and to implicit uses of this by calling a nonstatic member.

Using a Class static Member
 
We can access a static member directly through the scope operator:
 
double r;
r = Account::rate(); // access a static member using the scope operator
 
Even though static members are not part of the objects of its class, we can use an object, reference, or pointer of the class type to access a static member:

Account ac1;
Account *ac2 = &ac1;
// equivalent ways to call the static member rate function
r = ac1.rate();      // through an Account object or reference
r = ac2->rate();     // through a pointer to an Account object
 
Member functions can use static members directly, without the scope operator.

Defining static Members
 
As with any other member function, we can define a static member function inside or outside of the class body. When we define a static member outside the class, we do not repeat the static keyword. The keyword appears only with the declaration
inside the class body:
  
void Account::rate(double newRate)
{
    interestRate = newRate;
}

Because static data members are not part of individual objects of the class type, they are not defined when we create objects of the class. As a result, they are not initialized by the class‚Äô constructors. Moreover, in general, we may not initialize a static member inside the class. Instead, we must define and initialize each static data member outside the class body. Like any other object, a static data member may be defined only once.

Like global objects, static data members are defined outside any
function. Hence, once they are defined, they continue to exist until the program completes.

// define and initialize a static class member
double Account::interestRate = initRate();

Note also that even though initRate is private, we can use this function to initialize interestRate.

static Members Can Be Used in Ways Ordinary Members Can‚Äôt
 
As we‚Äôve seen, static members exist independently of any other object. As a result, they can be used in ways that would be illegal for nonstatic data members. As one example, a static data member can have incomplete type. In particular, a static data member can have the same type as the class type of which
MX K√º it is a member. A nonstatic data member is restricted to being declared as a pointer or a reference to an object of its class:

class Bar {
public:
    // ...
private:
    static Bar mem1; // ok: static member can have incomplete type
    Bar *mem2;       // ok: pointer member can have incomplete type
    Bar mem3;        // error: data members must have complete type
};
 
Another difference between static and ordinary members is that we can use a static member as a default argument:
 
class Screen {
public:
    // bkground refers to the static member
    // declared later in the class definition
    Screen& clear(char = bkground);
private:
    static const char bkground;
};
 
A nonstatic data member may not be used as a default argument because its value is part of the object of which it is a member. Using a nonstatic data member as a default argument provides no object from which to obtain the member‚Äôs value and so is an error.

--
(findconstructor)              
constructor

Constructors have the same name as the class. Unlike other functions, constructors have no return type. Like other functions, constructors have a (possibly empty) parameter list and a (possibly empty) function body. A class can have multiple constructors. Like any other overloaded function, the constructors must differ from each other in the number or types of their parameters.

Unlike other member functions, constructors may not be declared as const. When we create a const object of a class type, the object does not assume its ‚Äúconstness‚Äù until after the constructor completes the object‚Äôs initialization. Thus, constructors can write to const objects during their construction.

--
(findsynthesizeddefaultconstructor)
The Synthesized Default Constructor

Our Sales_data class does not define any constructors, yet the programs we‚Äôve written that use Sales_data objects compile and run correctly:

Sales_data total;

(finddefaultconstructor)
We did not supply an initializer for these objects, so we know that they are default initialized. Classes control default initialization by defining a special constructor, known as the default constructor. The default constructor is one that takes no arguments (tao: remember).

As we‚Äôll see, the default constructor is special in various ways, one of which is that if our class does not explicitly define any constructors, the compiler will implicitly define the default constructor for us

The compiler-generated constructor is known as the synthesized default constructor. For most classes, this synthesized constructor initializes each data member of the class as follows:

‚Ä¢ If there is an in-class initializer, use it to initialize the member.
‚Ä¢ Otherwise, default-initialize the member.

Some Classes Cannot Rely on the Synthesized Default Constructor 

Only fairly simple classes‚Äîsuch as the current definition of Sales_data‚Äîcan rely on the synthesized default constructor. The most common reason that a class must define its own default constructor is that the compiler generates the default for us only if we do not define any other constructors for the class. If we define any constructors, the class will not have a default constructor unless we define that constructor ourselves. The basis for this rule is that if a class requires control to initialize an object in one case, then the class is likely to require control in all cases.

Note: The compiler generates a default constructor automatically only if a class declares no constructors.

A second reason to define the default constructor is that for some classes, the synthesized default constructor does the wrong thing. Remember that objects of builtin or compound type (such as arrays and pointers) that are defined inside a block have undefined value when they are default initialized. The same rule applies to members of built-in type that are default initialized. Therefore, classes that have members of built-in or compound type should ordinarily either initialize those members inside the class or define their own version of the default constructor. Otherwise, users could create objects with members that have undefined value.

A third reason that some classes must define their own default constructor is that sometimes the compiler is unable to synthesize one. For example, if a class has a member that has a class type, and that class doesn‚Äôt have a default constructor, then the compiler can‚Äôt initialize that member. For such classes, we must define our own version of the default constructor.

Constructor example:

struct Sales_data {
    // constructors added
    Sales_data() = default; //From later: We can explicitly ask the compiler to generate the synthesized versions of the copycontrol members by defining them as = default
    Sales_data(const std::string &s): bookNo(s) { } 
    Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
    Sales_data(std::istream &);

    // other members as before
    std::string isbn() const { return bookNo; }
    Sales_data& combine(const Sales_data&);
    double avg_price() const;
    std::string bookNo;
    unsigned units_sold = 0; //Tao: in-class initializer, see below
    double revenue = 0.0; //Tao: in-class initializer, see below
};

Constructor examples from Leetcode default code:

struct Interval {
    int start;
    int end;
    Interval() : start(0), end(0) {}
    Interval(int s, int e) : start(s), end(e) {}
};

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
}; 

In the constructor, the code between the colon and the curly braces is a constructor initializer list, which specifies initial values for one or more data members of the object being created. The constructor initializer is a list of member names, each of which is followed by that member‚Äôs initial value in parentheses (or inside curly braces). Multiple member initializations are separated by commas.

When a member is omitted from the constructor initializer list, it is implicitly initialized using the same process as is used by the synthesized default constructor.

It is usually best for a constructor to use an in-class initializer if one exists and gives the member the correct value. On the other hand, if your compiler does not yet support in-class initializers, then every constructor should explicitly initialize every member of built-in type.

It is worth noting that both constructors have empty function bodies. The only work these constructors need to do is give the data members their values. If there is no further work, then the function body is empty.

Defining a Constructor outside the Class Body

Unlike our other constructors, the constructor that takes an istream does have work to do. Inside its function body, this constructor calls read to give the data members new values:

The function read below will read a transaction from is into this object 

Tao: read is a user defined function. read returns *this. I recorded some notes about functions that return *this somewhere below.

Sales_data::Sales_data(std::istream &is) {
    read(is, *this); 
}

Constructors have no return type, so this definition starts with the name of the function we are defining. As with any other member function, when we define a constructor outside of the class body, we must specify the class of which the
constructor is a member. Thus, Sales_data::Sales_data says that we‚Äôre defining the Sales_data member named Sales_data. This member is a constructor because it has the same name as its class.

In this constructor there is no constructor initializer list, although technically speaking, it would be more correct to say that the constructor initializer list is empty. Even though the constructor initializer list is empty, the members of this object are still initialized before the constructor body is executed.

Members that do not appear in the constructor initializer list are initialized by the corresponding in-class initializer (if there is one) or are default initialized.

Constructor Initializers Are Sometimes Required

We can often, but not always, ignore the distinction between whether a member is initialized or assigned. Members that are const or references must be initialized. Similarly, members that are of a class type that does not define a default constructor also must be initialized. For example:

class ConstRef {
public:
	ConstRef(int ii);

private:
	int i;
	const int ci;
	int &ri;
};

Like any other const object or reference, the members ci and ri must be initialized. As a result, omitting a constructor initializer for these members is an error.

By the time the body of the constructor begins executing, initialization is complete. Our only chance to initialize const or reference data members is in the constructor initializer.

The way to initialize them is:

ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) { }

We must use the constructor initializer list to provide values for members that are const, reference, or of a class type that does not have a default constructor.

Order of Member Initialization

Members are initialized in the order in which they appear in the class definition.  The order in which initializers appear in the constructor initializer list does not change the order of initialization.

The order of initialization often doesn‚Äôt matter. However, if one member is initialized in terms of another, then the order in which members are initialized is crucially important.

It is a good idea to write constructor initializers in the same order as the members are declared. Moreover, when possible, avoid using members to initialize other members.

--
Copy, Assignment, and Destruction

In addition to defining how objects of the class type are initialized, classes also control what happens when we copy, assign, or destroy objects of the class type. 

Objects are copied in several contexts, such as when we initialize a variable (tao: can be either =, or int a(b), confirmed) or when we pass or return an object by value. Objects are assigned when we use the assignment operator (tao: =, confirmed). Objects are destroyed when they cease to exist, such as when a local object is destroyed on exit from the block in which it was created. Objects stored in a vector (or an array) are destroyed when that vector (or array) is destroyed.

If we do not define these operations, the compiler will synthesize them for us. Ordinarily, the versions that the compiler generates for us execute by copying, assigning, or destroying each member of the object. For example, in our bookstore program, when the compiler executes this assignment

total = trans; // process the next book

it executes as if we had written

// default assignment for Sales_data is equivalent to:
total.bookNo = trans.bookNo;
total.units_sold = trans.units_sold;
total.revenue = trans.revenue;

Some Classes Cannot Rely on the Synthesized Versions

--
Delegating Constructors

The new standard extends the use of constructor initializers to let us define so-called delegating constructors. A delegating constructor uses another constructor from its own class to perform its initialization. It is said to ‚Äúdelegate‚Äù some (or all) of its work to this other constructor.

Like any other constructor, a delegating constructor has a member initializer list and a function body. In a delegating constructor, the member initializer list has a single
entry that is the name of the class itself. Like other member initializers, the name of the class is followed by a parenthesized list of arguments. The argument list must
match another constructor in the class.

As an example, we‚Äôll rewrite the Sales_data class to use delegating constructors as follows:

class Sales_data {
public:
	// nondelegating constructor initializes members from corresponding arguments
	Sales_data(std::string s, unsigned cnt, double price):
	bookNo(s), units_sold(cnt), revenue(cnt*price) {
	}
	// remaining constructors all delegate to another constructor
	Sales_data(): Sales_data("", 0, 0) {}
	Sales_data(std::string s): Sales_data(s, 0,0) {}
	Sales_data(std::istream &is): Sales_data()
	{ read(is, *this); }
	// other members as before
};

In this version of Sales_data, all but one of the constructors delegate their work. The first constructor takes three arguments, uses those arguments to initialize the
data members, and does no further work. In this version of the class, we define the default constructor (the default constructor is one that takes no arguments) to use the three-argument constructor to do its initialization. It too
has no additional work, as indicated by the empty constructor body. The constructor that takes a string also delegates to the three-argument version.

The constructor that takes an istream& also delegates. It delegates to the default constructor, which in turn delegates to the three-argument constructor.

When a constructor delegates to another constructor, the constructor initializer list and function body of the delegated-to constructor are both executed.

--
The Role of the Default Constructor

The default constructor is used automatically whenever an object is default or value initialized. Default initialization happens

‚Ä¢ When we define nonstatic variables or arrays at block scope without initializers

‚Ä¢ When a class that itself has members of class type uses the synthesized default constructor

‚Ä¢ When members of class type are not explicitly initialized in a constructor initializer list  Value initialization happens

‚Ä¢ During array initialization when we provide fewer initializers than the size of the array 

‚Ä¢ When we define a local static object without an initializer 

‚Ä¢ When we explicitly request value initialization by writing an expressions of the form T() where T is the name of a type (

Classes must have a default constructor in order to be used in these contexts.

In practice, it is almost always right to provide a default constructor if other constructors are being defined.

==
(findcopycontrol)
Copy control

Readers, therefore, should understand that Part III covers fairly advanced topics.

In this chapter we‚Äôll learn how classes can control what happens when objects of the class type are copied, assigned, moved, or destroyed. Classes control these actions through special member functions: the copy constructor, move constructor, copy-assignment operator, move-assignment operator, and destructor.

Tao's summary (from later):

Old standard has:
copy constructor 
copy-assignment operator
destructor

New standard added:
move constructor
move-assignment operator

The copy and move constructors define what happens when an object is initialized from another object of the same type. The copy-assignment and move-assignment operators define what happens when we assign an object of a class type to another
object of that same class type. The destructor defines what happens when an object of the type ceases to exist. Collectively, we‚Äôll refer to these operations as copy
control.

If a class does not define all of the copy-control members, the compiler automatically defines the missing operations. As a result, many classes can ignore copy control. However, for some classes, relying on the default definitions leads to disaster. Frequently, the hardest part of implementing copy-control operations is recognizing when we need to define them in the first place.

Warning: Copy control is an essential part of defining any C++ class. Programmers new to C++ are often confused by having to define what happens when objects are copied, moved, assigned, or destroyed. This confusion is compounded because if we do not explicitly define these operations, the compiler defines them for us‚Äîalthough the compiler-defined versions might not behave as we intend.

==
Copy, Assign, and Destroy

(findcopyconstructor)
Copy constructor

A constructor is the copy constructor if its first parameter is a reference to the class type and any additional parameters have default values:

class Foo {
public:
    Foo(); // default constructor
    Foo(const Foo&); // copy constructor
    // ...
};

For reasons we‚Äôll explain shortly, the first parameter must be a reference type. That parameter is almost always a reference to const, although we can define the copy constructor to take a reference to nonconst. The copy constructor is used implicitly in several circumstances. Hence, the copy constructor usually should not be explicit.

--
The Synthesized Copy Constructor

When we do not define a copy constructor for a class, the compiler synthesizes one for us. Unlike the synthesized default constructor, a copy constructor is synthesized even if we define other constructors.

As we‚Äôll see later, the synthesized copy constructor for some
classes prevents us from copying objects of that class type. Otherwise, the synthesized copy constructor memberwise copies the members of its argument into the object being created. The compiler copies each nonstatic member in turn from the given object into the one being created.

The type of each member determines how that member is copied: Members of class type are copied by the copy constructor for that class; members of built-in type are copied directly. Although we cannot directly copy an array, the synthesized copy constructor copies members of array type by copying each element. Elements of class type are copied by using the elements‚Äô copy constructor.

As an example, the synthesized copy constructor for our Sales_data class is equivalent to:

class Sales_data {
public:
    // other members and constructors as before
    // declaration equivalent to the synthesized copy constructor
    Sales_data(const Sales_data&);

private:
    std::string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
};

// equivalent to the copy constructor that would be synthesized for Sales_data
Sales_data::Sales_data(const Sales_data &orig):
    bookNo(orig.bookNo), // uses the string copy constructor
    units_sold(orig.units_sold), // copies orig.units_sold
    revenue(orig.revenue) // copies orig.revenue
    { } // empty body

--
(finddirectinitialization2)
(findcopyinitialization2)
Direct and copy Initialization 2

Copy Initialization

We are now in a position to fully understand the differences between direct initialization and copy initialization:

string dots(10, '.'); // direct initialization
string s(dots); // direct initialization
string s2 = dots; // copy initialization
string null_book = "9-999-99999-9"; // copy initialization
string nines = string(100, '9'); // copy initialization

When we use direct initialization, we are asking the compiler to use ordinary function matching to select the constructor that best matches the arguments we provide. When we use copy initialization, we are asking the compiler to copy the right-hand operand into the object being created, converting that operand if necessary.

Copy initialization ordinarily uses the copy constructor. However, as we‚Äôll see later, if a class has a move constructor, then copy initialization sometimes uses the move constructor instead of the copy constructor. For now, what‚Äôs useful to know is when copy initialization happens and that copy initialization requires either the copy constructor or the move constructor.

Copy initialization happens not only when we define variables using an =, but also when we

(findparameter2)
(findreturn2)
(Tao: the following cases use the copy constructor)

‚Ä¢ Pass an object as an argument to a parameter of nonreference type (tao: note nonreference)

‚Ä¢ Return an object from a function that has a nonreference return type (tao: note nonreference)

‚Ä¢ Brace initialize the elements in an array or the members of an aggregate class

Some class types also use copy initialization for the objects they allocate. For example, the library containers copy initialize their elements when we initialize the container, or
when we call an insert or push member. By contrast, elements
created by an emplace member are direct initialized.

The fact that the copy constructor is used to initialize nonreference parameters of class type explains why the copy constructor‚Äôs own parameter must be a reference.

The Compiler Can Bypass the Copy Constructor

During copy initialization, the compiler is permitted (but not obligated) to skip the copy/move constructor and create the object directly. That is, the compiler is permitted to rewrite

string null_book = "9-999-99999-9"; // copy initialization
into
string null_book("9-999-99999-9"); // compiler omits the copy
constructor

However, even if the compiler omits the call to the copy/move constructor, the copy/move constructor must exist and must be accessible (e.g., not private) at that point in the program.

--
The Copy-Assignment Operator

Just as a class controls how objects of that class are initialized, it also controls how objects of its class are assigned:

Sales_data trans, accum;
trans = accum; // uses the Sales_data copy-assignment operator

As with the copy constructor, the compiler synthesizes a copy-assignment operator if the class does not define its own.

Introducing Overloaded Assignment

Before we look at the synthesized assignment operator, we need to know a bit about overloaded operators, which we cover in detail later. 

Overloaded operators are functions that have the name operator followed by the symbol for the operator being defined. Hence, the assignment operator is a function named operator=. Like any other function, an operator function has a return type
and a parameter list.

The parameters in an overloaded operator represent the operands of the operator. Some operators, assignment among them, must be defined as member functions. When an operator is a member function, the left-hand operand is bound to the
implicit this parameter. The right-hand operand in a binary
operator, such as assignment, is passed as an explicit parameter.

The copy-assignment operator takes an argument of the same type as the class:

class Foo {
public:
    Foo& operator=(const Foo&); // assignment operator
    // ...
};

To be consistent with assignment for the built-in types, assignment operators usually return a reference to their left-hand operand. It is also worth noting that the library generally requires that types stored in a container have assignment operators that return a reference to the left-hand operand.

Best Practices: Assignment operators ordinarily should return a reference to their left-hand operand.

The Synthesized Copy-Assignment Operator

Just as it does for the copy constructor, the compiler generates a synthesized copy-assignment operator for a class if the class does not define its own. Analogously to the copy constructor, for some classes the synthesized copy-assignment operator disallows assignment. Otherwise, it assigns each nonstatic member of the right-hand object to the corresponding member of the left-hand object using the copy-assignment operator for the type of that member. Array members are assigned by assigning each element of the array. The synthesized copy-assignment operator returns a reference to its left-hand object.

As an example, the following is equivalent to the synthesized Sales_data copy-assignment operator:

// equivalent to the synthesized copy-assignment operator
Sales_data&
Sales_data::operator=(const Sales_data &rhs)
{
    bookNo = rhs.bookNo; // calls the string::operator=
    units_sold = rhs.units_sold; // uses the built-in int assignment
    revenue = rhs.revenue; // uses the built-in double
    assignment
    return *this; // return a reference to this object
}

==
(finddestructor)
The Destructor

Destructors do whatever work is needed to free the resources used by an object and destroy the data members of the object.

The destructor is a member function with the name of the class prefixed by a tilde (~). It has no return value and takes no parameters. Because it takes no parameters, it cannot be overloaded. There is always only one destructor for a given class.

class Sales_data {
public:
    ~Sales_data() { } // destructor
    ...
};

What a Destructor Does

Just as a constructor has an initialization part and a function body, a destructor has a function body and a destruction part. In a constructor, members are initialized before the function body is executed, and members are initialized in the same order as they appear in the class. In a destructor, the function body is executed first and then the members are destroyed. Members are destroyed in reverse order from the order in which they were initialized.

The function body of a destructor does whatever operations the class designer wishes to have executed subsequent to the last use of an object. Typically, the destructor frees resources an object allocated during its lifetime.

In a destructor, there is nothing akin to the constructor initializer list to control how members are destroyed; the destruction part is implicit. What happens when a member is destroyed depends on the type of the member. 

(finddestroy)
Members of class type are destroyed by running the member‚Äôs own destructor. The built-in types do not have destructors, so nothing is done to destroy members of built-in type. 

Note: The implicit destruction of a member of built-in pointer type does not delete the object to which that pointer points.

Unlike ordinary pointers, the smart pointers are class types and have destructors. As a result, unlike ordinary pointers, members that are smart pointers are automatically destroyed during the destruction phase.

When a Destructor Is Called

The destructor is used automatically whenever an object of its type is destroyed:

‚Ä¢ Variables are destroyed when they go out of scope.

‚Ä¢ Members of an object are destroyed when the object of which they are a part is destroyed.

‚Ä¢ Elements in a container‚Äîwhether a library container or an array‚Äîare destroyed when the container is destroyed.

‚Ä¢ Dynamically allocated objects are destroyed when the delete operator is applied to a pointer to the object.

‚Ä¢ Temporary objects are destroyed at the end of the full expression in which the temporary was created.

Because destructors are run automatically, our programs can allocate resources and (usually) not worry about when those resources are released.

For example, the following fragment defines four Sales_data objects:

{ // new scope
    // p and p2 point to dynamically allocated objects
    Sales_data *p = new Sales_data; // p is a built-in pointer
    auto p2 = make_shared<Sales_data>(); // p2 is a shared_ptr
    Sales_data item(*p); // copy constructor copies *p into item
    vector<Sales_data> vec; // local object
    vec.push_back(*p2); // copies the object to which p2 points
    delete p; // destructor called on the object pointed to
    by p
} // exit local scope; destructor called on item, p2, and vec
// destroying p2 decrements its use count; if the count goes to 0, the object is freed
// destroying vec destroys the elements in vec

The destructor is not run when a reference or a pointer to an object goes out of scope.

The Synthesized Destructor

The compiler defines a synthesized destructor for any class that does not define its own destructor. As with the copy constructor and the copy-assignment operator, for some classes, the synthesized destructor is defined to disallow objects of the type from being destroyed. Otherwise, the synthesized destructor has an empty function body.

For example, the synthesized Sales_data destructor is equivalent to:

class Sales_data {
public:
    // no work to do other than destroying the members, which happens automatically
    ~Sales_data() { }
    // other members as before
};

The members are automatically destroyed after the (empty) destructor body is run.

It is important to realize that the destructor body does not directly destroy the members themselves. Members are destroyed as part of the implicit destruction phase that follows the destructor body. A destructor body executes in addition to the
memberwise destruction that takes place as part of destroying an object.

--
The Rule of Three/Five

As we‚Äôve seen, there are three basic operations to control copies of class objects: the copy constructor, copy-assignment operator, and destructor. Moreover, as we‚Äôll see later, under the new standard, a class can also define a move constructor
and move-assignment operator.

There is no requirement that we define all of these operations: We can define one or two of them without having to define all of them. However, ordinarily these operations should be thought of as a unit. In general, it is unusual to need one without needing to define them all.

Classes That Need Destructors Need Copy and Assignment

One rule of thumb to use when you decide whether a class needs to define its own versions of the copy-control members is to decide first whether the class needs a destructor. Often, the need for a destructor is more obvious than the need for the
copy constructor or assignment operator. If the class needs a destructor, it almost surely needs a copy constructor and copy-assignment operator as well.

Classes That Need Copy Need Assignment, and Vice Versa

Although many classes need to define all of (or none of) the copy-control members, some classes have work that needs to be done to copy or assign objects but has no need for the destructor.

--
(finddefault)
Using = default

We can explicitly ask the compiler to generate the synthesized versions of the copycontrol members by defining them as = default:

class Sales_data {
public:
  // copy control; use defaults
  Sales_data() = default;
  Sales_data(const Sales_data&) = default;
  Sales_data& operator=(const Sales_data &);
  ~Sales_data() = default;
  // other members as before
};

Sales_data& Sales_data::operator=(const Sales_data&) =
default;

When we specify = default on the declaration of the member inside the class body, the synthesized function is implicitly inline (just as is any other member function defined in the body of the class). If we do not want the synthesized member to be an inline function, we can specify = default on the member‚Äôs definition, as we do in the definition of the copy-assignment operator.

Note: We can use = default only on member functions that have a synthesized version (i.e., the default constructor or a copy-control member).

--
Preventing Copies

Best Practices: Most classes should define‚Äîeither implicitly or explicitly‚Äîthe default and copy constructors and the copy-assignment operator.

Although most classes should (and generally do) define a copy constructor and a copy-assignment operator, for some classes, there really is no sensible meaning for these operations. In such cases, the class must be defined so as to prevent copies or assignments from being made. For example, the iostream classes prevent copying to avoid letting multiple objects write to or read from the same IO buffer. It might seem that we could prevent copies by not defining the copy-control members. However, this strategy doesn‚Äôt work: If our class doesn‚Äôt define these operations, the compiler will synthesize them.

--
Defining a Function as Deleted

Under the new standard, we can prevent copies by defining the copy constructor and copy-assignment operator as deleted functions. A deleted function is one that is declared but may not be used in any other way. We indicate that we want to define a function as deleted by following its parameter list with = delete:

struct NoCopy {
  NoCopy() = default; // use the synthesized default constructor
  NoCopy(const NoCopy&) = delete; // no copy
  NoCopy &operator=(const NoCopy&) = delete; // no assignment
  ~NoCopy() = default; // use the synthesized destructor
  // other members
};

The = delete signals to the compiler (and to readers of our code) that we are intentionally not defining these members.

Unlike = default, = delete must appear on the first declaration of a deleted function. This difference follows logically from the meaning of these declarations. A defaulted member affects only what code the compiler generates; hence the = default is not needed until the compiler generates code. On the other hand, the compiler needs to know that a function is deleted in order to prohibit operations that attempt to use it.

Also unlike = default, we can specify = delete on any function (we can use = default only on the default constructor or a copy-control member that the compiler can synthesize). Although the primary use of deleted functions is to suppress the copy-control members, deleted functions are sometimes also useful when we want to guide the function-matching process.

--
The Destructor Should Not be a Deleted Member

It is worth noting that we did not delete the destructor. If the destructor is deleted, then there is no way to destroy objects of that type. The compiler will not let us define variables or create temporaries of a type that has a deleted destructor. Moreover, we cannot define variables or temporaries of a class that has a member whose type has a deleted destructor. If a member has a deleted destructor, then that member cannot be destroyed. If a member can‚Äôt be destroyed, the object as a whole can‚Äôt be destroyed.

Although we cannot define variables or members of such types, we can dynamically allocate objects with a deleted destructor. However, we cannot free them:

struct NoDtor {
  NoDtor() = default; // use the synthesized default constructor
  ~NoDtor() = delete; // we can't destroy objects of type NoDtor
};

NoDtor nd; // error: NoDtor destructor is deleted
NoDtor *p = new NoDtor(); // ok: but we can't delete p
delete p; // error: NoDtor destructor is deleted

Warning: It is not possible to define an object or delete a pointer to a dynamically allocated object of a type with a deleted destructor.

--
The Copy-Control Members May Be Synthesized as Deleted

As we‚Äôve seen, if we do not define the copy-control members, the compiler defines them for us. Similarly, if a class defines no constructors, the compiler synthesizes a default constructor for that class. For some classes, the compiler
defines these synthesized members as deleted functions:

‚Ä¢ The synthesized destructor is defined as deleted if the class has a member whose own destructor is deleted or is inaccessible (e.g., private).

‚Ä¢ The synthesized copy constructor is defined as deleted if the class has a member whose own copy constructor is deleted or inaccessible. It is also deleted if the class has a member with a deleted or inaccessible destructor.

‚Ä¢ The synthesized copy-assignment operator is defined as deleted if a member has a deleted or inaccessible copy-assignment operator, or if the class has a const or reference member.

‚Ä¢ The synthesized default constructor is defined as deleted if the class has a member with a deleted or inaccessible destructor; or has a reference member that does not have an in-class initializer; or has a const member whose type does not explicitly define a default constructor and that
member does not have an in-class initializer.

In essence, these rules mean that if a class has a data member that cannot be default constructed, copied, assigned, or destroyed, then the corresponding member will be a deleted function.

It may be surprising that a member that has a deleted or inaccessible destructor causes the synthesized default and copy constructors to be defined as deleted. The reason for this rule is that without it, we could create objects that we could not destroy.

It should not be surprising that the compiler will not synthesize a default constructor for a class with a reference member or a const member that cannot be default constructed. Nor should it be surprising that a class with a const member cannot use the synthesized copy-assignment operator: After all, that operator attempts to assign to every member. It is not possible to assign a new value to a const object.

Although we can assign a new value to a reference, doing so changes the value of the object to which the reference refers. If the copy-assignment operator were synthesized for such classes, the left-hand operand would continue to refer to the
same object as it did before the assignment. It would not refer to the same object as the right-hand operand. Because this behavior is unlikely to be desired, the synthesized copy-assignment operator is defined as deleted if the class has a reference member.

We‚Äôll see later that there are other aspects of a class that can cause its copy members to be defined as deleted.

Note: In essence, the copy-control members are synthesized as deleted when it is impossible to copy, assign, or destroy a member of the class.

--
private Copy Control

Prior to the new standard, classes prevented copies by declaring their copy constructor and copy-assignment operator as private:

class PrivateCopy {
  // no access specifier; following members are private by default; see ¬ß 7.2 (p.
  268)
  // copy control is private and so is inaccessible to ordinary user code
  PrivateCopy(const PrivateCopy&);
  PrivateCopy &operator=(const PrivateCopy&);
  // other members
public:
  PrivateCopy() = default; // use the synthesized default constructor
  ~PrivateCopy(); // users can define objects of this type but not copy them
};

Because the destructor is public, users will be able to define PrivateCopy objects. However, because the copy constructor and copy-assignment operator are private, user code will not be able to copy such objects. However, friends and members of the
class can still make copies. To prevent copies by friends and members, we declare these members as private but do not define them.

With one exception, which we‚Äôll cover later, it is legal to declare, but not define, a member function. An attempt to use an undefined member results in a link-time failure. By declaring (but not defining) a private copy constructor, we can forestall any attempt to copy an object of the class type: User code that tries to make a copy will be flagged as an error at compile time; copies made in member functions or friends will result in an error at link time.

Best Practices: Classes that want to prevent copying should define their copy constructor and copy-assignment operators using = delete rather than making those members private.

--
Copy Control and Resource Management

Ordinarily, classes that manage resources that do not reside in the class must define the copy-control members. As we saw later, such classes will need destructors to free the resources allocated by the object. Once a class needs a destructor, it almost surely needs a copy constructor and copy-assignment operator as well.

In order to define these members, we first have to decide what copying an object of our type will mean. In general, we have two choices: We can define the copy operations to make the class behave like a value or like a pointer.

Classes that behave like values have their own state. When we copy a valuelike object, the copy and the original are independent of each other. Changes made to the copy have no effect on the original, and vice versa.

Classes that act like pointers share state. When we copy objects of such classes, the copy and the original use the same underlying data. Changes made to the copy also change the original, and vice versa.

Of the library classes we‚Äôve used, the library containers and string class have valuelike behavior. Not surprisingly, the shared_ptr class provides pointerlike behavior, as does our StrBlob class. The IO types and unique_ptr do not allow copying or assignment, so they provide neither valuelike
nor pointerlike behavior.

To illustrate these two approaches, we‚Äôll define the copy-control members for the HasPtr class used in the exercises. First, we‚Äôll make the class act like a value; then
we‚Äôll reimplement the class making it behave like a pointer.

Our HasPtr class has two members, an int and a pointer to string. Ordinarily, classes copy members of built-in type (other than pointers) directly; such members are values and hence ordinarily ought to behave like values. What we do when we copy the pointer member determines whether a class like HasPtr has valuelike or pointerlike behavior.

--
Classes That Act Like Values

To provide valuelike behavior, each object has to have its own copy of the resource that the class manages. That means each HasPtr object must have its own copy of the string to which ps points. To implement valuelike behavior HasPtr needs

‚Ä¢ A copy constructor that copies the string, not just the pointer

‚Ä¢ A destructor to free the string

‚Ä¢ A copy-assignment operator to free the object‚Äôs existing string and copy the string from its right-hand operand
The valuelike version of HasPtr is

class HasPtr {
public:
  HasPtr(const std::string &s = std::string()):
  ps(new std::string(s)), i(0) { }
  // each HasPtr has its own copy of the string to which ps points
  HasPtr(const HasPtr &p):
  ps(new std::string(*p.ps)), i(p.i) { }
  HasPtr& operator=(const HasPtr &);
  ~HasPtr() { delete ps; }
private:
  std::string *ps;
  int i;
};

Our class is simple enough that we‚Äôve defined all but the assignment operator in the class body. The first constructor takes an (optional) string argument. That constructor dynamically allocates its own copy of that string and stores a pointer to that string in ps. The copy constructor also allocates its own, separate copy of the string. The destructor frees the memory allocated in its constructors by executing
delete on the pointer member, ps.

--
Valuelike Copy-Assignment Operator

Assignment operators typically combine the actions of the destructor and the copy constructor. Like the destructor, assignment destroys the left-hand operand‚Äôs resources. Like the copy constructor, assignment copies data from the right-hand operand. However, it is crucially important that these actions be done in a sequence that is correct even if an object is assigned to itself. Moreover, when possible, we
should also write our assignment operators so that they will leave the left-hand operand in a sensible state should an exception occur.

In this case, we can handle self-assignment‚Äîand make our code safe should an exception happen‚Äîby first copying the right-hand side. After the copy is made, we‚Äôll free the left-hand side and update the pointer to point to the newly allocated string:

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  auto newp = new string(*rhs.ps); // copy the underlying string
  delete ps; // free the old memory
  ps = newp; // copy data from rhs into this object
  i = rhs.i;
  return *this; // return this object
}

In this assignment operator, we quite clearly first do the work of the constructor: The initializer of newp is identical to the initializer of ps in HasPtr‚Äôs copy constructor. As
in the destructor, we next delete the string to which ps currently points. What remains is to copy the pointer to the newly allocated string and the int value from rhs into this object.

Key Concept: Assignment Operators

There are two points to keep in mind when you write an assignment operator:

‚Ä¢ Assignment operators must work correctly if an object is assigned to itself.

‚Ä¢ Most assignment operators share work with the destructor and copy constructor.

A good pattern to use when you write an assignment operator is to first copy the right-hand operand into a local temporary. After the copy is done, it is safe to destroy the existing members of the left-hand operand. Once the lefthand operand is destroyed, copy the data from the temporary into the members of the left-hand operand.

To illustrate the importance of guarding against self-assignment, consider what would happen if we wrote the assignment operator as

// WRONG way to write an assignment operator!
HasPtr&
HasPtr::operator=(const HasPtr &rhs)
{
  delete ps; // frees the string to which this object points
  // if rhs and *this are the same object, we're copying from deleted memory!
  ps = new string(*(rhs.ps));
  i = rhs.i;
  return *this;
}

If rhs and this object are the same object, deleting ps frees the string to which both *this and rhs point. When we attempt to copy * (rhs.ps) in the new expression, that pointer points to invalid memory. What happens is undefined.

Warning: It is crucially important for assignment operators to work correctly, even when an object is assigned to itself. A good way to do so is to copy the right-hand operand before destroying the left-hand operand.

--
Defining Classes That Act Like Pointers

For our HasPtr class to act like a pointer, we need the copy constructor and copyassignment operator to copy the pointer member, not the string to which that pointer points. Our class will still need its own destructor to free the memory allocated
by the constructor that takes a string. In this case, though, the destructor cannot unilaterally free its associated string. It can do so only when the last HasPtr pointing to that string goes away. 

The easiest way to make a class act like a pointer is to use shared_ptrs to manage the resources in the class. Copying (or assigning) a shared_ptr copies (assigns) the pointer to which the shared_ptr points. The shared_ptr class itself keeps track of how many users are sharing the pointed-to object. When there are no more users, the shared_ptr class takes care of freeing the resource.

However, sometimes we want to manage a resource directly. In such cases, it can be useful to use a reference count. To show how reference counting works, we‚Äôll redefine HasPtr to provide pointerlike behavior, but we will do our own reference counting.

--
Reference Counts

Reference counting works as follows:

‚Ä¢ In addition to initializing the object, each constructor (other than the copy constructor) creates a counter. This counter will keep track of how many objects share state with the object we are creating. When we create an object, there is
only one such object, so we initialize the counter to 1.

‚Ä¢ The copy constructor does not allocate a new counter; instead, it copies the data members of its given object, including the counter. The copy constructor increments this shared counter, indicating that there is another user of that
object‚Äôs state.

‚Ä¢ The destructor decrements the counter, indicating that there is one less user of the shared state. If the count goes to zero, the destructor deletes that state.

‚Ä¢ The copy-assignment operator increments the right-hand operand‚Äôs counter and decrements the counter of the left-hand operand. If the counter for the left-hand operand goes to zero, there are no more users. In this case, the copyassignment
operator must destroy the state of the left-hand operand.

The only wrinkle is deciding where to put the reference count. The counter cannot be a direct member of a HasPtr object. To see why, consider what happens in the following example:

HasPtr p1("Hiya!");
HasPtr p2(p1); // p1 and p2 point to the same string
HasPtr p3(p1); // p1, p2, and p3 all point to the same string

If the reference count is stored in each object, how can we update it correctly when p3 is created? We could increment the count in p1 and copy that count into p3, but how would we update the counter in p2?

One way to solve this problem is to store the counter in dynamic memory. When we create an object, we‚Äôll also allocate a new counter. When we copy or assign an object, we‚Äôll copy the pointer to the counter. That way the copy and the original will point to the same counter.

--
Defining a Reference-Counted Clas

Using a reference count, we can write the pointerlike version of HasPtr as follows:

class HasPtr {
public:
  // constructor allocates a new string and a new counter, which it sets to 1
  HasPtr(const std::string &s = std::string()):
  ps(new std::string(s)), i(0), use(new std::size_t(1))
  {}
  // copy constructor copies all three data members and increments the counter
  HasPtr(const HasPtr &p):
  ps(p.ps), i(p.i), use(p.use) { ++*use; }
  HasPtr& operator=(const HasPtr&);
  ~HasPtr();
  private:
  std::string *ps;
  int i;
  std::size_t *use; // member to keep track of how many objects share
  *ps
};

Here, we‚Äôve added a new data member named use that will keep track of how many objects share the same string. The constructor that takes a string allocates this counter and initializes it to 1, indicating that there is one user of this object‚Äôs string member.

--
Pointerlike Copy Members ‚ÄúFiddle‚Äù the Reference Count

When we copy or assign a HasPtr object, we want the copy and the original to point to the same string. That is, when we copy a HasPtr, we‚Äôll copy ps itself, not the string to which ps points. When we make a copy, we also increment the counter
associated with that string.

The copy constructor (which we defined inside the class) copies all three members from its given HasPtr. This constructor also increments the use member, indicating
that there is another user for the string to which ps and p.ps point.

The destructor cannot unconditionally delete ps‚Äîthere might be other objects pointing to that memory. Instead, the destructor decrements the reference count, indicating that one less object shares the string. If the counter goes to zero, then
the destructor frees the memory to which both ps and use point:

HasPtr::~HasPtr()
{
  if (--*use == 0) { // if the reference count goes to 0
    delete ps; // delete the string
    delete use; // and the counter
  }
}

The copy-assignment operator, as usual, does the work common to the copy constructor and to the destructor. That is, the assignment operator must increment the counter of the right-hand operand (i.e., the work of the copy constructor) and
decrement the counter of the left-hand operand, deleting the memory used if appropriate (i.e., the work of the destructor).

Also, as usual, the operator must handle self-assignment. We do so by incrementing the count in rhs before decrementing the count in the left-hand object. That way if both objects are the same, the counter will have been incremented before we check to see if ps (and use) should be deleted:

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
  ++*rhs.use; // increment the use count of the right-hand operand
  if (--*use == 0) { // then decrement this object's counter
    delete ps; // if no other users
    delete use; // free this object's allocated members
  }
  ps = rhs.ps; // copy data from rhs into this object
  i = rhs.i;
  use = rhs.use;
  return *this; // return this object
}

==
Swap

In addition to defining the copy-control members, classes that manage resources often also define a function named swap. Defining swap is particularly important for classes that we plan to use with algorithms that reorder elements. Such algorithms call swap whenever they need to exchange two
elements.

If a class defines its own swap, then the algorithm uses that class-specific version. Otherwise, it uses the swap function defined by the library. Although, as usual, we don‚Äôt know how swap is implemented, conceptually it‚Äôs easy to see that swapping two objects involves a copy and two assignments. For example, code to swap two objects of our valuelike HasPtr class might look something like:

HasPtr temp = v1; // make a temporary copy of the value of v1
v1 = v2; // assign the value of v2 to v1
v2 = temp; // assign the saved value of v1 to v2

This code copies the string that was originally in v1 twice‚Äîonce when the HasPtr copy constructor copies v1 into temp and again when the assignment operator assigns temp to v2. It also copies the string that was originally in v2 when it
assigns v2 to v1. As we‚Äôve seen, copying a valuelike HasPtr allocates a new string and copies the string to which the HasPtr points.

In principle, none of this memory allocation is necessary. Rather than allocating new copies of the string, we‚Äôd like swap to swap the pointers. That is, we‚Äôd like swapping two HasPtrs to execute as:

string *temp = v1.ps; // make a temporary copy of the pointer in v1.ps
v1.ps = v2.ps; // assign the pointer in v2.ps to v1.ps
v2.ps = temp; // assign the saved pointer in v1.ps to v2.ps

--
Writing Our Own swap Function

We can override the default behavior of swap by defining a version of swap that operates on our class. The typical implementation of swap is:

class HasPtr {
  friend void swap(HasPtr&, HasPtr&);
  // other members as in ¬ß 13.2.1 (p. 511)
};

inline void swap(HasPtr &lhs, HasPtr &rhs)
{
  using std::swap;
  swap(lhs.ps, rhs.ps); // swap the pointers, not the string data
  swap(lhs.i, rhs.i); // swap the int members
}

We start by declaring swap as a friend to give it access to HasPtr‚Äôs (private) data members. Because swap exists to optimize our code, we‚Äôve defined swap as an inline function. The body of swap calls swap on each of the data members of the given object. In this case, we first swap the pointers and then the int members of the objects bound to rhs and lhs.

Note: Unlike the copy-control members, swap is never necessary. However, defining swap can be an important optimization for classes that allocate resources.

--
Using swap in Assignment Operators

Classes that define swap often use swap to define their assignment operator. These operators use a technique known as copy and swap. This technique swaps the lefthand operand with a copy of the right-hand operand:

// note rhs is passed by value, which means the HasPtr copy constructor
// copies the string in the right-hand operand into rhs
HasPtr& HasPtr::operator=(HasPtr rhs)
{
  // swap the contents of the left-hand operand with the local variable rhs
  swap(*this, rhs); // rhs now points to the memory this object had used
  return *this; // rhs is destroyed, which deletes the pointer in rhs
}

In this version of the assignment operator, the parameter is not a reference. Instead, we pass the right-hand operand by value. Thus, rhs is a copy of the right-hand operand. Copying a HasPtr allocates a new copy of that object‚Äôs string.

In the body of the assignment operator, we call swap, which swaps the data members of rhs with those in *this. This call puts the pointer that had been in the left-hand operand into rhs, and puts the pointer that was in rhs into *this. Thus,
after the swap, the pointer member in *this points to the newly allocated string that is a copy of the right-hand operand.

When the assignment operator finishes, rhs is destroyed and the HasPtr destructor is run. That destructor deletes the memory to which rhs now points, thus freeing the memory to which the left-hand operand had pointed.

The interesting thing about this technique is that it automatically handles self assignment and is automatically exception safe. By copying the right-hand operand before changing the left-hand operand, it handles self assignment in the same was as we did in our original assignment operator. It manages exception safety in the same way as the original definition as well. The only code that might throw is the new expression inside the copy constructor. If an exception occurs, it will happen before we have changed the left-hand operand

Tip:  Assignment operators that use copy and swap are automatically exception safe and correctly handle self-assignment

--
Best Practices:  The copy-assignment operator often does the same work as is needed in the copy constructor and destructor. In such cases, the common work should be put in private utility functions.

--
Classes That Manage Dynamic Memory

Some classes need to allocate a varying amount of storage at run time. Such classes often can (and if they can, generally should) use a library container to hold their data. For example, our StrBlob class uses a vector to manage the underlying storage for its elements.

However, this strategy does not work for every class; some classes need to do their own allocation. Such classes generally must define their own copy-control members to
manage the memory they allocate.

As an example, we‚Äôll implement a simplification of the library vector class. Among the simplifications we‚Äôll make is that our class will not be a template. Instead, our class will hold strings. Thus, we‚Äôll call our class StrVec.

--
StrVec Class Design

Recall that the vector class stores its elements in contiguous storage. To obtain acceptable performance, vector preallocates enough storage to hold more elements than are needed. Each vector member that adds elements checks whether there is space available for another element. If so, the member constructs an
object in the next available spot. If there isn‚Äôt space left, then the vector is reallocated: The vector obtains new space, moves the existing elements into that space, frees the old space, and adds the new element. We‚Äôll use a similar strategy in our StrVec class.

==
Move Constructors and std::move

We can avoid copying the strings by using two facilities introduced by the new library. First, several of the library classes, including string, define so-called ‚Äúmove constructors.‚Äù The details of how the string move constructor works‚Äîlike any other detail about the implementation‚Äîare not disclosed. However, we do know that move constructors typically operate by ‚Äúmoving‚Äù resources from the given object to the object being constructed. We also know that the library guarantees that the ‚Äúmoved-from‚Äù string remains in a valid, destructible state. For string, we can imagine that each string has a pointer to an array of char. Presumably the string move constructor copies the pointer rather than allocating space for and copying the characters themselves.

The second facility we‚Äôll use is a library function named move, which is defined in the utility header. For now, there are two important points to know about move.

First, for reasons we‚Äôll explain later, when reallocate constructs the strings in the new memory it must call move to signal that it wants to use the string move constructor. If it omits the call to move the string the copy constructor will be used. Second, for reasons we‚Äôll cover later, we usually do not provide a using declaration for move. When we use move, we call std::move, not move.

--
Moving Objects

One of the major features in the new standard is the ability to move rather than copy an object. As we saw later, copies are made in many circumstances. In some of these circumstances, an object is immediately destroyed after it is copied. In those cases, moving, rather than copying, the object can provide a significant performance boost.

As we‚Äôve just seen, our StrVec class is a good example of this kind of superfluous copy. During reallocation, there is no need to copy‚Äîrather than move‚Äîthe elements from the old memory to the new. A second reason to move rather than copy occurs in
classes such as the IO or unique_ptr classes. These classes have a resource (such as a pointer or an IO buffer) that may not be shared. Hence, objects of these types can‚Äôt be copied but can be moved.

Under earlier versions of the language, there was no direct way to move an object. We had to make a copy even if there was no need for the copy. If the objects are large, or if the objects themselves require memory allocation (e.g., strings), making a needless copy can be expensive. Similarly, in previous versions of the library, classes stored in a container had to be copyable. Under the new standard, we can use containers on types that cannot be copied so long as they can be moved.

Note: The library containers, string, and shared_ptr classes support move as well as copy. The IO and unique_ptr classes can be moved but not copied.

--
Rvalue References

To support move operations, the new standard introduced a new kind of reference, an rvalue reference. An rvalue reference is a reference that must be bound to an rvalue. An rvalue reference is obtained by using && rather than &. As we‚Äôll see, rvalue references have the important property that they may be bound only to an object that is about to be destroyed. As a result, we are free to ‚Äúmove‚Äù resources from an rvalue
reference to another object.

Recall that lvalue and rvalue are properties of an expression. Some expressions yield or require lvalues; others yield or require rvalues. Generally speaking, an lvalue expression refers to an object‚Äôs identity whereas an rvalue expression refers to an object‚Äôs value.

Like any reference, an rvalue reference is just another name for an object. As we know, we cannot bind regular references‚Äîwhich we‚Äôll refer to as lvalue references when we need to distinguish them from rvalue references‚Äîto expressions that require a conversion, to literals, or to expressions that return an rvalue.  Rvalue references have the opposite binding properties: We can bind an rvalue reference to these kinds of expressions, but we cannot directly bind an rvalue reference to an lvalue:

int i = 42;
int &r = i; // ok: r refers to i
int &&rr = i; // error: cannot bind an rvalue reference to an
lvalue

int &r2 = i * 42; // error: i * 42 is an rvalue
const int &r3 = i * 42; // ok: we can bind a reference to const to an
rvalue
int &&rr2 = i * 42; // ok: bind rr2 to the result of the multiplication

Functions that return lvalue references, along with the assignment, subscript, dereference, and prefix increment/decrement operators, are all examples of expressions that return lvalues. We can bind an lvalue reference to the result of any of these expressions.

Functions that return a nonreference type, along with the arithmetic, relational, bitwise, and postfix increment/decrement operators, all yield rvalues. We cannot bind an lvalue reference to these expressions, but we can bind either an lvalue reference to const or an rvalue reference to such expressions.

--
Lvalues Persist; Rvalues Are Ephemeral

Looking at the list of lvalue and rvalue expressions, it should be clear that lvalues and rvalues differ from each other in an important manner: Lvalues have persistent state,
whereas rvalues are either literals or temporary objects created in the course of evaluating expressions.

Because rvalue references can only be bound to temporaries, we know that
‚Ä¢ The referred-to object is about to be destroyed
‚Ä¢ There can be no other users of that object

These facts together mean that code that uses an rvalue reference is free to take over resources from the object to which the reference refers.

Note: Rvalue references refer to objects that are about to be destroyed. Hence, we can ‚Äústeal‚Äù state from an object bound to an rvalue reference.

--
Variables Are Lvalues

Although we rarely think about it this way, a variable is an expression with one operand and no operator. Like any other expression, a variable expression has the lvalue/rvalue property. Variable expressions are lvalues. It may be surprising, but as a consequence, we cannot bind an rvalue reference to a variable defined as an rvalue reference type:

int &&rr1 = 42; // ok: literals are rvalues
int &&rr2 = rr1; // error: the expression rr1 is an lvalue!

Given our previous observation that rvalues represent ephemeral objects, it should not be surprising that a variable is an lvalue. After all, a variable persists until it goes out
of scope.

Note: A variable is an lvalue; we cannot directly bind an rvalue reference to a variable even if that variable was defined as an rvalue reference type.

--
The Library move Function

Although we cannot directly bind an rvalue reference to an lvalue, we can explicitly cast an lvalue to its corresponding rvalue reference type. We can also obtain an rvalue reference bound to an lvalue by calling a new library function named move, which is defined in the utility header. The move function uses facilities that we‚Äôll describe later to return an rvalue reference to its given object.

int &&rr3 = std::move(rr1); // ok

Calling move tells the compiler that we have an lvalue that we want to treat as if it were an rvalue. It is essential to realize that the call to move promises that we do not intend to use rr1 again except to assign to it or to destroy it. After a call to move, we cannot make any assumptions about the value of the moved-from object.

Note: We can destroy a moved-from object and can assign a new value to it, but we cannot use the value of a moved-from object.

As we‚Äôve seen, differently from how we use most names from the library, we do not provide a using declaration for move. We call std::move not move. We‚Äôll explain the reasons for this usage later.

Warning: Code that uses move should use std::move, not move. Doing so avoids potential name collisions.

--
Move Constructor and Move Assignment

Like the string class (and other library classes), our own classes can benefit from being able to be moved as well as copied. To enable move operations for our own types, we define a move constructor and a move-assignment operator. These members are similar to the corresponding copy operations, but they ‚Äústeal‚Äù resources from their given object rather than copy them.

Like the copy constructor, the move constructor has an initial parameter that is a reference to the class type. Differently from the copy constructor, the reference parameter in the move constructor is an rvalue reference. As in the copy constructor,
any additional parameters must all have default arguments.

In addition to moving resources, the move constructor must ensure that the movedfrom object is left in a state such that destroying that object will be harmless. In particular, once its resources are moved, the original object must no longer point to those moved resources‚Äîresponsibility for those resources has been assumed by the newly created object.

As an example, we‚Äôll define the StrVec move constructor to move rather than copy the elements from one StrVec to another:

StrVec::StrVec(StrVec &&s) noexcept // move won't throw any
exceptions
  // member initializers take over the resources in s: elements(s.elements), first_free(s.first_free), cap(s.cap)
{
  // leave s in a state in which it is safe to run the destructor
  s.elements = s.first_free = s.cap = nullptr;
}

We‚Äôll explain the use of noexcept (which signals that our constructor does not throw any exceptions) shortly, but let‚Äôs first look at what this constructor does.

Unlike the copy constructor, the move constructor does not allocate any new memory; it takes over the memory in the given StrVec. Having taken over the memory from its argument, the constructor body sets the pointers in the given object to nullptr. After an object is moved from, that object continues to exist. Eventually, the moved-from object will be destroyed, meaning that the destructor will be run on that object. The StrVec destructor calls deallocate on first_free. If we neglected to change s.first_free, then destroying the moved-from object would delete the memory we just moved.

--
Move Operations, Library Containers, and Exceptions

Because a move operation executes by ‚Äústealing‚Äù resources, it ordinarily does not itself allocate any resources. As a result, move operations ordinarily will not throw any exceptions. When we write a move operation that cannot throw, we should inform the library of that fact. As we‚Äôll see, unless the library knows that our move constructor won‚Äôt throw, it will do extra work to cater to the possibliity that moving an object of our class type might throw.

One way inform the library is to specify noexcept on our constructor. We‚Äôll cover noexcept, which was introduced by the new standard, in more detail later. For now what‚Äôs important to know is that noexcept is a way for us to promise that a function does not throw any exceptions. We specify noexcept on a function after its parameter list. In a constructor, noexcept appears between the parameter list and the : that begins the constructor initializer list:

class StrVec {
public:
  StrVec(StrVec&&) noexcept; // move constructor
  // other members as before
};

StrVec::StrVec(StrVec &&s) noexcept : /* member initializers */
{ /* constructor body */ }

We must specify noexcept on both the declaration in the class header and on the definition if that definition appears outside the class.

Note: Move constructors and move assignment operators that cannot throw exceptions should be marked as noexcept.

Understanding why noexcept is needed can help deepen our understanding of how the library interacts with objects of the types we write. We need to indicate that a move operation doesn‚Äôt throw because of two interrelated facts: First, although move operations usually don‚Äôt throw exceptions, they are permitted to do so. Second, the library containers provide guarantees as to what they do if an exception happens. As
one example, vector guarantees that if an exception happens when we call push_back, the vector itself will be left unchanged.

Now let‚Äôs think about what happens inside push_back. Like the corresponding StrVec operation, push_back on a vector might require that the vector be reallocated. When a vector is reallocated, it moves the elements from its old space to new memory, just as we did in reallocate.

As we‚Äôve just seen, moving an object generally changes the value of the movedfrom object. If reallocation uses a move constructor and that constructor throws an exception after moving some but not all of the elements, there would be a problem.

The moved-from elements in the old space would have been changed, and the unconstructed elements in the new space would not yet exist. In this case, vector would be unable to meet its requirement that the vector is left unchanged.

On the other hand, if vector uses the copy constructor and an exception happens, it can easily meet this requirement. In this case, while the elements are being constructed in the new memory, the old elements remain unchanged. If an exception
happens, vector can free the space it allocated (but could not successfully construct) and return. The original vector elements still exist.

To avoid this potential problem, vector must use a copy constructor instead of a move constructor during reallocation unless it knows that the element type‚Äôs move constructor cannot throw an exception. If we want objects of our type to be moved rather than copied in circumstances such as vector reallocation, we must explicity tell the library that our move constructor is safe to use. We do so by marking the move constructor (and move-assignment operator) noexcept.

--
Move-Assignment Operator

The move-assignment operator does the same work as the destructor and the move constructor. As with the move constructor, if our move-assignment operator won‚Äôt throw any exceptions, we should make it noexcept. Like a copy-assignment
operator, a move-assignment operator must guard against self-assignment:

StrVec &StrVec::operator=(StrVec &&rhs) noexcept
{
  // direct test for self-assignment
  if (this != &rhs) {
    free(); // free existing elements
    elements = rhs.elements; // take over resources from rhs
    first_free = rhs.first_free;
    cap = rhs.cap;
    // leave rhs in a destructible state
    rhs.elements = rhs.first_free = rhs.cap = nullptr;
  }
  return *this;
}

In this case we check directly whether the this pointer and the address of rhs are the same. If they are, the right- and left-hand operands refer to the same object and there is no work to do. Otherwise, we free the memory that the left-hand operand had used, and then take over the memory from the given object. As in the move constructor, we set the pointers in rhs to nullptr.

It may seem surprising that we bother to check for self-assignment. After all, move assignment requires an rvalue for the right-hand operand. We do the check because that rvalue could be the result of calling move. As in any other assignment operator, it is crucial that we not free the left-hand resources before using those (possibly same)
resources from the right-hand operand.

--
A Moved-from Object Must Be Destructible

Moving from an object does not destroy that object: Sometime after the move operation completes, the moved-from object will be destroyed. Therefore, when we write a move operation, we must ensure that the moved-from object is in a state in
which the destructor can be run. Our StrVec move operations meet this requirement by setting the pointer members of the moved-from object to nullptr.

In addition to leaving the moved-from object in a state that is safe to destroy, move operations must guarantee that the object remains valid. In general, a valid object is one that can safely be given a new value or used in other ways that do not depend on its current value. On the other hand, move operations have no requirements as to the value that remains in the moved-from object. As a result, our programs should
never depend on the value of a moved-from object.

For example, when we move from a library string or container object, we know that the moved-from object remains valid. As a result, we can run operations such as as empty or size on moved-from objects. However, we don‚Äôt know what result we‚Äôll
get. We might expect a moved-from object to be empty, but that is not guaranteed.

Our StrVec move operations leave the moved-from object in the same state as a default-initialized object. Therefore, all the operations of StrVec will continue to run the same way as they do for any other default-initialized StrVec. Other classes, with more complicated internal structure, may behave differently.

Warning: After a move operation, the ‚Äúmoved-from‚Äù object must remain a valid, destructible object but users may make no assumptions about its value.

--
The Synthesized Move Operations

As it does for the copy constructor and copy-assignment operator, the compiler will synthesize the move constructor and move-assignment operator. However, the conditions under which it synthesizes a move operation are quite different from those in which it synthesizes a copy operation.

Recall that if we do not declare our own copy constructor or copy-assignment operator the compiler always synthesizes these operations. The copy operations are defined either to memberwise copy or assign the object or they are defined as deleted functions.

Differently from the copy operations, for some classes the compiler does not synthesize the move operations at all. In particular, if a class defines its own copy constructor, copy-assignment operator, or destructor, the move constructor and moveassignment operator are not synthesized. As a result, some classes do not have a move constructor or a move-assignment operator. As we‚Äôll see later, when a
class doesn‚Äôt have a move operation, the corresponding copy operation is used in place of move through normal function matching.

The compiler will synthesize a move constructor or a move-assignment operator only if the class doesn‚Äôt define any of its own copy-control members and if every nonstatic data member of the class can be moved. The compiler can move members of built-in type. It can also move members of a class type if the member‚Äôs class has the corresponding move operation:

// the compiler will synthesize the move operations for X and hasX
struct X {
  int i; // built-in types can be moved
  std::string s; // string defines its own move operations
};

struct hasX {
  X mem; // X has synthesized move operations
};

X x, x2 = std::move(x); // uses the synthesized move constructor
hasX hx, hx2 = std::move(hx); // uses the synthesized move constructor

Note: The compiler synthesizes the move constructor and move assignment only if a class does not define any of its own copy-control members and only if all the data members can be moved constructed and move assigned, respectively.

Unlike the copy operations, a move operation is never implicitly defined as a deleted function. However, if we explicitly ask the compiler to generate a move operation by
using = default, and the compiler is unable to move all the
members, then the move operation will be defined as deleted. With one important exception, the rules for when a synthesized move operation is defined as deleted are analogous to those for the copy operations:

‚Ä¢ Unlike the copy constructor, the move constructor is defined as deleted if the class has a member that defines its own copy constructor but does not also define a move constructor, or if the class has a member that doesn‚Äôt define its own copy operations and for which the compiler is unable to synthesize a move constructor. Similarly for move-assignment.

‚Ä¢ The move constructor or move-assignment operator is defined as deleted if the class has a member whose own move constructor or move-assignment operator is deleted or inaccessible.

‚Ä¢ Like the copy constructor, the move constructor is defined as deleted if the destructor is deleted or inaccessible.

‚Ä¢ Like the copy-assignment operator, the move-assignment operator is defined as deleted if the class has a const or reference member.

For example, assuming Y is a class that defines its own copy constructor but does not also define its own move constructor:

// assume Y is a class that defines its own copy constructor but not a move constructor
struct hasY {
  hasY() = default;
  hasY(hasY&&) = default;
  Y mem; // hasY will have a deleted move constructor
};

hasY hy, hy2 = std::move(hy); // error: move constructor is deleted

The compiler can copy objects of type Y but cannot move them. Class hasY explicitly requested a move constructor, which the compiler is unable to generate. Hence, hasY will get a deleted move constructor. Had hasY omitted the declaration of its move
constructor, then the compiler would not synthesize the hasY move constructor at all. The move operations are not synthesized if they would otherwise be defined as deleted.

There is one final interaction between move operations and the synthesized copycontrol members: Whether a class defines its own move operations has an impact on how the copy operations are synthesized. If the class defines either a move constructor and/or a move-assignment operator, then the synthesized copy constructor and copy-assignment operator for that class will be defined as deleted.

Note: Classes that define a move constructor or move-assignment operator must also define their own copy operations. Otherwise, those members are deleted by default.

--
Rvalues Are Moved, Lvalues Are Copied ...

When a class has both a move constructor and a copy constructor, the compiler uses ordinary function matching to determine which constructor to use. Similarly for assignment. For example, in our StrVec class the copy versions take a reference to const StrVec. As a result, they can be used on any type that can be converted to StrVec. The move versions take a StrVec&& and can be used only when the argument is a (nonconst) rvalue:

StrVec v1, v2;
v1 = v2; // v2 is an lvalue; copy assignment
StrVec getVec(istream &); // getVec returns an rvalue
v2 = getVec(cin); // getVec(cin) is an rvalue; move assignment

In the first assignment, we pass v2 to the assignment operator. The type of v2 is StrVec and the expression, v2, is an lvalue. The move version of assignment is not viable, because we cannot implicitly bind an rvalue reference to an
lvalue. Hence, this assignment uses the copy-assignment operator.

In the second assignment, we assign from the result of a call to getVec. That expression is an rvalue. In this case, both assignment operators are viable‚Äîwe can bind the result of getVec to either operator‚Äôs parameter. Calling the copy-assignment operator requires a conversion to const, whereas StrVec&& is an exact match. Hence, the second assignment uses the move-assignment operator.

--
...But Rvalues Are Copied If There Is No Move Constructor

What if a class has a copy constructor but does not define a move constructor? In this case, the compiler will not synthesize the move constructor, which means the class
has a copy constructor but no move constructor. If a class has no move constructor, function matching ensures that objects of that type are copied, even if we attempt to move them by calling move:

class Foo {
public:
  Foo() = default;
  Foo(const Foo&); // copy constructor
  // other members, but Foo does not define a move constructor
};
Foo x;
Foo y(x); // copy constructor; x is an lvalue
Foo z(std::move(x)); // copy constructor, because there is no move constructor

The call to move(x) in the initialization of z returns a Foo&& bound to x. The copy constructor for Foo is viable because we can convert a Foo&& to a const Foo&. Thus, the initialization of z uses the copy constructor for Foo.

It is worth noting that using the copy constructor in place of a move constructor is almost surely safe (and similarly for the assignment operators). Ordinarily, the copy constructor will meet the requirements of the corresponding move constructor: It will copy the given object and leave that original object in a valid state. Indeed, the copy constructor won‚Äôt even change the value of the original object.

Note: If a class has a usable copy constructor and no move constructor, objects will be ‚Äúmoved‚Äù by the copy constructor. Similarly for the copy-assignment operator and move-assignment.

--
Advice: Updating the Rule of Three

All five copy-control members should be thought of as a unit: Ordinarily, if a class defines any of these operations, it usually should define them all. As we‚Äôve seen, some classes must define the copy constructor, copy-assignment operator, and destructor to work correctly. Such classes typically have a resource that the copy members must copy. Ordinarily, copying a resource entails some amount of overhead. Classes that define the move constructor and move-assignment operator can avoid this overhead in those circumstances where a copy isn‚Äôt necessary.

--
Move Operations for the Message Class

Classes that define their own copy constructor and copy-assignment operator generally also benefit by defining the move operations. For example, our Message and Folder classes should define move operations. By defining move
operations, the Message class can use the string and set move operations to avoid the overhead of copying the contents and folders members.

However, in addition to moving the folders member, we must also update each Folder that points to the original Message. We must remove pointers to the old Message and add a pointer to the new one.

Both the move constructor and move-assignment operator need to update the Folder pointers, so we‚Äôll start by defining an operation to do this common work:

// move the Folder pointers from m to this Message
void Message::move_Folders(Message *m)
{
  folders = std::move(m->folders); // uses set move assignment
  for (auto f : folders) { // for each Folder
    f->remMsg(m); // remove the old Message from the Folder
    f->addMsg(this); // add this Message to that Folder
  }
  m->folders.clear(); // ensure that destroying m is harmless
}

This function begins by moving the folders set. By calling move, we use the set move assignment rather than its copy assignment. Had we omitted the call to move, the code would still work, but the copy is unnecessary. The function then iterates through those Folders, removing the pointer to the original Message and adding a pointer to the new Message.

It is worth noting that inserting an element to a set might throw an exception‚Äî adding an element to a container requires memory to be allocated, which means that a bad_alloc exception might be thrown. As a result, unlike our HasPtr and StrVec move operations, the Message move constructor and move-assignment operators might throw exceptions. We will not mark them as noexcept.

The function ends by calling clear on m.folders. After the move, we know that m.folders is valid but have no idea what its contents are. Because the Message destructor iterates through folders, we want to be certain that the set is empty.
The Message move constructor calls move to move the contents and default initializes its folders member:

Message::Message(Message &&m):
contents(std::move(m.contents))
{
  move_Folders(&m); // moves folders and updates the Folder pointers
}

In the body of the constructor, we call move_Folders to remove the pointers to m and insert pointers to this Message.

The move-assignment operator does a direct check for self-assignment:

Message& Message::operator=(Message &&rhs)
{
  if (this != &rhs) { // direct check for self-assignment
    remove_from_Folders();
    contents = std::move(rhs.contents); // move assignment
    move_Folders(&rhs); // reset the Folders to point to this Message
  }
  return *this;
}

As with any assignment operator, the move-assignment operator must destroy the old state of the left-hand operand. In this case, destroying the left-hand operand requires that we remove pointers to this Message from the existing folders, which we do in the call to remove_from_Folders. Having removed itself from its Folders, we call move to move the contents from rhs to this object. What remains is to call move_Messages to update the Folder pointers.

--
Move Iterators

The reallocate member of StrVec used a for loop to call
construct to copy the elements from the old memory to the new. As an alternative to writing that loop, it would be easier if we could call uninitialized_copy to construct the newly allocated space. However, uninitialized_copy does what it
says: It copies the elements. There is no analogous library function to ‚Äúmove‚Äù objects into unconstructed memory.

Instead, the new library defines a move iterator adaptor. A move iterator adapts its given iterator by changing the behavior of the iterator‚Äôs dereference operator. Ordinarily, an iterator dereference operator returns an lvalue reference to
the element. Unlike other iterators, the dereference operator of a move iterator yields an rvalue reference.

We transform an ordinary iterator to a move iterator by calling the library make_move_iterator function. This function takes an iterator and returns a move iterator.

All of the original iterator‚Äôs other operations work as usual. Because these iterators support normal iterator operations, we can pass a pair of move iterators to an algorithm. In particular, we can pass move iterators to uninitialized_copy:

void StrVec::reallocate()
{
  // allocate space for twice as many elements as the current size
  auto newcapacity = size() ? 2 * size() : 1;
  auto first = alloc.allocate(newcapacity);
  // move the elements
  auto last =
  uninitialized_copy(make_move_iterator(begin()),
  make_move_iterator(end()),
  first);
  free(); // free the old space
  elements = first; // update the pointers
  first_free = last;
  cap = elements + newcapacity;
}

uninitialized_copy calls construct on each element in the input sequence to ‚Äúcopy‚Äù that element into the destination. That algorithm uses the iterator dereference operator to fetch elements from the input sequence. Because we passed move
iterators, the dereference operator yields an rvalue reference, which means construct will use the move constructor to construct the elements.

It is worth noting that standard library makes no guarantees about which algorithms can be used with move iterators and which cannot. Because moving an object can obliterate the source, you should pass move iterators to algorithms only when you are confident that the algorithm does not access an element after it has assigned to that element or passed that element to a user-defined function.

Advice: Don‚Äôt Be Too Quick to Move

Because a moved-from object has indeterminate state, calling std::move on an object is a dangerous operation. When we call move, we must be absolutely certain that there can be no other users of the moved-from object.

Judiciously used inside class code, move can offer significant performance benefits. Casually used in ordinary user code (as opposed to class implementation code), moving an object is more likely to lead to mysterious and hard-to-find bugs than to any improvement in the performance of the application.

Best Practices: Outside of class implementation code such as move constructors or move-assignment operators, use std::move only when you are certain that you need to do a move and that the move is guaranteed to be safe.

--
Rvalue References and Member Functions

Member functions other than constructors and assignment can benefit from providing both copy and move versions. Such move-enabled members typically use the same parameter pattern as the copy/move constructor and the assignment operators‚Äîone
version takes an lvalue reference to const, and the second takes an rvalue reference to nonconst.

For example, the library containers that define push_back provide two versions: one that has an rvalue reference parameter and the other a const lvalue reference. Assuming X is the element type, these containers define:

void push_back(const X&); // copy: binds to any kind of X
void push_back(X&&); // move: binds only to modifiable rvalues of type X

We can pass any object that can be converted to type X to the first version of push_back. This version copies data from its parameter. We can pass only an rvalue that is not const to the second version. This version is an exact match (and a better
match) for nonconst rvalues and will be run when we pass a modifiable rvalue. This version is free to steal resources from its parameter.

Ordinarily, there is no need to define versions of the operation that take a const X&& or a (plain) X&. Usually, we pass an rvalue reference when we want to ‚Äústeal‚Äù from the argument. In order to do so, the argument must not be const. Similarly, copying from an object should not change the object being copied. As a result, there is usually no need to define a version that take a (plain) X& parameter.

Note: Overloaded functions that distinguish between moving and copying a parameter typically have one version that takes a const T& and one that takes a T&&.

As a more concrete example, we‚Äôll give our StrVec class a second version of push_back:

class StrVec {
public:
  void push_back(const std::string&); // copy the element
  void push_back(std::string&&); // move the element

  // other members as before
};

// unchanged from the original version in ¬ß 13.5 (p. 527)
void StrVec::push_back(const string& s)
{
  chk_n_alloc(); // ensure that there is room for another element
  // construct a copy of s in the element to which first_free points
  alloc.construct(first_free++, s);
}
void StrVec::push_back(string &&s)
{
  chk_n_alloc(); // reallocates the StrVec if necessary
  alloc.construct(first_free++, std::move(s));
}

These members are nearly identical. The difference is that the rvalue reference version of push_back calls move to pass its parameter to construct. As we‚Äôve seen, the construct function uses the type of its second and subsequent arguments to determine which constructor to use. Because move returns an rvalue reference, the type of the argument to construct is string&&. Therefore, the string move constructor will be used to construct a new last element.

When we call push_back the type of the argument determines whether the new element is copied or moved into the container:

StrVec vec; // empty StrVec
string s = "some string or another";
vec.push_back(s); // calls push_back(const string&)
vec.push_back("done"); // calls push_back(string&&)

These calls differ as to whether the argument is an lvalue (s) or an rvalue (the temporary string created from "done"). The calls are resolved accordingly.

--
Rvalue and Lvalue Reference Member Functions

Ordinarily, we can call a member function on an object, regardless of whether that object is an lvalue or an rvalue. For example:

string s1 = "a value", s2 = "another";
auto n = (s1 + s2).find('a');

Here, we called the find member on the string rvalue that results from adding two strings. Sometimes such usage can be surprising:

s1 + s2 = "wow!";

Here we assign to the rvalue result of concatentating these strings.

Prior to the new standard, there was no way to prevent such usage. In order to maintain backward compatability, the library classes continue to allow assignment to rvalues, However, we might want to prevent such usage in our own classes. In this case, we‚Äôd like to force the left-hand operand (i.e., the object to which this points) to be an lvalue.

We indicate the lvalue/rvalue property of this in the same way that we define const member functions; we place a reference qualifier after the parameter list:

class Foo {
public:
  Foo &operator=(const Foo&) &; // may assign only to modifiable
  lvalues
  // other members of Foo
};

Foo &Foo::operator=(const Foo &rhs) &
{
  // do whatever is needed to assign rhs to this object
  return *this;
}

The reference qualifier can be either & or &&, indicating that this may point to an rvalue or lvalue, respectively. Like the const qualifier, a reference qualifier may appear only on a (nonstatic) member function and must appear in both the
declaration and definition of the function.

We may run a function qualified by & only on an lvalue and may run a function qualified by && only on an rvalue:

  Foo &retFoo(); // returns a reference; a call to retFoo is an lvalue
  Foo retVal(); // returns by value; a call to retVal is an rvalue
  Foo i, j; // i and j are lvalues
  i = j; // ok: i is an lvalue
  retFoo() = j; // ok: retFoo() returns an lvalue
  retVal() = j; // error: retVal() returns an rvalue
  i = retVal(); // ok: we can pass an rvalue as the right-hand operand to assignment

A function can be both const and reference qualified. In such cases, the reference qualifier must follow the const qualifier:

class Foo {
public:
  Foo someMem() & const; // error: const qualifier must come first
  Foo anotherMem() const &; // ok: const qualifier comes first
};

--
Overloading and Reference Functions

Just as we can overload a member function based on whether it is const, we can also overload a function based on its reference qualifier. Moreover, we may overload a function by its reference qualifier and by whether it is a const
member. As an example, we‚Äôll give Foo a vector member and a function named sorted that returns a copy of the Foo object in which the vector is sorted:

class Foo {
public:
  Foo sorted() &&; // may run on modifiable rvalues
  Foo sorted() const &; // may run on any kind of Foo
  // other members of Foo
private:
  vector<int> data;
};

// this object is an rvalue, so we can sort in place
Foo Foo::sorted() &&
{
  sort(data.begin(), data.end());
  return *this;
}
// this object is either const or it is an lvalue; either way we can't sort in place
Foo Foo::sorted() const & {
  Foo ret(*this); // make a copy
  sort(ret.data.begin(), ret.data.end()); // sort the copy
  return ret; // return the copy
}

When we run sorted on an rvalue, it is safe to sort the data member directly. The object is an rvalue, which means it has no other users, so we can change the object itself. When we run sorted on a const rvalue or on an lvalue, we can‚Äôt change this object, so we copy data before sorting it.

Overload resolution uses the lvalue/rvalue property of the object that calls sorted to determine which version is used:

retVal().sorted(); // retVal() is an rvalue, calls Foo::sorted() &&
retFoo().sorted(); // retFoo() is an lvalue, calls Foo::sorted() const &

When we define const memeber functions, we can define two versions that differ only in that one is const qualified and the other is not. There is no similar default for reference qualified functions. When we define two or more members that have the same name and the same parameter list, we must provide a reference qualifier on all or none of those functions:

class Foo {
public:
  Foo sorted() &&;
  Foo sorted() const; // error: must have reference qualifier
  // Comp is type alias for the function type (see ¬ß 6.7 (p. 249))
  // that can be used to compare int values
  using Comp = bool(const int&, const int&);
  Foo sorted(Comp*); // ok: different parameter list
  Foo sorted(Comp*) const; // ok: neither version is reference qualified
};

Here the declaration of the const version of sorted that has no parameters is an error. There is a second version of sorted that has no parameters and that function has a reference qualifier, so the const version of that function must have a reference qualifier as well. On the other hand, the versions of sorted that take a pointer to a comparison operation are fine, because neither function has a qualifier.

Note: If a member function has a reference qualifier, all the versions of that member with the same parameter list must have reference qualifiers.

==
(findoverload)
Overloaded Operations and Conversions

Earlier we saw that C++ defines a large number of operators and automatic conversions among the built-in types. These facilities allow programmers to write a rich set of mixed-type expressions.

C++ lets us define what the operators mean when applied to objects of class type. It also lets us define conversions for class types. Class-type conversions are used like the built-in conversions to implicitly convert an object of one type to another type when needed.

Operator overloading lets us define the meaning of an operator when applied to operand(s) of a class type. Judicious use of operator overloading can make our programs easier to write and easier to read. As an example, because our original Sales_item class type defined the input, output, and addition operators, we can print the sum of two Sales_items as 

cout << item1 + item2; // print the sum of two Sales_items

In contrast, because our Sales_data class does not yet have overloaded operators, code to print their sum is more verbose and, hence, less clear:

print(cout, add(data1, data2)); // print the sum of two Sales_datas

--
Basic Concepts

Overloaded operators are functions with special names: the keyword operator followed by the symbol for the operator being defined. Like any other function, an overloaded operator has a return type, a parameter list, and a body.

An overloaded operator function has the same number of parameters as the operator has operands. A unary operator has one parameter; a binary operator has two. In a binary operator, the left-hand operand is passed to the first parameter and the right-hand operand to the second. Except for the overloaded function-call operator, operator(), an overloaded operator may not have default arguments.

If an operator function is a member function, the first (left-hand) operand is bound to the implicit this pointer. Because the first operand is implicitly bound to this, a member operator function has one less (explicit) parameter than
the operator has operands.

Note: When an overloaded operator is a member function, this is bound to the left-hand operand. Member operator functions have one less (explicit) parameter than the number of operands.
An operator function must either be a member of a class or have at least one parameter of class type:

// error: cannot redefine the built-in operator for ints
int operator+(int, int);

This restriction means that we cannot change the meaning of an operator when applied to operands of built-in type.

We can overload most, but not all, of the operators. Table below (tao: omitted) shows whether or not an operator may be overloaded. We‚Äôll cover overloading new and delete later.

We can overload only existing operators and cannot invent new operator symbols. For example, we cannot define operator** to provide exponentiation.

Four symbols (+, -, *, and &) serve as both unary and binary operators. Either or both of these operators can be  verloaded. The number of parameters determines which operator is being defined.

An overloaded operator has the same precedence and associativity as the corresponding built-in operator. Regardless of the operand types

x == y + z;

is always equivalent to x == (y + z).

--
Calling an Overloaded Operator Function Directly

Ordinarily, we ‚Äúcall‚Äù an overloaded operator function indirectly by using the operator on arguments of the appropriate type. However, we can also call an overloaded
operator function directly in the same way that we call an ordinary function. We name the function and pass an appropriate number of arguments of the appropriate type:

// equivalent calls to a nonmember operator function
data1 + data2; // normal expression
operator+(data1, data2); // equivalent function call

These calls are equivalent: Both call the nonmember function operator+, passing data1 as the first argument and data2 as the second.

We call a member operator function explicitly in the same way that we call any other member function. We name an object (or pointer) on which to run the function and use the dot (or arrow) operator to fetch the function we wish to call:

data1 += data2; // expression-based ''call''
data1.operator+=(data2); // equivalent call to a member operator function

Each of these statements calls the member function operator+=, binding this to the address of data1 and passing data2 as an argument.

--
Some Operators Shouldn‚Äôt Be Overloaded

Recall that a few operators guarantee the order in which operands are evaluated. Because using an overloaded operator is really a function call, these guarantees do not apply to overloaded operators. In particular, the operand-evaluation guarantees of the logical AND, logical OR, and comma operators are not preserved. Moreover, overloaded versions of && or || operators do not preserve short-circuit evaluation properties of the built-in operators. Both operands are always evaluated.

Because the overloaded versions of these operators do not preserve order of evaluation and/or short-circuit evaluation, it is usually a bad idea to overload them. Users are likely to be surprised when the evaluation guarantees they are accustomed
to are not honored for code that happens to use an overloaded version of one of these operators.

Another reason not to overload comma, which also applies to the address-of operator, is that unlike most operators, the language defines what the comma and address-of operators mean when applied to objects of class type. Because these operators have built-in meaning, they ordinarily should not be overloaded. Users of the class will be surprised if these operators behave differently from their normal meanings.

Best Practices: Ordinarily, the comma, address-of, logical AND, and logical OR operators should not be overloaded.

--
Use Definitions That Are Consistent with the Built-in Meaning

When you design a class, you should always think first about what operations the class will provide. Only after you know what operations are needed should you think about whether to define each operation as an ordinary function or as an overloaded operator. Those operations with a logical mapping to an operator are good candidates for defining as overloaded operators:

‚Ä¢ If the class does IO, define the shift operators to be consistent with how IO is done for the built-in types.

‚Ä¢ If the class has an operation to test for equality, define operator==. If the class has operator==, it should usually have operator!= as well.

‚Ä¢ If the class has a single, natural ordering operation, define operator<. If the class has operator<, it should probably have all of the relational operators.

‚Ä¢ The return type of an overloaded operator usually should be compatible with the return from the built-in version of the operator: The logical and relational operators should return bool, the arithmetic operators should return a value of the class type, and assignment and compound assignment should return a reference to the left-hand operand.

--
Assignment and Compound Assignment Operators

Assignment operators should behave analogously to the synthesized operators: After an assignment, the values in the left-hand and right-hand operands should have the same value, and the operator should return a reference to its left-hand operand. Overloaded assignment should generalize the built-in meaning of assignment, not circumvent it.

Caution: Use Operator Overloading Judiciously

Each operator has an associated meaning from its use on the built-in types. Binary +, for example, is strongly identified with addition. Mapping binary + to an analogous operation for a class type can provide a convenient notational shorthand. For example, the library string type, following a convention common to many programming languages, uses + to represent concatenation‚Äî‚Äúadding‚Äù one string to the other.

Operator overloading is most useful when there is a logical mapping of a built-in operator to an operation on our type. Using overloaded operators rather than inventing named operations can make our programs more natural and intuitive. Overuse or outright abuse of operator overloading can make
our classes incomprehensible.

Obvious abuses of operator overloading rarely happen in practice. As an example, no responsible programmer would define operator+ to perform subtraction. More common, but still inadvisable, are uses that contort an operator‚Äôs ‚Äúnormal‚Äù meaning to force a fit to a given type. Operators should be used only for operations that are likely to be unambiguous to users. An operator has an ambiguous meaning if it plausibly has more than one interpretation.

If a class has an arithmetic or bitwise operator, then it is usually a good idea to provide the corresponding compound-assignment operator as well. Needless to say, the += operator should be defined to behave the same way the built-in operators do: it should behave as + followed by =.

--
Choosing Member or Nonmember Implementation

When we define an overloaded operator, we must decide whether to make the operator a class member or an ordinary nonmember function. In some cases, there is no choice‚Äîsome operators are required to be members; in other cases, we may not be able to define the operator appropriately if it is a member.

The following guidelines can be of help in deciding whether to make an operator a member or an ordinary nonmember function:

‚Ä¢ The assignment (=), subscript ([]), call (()), and member access arrow (->) operators must be defined as members.

‚Ä¢ The compound-assignment operators ordinarily ought to be members. However, unlike assignment, they are not required to be members.

‚Ä¢ Operators that change the state of their object or that are closely tied to their given type‚Äîsuch as increment, decrement, and dereference‚Äîusually should be members.

‚Ä¢ Symmetric operators‚Äîthose that might convert either operand, such as the arithmetic, equality, relational, and bitwise operators‚Äîusually should be defined as ordinary nonmember functions.

Programmers expect to be able to use symmetric operators in expressions with mixed types. For example, we can add an int and a double. The addition is symmetric because we can use either type as the left-hand or the right-hand operand.

If we want to provide similar mixed-type expressions involving class objects, then the operator must be defined as a nonmember function.

When we define an operator as a member function, then the left-hand operand must be an object of the class of which that operator is a member. For example:

string s = "world";
string t = s + "!"; // ok: we can add a const char* to a string
string u = "hi" + s; // would be an error if + were a member of string

If operator+ were a member of the string class, the first addition would be equivalent to s.operator+("!"). Likewise, "hi" + s would be equivalent to "hi".operator+(s). However, the type of "hi" is const char*, and that is a built-in type; it does not even have member functions.

Because string defines + as an ordinary nonmember function, "hi" + s is equivalent to operator+("hi", s). As with any function call, either of the arguments can be converted to the type of the parameter. The only requirements are that at least one of the operands has a class type, and that both operands can be converted (unambiguously) to string.

--
Input and Output Operators

As we‚Äôve seen, the IO library uses >> and << for input and output, respectively. The IO library itself defines versions of these operators to read and write the built-in types. Classes that support IO ordinarily define versions of these operators for objects of the class type.

Overloading the Output Operator <<

Ordinarily, the first parameter of an output operator is a reference to a nonconst ostream object. The ostream is nonconst because writing to the stream changes The second parameter ordinarily should be a reference to const of the class type we want to print. The parameter is a reference to avoid copying the argument. It can be const because (ordinarily) printing an object does not change that object.
To be consistent with other output operators, operator<< normally returns its ostream parameter.

--
The Sales_data Output Operator

As an example, we‚Äôll write the Sales_data output operator:

ostream &operator<<(ostream &os, const Sales_data &item)
{
	os << item.isbn() << " " << item.units_sold << " "
	<< item.revenue << " " << item.avg_price();
	return os;
}

Except for its name, this function is identical to our earlier print function. Printing a Sales_data entails printing its three data elements and the computed average sales price. Each element is separated by a space. After printing the values, the operator returns a reference to the ostream it just wrote.

--
Output Operators Usually Do Minimal Formatting

The output operators for the built-in types do little if any formatting. In particular, they do not print newlines. Users expect class output operators to behave similarly. If the operator does print a newline, then users would be unable to print descriptive text along with the object on the same line. An output operator that does minimal formatting lets users control the details of their output.

Best Practices: Generally, output operators should print the contents of the object, with minimal formatting. They should not print a newline.

--
IO Operators Must Be Nonmember Functions

Input and output operators that conform to the conventions of the iostream library must be ordinary nonmember functions. These operators cannot be members of our own class. If they were, then the left-hand operand would have to be an object of our class type:

Sales_data data;
data << cout; // if operator<< is a member of Sales_data

If these operators are members of any class, they would have to be members of istream or ostream. However, those classes are part of the standard library, and we cannot add members to a class in the library.

Thus, if we want to define the IO operators for our types, we must define them as nonmember functions. Of course, IO operators usually need to read or write the nonpublic data members. As a consequence, IO operators usually must be declared as friends.

--
Overloading the Input Operator >>

Ordinarily the first parameter of an input operator is a reference to the stream from which it is to read, and the second parameter is a reference to the (nonconst) object into which to read. The operator usually returns a reference to its given stream. The second parameter must be nonconst because the purpose of an input operator is to read data into this object.

The Sales_data Input Operator

As an example, we‚Äôll write the Sales_data input operator:

istream &operator>>(istream &is, Sales_data &item)
{
	double price; // no need to initialize; we'll read into price before we use it
	is >> item.bookNo >> item.units_sold >> price;
	if (is) // check that the inputs succeeded
		item.revenue = item.units_sold * price;
	else
		item = Sales_data(); // input failed: give the object the default state
	return is;
}

Except for the if statement, this definition is similar to our earlier read function. The if checks whether the reads were successful. If an IO error occurs, the operator resets its given object to the empty Sales_data. That way, the object is guaranteed to be in a consistent state.

Note: Input operators must deal with the possibility that the input might fail; output operators generally don‚Äôt bother.

--
Errors during Input

The kinds of errors that might happen in an input operator include the following:

‚Ä¢ A read operation might fail because the stream contains data of an incorrect type. For example, after reading bookNo, the input operator assumes that the next two items will be numeric data. If nonnumeric data is input, that read and any subsequent use of the stream will fail.

‚Ä¢ Any of the reads could hit end-of-file or some other error on the input stream. 

Rather than checking each read, we check once after reading all the data and before using those data:

if (is) // check that the inputs succeeded
	item.revenue = item.units_sold * price;
else
	item = Sales_data(); // input failed: give the object the default state

If any of the read operations fails, price will have an undefined value. Therefore, before using price, we check that the input stream is still valid. If it is, we do the calculation and store the result in revenue. If there was an error, we do not worry about which input failed. Instead, we reset the entire object to the empty Sales_data by assigning a new, default-initialized Sales_data object to item. After this assignment, item will have an empty string for its bookNo member, and its revenue and units_sold members will be zero.

Putting the object into a valid state is especially important if the object might have been partially changed before the error occurred. For example, in this input operator, we might encounter an error after successfully reading a new bookNo. An error after reading bookNo would mean that the units_sold and revenue members of the old those data.

By leaving the object in a valid state, we (somewhat) protect a user that ignores the possibility of an input error. The object will be in a usable state‚Äîits members are all defined. Similarly, the object won‚Äôt generate misleading results‚Äîits data are internally consistent.

Best Practices: Input operators should decide what, if anything, to do about error recovery.

--
Indicating Errors

Some input operators need to do additional data verification. For example, our input operator might check that the bookNo we read is in an appropriate format. In such cases, the input operator might need to set the stream‚Äôs condition state to indicate failure, even though technically speaking the actual IO was successful. Usually an input operator should set only the failbit. Setting eofbit would imply that the file was exhausted, and setting badbit would indicate that the stream was corrupted. These errors are best left to the IO library itself to indicate.

--
Arithmetic and Relational Operators

Ordinarily, we define the arithmetic and relational operators as nonmember functions in order to allow conversions for either the left- or right-hand operand. These operators shouldn‚Äôt need to change the state of either operand, so the
parameters are ordinarily references to const.

An arithmetic operator usually generates a new value that is the result of a computation on its two operands. That value is distinct from either operand and is calculated in a local variable. The operation returns a copy of this local as its result. Classes that define an arithmetic operator generally define the corresponding compound assignment operator as well. When a class has both operators, it is usually more efficient to define the arithmetic operator to use compound assignment:

// assumes that both objects refer to the same book
Sales_data
operator+(const Sales_data &lhs, const Sales_data &rhs)
{
	Sales_data sum = lhs; // copy data members from lhs into sum
	sum += rhs; // add rhs into sum
	return sum;
}

This definition is essentially identical to our original add function. We copy lhs into the local variable sum. We then use the Sales_data compound-assignment operator (which we‚Äôll define later) to add the values from rhs into sum. We end the function by returning a copy of sum.

Tip: Classes that define both an arithmetic operator and the related compound assignment ordinarily ought to implement the arithmetic operator by using the compound assignment.

--
Equality Operators

Ordinarily, classes in C++ define the equality operator to test whether two objects are equivalent. That is, they usually compare every data member and treat two objects as equal if and only if all the corresponding members are equal. In line with this design philosophy, our Sales_data equality operator should compare the bookNo as well as the sales figures:

bool operator==(const Sales_data &lhs, const Sales_data &rhs)
{
	return lhs.isbn() == rhs.isbn() &&
	lhs.units_sold == rhs.units_sold &&
	lhs.revenue == rhs.revenue;
}

bool operator!=(const Sales_data &lhs, const Sales_data &rhs)
{
	return !(lhs == rhs);
}

The definition of these functions is trivial. More important are the design principles that these functions embody:

‚Ä¢ If a class has an operation to determine whether two objects are equal, it should define that function as operator== rather than as a named function: Users will expect to be able to compare objects using ==; providing == means they won‚Äôt need to learn and remember a new name for the operation; and it is
easier to use the library containers and algorithms with classes that define the == operator.

‚Ä¢ If a class defines operator==, that operator ordinarily should determine whether the given objects contain equivalent data.

‚Ä¢ Ordinarily, the equality operator should be transitive, meaning that if a == b and b == c are both true, then a == c should also be true.

‚Ä¢ If a class defines operator==, it should also define operator!=. Users will expect that if they can use == then they can also use !=, and vice versa.

‚Ä¢ One of the equality or inequality operators should delegate the work to the other. That is, one of these operators should do the real work to compare objects. The other should call the one that does the real work.

Best Practices: Classes for which there is a logical meaning for equality normally should define operator==. Classes that define == make it easier for users to use the class with the library algorithms.

--
Relational Operators

Classes for which the equality operator is defined also often (but not always) have relational operators. In particular, because the associative containers and some of the algorithms use the less-than operator, it can be useful to define an operator<.

Ordinarily the relational operators should

1. Define an ordering relation that is consistent with the requirements for use as a key to an associative container; and

2. Define a relation that is consistent with == if the class has both operators. In particular, if two objects are !=, then one object should be < the other.

Although we might think our Sales_data class should support the relational operators, it turns out that it probably should not do so. The reasons are subtle and are worth understanding.

We might think that we‚Äôd define < similarly to compareIsbn. That function compared Sales_data objects by comparing their ISBNs. Although compareIsbn provides an ordering relation that meets requirment 1, that function yields results that are inconsistent with our definition of ==. As a result, it does not meet requirement 2.

The Sales_data == operator treats two transactions with the same ISBN as unequal if they have different revenue or units_sold members. If we defined the < operator to compare only the ISBN member, then two objects with the same ISBN but
different units_sold or revenue would compare as unequal, but neither object would be less than the other. Ordinarily, if we have two objects, neither of which is less than the other, then we expect that those objects are equal.

We might think that we should, therefore, define operator< to compare each data element in turn. We could define operator< to compare objects with equal isbns by looking next at the units_sold and then at the revenue members.

However, there is nothing essential about this ordering. Depending on how we plan to use the class, we might want to define the order based first on either revenue or units_sold. We might want those objects with fewer units_sold to be ‚Äúless
than‚Äù those with more. Or we might want to consider those with smaller revenue ‚Äúless than‚Äù those with more.

For Sales_data, there is no single logical definition of <. Thus, it is better for this class not to define < at all.

Best Practices: If a single logical definition for < exists, classes usually should define the < operator. However, if the class also has ==, define < only if the definitions of < and == yield consistent results.

--
Assignment Operators

In addition to the copy- and move-assignment operators that assign one object of the class type to another object of the same type, a class can define additional assignment operators that allow other types as the right-hand operand.

As one example, in addition to the copy- and move-assignment operators, the library vector class defines a third assignment operator that takes a braced list of elements. We can use this operator as follows:

v = {"a", "an", "the"};

We can add this operator to our StrVec class (¬ß 13.5, p. 526) as well:

class StrVec {
public:
	StrVec &operator=(std::initializer_list<std::string>);
	// other members
};

To be consistent with assignment for the built-in types (and with the copy- and moveassignment operators we already defined), our new assignment operator will return a reference to its left-hand operand:

StrVec &StrVec::operator=(initializer_list<string> il)
{
	// alloc_n_copy allocates space and copies elements from the given range
	auto data = alloc_n_copy(il.begin(), il.end());
	free(); // destroy the elements in this object and free the space
	elements = data.first; // update data members to point to the new
	space
	first_free = cap = data.second;
	return *this;
}

As with the copy- and move-assignment operators, other overloaded assignment operators have to free the existing elements and create new ones. Unlike the copy-and move-assignment operators, this operator does not need to check for selfassignment. The parameter is an initializer_list<string>, which means that il cannot be the same object as the one denoted by this.

Note: Assignment operators can be overloaded. Assignment operators, regardless of parameter type, must be defined as member functions.

--
Compound-Assignment Operators

Compound assignment operators (tao eg: +=) are not required to be members. However, we prefer to define all assignments, including compound assignments, in the class. For consistency with the built-in compound assignment, these operators should return a reference to their left-hand operand. For example, here is the definition of the Sales_data compound-assignment operator:

// member binary operator: left-hand operand is bound to the implicit this pointer
// assumes that both objects refer to the same book
Sales_data& Sales_data::operator+=(const Sales_data &rhs)
{
	units_sold += rhs.units_sold;
	revenue += rhs.revenue;
	return *this;
}

Best Practices: Assignment operators must, and ordinarily compound-assignment operators should, be defined as members. These operators should return a reference to the left-hand operand.

--
Subscript Operator

Classes that represent containers from which elements can be retrieved by position often define the subscript operator, operator[].

Note: The subscript operator must be a member function.

To be compatible with the ordinary meaning of subscript, the subscript operator usually returns a reference to the element that is fetched. By returning a reference, subscript can be used on either side of an assignment. Consequently, it is also usually a good idea to define both const and nonconst versions of this operator. When applied to a const object, subscript should return a reference to const so that it is not possible to assign to the returned object.

Best Practices: If a class has a subscript operator, it usually should define two versions: one that returns a plain reference and the other that is a const member and returns a reference to const.

As an example, we‚Äôll define subscript for StrVec:

class StrVec {
public:
	std::string& operator[](std::size_t n)
	{ return elements[n]; }
	const std::string& operator[](std::size_t n) const
	{ return elements[n]; }
	// other members as in ¬ß 13.5 (p. 526)
private:
	std::string *elements; // pointer to the first element in the array
};

We can use these operators similarly to how we subscript a vector or array. Because subscript returns a reference to an element, if the StrVec is nonconst, we can assign to that element; if we subscript a const object, we can‚Äôt:

// assume svec is a StrVec
const StrVec cvec = svec; // copy elements from svec into cvec
// if svec has any elements, run the string empty function on the first one
if (svec.size() && svec[0].empty()) {
	svec[0] = "zero"; // ok: subscript returns a reference to a string
	cvec[0] = "Zip"; // error: subscripting cvec returns a reference to const
}

--
Increment and Decrement Operators

The increment (++) and decrement (--) operators are most often implemented for iterator classes. These operators let the class move between the elements of a sequence. There is no language requirement that these operators be members of the
class. However, because these operators change the state of the object on which they operate, our preference is to make them members.

For the built-in types, there are both prefix and postfix versions of the increment and decrement operators. Not surprisingly, we can define both the prefix and postfix instances of these operators for our own classes as well. We‚Äôll look at the prefix versions first and then implement the postfix ones.

Best Practices: Classes that define increment or decrement operators should define both the prefix and postfix versions. These operators usually should be defined as members.

--
Defining Prefix Increment/Decrement Operators

To illustrate the increment and decrement operators, we‚Äôll define these operators for our StrBlobPtr class:

class StrBlobPtr {
public:
	// increment and decrement
	StrBlobPtr& operator++(); // prefix operators
	StrBlobPtr& operator--();
	// other members as before
};

Best Practices: To be consistent with the built-in operators, the prefix operators should return a reference to the incremented or decremented object.

The increment and decrement operators work similarly to each other‚Äîthey call check to verify that the StrBlobPtr is still valid. If so, check also verifies that its given index is valid. If check doesn‚Äôt throw an exception, these operators return a reference to this object.

In the case of increment, we pass the current value of curr to check. So long as that value is less than the size of the underlying vector, check will return. If curr is already at the end of the vector, check will throw:

// prefix: return a reference to the incremented/decremented object
StrBlobPtr& StrBlobPtr::operator++()
{
	// if curr already points past the end of the container, can't increment it
	check(curr, "increment past end of StrBlobPtr");
	++curr; // advance the current state
	return *this;
}

StrBlobPtr& StrBlobPtr::operator--()
{
	// if curr is zero, decrementing it will yield an invalid subscript
	--curr; // move the current state back one element
	check(-1, "decrement past begin of StrBlobPtr");
	return *this;
}

The decrement operator decrements curr before calling check. That way, if curr (which is an unsigned number) is already zero, the value that we pass to check will be a large positive value representing an invalid subscript.

--
Differentiating Prefix and Postfix Operators

There is one problem with defining both the prefix and postfix operators: Normal overloading cannot distinguish between these operators. The prefix and postfix versions use the same symbol, meaning that the overloaded versions of these operators have the same name. They also have the same number and type of operands.

To solve this problem, the postfix versions take an extra (unused) parameter of type int. When we use a postfix operator, the compiler supplies 0 as the argument for this parameter. Although the postfix function can use this extra parameter, it usually should not. That parameter is not needed for the work normally performed by a postfix operator. Its sole purpose is to distinguish a postfix function from the prefix version.

We can now add the postfix operators to StrBlobPtr:

class StrBlobPtr {
public:
	// increment and decrement
	StrBlobPtr operator++(int); // postfix operators
	StrBlobPtr operator--(int);
	// other members as before
};

Best Practices: To be consistent with the built-in operators, the postfix operators should return the old (unincremented or undecremented) value. That value is returned as a value, not a reference.

The postfix versions have to remember the current state of the object before incrementing the object:

// postfix: increment/decrement the object but return the unchanged value
StrBlobPtr StrBlobPtr::operator++(int)
{
	// no check needed here; the call to prefix increment will do the check
	StrBlobPtr ret = *this; // save the current value
	++*this; // advance one element; prefix ++ checks the increment
	return ret; // return the saved state
}

StrBlobPtr StrBlobPtr::operator--(int)
{
	// no check needed here; the call to prefix decrement will do the check
	StrBlobPtr ret = *this; // save the current value
	--*this; // move backward one element; prefix -- checks the
	decrement
	return ret; // return the saved state
}

Each of our operators calls its own prefix version to do the actual work. For example, the postfix increment operator executes 

++*this

This expression calls the prefix increment operator. That operator checks that the increment is safe and either throws an exception or increments curr. Assuming check doesn‚Äôt throw an exception, the postfix functions return the stored copy in
ret. Thus, after the return, the object itself has been advanced, but the value returned reflects the original, unincremented value.

Note: The int parameter is not used, so we do not give it a name.

--
Calling the Postfix Operators Explicitly

As we saw earlier, we can explicitly call an overloaded operator as an alternative to using it as an operator in an expression. If we want to call the postfix version using a function call, then we must pass a value for the integer argument:

StrBlobPtr p(a1); // p points to the vector inside a1
p.operator++(0); // call postfix operator++
p.operator++(); // call prefix operator++

The value passed usually is ignored but is necessary in order to tell the compiler to use the postfix version.

--
Member Access Operators

The dereference (*) and arrow (->) operators are often used in classes that represent iterators and in smart pointer classes. We can logically add these operators to our StrBlobPtr class as well:

class StrBlobPtr {
public:
	std::string& operator*() const { 
		auto p = check(curr, "dereference past end");
		return (*p)[curr]; // (*p) is the vector to which this object points
	}
	std::string* operator->() const { 
		// delegate the real work to the dereference operator
		return & this->operator*();
	}
	// other members as before
};

The dereference operator checks that curr is still in range and, if so, returns a reference to the element denoted by curr. The arrow operator avoids doing any work of its own by calling the dereference operator and returning the address of the element returned by that operator.

Note: Operator arrow must be a member. The dereference operator is not required to be a member but usually should be a member as well.

It is worth noting that we‚Äôve defined these operators as const members. Unlike the increment and decrment operators, fetching an element doesn‚Äôt change the state of a StrBlobPtr. Also note that these operators return a reference or pointer to nonconst string. They do so because we know that a StrBlobPtr can only be bound to a nonconst StrBlob.

We can use these operators the same way that we‚Äôve used the corresponding operations on pointers or vector iterators:

StrBlob a1 = {"hi", "bye", "now"};
StrBlobPtr p(a1); // p points to the vector inside a1
*p = "okay"; // assigns to the first element in a1
cout << p->size() << endl; // prints 4, the size of the first element in a1
cout << (*p).size() << endl; // equivalent to p->size()

--
Constraints on the Return from Operator Arrow

As with most of the other operators (although it would be a bad idea to do so), we can define operator* to do whatever processing we like. That is, we can define operator* to return a fixed value, say, 42, or print the contents of the object to
which it is applied, or whatever. The same is not true for overloaded arrow. The arrow operator never loses its fundamental meaning of member access. When we overload
arrow, we change the object from which arrow fetches the specified member. We cannot change the fact that arrow fetches a member.

When we write point->mem, point must be a pointer to a class object or it must be an object of a class with an overloaded operator->. Depending on the type of point, writing point->mem is equivalent to

(*point).mem; // point is a built-in pointer type
point.operator()->mem; // point is an object of class type

Otherwise the code is in error. That is, point->mem executes as follows:

1. If point is a pointer, then the built-in arrow operator is applied, which means this expression is a synonym for (*point).mem. The pointer is dereferenced and the indicated member is fetched from the resulting object. If the type
pointed to by point does not have a member named mem, then the code is in error.

2. If point is an object of a class that defines operator->, then the result of point.operator->() is used to fetch mem. If that result is a pointer, then step 1 is executed on that pointer. If the result is an object that itself has an overloaded operator->(), then this step is repeated on that object. This process continues until either a pointer to an object with the indicated member is returned or some other value is returned, in which case the code is in error.

Note: The overloaded arrow operator must return either a pointer to a class type or an object of a class type that defines its own operator arrow.

--
Function-Call Operator

Classes that overload the call operator allow objects of its type to be used as if they were a function. Because such classes can also store state, they can be more flexible
than ordinary functions.

As a simple example, the following struct, named absInt, has a call operator that returns the absolute value of its argument:

struct absInt {
	int operator()(int val) const {
		return val < 0 ? -val : val;
	}
};

This class defines a single operation: the function-call operator. That operator takes an argument of type int and returns the argument‚Äôs absolute value.

We use the call operator by applying an argument list to an absInt object in a way that looks like a function call:

int i = -42;
absInt absObj; // object that has a function-call operator
int ui = absObj(i); // passes i to absObj.operator()

Even though absObj is an object, not a function, we can ‚Äúcall‚Äù this object. Calling an object runs its overloaded call operator. In this case, that operator takes an int value
and returns its absolute value.

Note: The function-call operator must be a member function. A class may define multiple versions of the call operator, each of which must differ as to the number or types of their parameters.

Objects of classes that define the call operator are referred to as function objects. Such objects ‚Äúact like functions‚Äù because we can call them.

--
Function-Object Classes with State

Like any other class, a function-object class can have additional members aside from operator(). Function-object classes often contain data members that are used to customize the operations in the call operator.

As an example, we‚Äôll define a class that prints a string argument. By default, our class will write to cout and will print a space following each string. We‚Äôll also let users of our class provide a different stream on which to write and provide a different separator. We can define this class as follows:

class PrintString {
public:
	PrintString(ostream &o = cout, char c = ' '):
		os(o), sep(c) { }
	void operator()(const string &s) const { os << s << sep;
}

private:
	ostream &os; // stream on which to write
	char sep; // character to print after each output
};

Our class has a constructor that takes a reference to an output stream and a character to use as the separator. It uses cout and a space as default arguments for these parameters. The body of the function-call operator uses these members when it prints the given string.

When we define PrintString objects, we can use the defaults or supply our own values for the separator or output stream:

PrintString printer; // uses the defaults; prints to cout
printer(s); // prints s followed by a space on cout
PrintString errors(cerr, '\n');
errors(s); // prints s followed by a newline on cerr

Function objects are most often used as arguments to the generic algorithms. For example, we can use the library for_each algorithm and our PrintString class to print the contents of a container:

for_each(vs.begin(), vs.end(), PrintString(cerr, '\n'));

The third argument to for_each is a temporary object of type PrintString that we initialize from cerr and a newline character. The call to for_each will print each element in vs to cerr followed by a newline.

--
Lambdas Are Function Objects

In the previous section, we used a PrintString object as an argument in a call to for_each. This usage is similar to the programs we wrote earlier that used lambda expressions. When we write a lambda, the compiler translates that expression into an unnamed object of an unnamed class. The classes generated from a lambda contain an overloaded function-call operator. For example, the lambda that we passed as the last argument to stable_sort:

// sort words by size, but maintain alphabetical order for words of the same size
stable_sort(words.begin(), words.end(),
	[](const string &a, const string &b)
		{ return a.size() < b.size();});

acts like an unnamed object of a class that would look something like

class ShorterString {
public:
	bool operator()(const string &s1, const string &s2) const
	{ return s1.size() < s2.size(); }
};

The generated class has a single member, which is a function-call operator that takes two strings and compares their lengths. The parameter list and function body are the same as the lambda. As we saw earlier, by default, lambdas may not change their captured variables. As a result, by default, the function-call operator in a class generated from a lambda is a const member function. If the lambda is declared as mutable, then the call operator is not const.

We can rewrite the call to stable_sort to use this class instead of the lambda expression:

stable_sort(words.begin(), words.end(), ShorterString());

The third argument is a newly constructed ShorterString object. The code in stable_sort will ‚Äúcall‚Äù this object each time it compares two strings. When the object is called, it will execute the body of its call operator, returning true if the first string‚Äôs size is less than the second‚Äôs.

--
Classes Representing Lambdas with Captures

As we‚Äôve seen, when a lambda captures a variable by reference, it is up to the program to ensure that the variable to which the reference refers exists when the lambda is executed. Therefore, the compiler is permitted to use the reference directly without storing that reference as a data member in the generated class.

In contrast, variables that are captured by value are copied into the lambda. As a result, classes generated from lambdas that capture variables by value have data members corresponding to each such variable. These classes also
have a constructor to initialize these data members from the value of the captured variables. As an example, earlier, the lambda that we used to find the first string whose length was greater than or equal to a given bound:

// get an iterator to the first element whose size() is >= sz
auto wc = find_if(words.begin(), words.end(), [sz](const string &a)

would generate a class that looks something like

class SizeComp {
	SizeComp(size_t n): sz(n) { } // parameter for each captured variable
	// call operator with the same return type, parameters, and body as the lambda
	bool operator()(const string &s) const
		{ return s.size() >= sz; }
private:
	size_t sz; // a data member for each variable captured by value
};

Unlike our ShorterString class, this class has a data member and a constructor to initialize that member. This synthesized class does not have a default constructor; to use this class, we must pass an argument:

// get an iterator to the first element whose size() is >= sz
auto wc = find_if(words.begin(), words.end(), SizeComp(sz));

Classes generated from a lambda expression have a deleted default constructor, deleted assignment operators, and a default destructor. Whether the class has a defaulted or deleted copy/move constructor depends in the usual ways on the types of the captured data members.

--
Library-Defined Function Objects

The standard library defines a set of classes that represent the arithmetic, relational, and logical operators. Each class defines a call operator that applies the named operation. For example, the plus class has a function-call operator that applies + to a pair of operands; the modulus class defines a call operator that applies the binary % operator; the equal_to class applies ==; and so on.

These classes are templates to which we supply a single type. That type specifies the parameter type for the call operator. For example, plus<string> applies the string addition operator to string objects; for plus<int> the operands are ints;
plus<Sales_data> applies + to Sales_datas; and so on:

plus<int> intAdd; // function object that can add two int values
negate<int> intNegate; // function object that can negate an int value
// uses intAdd::operator(int, int) to add 10 and 20
int sum = intAdd(10, 20); // equivalent to sum = 30
sum = intNegate(intAdd(10, 20)); // equivalent to sum = 30
// uses intNegate::operator(int) to generate -10 as the second parameter
// to intAdd::operator(int, int)
sum = intAdd(10, intNegate(10)); // sum = 0

These types, listed in Table 14.2, are defined in the functional header.

Table: Library Function Objects (omitted)

--
Using a Library Function Object with the Algorithms

The function-object classes that represent operators are often used to override the default operator used by an algorithm. As we‚Äôve seen, by default, the sorting algorithms use operator<, which ordinarily sorts the sequence into ascending order. To sort into descending order, we can pass an object of type greater. That class generates a call operator that invokes the greater-than operator of the underlying element type. For example, if svec is a vector<string>,

// passes a temporary function object that applies the < operator to two strings
sort(svec.begin(), svec.end(), greater<string>());

sorts the vector in descending order. The third argument is an unnamed object of type greater<string>. When sort compares elements, rather than applying the < operator for the element type, it will call the given greater function object. That
object applies > to the string elements.

One important aspect of these library function objects is that the library guarantees that they will work for pointers. Recall that comparing two unrelated pointers is undefined. However, we might want to sort a vector of pointers based on their addresses in memory. Although it would be undefined for us to do so directly, we can do so through one of the library function objects:

vector<string *> nameTable; // vector of pointers
// error: the pointers in nameTable are unrelated, so < is undefined
sort(nameTable.begin(), nameTable.end(),
[](string *a, string *b) { return a < b; });
// ok: library guarantees that less on pointer types is well defined
sort(nameTable.begin(), nameTable.end(), less<string*>());

It is also worth noting that the associative containers use less<key_type> to order their elements. As a result, we can define a set of pointers or use a pointer as the key in a map without specifying less directly.

--
Callable Objects and function

C++ has several kinds of callable objects: functions and pointers to functions, lambdas, objects created by bind, and classes that overload the function-call operator.

Like any other object, a callable object has a type. For example, each lambda has its own unique (unnamed) class type. Function and function-pointer types vary by their return type and argument types, and so on.

However, two callable objects with different types may share the same call signature. The call signature specifies the type returned by a call to the object and the argument type(s) that must be passed in the call. A call signature corresponds to
a function type. For example:

int(int, int)

is a function type that takes two ints and returns an int. Different Types Can Have the Same Call Signature Sometimes we want to treat several callable objects that share a call signature as if they had the same type. For example, consider the following different types of callable objects:

// ordinary function
int add(int i, int j) { return i + j; }
// lambda, which generates an unnamed function-object class

auto mod = [](int i, int j) { return i % j; };
// function-object class
struct div {
	int operator()(int denominator, int divisor) {
		return denominator / divisor;
	}
};

Each of these callables applies an arithmetic operation to its parameters. Even though each has a distinct type, they all share the same call signature:

int(int, int)

We might want to use these callables to build a simple desk calculator. To do so, we‚Äôd want to define a function table to store ‚Äúpointers‚Äù to these callables. When the program needs to execute a particular operation, it will look in the table to find which function to call.

In C++, function tables are easy to implement using a map. In this case, we‚Äôll use a string corresponding to an operator symbol as the key; the value will be the function that implements that operator. When we want to evaluate a given operator, we‚Äôll index the map with that operator and call the resulting element.

If all our functions were freestanding functions, and assuming we were handling only binary operators for type int, we could define the map as

// maps an operator to a pointer to a function taking two ints and returning an int
map<string, int(*)(int,int)> binops;

We could put a pointer to add into binops as follows:

// ok: add is a pointer to function of the appropriate type
binops.insert({"+", add}); // {"+", add} is a pair

However, we can‚Äôt store mod or div in binops:

binops.insert({"%", mod}); // error: mod is not a pointer to function

The problem is that mod is a lambda, and each lambda has its own class type. That type does not match the type of the values stored in binops.

--
The Library function Type

We can solve this problem using a new library type named function that is defined in the functional header; Table below lists the operations defined by function.

Operations on function:

function<T> f: f is a null function object that can store callable objects with a call signature that is equivalent to the function type T (ie, T is relType(args)).

function<T> f(nullptr): Explicitly construct a null function.

function<T> f(obj): Stores a copy of the callable object obj in f.

f: Use f as a condition; true if f holds a callable object; false otherwise.

f(args): Calls the object in f passing args.

Types defined as members of function <T>:

result_type: The type returned by this function type's callable object.

argument_type: Types defined when T has exactly one or two arguments.

first_argument_type, second_argument_type: If T has one argument, argument_type is a synonym for that type. If T has two arguments, first_argument_type and second_argument_type are synonyms for those argument types.

"function" is a template. As with other templates we‚Äôve used, we must specify additional information when we create a function type. In this case, that information is the call signature of the objects that this particular function type can
represent. As with other templates, we specify the type inside angle brackets:

function<int(int, int)>

Here we‚Äôve declared a function type that can represent callable objects that return an int result and have two int parameters. We can use that type to represent any of our desk calculator types:

function<int(int, int)> f1 = add; // function pointer
function<int(int, int)> f2 = div(); // object of a function-object class
function<int(int, int)> f3 = [](int i, int j) // lambda
{ return i * j; };
cout << f1(4,2) << endl; // prints 6
cout << f2(4,2) << endl; // prints 2
cout << f3(4,2) << endl; // prints 8

We can now redefine our map using this function type:

// table of callable objects corresponding to each binary operator
// all the callables must take two ints and return an int
// an element can be a function pointer, function object, or lambda
map<string, function<int(int, int)>> binops;

We can add each of our callable objects, be they function pointers, lambdas, or function objects, to this map:

map<string, function<int(int, int)>> binops = {
	{"+", add}, // function pointer
	{"-", std::minus<int>()}, // library function object
	{"/", div()}, // user-defined function object
	{"*", [](int i, int j) { return i * j; }}, // unnamed
	lambda
	{"%", mod} 
}; // named lambda object

Our map has five elements. Although the underlying callable objects all have different types from one another, we can store each of these distinct types in the common function<int(int, int)> type.

As usual, when we index a map, we get a reference to the associated value. When we index binops, we get a reference to an object of type function. The function type overloads the call operator. That call operator takes its own arguments and
passes them along to its stored callable object:

binops["+"](10, 5); // calls add(10, 5)
binops["-"](10, 5); // uses the call operator of the minus<int> object
binops["/"](10, 5); // uses the call operator of the div object
binops["*"](10, 5); // calls the lambda function object
binops["%"](10, 5); // calls the lambda function object

Here we call each of the operations stored in binops. In the first call, the element we get back holds a function pointer that points to our add function. Calling binops["+"](10, 5) uses that pointer to call add, passing it the values 10 and 5.
In the next call, binops["-"], returns a function that stores an object of type std::minus<int>. We call that object‚Äôs call operator, and so on.

--
Overloaded Functions and function

We cannot (directly) store the name of an overloaded function in an object of type function:

int add(int i, int j) { return i + j; }
Sales_data add(const Sales_data&, const Sales_data&);
map<string, function<int(int, int)>> binops;
binops.insert( {"+", add} ); // error: which add?

One way to resolve the ambiguity is to store a function pointer instead of the name of the function:

int (*fp)(int,int) = add; // pointer to the version of add that takes two ints
binops.insert( {"+", fp} ); // ok: fp points to the right version of add

Alternatively, we can use a lambda to disambiguate:

// ok: use a lambda to disambiguate which version of add we want to use
binops.insert( {"+", [](int a, int b) {return add(a, b);} }
);

The call inside the lambda body passes two ints. That call can match only the version of add that takes two ints, and so that is the function that is called when the lambda is executed.

Note: The function class in the new library is not related to classes named unary_function and binary_function that were part of earlier versions of the library. These classes have been deprecated by the more general bind function.

--
Overloading, Conversions, and Operators

Earlier we saw that a nonexplicit constructor that can be called with one argument defines an implicit conversion. Such constructors convert an object from the argument‚Äôs type to the class type. We can also define conversions from the class
type. We define a conversion from a class type by defining a conversion operator. Converting constructors and conversion operators define class-type conversions. Such conversions are also referred to as user-defined conversions.

--
Conversion Operators

A conversion operator is a special kind of member function that converts a value of a class type to a value of some other type. A conversion function typically has the general form

operator type() const;

where type represents a type. Conversion operators can be defined for any type (other than void) that can be a function return type. Conversions to an array or a function type are not permitted. Conversions to pointer types‚Äîboth data and function pointers‚Äîand to reference types are allowed.

Conversion operators have no explicitly stated return type and no parameters, and they must be defined as member functions. Conversion operations ordinarily should not change the object they are converting. As a result, conversion operators usually
should be defined as const members.

Note: A conversion function must be a member function, may not specify a return type, and must have an empty parameter list. The function usually should be const.

--
Defining a Class with a Conversion Operator

As an example, we‚Äôll define a small class that represents an integer in the range of 0 to 255:

class SmallInt {
public:
	SmallInt(int i = 0): val(i)
	{
		if (i < 0 || i > 255)
			throw std::out_of_range("Bad SmallInt value");
	}
	operator int() const { return val; }
private:
	std::size_t val;
};

Our SmallInt class defines conversions to and from its type. The constructor converts values of arithmetic type to a SmallInt. The conversion operator converts SmallInt objects to int:

SmallInt si;
si = 4; // implicitly converts 4 to SmallInt then calls SmallInt::operator=
si + 3; // implicitly converts si to int followed by integer addition

Although the compiler will apply only one user-defined conversion at a time, an implicit user-defined conversion can be preceded or followed by a standard (built-in) conversion. As a result, we can pass any arithmetic type to the SmallInt constructor. Similarly, we can use the converion operator to convert a SmallInt to an int and then convert the resulting int value to another arithmetic type:

// the double argument is converted to int using the built-in conversion
SmallInt si = 3.14; // calls the SmallInt(int) constructor

// the SmallInt conversion operator converts si to int;
si + 3.14; // that int is converted to double using the built-in conversion

Because conversion operators are implicitly applied, there is no way to pass arguments to these functions. Hence, conversion operators may not be defined to take parameters. Although a conversion function does not specify a return type, each conversion function must return a value of its corresponding type:

class SmallInt;
operator int(SmallInt&); // error: nonmember
class SmallInt {
public:
	int operator int() const; // error: return type
	operator int(int = 0) const; // error: parameter list
	operator int*() const { return 42; } // error: 42 is not a
	pointer
};

Caution: Avoid Overuse of Conversion Functions

As with using overloaded operators, judicious use of conversion operators can greatly simplify the job of a class designer and make using a class easier. However, some conversions can be misleading. Conversion operators are
misleading when there is no obvious single mapping between the class type and the conversion type.

For example, consider a class that represents a Date. We might think it would be a good idea to provide a conversion from Date to int. However, what value should the conversion function return? The function might return a decimal representation of the year, month, and day. For example, July 30, 1989 might be represented as the int value 19800730. Alternatively, the conversion operator might return an int representing the number of days that have elapsed since some epoch point, such as January 1, 1970. Both these conversions have the desirable property that later dates correspond to
larger integers, and so either might be useful.

The problem is that there is no single one-to-one mapping between an object of type Date and a value of type int. In such cases, it is better not to define the conversion operator. Instead, the class ought to define one or more ordinary members to extract the information in these various forms.

--
Conversion Operators Can Yield Suprising Results

In practice, classes rarely provide conversion operators. Too often users are more likely to be surprised if a conversion happens automatically than to be helped by the existence of the conversion. However, there is one important exception to this rule of thumb: It is not uncommon for classes to define conversions to bool.

Under earlier versions of the standard, classes that wanted to define a conversion to bool faced a problem: Because bool is an arithmetic type, a class-type object that is converted to bool can be used in any context where an arithmetic type is expected. Such conversions can happen in surprising ways. In particular, if istream had a conversion to bool, the following code would compile:

int i = 42;
cin << i; // this code would be legal if the conversion to bool were not explicit!

This program attempts to use the output operator on an input stream. There is no << defined for istream, so the code is almost surely in error. However, this code could use the bool conversion operator to convert cin to bool. The resulting bool value would then be promoted to int and used as the left-hand operand to the built-in version of the left-shift operator. The promoted bool value (either 1 or 0) would be shifted left 42 positions.

--
explicit Conversion Operators

To prevent such problems, the new standard introduced explicit conversion operators:

class SmallInt {
public:
	// the compiler won't automatically apply this conversion
	explicit operator int() const { return val; }
	// other members as before
};

As with an explicit constructor, the compiler won‚Äôt (generally) use an explicit conversion operator for implicit conversions:

SmallInt si = 3; // ok: the SmallInt constructor is not explicit
si + 3; // error: implicit is conversion required, but operator int is explicit
static_cast<int>(si) + 3; // ok: explicitly request the conversion

If the conversion operator is explicit, we can still do the conversion. However, with one exception, we must do so explicitly through a cast.

The exception is that the compiler will apply an explicit conversion to an expression used as a condition. That is, an explicit conversion will be used implicitly to convert an expression used as

‚Ä¢ The condition of an if, while, or do statement
‚Ä¢ The condition expression in a for statement header
‚Ä¢ An operand to the logical NOT (!), OR (||), or AND (&&) operators
‚Ä¢ The condition expression in a conditional (?:) operator

--
Conversion to bool

In earlier versions of the library, the IO types defined a conversion to void*. They did so to avoid the kinds of problems illustrated above. Under the new standard, the
IO library instead defines an explicit conversion to bool.
Whenever we use a stream object in a condition, we use the operator bool that is defined for the IO types. For example,

while (std::cin >> value)

The condition in the while executes the input operator, which reads into value and returns cin. To evaluate the condition, cin is implicitly converted by the istream operator bool conversion function. That function returns true if the condition state of cin is good, and false otherwise.

Best Practices: Conversion to bool is usually intended for use in conditions. As a result, operator bool ordinarily should be defined as explicit.

--
Avoiding Ambiguous Conversions

If a class has one or more conversions, it is important to ensure that there is only one way to convert from the class type to the target type. If there is more than one way
to perform a conversion, it will be hard to write unambiguous code.

There are two ways that multiple conversion paths can occur. The first happens when two classes provide mutual conversions. For example, mutual conversions exist when a class A defines a converting constructor that takes an object of class B and B
itself defines a conversion operator to type A.

The second way to generate multiple conversion paths is to define multiple conversions from or to types that are themselves related by conversions. The most obvious instance is the built-in arithmetic types. A given class ordinarily ought to define at most one conversion to or from an arithmetic type.

Warning: Ordinarily, it is a bad idea to define classes with mutual conversions or to define conversions to or from two arithmetic types.

--
Argument Matching and Mutual Conversions

In the following example, we‚Äôve defined two ways to obtain an A from a B: either by using B‚Äôs conversion operator or by using the A constructor that takes a B:

// usually a bad idea to have mutual conversions between two class types
struct B;
struct A {
	A() = default;
	A(const B&); // converts a B to an A
	// other members
};
struct B {
	operator A() const; // also converts a B to an A
	// other members
};
A f(const A&);
B b;
A a = f(b); // error ambiguous: f(B::operator A()) or f(A::A(const B&))

Because there are two ways to obtain an A from a B, the compiler doesn‚Äôt know which conversion to run; the call to f is ambiguous. This call can use the A constructor that
takes a B, or it can use the B conversion operator that converts a B to an A. Because these two functions are equally good, the call is in error.

If we want to make this call, we have to explicitly call the conversion operator or the constructor:

A a1 = f(b.operator A()); // ok: use B's conversion operator
A a2 = f(A(b)); // ok: use A's constructor

Note that we can‚Äôt resolve the ambiguity by using a cast‚Äîthe cast itself would have the same ambiguity.

--
Ambiguities and Multiple Conversions to Built-in Types

Ambiguities also occur when a class defines multiple conversions to (or from) types that are themselves related by conversions. The easiest case to illustrate‚Äîand one that is particularly problematic‚Äîis when a class defines constructors from or conversions to more than one arithmetic type.

For example, the following class has converting constructors from two different arithmetic types, and conversion operators to two different arithmetic types:

struct A {
	A(int = 0); // usually a bad idea to have two
	A(double); // conversions from arithmetic types
	operator int() const; // usually a bad idea to have two
	operator double() const; // conversions to arithmetic types
	// other members
};
void f2(long double);
A a;
f2(a); // error ambiguous: f(A::operator int()) or f(A::operator double())
long lg;
A a2(lg); // error ambiguous: A::A(int) or A::A(double)

In the call to f2, neither conversion is an exact match to long double. However, either conversion can be used, followed by a standard conversion to get to long double. Hence, neither conversion is better than the other; the call is ambiguous.
We encounter the same problem when we try to initialize a2 from a long. Neither constructor is an exact match for long. Each would require that the argument be converted before using the constructor:

‚Ä¢ Standard long to double conversion followed by A(double)
‚Ä¢ Standard long to int conversion followed by A(int)

These conversion sequences are indistinguishable, so the call is ambiguous. The call to f2, and the initialization of a2, are ambiguous because the standard conversions that were needed had the same rank. When a userdefined conversion is used, the rank of the standard conversion, if any, is used to
select the best match:

short s = 42;
// promoting short to int is better than converting short to double
A a3(s); // uses A::A(int)

In this case, promoting a short to an int is preferred to converting the short to a double. Hence a3 is constructed using the A::A(int) constructor, which is run on the (promoted) value of s.

Note: When two user-defined conversions are used, the rank of the standard conversion, if any, preceding or following the conversion function is used to select the best match.

--
Overloaded Functions and Converting Constructors

Choosing among multiple conversions is further complicated when we call an overloaded function. If two or more conversions provide a viable match, then the conversions are considered equally good.

As one example, ambiguity problems can arise when overloaded functions take parameters that differ by class types that define the same converting constructors:

Caution: Conversions and Operators

Correctly designing the overloaded operators, conversion constructors, and conversion functions for a class requires some care. In particular, ambiguities are easy to generate if a class defines both conversion operators and overloaded operators. A few rules of thumb can be helpful:

‚Ä¢ Don‚Äôt define mutually converting classes‚Äîif class Foo has a constructor that takes an object of class Bar, do not give Bar a conversion operator to type Foo.

‚Ä¢ Avoid conversions to the built-in arithmetic types. In particular, if you do define a conversion to an arithmetic type, then

‚Äì Do not define overloaded versions of the operators that take arithmetic types. If users need to use these operators, the conversion operation will convert objects of your type, and then the built-in operators can be used.

‚Äì Do not define a conversion to more than one arithmetic type. Let the standard conversions provide conversions to the other arithmetic types.

The easiest rule of all: With the exception of an explicit conversion to bool, avoid defining conversion functions and limit nonexplicit constructors to those that are ‚Äúobviously right.‚Äù

struct C {
	C(int);
	// other members
};
struct D {
	D(int);
	// other members
};
void manip(const C&);
void manip(const D&);
manip(10); // error ambiguous: manip(C(10)) or manip(D(10))

Here both C and D have constructors that take an int. Either constructor can be used to match a version of manip. Hence, the call is ambiguous: It could mean convert the int to C and call the first version of manip, or it could mean convert the int to D and call the second version.

The caller can disambiguate by explicitly constructing the correct type:

manip(C(10)); // ok: calls manip(const C&)

Warning: Needing to use a constructor or a cast to convert an argument in a call to an overloaded function frequently is a sign of bad design.

--
Overloaded Functions and User-Defined Conversion

In a call to an overloaded function, if two (or more) user-defined conversions provide a viable match, the conversions are considered equally good. The rank of any
standard conversions that might or might not be required is not considered. Whether a built-in conversion is also needed is considered only if the overload set can be matched using the same conversion function.

For example, our call to manip would be ambiguous even if one of the classes defined a constructor that required a standard conversion for the argument:

struct E {
	E(double);
	// other members
};
void manip2(const C&);
void manip2(const E&);
// error ambiguous: two different user-defined conversions could be used
manip2(10); // manip2(C(10) or manip2(E(double(10)))

In this case, C has a conversion from int and E has a conversion from double. For the call manip2(10), both manip2 functions are viable:

‚Ä¢ manip2(const C&) is viable because C has a converting constructor that takes an int. That constructor is an exact match for the argument.

‚Ä¢ manip2(const E&) is viable because E has a converting constructor that takes a double and we can use a standard conversion to convert the int argument in order to use that converting constructor.

Because calls to the overloaded functions require different user-defined conversions from one another, this call is ambiguous. In particular, even though one of the calls requires a standard conversion and the other is an exact match, the compiler will still flag this call as an error.

Note: In a call to an overloaded function, the rank of an additional standard conversion (if any) matters only if the viable functions require the same userdefined conversion. If different user-defined conversions are needed, then the call is ambiguous.

--
Function Matching and Overloaded Operators

Overloaded operators are overloaded functions. Normal function matching is used to determine which operator‚Äîbuilt-in or overloaded‚Äîto apply to a given expression. However, when an operator function is used in an expression, the set of candidate functions is broader than when we call a function using the call operator. If a has a class type, the expression a sym b might be

a.operatorsym (b); // a has operatorsym as a member function
operatorsym(a, b); // operatorsym is an ordinary function

Unlike ordinary function calls, we cannot use the form of the call to distinquish whether we‚Äôre calling a nonmember or a member function.

When we use an overloaded operator with an operand of class type, the candidate functions include ordinary nonmember versions of that operator, as well as the built-in versions of the operator. Moreover, if the left-hand operand has class type, the overloaded versions of the operator, if any, defined by that class are also included.

When we call a named function, member and nonmember functions with the same name do not overload one another. There is no overloading because the syntax we use to call a named function distinguishes between member and nonmember functions. When a call is through an object of a class type (or through a reference or pointer to such an object), then only the member functions of that class are considered. When we use an overloaded operator in an expression, there is nothing to
indicate whether we‚Äôre using a member or nonmember function. Therefore, both member and nonmember versions must be considered.

Note: The set of candidate functions for an operator used in an expression can contain both nonmember and member functions.

As an example, we‚Äôll define an addition operator for our SmallInt class:

class SmallInt {
	friend
	SmallInt operator+(const SmallInt&, const SmallInt&);
public:
	SmallInt(int = 0); // conversion from int
	operator int() const { return val; } // conversion to int
private:
	std::size_t val;
};

We can use this class to add two SmallInts, but we will run into ambiguity problems if we attempt to perform mixed-mode arithmetic:

SmallInt s1, s2;
SmallInt s3 = s1 + s2; // uses overloaded operator+
int i = s3 + 0; // error: ambiguous

The first addition uses the overloaded version of + that takes two SmallInt values. The second addition is ambiguous, because we can convert 0 to a SmallInt and use the SmallInt version of +, or convert s3 to int and use the built-in addition operator on ints.

Warning: Providing both conversion functions to an arithmetic type and overloaded operators for the same class type may lead to ambiguities between the overloaded operators and the built-in operators.

==
(findinheritance)
(findobjectorientedprogramming)
(findoop)
Object-Oriented Programming (tao: actually talking about inheritance)

Object-oriented programming is based on three fundamental concepts: data abstraction, which we covered in Chapter 7, and inheritance and dynamic binding, which we‚Äôll cover in this chapter.

Inheritance and dynamic binding affect how we write our programs in two ways: They make it easier to define new classes that are similar, but not identical, to other
classes, and they make it easier for us to write programs that can ignore the details of how those similar types differ.

Many applications include concepts that are related to but slightly different from one another. For example, our bookstore might offer different pricing strategies for
different books. Some books might be sold only at a given price. Others might be sold subject to a discount. We might give a discount to purchasers who buy a specified number of copies of the book. Or we might give a discount for only the first few copies purchased but charge full price for any bought beyond a given limit, and so on. Object-oriented programming (OOP) is a good match to this kind of application.

--
OOP: An Overview

The key ideas in object-oriented programming are data abstraction, inheritance, and dynamic binding. Using data abstraction, we can define classes that separate interface from implementation (Chapter 7). Through inheritance, we can define classes that model the relationships among similar types. Through dynamic binding, we can use objects of these types while ignoring the details of how they differ.

--
Inheritance

Classes related by inheritance form a hierarchy. Typically there is a base class at the root of the hierarchy, from which the other classes inherit, directly or indirectly. These inheriting classes are known as derived classes. The base class defines those members that are common to the types in the hierarchy. Each derived class defines those members that are specific to the derived class itself.

To model our different kinds of pricing strategies, we‚Äôll define a class named Quote, which will be the base class of our hierarchy. A Quote object will represent undiscounted books. From Quote we will inherit a second class, named Bulk_quote, to represent books that can be sold with a quantity discount.

These classes will have the following two member functions:

‚Ä¢ isbn(), which will return the ISBN. This operation does not depend on the specifics of the inherited class(es); it will be defined only in class Quote.

‚Ä¢ net_price(size_t), which will return the price for purchasing a specified number of copies of a book. This operation is type specific; both Quote and Bulk_quote will define their own version of this function.

In C++, a base class distinguishes functions that are type dependent from those that it expects its derived classes to inherit without change. The base class defines as virtual those functions it expects its derived classes to define for themselves. Using this knowledge, we can start to write our Quote class:

class Quote {
public:
	std::string isbn() const;
	virtual double net_price(std::size_t n) const;
};

A derived class must specify the class(es) from which it intends to inherit. It does so in a class derivation list, which is a colon followed by a comma-separated list of
base classes each of which may have an optional access specifier:

class Bulk_quote : public Quote { // Bulk_quote inherits from Quote
public:
	double net_price(std::size_t) const override;
};

Because Bulk_quote uses public in its derivation list, we can use objects of type Bulk_quote as if they were Quote objects.

A derived class must include in its own class body a declaration of all the virtual functions it intends to define for itself. A derived class may include the virtual keyword on these functions but is not required to do so. For reasons we‚Äôll explain later, the new standard lets a derived class explicitly note that it intends a member function to override a virtual that it inherits. It does so by specifying override after its parameter list.

--
Dynamic Binding

Through dynamic binding, we can use the same code to process objects of either type Quote or Bulk_quote interchangeably. For example, the following function prints the total price for purchasing the given number of copies of a given book:

// calculate and print the price for the given number of copies, applying any discounts
double print_total(ostream &os, const Quote &item, size_t n)
{
	// depending on the type of the object bound to the item parameter
	// calls either Quote::net_price or Bulk_quote::net_price
	double ret = item.net_price(n);
	os << "ISBN: " << item.isbn() // calls Quote::isbn
	   << " # sold: " << n << " total due: " << ret << endl;
	return ret;
}

This function is pretty simple‚Äîit prints the results of calling isbn and net_price on its parameter and returns the value calculated by the call to net_price.

Nevertheless, there are two interesting things about this function: For reasons we‚Äôll explain later, because the item parameter is a reference to Quote, we can call this function on either a Quote object or a Bulk_quote object. And, for
reasons we‚Äôll explain later, because net_price is a virtual function, and because print_total calls net_price through a reference, the version of net_price that is run will depend on the type of the object that we pass to print_total:

// basic has type Quote; bulk has type Bulk_quote
print_total(cout, basic, 20); // calls Quote version of net_price
print_total(cout, bulk, 20); // calls Bulk_quote version of net_price

The first call passes a Quote object to print_total. When print_total calls net_price, the Quote version will be run. In the next call, the argument is a Bulk_quote, so the Bulk_quote version of net_price (which applies a discount) will be run. Because the decision as to which version to run depends on the type of the argument, that decision can‚Äôt be made until run time. Therefore, dynamic binding is sometimes known as run-time binding.

Note: In C++, dynamic binding happens when a virtual function is called through a reference (or a pointer) to a base class

--
Defining Base and Derived Classes

In many, but not all, ways base and derived classes are defined like other classes we have already seen. In this section, we‚Äôll cover the basic features used to define classes
related by inheritance.

Defining a Base Class

We‚Äôll start by completing the definition of our Quote class:

class Quote {
public:
	Quote() = default; // = default see ¬ß 7.1.4 (p. 264)
	Quote(const std::string &book, double sales_price):
	bookNo(book), price(sales_price) { }
	std::string isbn() const { return bookNo; }
	// returns the total sales price for the specified number of items
	// derived classes will override and apply different discount algorithms
	virtual double net_price(std::size_t n) const
	{ return n * price; }
	virtual ~Quote() = default; // dynamic binding for the destructor
private:
	std::string bookNo; // ISBN number of this item
protected:
	double price = 0.0; // normal, undiscounted price
};

The new parts in this class are the use of virtual on the net_price function and the destructor, and the protected access specifier. We‚Äôll explain virtual destructors later, but for now it is worth noting that classes used as the root of an
inheritance hierarchy almost always define a virtual destructor.

Note: Base classes ordinarily should define a virtual destructor. Virtual destructors are needed even if they do no work.

--
Member Functions and Inheritance

Derived classes inherit the members of their base class. However, a derived class needs to be able to provide its own definition for operations, such as net_price, that are type dependent. In such cases, the derived class needs to override the definition it inherits from the base class, by providing its own definition.

In C++, a base class must distinguish the functions it expects its derived classes to override from those that it expects its derived classes to inherit without change. The base class defines as virtual those functions it expects its derived classes to override. When we call a virtual function through a pointer or reference, the call will be dynamically bound. Depending on the type of the object to which the reference or
pointer is bound, the version in the base class or in one of its derived classes will be executed.

A base class specifies that a member function should be dynamically bound by preceding its declaration with the keyword virtual. Any nonstatic member function, other than a constructor, may be virtual. The virtual keyword appears only on the declaration inside the class and may not be used on a
function definition that appears outside the class body. A function that is declared as virtual in the base class is implicitly virtual in the derived classes as well. We‚Äôll
have more to say about virtual functions later.

Member functions that are not declared as virtual are resolved at compile time, not run time. For the isbn member, this is exactly the behavior we want. The isbn function does not depend on the details of a derived type. It behaves identically when run on a Quote or Bulk_quote object. There will be only one version of the isbn function in our inheritance hierarchy. Thus, there is no question as to which function to run when we call isbn().

--
Access Control and Inheritance

A derived class inherits the members defined in its base class. However, the member functions in a derived class may not necessarily access the members that are inherited from the base class. Like any other code that uses the base class, a derived class may access the public members of its base class but may not access the private members. However, sometimes a base class has members that it wants to let its derived classes use while still prohibiting access to those same members by other users. We specify such members after a protected access specifier.

Our Quote class expects its derived classes to define their own net_price function. To do so, those classes need access to the price member. As a result, Quote defines that member as protected. Derived classes are expected to access bookNo in the same way as ordinary users‚Äîby calling the isbn function. Hence, the bookNo member is private and is inaccessible to classes that inherit from Quote. We‚Äôll have more to say about protected members later.

--
Defining a Derived Class

A derived class must specify from which class(es) it inherits. It does so in its class derivation list, which is a colon followed by a comma-separated list of names of previously defined classes. Each base class name may be preceded by an optional access specifier, which is one of public, protected, or private.

A derived class must declare each inherited member function it intends to override. Therefore, our Bulk_quote class must include a net_price member:

class Bulk_quote : public Quote { // Bulk_quote inherits from Quote
	Bulk_quote() = default;
	Bulk_quote(const std::string&, double, std::size_t,
	double);
	// overrides the base version in order to implement the bulk purchase discount policy
	double net_price(std::size_t) const override;
private:
	std::size_t min_qty = 0; // minimum purchase for the discount to apply
	double discount = 0.0; // fractional discount to apply
};

Our Bulk_quote class inherits the isbn function and the bookNo and price data members of its Quote base class. It defines its own version of net_price and has two additional data members, min_qty and discount. These members specify the minimum quantity and the discount to apply once that number of copies are purchased.

We‚Äôll have more to say about the access specifier used in a derivation list later. For now, what‚Äôs useful to know is that the access specifier determines whether users of a derived class are allowed to know that the derived class inherits
from its base class.

When the derivation is public, the public members of the base class become part of the interface of the derived class as well. In addition, we can bind an object of a publicly derived type to a pointer or reference to the base type. Because we used public in the derivation list, the interface to Bulk_quote implicitly contains the isbn function, and we may use a Bulk_quote object where a pointer or reference to Quote is expected.

Most classes inherit directly from only one base class. This form of inheritance, known as ‚Äúsingle inheritance,‚Äù forms the topic of this chapter. Later will cover classes that have derivation lists with more than one base class.

--
Virtual Functions in the Derived Class

Derived classes frequently, but not always, override the virtual functions that they inherit. If a derived class does not override a virtual from its base, then, like any other
member, the derived class inherits the version defined in its base class.

A derived class may include the virtual keyword on the functions it overrides, but it is not required to do so. For reasons we‚Äôll explain later, the new standard lets a derived class explicitly note that it intends a member function to
override a virtual that it inherits. It does so by specifying override after the parameter list, or after the const or reference qualifier(s) if the member is a const or reference function.

--
Derived-Class Objects and the Derived-to-Base Conversion

A derived object contains multiple parts: a subobject containing the (nonstatic) members defined in the derived class itself, plus subobjects corresponding to each base class from which the derived class inherits. Thus, a Bulk_quote object will contain four data elements: the bookNo and price data members that it inherits from Quote, and the min_qty and discount members, which are defined by Bulk_quote.

Although the standard does not specify how derived objects are laid out in memory, we can think of a Bulk_quote object as consisting of two parts as represented in Figure below:

Bulk_quote object:
Members inherited from Quote: bookNo, price
Members defined by Bulk_quote: min_qty, discount

The base and derived parts of an object are not guaranteed to be stored contiguously. Figure above is a conceptual, not physical, representation of how classes work.

Because a derived object contains subparts corresponding to its base class(es), we can use an object of a derived type as if it were an object of its base type(s). In particular, we can bind a base-class reference or pointer to the base-class part of a derived object.

Quote item; // object of base type
Bulk_quote bulk; // object of derived type
Quote *p = &item; // p points to a Quote object
p = &bulk; // p points to the Quote part of bulk
Quote &r = bulk; // r bound to the Quote part of bulk

This conversion is often referred to as the derived-to-base conversion. As with any other conversion, the compiler will apply the derived-to-base conversion implicitly.

The fact that the derived-to-base conversion is implicit means that we can use an object of derived type or a reference to a derived type when a reference to the base type is required. Similarly, we can use a pointer to a derived type where a pointer to the base type is required.

Note: The fact that a derived object contains subobjects for its base classes is key to how inheritance works.

--
Derived-Class Constructors

Although a derived object contains members that it inherits from its base, it cannot directly initialize those members. Like any other code that creates an object of the base-class type, a derived class must use a base-class constructor to initialize its base-class part.

Note: Each class controls how its members are initialized.

The base-class part of an object is initialized, along with the data members of the derived class, during the initialization phase of the constructor. Analogously to how we initialize a member, a derived-class constructor uses its
constructor initializer list to pass arguments to a base-class constructor. For example, the Bulk_quote constructor with four parameters:

Bulk_quote(const std::string& book, double p,
			std::size_t qty, double disc) :
			Quote(book, p), min_qty(qty), discount(disc) { }
	// as before
};

passes its first two parameters (representing the ISBN and price) to the Quote constructor. That Quote constructor initializes the Bulk_quote‚Äôs base-class part (i.e., the bookNo and price members). When the (empty) Quote constructor body completes, the base-class part of the object being constructed will have been initialized. Next the direct members, min_qty and discount, are initialized. Finally, the (empty) function body of the Bulk_quote constructor is run.

As with a data member, unless we say otherwise, the base part of a derived object is default initialized. To use a different base-class constructor, we provide a constructor initializer using the name of the base class, followed (as usual) by a
parenthesized list of arguments. Those arguments are used to select which base-class constructor to use to initialize the base-class part of the derived object.

Note: The base class is initialized first, and then the members of the derived class are initialized in the order in which they are declared in the class.

--
Using Members of the Base Class from the Derived Class

A derived class may access the public and protected members of its base class:

// if the specified number of items are purchased, use the discounted price
double Bulk_quote::net_price(size_t cnt) const
{
	if (cnt >= min_qty)
		return cnt * (1 - discount) * price;
	else
		return cnt * price;
}

This function generates a discounted price: If the given quantity is more than min_qty, we apply the discount (which was stored as a fraction) to the price.

We‚Äôll have more to say about scope later, but for now it‚Äôs worth knowing that the scope of a derived class is nested inside the scope of its base class. As a result, there is no distinction between how a member of the derived class uses
members defined in its own class (e.g., min_qty and discount) and how it uses members defined in its base (e.g., price).

Key Concept: Respecting the Base-Class Interface

It is essential to understand that each class defines its own interface. Interactions with an object of a class-type should use the interface of that class, even if that object is the base-class part of a derived object.

As a result, derived-class constructors may not directly initialize the members of its base class. The constructor body of a derived constructor can assign values to its public or protected base-class members. Although it can assign to those members, it generally should not do so. Like any other
user of the base class, a derived class should respect the interface of its base class by using a constructor to initialize its inherited members.

--
Inheritance and static Members

If a base class defines a static member, there is only one such
member defined for the entire hierarchy. Regardless of the number of classes derived from a base class, there exists a single instance of each static member.

class Base {
public:
	static void statmem();
};

class Derived : public Base {
	void f(const Derived&);
};

static members obey normal access control. If the member is private in the base class, then derived classes have no access to it. Assuming the member is accessible, we can use a static member through either the base or derived:

void Derived::f(const Derived &derived_obj)
{
	Base::statmem(); // ok: Base defines statmem
	Derived::statmem(); // ok: Derived inherits statmem
	// ok: derived objects can be used to access static from base
	derived_obj.statmem(); // accessed through a Derived object
	statmem(); // accessed through this object
}

--
Declarations of Derived Classes

A derived class is declared like any other class. The declaration contains the class name but does not include its derivation list:

class Bulk_quote : public Quote; // error: derivation list can't appear here
class Bulk_quote; // ok: right way to declare a derived class

The purpose of a declaration is to make known that a name exists and what kind of entity it denotes, for example, a class, function, or variable. The derivation list, and all
other details of the definition, must appear together in the class body.

--
Classes Used as a Base Class

A class must be defined, not just declared, before we can use it as a base class:

class Quote; // declared but not defined
// error: Quote must be defined
class Bulk_quote : public Quote { ... };

The reason for this restriction should be easy to see: Each derived class contains, and may use, the members it inherits from its base class. To use those members, the derived class must know what they are. One implication of this rule is that it is impossible to derive a class from itself.

A base class can itself be a derived class:

class Base { /* ... */ } ;
class D1: public Base { /* ... */ };
class D2: public D1 { /* ... */ };

In this hierarchy, Base is a direct base to D1 and an indirect base to D2. A direct base class is named in the derivation list. An indirect base is one that a derived class inherits through its direct base class.

Each class inherits all the members of its direct base class. The most derived class inherits the members of its direct base. The members in the direct base include those it inherits from its base class, and so on up the inheritance chain. Effectively, the most derived object contains a subobject for its direct base and for each of its indirect bases.

--
Preventing Inheritance

Sometimes we define a class that we don‚Äôt want others to inherit from. Or we might define a class for which we don‚Äôt want to think about whether it is appropriate as a base class. Under the new standard, we can prevent a class from being used as a base by following the class name with final:

class NoDerived final { /* */ }; // NoDerived can't be a base class
class Base { /* */ };
// Last is final; we cannot inherit from Last
class Last final : Base { /* */ }; // Last can't be a base class
class Bad : NoDerived { /* */ }; // error: NoDerived is final
class Bad2 : Last { /* */ }; // error: Last is final

--
Conversions and Inheritance

Warning: Understanding conversions between base and derived classes is essential to understanding how object-oriented programming works in C++.

Ordinarily, we can bind a reference or a pointer only to an object that has the same type as the corresponding reference or pointer or to a type that involves an acceptable const conversion. Classes related by inheritance are an important exception: We can bind a pointer or reference to a base-class type to an object of a type derived from that base class. For example, we can use a Quote& to refer to a Bulk_quote object, and we can assign the address of a Bulk_quote object to a Quote*.

The fact that we can bind a reference (or pointer) to a base-class type to a derived object has a crucially important implication: When we use a reference (or pointer) to a base-class type, we don‚Äôt know the actual type of the object to which the pointer or reference is bound. That object can be an object of the base class or it can be an object of a derived class.

Note: Like built-in pointers, the smart pointer classes support the derived-to-base conversion‚Äîwe can store a pointer to a derived object in a smart pointer to the base type.

--
Static Type and Dynamic Type

When we use types related by inheritance, we often need to distinguish between the static type of a variable or other expression and the dynamic type of the object that expression represents. The static type of an expression is always known at compile time‚Äîit is the type with which a variable is declared or that an expression yields. The dynamic type is the type of the object in memory that the variable or expression represents. The dynamic type may not be known until run time.
For example, when print_total calls net_price:

double ret = item.net_price(n);

we know that the static type of item is Quote&. The dynamic type depends on the type of the argument to which item is bound. That type cannot be known until a call is executed at run time. If we pass a Bulk_quote object to print_total, then the static type of item will differ from its dynamic type. As we‚Äôve seen, the static type of item is Quote&, but in this case the dynamic type is Bulk_quote.

The dynamic type of an expression that is neither a reference nor a pointer is always the same as that expression‚Äôs static type. For example, a variable of type Quote is always a Quote object; there is nothing we can do that will change the type
of the object to which that variable corresponds.

Note: It is crucial to understand that the static type of a pointer or reference to a base class may differ from its dynamic type.

--
There Is No Implicit Conversion from Base to Derived ...

The conversion from derived to base exists because every derived object contains a base-class part to which a pointer or reference of the base-class type can be bound. There is no similar guarantee for base-class objects. A base-class object can exist either as an independent object or as part of a derived object. A base object that is not part of a derived object has only the members defined by the base class; it
doesn‚Äôt have the members defined by the derived class.

Because a base object might or might not be part of a derived object, there is no automatic conversion from the base class to its derived class(s):

Quote base;
Bulk_quote* bulkP = &base; // error: can't convert base to derived
Bulk_quote& bulkRef = base; // error: can't convert base to derived

If these assignments were legal, we might attempt to use bulkP or bulkRef to use members that do not exist in base.

What is sometimes a bit surprising is that we cannot convert from base to derived even when a base pointer or reference is bound to a derived object:

Bulk_quote bulk;
Quote *itemP = &bulk; // ok: dynamic type is Bulk_quote
Bulk_quote *bulkP = itemP; // error: can't convert base to derived

The compiler has no way to know (at compile time) that a specific conversion will be safe at run time. The compiler looks only at the static types of the pointer or reference to determine whether a conversion is legal. If the base class has one or more virtual functions, we can use a dynamic_cast (which we‚Äôll cover later to request a conversion that is checked at run time. Alternatively, in those cases when we know that the conversion from base to derived is safe, we can use a static_cast to override the compiler.

--
...and No Conversion between Objects

The automatic derived-to-base conversion applies only for conversions to a reference or pointer type. There is no such conversion from a derived-class type to the baseclass type. Nevertheless, it is often possible to convert an object of a derived class to its base-class type. However, such conversions may not behave as we might want.

Remember that when we initialize or assign an object of a class type, we are actually calling a function. When we initialize, we‚Äôre calling a constructor; when we assign, we‚Äôre calling an assignment operator. These members normally have a parameter that is a reference to the const version of the class type.

Because these members take references, the derived-to-base conversion lets us pass a derived object to a base-class copy/move operation. These operations are not virtual. When we pass a derived object to a base-class constructor, the constructor
that is run is defined in the base class. That constructor knows only about the members of the base class itself. Similarly, if we assign a derived object to a base object, the assignment operator that is run is the one defined in the base class. That operator also knows only about the members of the base class itself.

For example, our bookstore classes use the synthesized versions of copy and assignment. We‚Äôll have more to say about copy control and inheritance later, but for now what‚Äôs useful to know is that the synthesized versions memberwise copy or assign the data members of the class the same way as for any other class:

Bulk_quote bulk; // object of derived type
Quote item(bulk); // uses the Quote::Quote(const Quote&) constructor
item = bulk; // calls Quote::operator=(const Quote&)

When item is constructed, the Quote copy constructor is run. That constructor knows only about the bookNo and price members. It copies those members from the Quote part of bulk and ignores the members that are part of the Bulk_quote portion of bulk. Similarly for the assignment of bulk to item; only the Quote part of bulk is assigned to item.

Because the Bulk_quote part is ignored, we say that the Bulk_quote portion of bulk is sliced down.

Warning: When we initialize or assign an object of a base type from an object of a derived type, only the base-class part of the derived object is copied, moved, or assigned. The derived part of the object is ignored.

--
Virtual Functions

As we‚Äôve seen, in C++ dynamic binding happens when a virtual member function is called through a reference or a pointer to a base-class type. Because we don‚Äôt know which version of a function is called until run time, virtual functions must always be defined. Ordinarily, if we do not use a function, we don‚Äôt need to supply a definition for that function. However, we must define every virtual function, regardless of whether it is used, because the compiler has no way to determine whether a virtual function is used.

Key Concept: Conversions among Types Related by Inheritance
There are three things that are important to understand about conversions among classes related by inheritance:

‚Ä¢ The conversion from derived to base applies only to pointer or reference types.

‚Ä¢ There is no implicit conversion from the base-class type to the derived type.

‚Ä¢ Like any member, the derived-to-base conversion may be inaccessible due to access controls. We‚Äôll cover accessibility later.

Although the automatic conversion applies only to pointers and references, most classes in an inheritance hierarchy (implicitly or explicitly) define the copy-control members. As a result, we can often copy, move, or assign an object of derived type to a base-type object. However, copying,
moving, or assigning a derived-type object to a base-type object copies, moves, or assigns only the members in the base-class part of the object.

--
Calls to Virtual Functions May Be Resolved at Run Time

When a virtual function is called through a reference or pointer, the compiler generates code to decide at run time which function to call. The function that is called is the one that corresponds to the dynamic type of the object bound to that pointer or reference.

As an example, consider our print_total function from. That
function calls net_price on its parameter named item, which has type Quote&. Because item is a reference, and because net_price is virtual, the version of net_price that is called depends at run time on the actual (dynamic) type of the
argument bound to item:

Quote base("0-201-82470-1", 50);
print_total(cout, base, 10); // calls Quote::net_price
Bulk_quote derived("0-201-82470-1", 50, 5, .19);
print_total(cout, derived, 10); // calls Bulk_quote::net_price

In the first call, item is bound to an object of type Quote. As a result, when print_total calls net_price, the version defined by Quote is run. In the second call, item is bound to a Bulk_quote object. In this call, print_total calls the
Bulk_quote version of net_price. 

It is crucial to understand that dynamic binding happens only when a virtual function is called through a pointer or a reference.

base = derived; // copies the Quote part of derived into base
base.net_price(20); // calls Quote::net_price

When we call a virtual function on an expression that has a plain‚Äînonreference and nonpointer‚Äîtype, that call is bound at compile time. For example, when we call net_price on base, there is no question as to which version of net_price to run.
We can change the value (i.e., the contents) of the object that base represents, but there is no way to change the type of that object. Hence, this call is resolved, at compile time, to the Quote version of net_price.

Key Concept: Polymorphism in C++

The key idea behind OOP is polymorphism. Polymorphism i derived from a Greek word meaning ‚Äúmany forms.‚Äù We speak of types related by inheritance as polymorphic types, because we can use the ‚Äúmany forms‚Äù of these types while ignoring the differences among them. The fact that the static and dynamic types of references and pointers can differ is the cornerstone of how C++ supports polymorphism.

When we call a function defined in a base class through a reference or pointer to the base class, we do not know the type of the object on which that member is executed. The object can be a base-class object or an object of a derived class. If the function is virtual, then the decision as to which function to run is delayed until run time. The version of the virtual function that is run is the one defined by
the type of the object to which the reference is bound or to which the pointer points.

On the other hand, calls to nonvirtual functions are bound at compile time. Similarly, calls to any function (virtual or not) on an object are also bound at compile time. The type of an object is fixed and unvarying‚Äîthere is nothing we can do to make the dynamic type of an object differ from its static type.
Therefore, calls made on an object are bound at compile time to the version defined by the type of the object.

Note: Virtuals are resolved at run time only if the call is made through a reference or pointer. Only in these cases is it possible for an object‚Äôs dynamic type to differ from its static type.

--
Virtual Functions in a Derived Class

When a derived class overrides a virtual function, it may, but is not required to, repeat the virtual keyword. Once a function is declared as virtual, it remains virtual in all the derived classes.

A derived-class function that overrides an inherited virtual function must have  exactly the same parameter type(s) as the base-class function that it overrides.

With one exception, the return type of a virtual in the derived class also must match the return type of the function from the base class. The exception applies to virtuals that return a reference (or pointer) to types that are themselves related by inheritance. That is, if D is derived from B, then a base class virtual can return a B* and the version in the derived can return a D*. However, such return types require
that the derived-to-base conversion from D to B is accessible. Later covers how to determine whether a base class is accessible. We‚Äôll see an example of this kind of virtual function later.

Note: A function that is virtual in a base class is implicitly virtual in its derived classes. When a derived class overrides a virtual, the parameters in the base and derived classes must match exactly.

--
The final and override Specifiers

As we‚Äôll see later, it is legal for a derived class to define a function with the same name as a virtual in its base class but with a different parameter list. The compiler considers such a function to be independent from the base-class function. In such cases, the derived version does not override the version in the base class. In practice, such declarations often are a mistake‚Äîthe class author intended to override
a virtual from the base class but made a mistake in specifying the parameter list.

Finding such bugs can be surprisingly hard. Under the new standard we can specify override on a virtual function in a derived class. Doing so makes our intention clear and (more importantly) enlists the compiler in finding such problems for us. The compiler will reject a program if a function marked override does not override an existing virtual function:

struct B {
	virtual void f1(int) const;
	virtual void f2();
	void f3();
};

struct D1 : B {
	void f1(int) const override; // ok: f1 matches f1 in the base
	void f2(int) override; // error: B has no f2(int) function
	void f3() override; // error: f3 not virtual
	void f4() override; // error: B doesn't have a function named f4
};

In D1, the override specifier on f1 is fine; both the base and derived versions of f1 are const members that take an int and return void. The version of f1 in D1 properly overrides the virtual that it inherits from B.

The declaration of f2 in D1 does not match the declaration of f2 in B‚Äîthe version defined in B takes no arguments and the one defined in D1 takes an int. Because the declarations don‚Äôt match, f2 in D1 doesn‚Äôt override f2 from B; it is a new function that happens to have the same name. Because we said we intended this declaration to be an override and it isn‚Äôt, the compiler will generate an error.

Because only a virtual function can be overridden, the compiler will also reject f3 in D1. That function is not virtual in B, so there is no function to override. Similarly f4 is in error because B doesn‚Äôt even have a function named f4.
We can also designate a function as final. Any attempt to override a function that
has been defined as final will be flagged as an error:
Click here to view code image
struct D2 : B {
	// inherits f2() and f3() from B and overrides f1(int)
	void f1(int) const final; // subsequent classes can't override f1
(int)
};

struct D3 : D2 {
	void f2(); // ok: overrides f2 inherited from the indirect base,
	B
	void f1(int) const; // error: D2 declared f2 as final
};

final and override specifiers appear after the parameter list  including any const or reference qualifiers) and after a trailing return.

--
Virtual Functions and Default Arguments

Like any other function, a virtual function can have default arguments. If a call uses a default argument, the value that is used is the one defined by the static type through which the function is called.

That is, when a call is made through a reference or pointer to base, the default argument(s) will be those defined in the base class. The base-class arguments will be used even when the derived version of the function is run. In this case, the derived function will be passed the default arguments defined for the base-class version of the function. If the derived function relies on being passed different arguments, the
program will not execute as expected.

Best Practices: Virtual functions that have default arguments should use the same argument values in the base and derived classes.

--
Circumventing the Virtual Mechanism

In some cases, we want to prevent dynamic binding of a call to a virtual function; we want to force the call to use a particular version of that virtual. We can use the scope
operator to do so. For example, this code:

	// calls the version from the base class regardless of the dynamic type of baseP
	double undiscounted = baseP->Quote::net_price(42);

calls the Quote version of net_price regardless of the type of the object to which baseP actually points. This call will be resolved at compile time.

Note: Ordinarily, only code inside member functions (or friends) should need to use the scope operator to circumvent the virtual mechanism.

Why might we wish to circumvent the virtual mechanism? The most common reason is when a derived-class virtual function calls the version from the base class. In such cases, the base-class version might do work common to all types in the hierarchy. The versions defined in the derived classes would do whatever additional work is particular to their own type.
Warning

If a derived virtual function that intended to call its base-class version omits the scope operator, the call will be resolved at run time as a call to the derived version itself, resulting in an infinite recursion.

--
Abstract Base Classes

Imagine that we want to extend our bookstore classes to support several discount strategies. In addition to a bulk discount, we might offer a discount for purchases up to a certain quantity and then charge the full price thereafter. Or we might offer a discount for purchases above a certain limit but not for purchases up to that limit.

Each of these discount strategies is the same in that it requires a quantity and a discount amount. We might support these differing strategies by defining a new class named Disc_quote to store the quantity and the discount amount. Classes, such as Bulk_item, that represent a specific discount strategy will inherit from Disc_quote. Each of the derived classes will implement its discount strategy by defining its own version of net_price.

Before we can define our Disc_Quote class, we have to decide what to do about net_price. Our Disc_quote class doesn‚Äôt correspond to any particular discount strategy; there is no meaning to ascribe to net_price for this class.

We could define Disc_quote without its own version of net_price. In this case, Disc_quote would inherit net_price from Quote.

However, this design would make it possible for our users to write nonsensical code. A user could create an object of type Disc_quote by supplying a quantity and a discount rate. Passing that Disc_quote object to a function such as print_total would use the Quote version of net_price. The calculated price would not include the discount that was supplied when the object was created. That state of affairs
makes no sense.

--
Pure Virtual Functions

Thinking about the question in this detail reveals that our problem is not just that we don‚Äôt know how to define net_price. In practice, we‚Äôd like to prevent users from creating Disc_quote objects at all. This class represents the general concept of a discounted book, not a concrete discount strategy.

We can enforce this design intent‚Äîand make it clear that there is no meaning for net_price‚Äîby defining net_price as a pure virtual function. Unlike ordinary virtuals, a pure virtual function does not have to be defined. We specify that a virtual
function is a pure virtual by writing = 0 in place of a function body (i.e., just before the semicolon that ends the declaration). The = 0 may appear only on the declaration of a virtual function in the class body:

// class to hold the discount rate and quantity
// derived classes will implement pricing strategies using these data
class Disc_quote : public Quote {
public:
	Disc_quote() = default;
	Disc_quote(const std::string& book, double price,
	std::size_t qty, double disc):
	Quote(book, price),
	quantity(qty), discount(disc) { }
	double net_price(std::size_t) const = 0;
protected:
	std::size_t quantity = 0; // purchase size for the discount to apply
	double discount = 0.0; // fractional discount to apply
};

Like our earlier Bulk_item class, Disc_quote defines a default constructor and a constructor that takes four parameters. Although we cannot define objects of this type directly, constructors in classes derived from Disc_quote will use the Disc_quote constructors to construct the Disc_quote part of their objects. The constructor that has four parameters passes its first two to the Quote constructor and directly
initializes its own members, discount and quantity. The default constructor default initializes those members.

It is worth noting that we can provide a definition for a pure virtual. However, the function body must be defined outside the class. That is, we cannot provide a function body inside the class for a function that is = 0.

--
Classes with Pure Virtuals Are Abstract Base Classes

A class containing (or inheriting without overridding) a pure virtual function is an abstract base class. An abstract base class defines an interface for subsequent classes to override. We cannot (directly) create objects of a type that is an abstract base class. Because Disc_quote defines net_price as a pure virtual, we cannot define objects of type Disc_quote. We can define objects of classes that inherit from Disc_quote, so long as those classes override net_price:

// Disc_quote declares pure virtual functions, which Bulk_quote will override
Disc_quote discounted; // error: can't define a Disc_quote object
Bulk_quote bulk; // ok: Bulk_quote has no pure virtual functions

Classes that inherit from Disc_quote must define net_price or those classes will be abstract as well.

Note: We may not create objects of a type that is an abstract base class.

--
A Derived Class Constructor Initializes Its Direct Base Class Only

Now we can reimplement Bulk_quote to inherit from Disc_quote rather than inheriting directly from Quote:

// the discount kicks in when a specified number of copies of the same book are sold
// the discount is expressed as a fraction to use to reduce the normal price
class Bulk_quote : public Disc_quote {
public:
	Bulk_quote() = default;
	Bulk_quote(const std::string& book, double price,
				std::size_t qty, double disc):
	Disc_quote(book, price, qty, disc) { }

// overrides the base version to implement the bulk purchase discount policy
double net_price(std::size_t) const override;
};

This version of Bulk_quote has a direct base class, Disc_quote, and an indirect base class, Quote. Each Bulk_quote object has three subobjects: an (empty) Bulk_quote part, a Disc_quote subobject, and a Quote subobject.

As we‚Äôve seen, each class controls the initialization of objects of its type. Therefore, even though Bulk_quote has no data members of its own, it provides the same four-argument constructor as in our original class. Our new constructor passes its arguments to the Disc_quote constructor. That constructor in turn runs the Quote constructor. The Quote constructor initializes the bookNo and price members of
bulk. When the Quote constructor ends, the Disc_quote constructor runs and initializes the quantity and discount members. At this point, the Bulk_quote constructor resumes. That constructor has no further initializations or any other work to do.

Key Concept: Refactoring

Adding Disc_quote to the Quote hierarchy is an example of refactoring. Refactoring involves redesigning a class hierarchy to move operations and/or data from one class to another. Refactoring is common in object-oriented applications.

It is noteworthy that even though we changed the inheritance hierarchy, code that uses Bulk_quote or Quote would not need to change. However, when classes are refactored (or changed in any other way) we must recompile any code that uses those classes.

--
Access Control and Inheritance

Just as each class controls the initialization of its own members, each class also controls whether its members are accessible to a derived class.

protected Members

As we‚Äôve seen, a class uses protected for those members that it is willing to share with its derived classes but wants to protect from general access. The protected specifier can be thought of as a blend of private and public:

‚Ä¢ Like private, protected members are inaccessible to users of the class.

‚Ä¢ Like public, protected members are accessible to members and friends of classes derived from this class. In addition, protected has another important property:

‚Ä¢ A derived class member or friend may access the protected members of the base class only through a derived object. The derived class has no special access to the protected members of base-class objects.

To understand this last rule, consider the following example:

class Base {
protected:
	int prot_mem; // protected member
};
	class Sneaky : public Base {
	friend void clobber(Sneaky&); // can access Sneaky::prot_mem
	friend void clobber(Base&); // can't access Base::prot_mem
	int j; // j is private by default
};

// ok: clobber can access the private and protected members in Sneaky objects void clobber(Sneaky &s) { s.j = s.prot_mem = 0; }
// error: clobber can't access the protected members in Base
void clobber(Base &b) { b.prot_mem = 0; }

If derived classes (and friends) could access protected members in a base-class object, then our second version of clobber (that takes a Base&) would be legal. That function is not a friend of Base, yet it would be allowed to change an object of type Base; we could circumvent the protection provided by protected for any class simply by defining a new class along the lines of Sneaky. To prevent such usage, members and friends of a derived class can access the protected members only in base-class objects that are embedded inside a derived type object; they have no special access to ordinary objects of the base type.

--
public, private, and protected Inheritance

Access to a member that a class inherits is controlled by a combination of the access specifier for that member in the base class, and the access specifier in the derivation
list of the derived class. As an example, consider the following hierarchy:

class Base {
public:
void pub_mem(); // public member
protected:
int prot_mem; // protected member
private:
char priv_mem; // private member
};

struct Pub_Derv : public Base {
// ok: derived classes can access protected members
	int f() { return prot_mem; }
	// error: private members are inaccessible to derived classes
	char g() { return priv_mem; }
};

struct Priv_Derv : private Base {
	// private derivation doesn't affect access in the derived class
	int f1() const { return prot_mem; }
};

The derivation access specifier has no effect on whether members (and friends) of a derived class may access the members of its own direct base class. Access to the
members of a base class is controlled by the access specifiers in the base class itself. Both Pub_Derv and Priv_Derv may access the protected member prot_mem. Neither may access the private member priv_mem.

The purpose of the derivation access specifier is to control the access that users of the derived class‚Äîincluding other classes derived from the derived class‚Äîhave to the members inherited from Base:

Pub_Derv d1; // members inherited from Base are public
Priv_Derv d2; // members inherited from Base are private
d1.pub_mem(); // ok: pub_mem is public in the derived class
d2.pub_mem(); // error: pub_mem is private in the derived class

Both Pub_Derv and Priv_Derv inherit the pub_mem function. When the inheritance is public, members retain their access specification. Thus, d1 can call pub_mem. In Priv_Derv, the members of Base are private; users of that class may not call
pub_mem.

The derivation access specifier used by a derived class also controls access from classes that inherit from that derived class:

struct Derived_from_Public : public Pub_Derv {
	// ok: Base::prot_mem remains protected in Pub_Derv
	int use_base() { return prot_mem; }
};
struct Derived_from_Private : public Priv_Derv {
	// error: Base::prot_mem is private in Priv_Derv
	int use_base() { return prot_mem; }
};

Classes derived from Pub_Derv may access prot_mem from Base because that member remains a protected member in Pub_Derv. In contrast, classes derived from Priv_Derv have no such access. To them, all the members that Priv_Derv inherited from Base are private.

Had we defined another class, say, Prot_Derv, that used protected inheritance, the public members of Base would be protected members in that class. Users of Prot_Derv would have no access to pub_mem, but the members and friends of Prot_Derv could access that inherited member.

--
Accessibility of Derived-to-Base Conversion

Whether the derived-to-base conversion is accessible depends on
which code is trying to use the conversion and may depend on the access specifier used in the derived class‚Äô derivation. 

Assuming D inherits from B:

‚Ä¢ User code may use the derived-to-base conversion only if D inherits publicly from B. User code may not use the conversion if D inherits from B using either protected or private.

‚Ä¢ Member functions and friends of D can use the conversion to B regardless of how D inherits from B. The derived-to-base conversion to a direct base class is always accessible to members and friends of a derived class.

‚Ä¢ Member functions and friends of classes derived from D may use the derived-tobase conversion if D inherits from B using either public or protected. Such code may not use the conversion if D inherits privately from B.

Tip: For any given point in your code, if a public member of the base class would be accessible, then the derived-to-base conversion is also accessible, and not otherwise.

Key Concept: Class Design and protected Members

In the absence of inheritance, we can think of a class as having two different kinds of users: ordinary users and implementors. Ordinary users write code that uses objects of the class type; such code can access only the public
(interface) members of the class. Implementors write the code contained in the members and friends of the class. The members and friends of the class can access both the public and private (implementation) sections.

Under inheritance, there is a third kind of user, namely, derived classes. A base class makes protected those parts of its implementation that it is willing to let its derived classes use. The protected members remain inaccessible to ordinary user code; private members remain inaccessible to
derived classes and their friends.

Like any other class, a class that is used as a base class makes its interface members public. A class that is used as a base class may divide its implementation into those members that are accessible to derived classes and those that remain accessible only to the base class and its friends. An
implementation member should be protected if it provides an operation or data that a derived class will need to use in its own implementation. Otherwise, implementation members should be private.

--
Friendship and Inheritance

Just as friendship is not transitive, friendship is also not inherited. Friends of the base have no special access to members of its derived classes, and friends of a derived class have no special access to the base class:

class Base {
	// added friend declaration; other members as before
	friend class Pal; // Pal has no access to classes derived from Base
};
class Pal {
public:
	int f(Base b) { return b.prot_mem; } // ok: Pal is a friend of
	Base
	int f2(Sneaky s) { return s.j; } // error: Pal not friend of
	Sneaky
	// access to a base class is controlled by the base class, even inside a derived
	object
	int f3(Sneaky s) { return s.prot_mem; } // ok: Pal is a friend
};

The fact that f3 is legal may seem surprising, but it follows directly from the notion that each class controls access to its own members. Pal is a friend of Base, so Pal can access the members of Base objects. That access includes access to Base objects that are embedded in an object of a type derived from Base.

When a class makes another class a friend, it is only that class to which friendship is granted. The base classes of, and classes derived from, the friend have no special access to the befriending class:

// D2 has no access to protected or private members in Base
class D2 : public Pal {
public:
	int mem(Base b)
		{ return b.prot_mem; } // error: friendship doesn't inherit
};

Note: Friendship is not inherited; each class controls access to its members.

--
Exempting Individual Members

Sometimes we need to change the access level of a name that a derived class inherits. We can do so by providing a using declaration:

class Base {
public:
	std::size_t size() const { return n; }
protected:
	std::size_t n;
};

class Derived : private Base { // note: private inheritance
public:
	// maintain access levels for members related to the size of the object
	using Base::size;
protected:
	using Base::n;
};

Because Derived uses private inheritance, the inherited members, size and n, are (by default) private members of Derived. The using declarations adjust the accessibility of these members. Users of Derived can access the size member, and
classes subsequently derived from Derived can access n. A using declaration inside a class can name any accessible (e.g., not private) member of a direct or indirect base class. Access to a name specified in a using declaration depends on the access specifier preceding the using declaration. That is,
if a using declaration appears in a private part of the class, that name is accessible to members and friends only. If the declaration is in a public section, the name is available to all users of the class. If the declaration is in a protected
section, the name is accessible to the members, friends, and derived classes.

Note: A derived class may provide a using declaration only for names it is permitted to access.

--
Default Inheritance Protection Levels

Later we saw that classes defined with the struct and class keywords have different default access specifiers. Similarly, the default derivation specifier depends on which keyword is used to define a derived class. By default, a derived class defined with the class keyword has private inheritance; a derived class defined with struct has public inheritance:

class Base { /* ... */ };
struct D1 : Base { /* ... */ }; // public inheritance by default
class D2 : Base { /* ... */ }; // private inheritance by default

It is a common misconception to think that there are deeper differences between classes defined using the struct keyword and those defined using class. The only differences are the default access specifier for members and the default derivation
access specifier. There are no other distinctions.

Best Practices: A privately derived class should specify private explicitly rather than rely on the default. Being explicit makes it clear that private inheritance is intended
and not an oversight.

--
Class Scope under Inheritance

Each class defines its own scope within which its members are defined. Under inheritance, the scope of a derived class is nested inside the scope of its base classes. If a name is unresolved within the scope of the derived class, the enclosing base-class scopes are searched for a definition of that name.

The fact that the scope of a derived class nests inside the scope of its base classes can be surprising. After all, the base and derived classes are defined in separate parts
of our program‚Äôs text. However, it is this hierarchical nesting of class scopes that allows the members of a derived class to use members of its base class as if those members were part of the derived class. For example, when we write

Bulk_quote bulk;

cout << bulk.isbn();

the use of the name isbn is resolved as follows:

‚Ä¢ Because we called isbn on an object of type Bulk_quote, the search starts in the Bulk_quote class. The name isbn is not found in that class.

‚Ä¢ Because Bulk_quote is derived from Disc_quote, the Disc_quote class is searched next. The name is still not found.

‚Ä¢ Because Disc_quote is derived from Quote, the Quote class is searched next. The name isbn is found in that class; the use of isbn is resolved to the isbn in Quote.

--
Name Lookup Happens at Compile Time

The static type of an object, reference, or pointer determines which members of that object are visible. Even when the static and dynamic types might differ (as can happen when a reference or pointer to a base class is used), the static type determines what members can be used. As an example, we might add a member to the Disc_quote class that returns a pair holding the minimum (or maximum) quantity and the discounted price:

class Disc_quote : public Quote {
public:
	std::pair<size_t, double> discount_policy() const
	{ return {quantity, discount}; }
	// other members as before
};

We can use discount_policy only through an object, pointer, or reference of type Disc_quote or of a class derived from Disc_quote:

Bulk_quote bulk;
Bulk_quote *bulkP = &bulk; // static and dynamic types are the same
Quote *itemP = &bulk; // static and dynamic types differ
bulkP->discount_policy(); // ok: bulkP has type Bulk_quote*
itemP->discount_policy(); // error: itemP has type Quote*

Even though bulk has a member named discount_policy, that member is not visible through itemP. The type of itemP is a pointer to Quote, which means that the search for discount_policy starts in class Quote. The Quote class has no
member named discount_policy, so we cannot call that member on an object, reference, or pointer of type Quote.

--
Name Collisions and Inheritance

Like any other scope, a derived class can reuse a name defined in one of its direct or indirect base classes. As usual, names defined in an inner scope (e.g., a derived class) hide uses of that name in the outer scope (e.g., a base class):

struct Base {
	Base(): mem(0) { }
protected:
	int mem;
};

struct Derived : Base {
Derived(int i): mem(i) { } // initializes Derived::mem to i
	// Base::mem is default initialized
	int get_mem() { return mem; } // returns Derived::mem
protected:
	int mem; // hides mem in the base
};

The reference to mem inside get_mem is resolved to the name inside Derived. Were we to write

Derived d(42);

cout << d.get_mem() << endl; // prints 42

then the output would be 42.

Note: A derived-class member with the same name as a member of the base class hides direct use of the base-class member.

--
Using the Scope Operator to Use Hidden Members

We can use a hidden base-class member by using the scope operator:

struct Derived : Base {
	int get_base_mem() { return Base::mem; }
	// ...
};

The scope operator overrides the normal lookup and directs the compiler to look for mem starting in the scope of class Base. If we ran the code above with this version of Derived, the result of d.get_mem() would be 0.

Best Practices: Aside from overriding inherited virtual functions, a derived class usually should not reuse names defined in its base class.

Key Concept: Name Lookup and Inheritance

Understanding how function calls are resolved is crucial  understanding inheritance in C++. Given the call p->mem() (or obj.mem()), the following four steps happen:

‚Ä¢ First determine the static type of p (or obj). Because we‚Äôre calling a member, that type must be a class type.

‚Ä¢ Look for mem in the class that corresponds to the static type of p (or obj). If mem is not found, look in the direct base class and continue up the chain of classes until mem is found or the last class is searched. If mem is not
found in the class or its enclosing base classes, then the call will not compile.

‚Ä¢ Once mem is found, do normal type checking (¬ß6.1, p. 203) to see if this call is legal given the definition that was found.

‚Ä¢ Assuming the call is legal, the compiler generates code, which varies depending on whether the call is virtual or not:

‚Äì If mem is virtual and the call is made through a reference or pointer, then the compiler generates code to determine at run time which version to run based on the dynamic type of the object.

‚Äì Otherwise, if the function is nonvirtual, or if the call is on an object (not a reference or pointer), the compiler generates a normal function call.

--
As Usual, Name Lookup Happens before Type Checking

As we‚Äôve seen, functions declared in an inner scope do not overload functions declared in an outer scope. As a result, functions defined in a derived class do not overload members defined in its base class(es). As in any other scope, if a member in a derived class (i.e., in an inner scope) has the same name as a baseclass member (i.e., a name defined in an outer scope), then the derived member hides the base-class member within the scope of the derived class. The base member
is hidden even if the functions have different parameter lists:

--
struct Base {
	int memfcn();
};
struct Derived : Base {
	int memfcn(int); // hides memfcn in the base
	};
	Derived d; Base b;
	b.memfcn(); // calls Base::memfcn
	d.memfcn(10); // calls Derived::memfcn
	d.memfcn(); // error: memfcn with no arguments is hidden
	d.Base::memfcn(); // ok: calls Base::memfcn

The declaration of memfcn in Derived hides the declaration of memfcn in Base. Not surprisingly, the first call through b, which is a Base object, calls the version in the base class. Similarly, the second call (through d) calls the one from Derived. What can be surprising is that the third call, d.memfcn(), is illegal.

To resolve this call, the compiler looks for the name memfcn in Derived. That class defines a member named memfcn and the search stops. Once the name is found, the compiler looks no further. The version of memfcn in Derived expects an int argument. This call provides no such argument; it is in error.

--
Virtual Functions and Scope

We can now understand why virtual functions must have the same parameter list in the base and derived classes. If the base and derived members took arguments that differed from one another, there would be no way to call the derived version through a reference or pointer to the base class. For example:

class Base {
public:
	virtual int fcn();
};
class D1 : public Base {
public:
	// hides fcn in the base; this fcn is not virtual
	// D1 inherits the definition of Base::fcn()
	int fcn(int); // parameter list differs from fcn in Base
	virtual void f2(); // new virtual function that does not exist in Base
};

class D2 : public D1 {
public:
	int fcn(int); // nonvirtual function hides D1::fcn(int)
	int fcn(); // overrides virtual fcn from Base
	void f2(); // overrides virtual f2 from D1
};

The fcn function in D1 does not override the virtual fcn from Base because they have different parameter lists. Instead, it hides fcn from the base. Effectively, D1 has two functions named fcn: D1 inherits a virtual named fcn from Base and defines its own, nonvirtual member named fcn that takes an int parameter.

--
Calling a Hidden Virtual through the Base Class

Given the classes above, let‚Äôs look at several different ways to call these functions:

Base bobj; D1 d1obj; D2 d2obj;
Base *bp1 = &bobj, *bp2 = &d1obj, *bp3 = &d2obj;
bp1->fcn(); // virtual call, will call Base::fcn at run time
bp2->fcn(); // virtual call, will call Base::fcn at run time
bp3->fcn(); // virtual call, will call D2::fcn at run time
D1 *d1p = &d1obj; D2 *d2p = &d2obj;
bp2->f2(); // error: Base has no member named f2
d1p->f2(); // virtual call, will call D1::f2() at run time
d2p->f2(); // virtual call, will call D2::f2() at run time

The first three calls are all made through pointers to the base class. Because fcn is virtual, the compiler generates code to decide at run time which version to call. That
decision will be based on the actual type of the object to which the pointer is bound. In the case of bp2, the underlying object is a D1. That class did not override the fcn function that takes no arguments. Thus, the call through bp2 is resolved (at run time) to the version defined in Base.

The next three calls are made through pointers with differing types. Each pointer points to one of the types in this hierarchy. The first call is illegal because there is no
f2() in class Base. The fact that the pointer happens to point to a derived object is irrelevant.

For completeness, let‚Äôs look at calls to the nonvirtual function fcn(int):

Base *p1 = &d2obj; D1 *p2 = &d2obj; D2 *p3 = &d2obj;
p1->fcn(42); // error: Base has no version of fcn that takes an int
p2->fcn(42); // statically bound, calls D1::fcn(int)
p3->fcn(42); // statically bound, calls D2::fcn(int)

In each call the pointer happens to point to an object of type D2. However, the dynamic type doesn‚Äôt matter when we call a nonvirtual function. The version that is called depends only on the static type of the pointer.

--
Overriding Overloaded Functions

As with any other function, a member function (virtual or otherwise) can be overloaded. A derived class can override zero or more instances of the overloaded functions it inherits. If a derived class wants to make all the overloaded versions available through its type, then it must override all of them or none of them.

Sometimes a class needs to override some, but not all, of the functions in an overloaded set. It would be tedious in such cases to have to override every base-class version in order to override the ones that the class needs to specialize. 

Instead of overriding every base-class version that it inherits, a derived class can provide a using declaration for the overloaded member. A using declaration specifies only a name; it may not specify a parameter list. Thus, a using
declaration for a base-class member function adds all the overloaded instances of that function to the scope of the derived class. Having brought all the names into its scope,
the derived class needs to define only those functions that truly depend on its type. It can use the inherited definitions for the others. 

The normal rules for a using declaration inside a class apply to names of overloaded functions; every overloaded instance of the function in the base class must be accessible to the derived class. The access to the overloaded
versions that are not otherwise redefined by the derived class will be the access in effect at the point of the using declaration.

--
Constructors and Copy Control

Like any other class, a class in an inheritance hierarchy controls what happens when objects of its type are created, copied, moved, assigned, or destroyed. As for any other class, if a class (base or derived) does not itself define one of the copy-control operations, the compiler will synthesize that operation. Also, as usual, the synthesized version of any of these members might be a deleted function.

Virtual Destructors

The primary direct impact that inheritance has on copy control for a base class is that a base class generally should define a virtual destructor. The destructor needs to be virtual to allow objects in the inheritance hierarchy to be dynamically allocated.

Recall that the destructor is run when we delete a pointer to a dynamically allocated object. If that pointer points to a type in an inheritance hierarchy, it is possible that the static type of the pointer might differ from the dynamic type of the object being destroyed. For example, if we delete a pointer of type Quote*, that pointer might point at a Bulk_quote object. If the pointer points at a Bulk_quote, the compiler has to know that it should run the Bulk_quote destructor. As with any other function, we arrange to run the proper destructor by defining the destructor as virtual in the base class:

class Quote {
public:
	// virtual destructor needed if a base pointer pointing to a derived object is deleted
	virtual ~Quote() = default; // dynamic binding for the destructor
};

Like any other virtual, the virtual nature of the destructor is inherited. Thus, classes derived from Quote have virtual destructors, whether they use the synthesized destructor or define their own version. So long as the base class destructor is virtual, when we delete a pointer to base, the correct destructor will be run:

Quote *itemP = new Quote; // same static and dynamic type
delete itemP; // destructor for Quote called
itemP = new Bulk_quote; // static and dynamic types differ
delete itemP; // destructor for Bulk_quote called

Warning: Executing delete on a pointer to base that points to a derived object has undefined behavior if the base‚Äôs destructor is not virtual.

Destructors for base classes are an important exception to the rule of thumb that if a class needs a destructor, it also needs copy and assignment. A base class almost always needs a destructor, so that it can make the destructor virtual. If a base class has an empty destructor in order to make it virtual, then the fact that the class has a destructor does not indicate that the assignment operator or copy constructor is also needed.

--
Virtual Destructors Turn Off Synthesized Move

The fact that a base class needs a virtual destructor has an important indirect impact on the definition of base and derived classes: If a class defines a destructor‚Äîeven if
it uses = default to use the synthesized version‚Äîthe compiler will not synthesize a move operation for that class.

--
Synthesized Copy Control and Inheritance

The synthesized copy-control members in a base or a derived class execute like any other synthesized constructor, assignment operator, or destructor: They memberwise initialize, assign, or destroy the members of the class itself. In addition, these synthesized members initialize, assign, or destroy the direct base part of an object by
using the corresponding operation from the base class. For example,

‚Ä¢ The synthesized Bulk_quote default constructor runs the Disc_Quote default constructor, which in turn runs the Quote default constructor.

‚Ä¢ The Quote default constructor default initializes the bookNo member to the empty string and uses the in-class initializer to initialize price to zero.

‚Ä¢ When the Quote constructor finishes, the Disc_Quote constructor continues, which uses the in-class initializers to initialize qty and discount.

‚Ä¢ When the Disc_quote constructor finishes, the Bulk_quote constructor continues but has no other work to do.

Similarly, the synthesized Bulk_quote copy constructor uses the (synthesized) Disc_quote copy constructor, which uses the (synthesized) Quote copy constructor. The Quote copy constructor copies the bookNo and price members; and the
Disc_Quote copy constructor copies the qty and discount members.

It is worth noting that it doesn‚Äôt matter whether the base-class member is itself synthesized (as is the case in our Quote hierarchy) or has a an user-provided definition. All that matters is that the corresponding member is accessible and that it is not a deleted function.

Each of our Quote classes use the synthesized destructor. The derived classes do so implicitly, whereas the Quote class does so explicitly by defining its (virtual) destructor as = default. The synthesized destructor is (as usual) empty and its
implicit destruction part destroys the members of the class. In
addition to destroying its own members, the destruction phase of a destructor in a derived class also destroys its direct base. That destructor in turn invokes the destructor for its own direct base, if any. And, so on up to the root of the hierarchy.

As we‚Äôve seen, Quote does not have synthesized move operations because it defines a destructor. The (synthesized) copy operations will be used whenever we move a Quote object. As we‚Äôre about to see, the fact that Quote does not have move operations means that its derived classes don‚Äôt either.

--
Base Classes and Deleted Copy Control in the Derived

The synthesized default constructor, or any of the copy-control members of either a base or a derived class, may be defined as deleted for the same reasons as in any other class. In addition, the way in which a base class is defined can cause a derived-class member to be defined as deleted:

‚Ä¢ If the default constructor, copy constructor, copy-assignment operator, or destructor in the base class is deleted or inaccessible, then the corresponding member in the derived class is defined as deleted, because the compiler can‚Äôt use the base-class member to construct, assign, or destroy the base-class part of the object.

‚Ä¢ If the base class has an inaccessible or deleted destructor, then the synthesized default and copy constructors in the derived classes are defined as deleted, because there is no way to destroy the base part of the derived object.

‚Ä¢ As usual, the compiler will not synthesize a deleted move operation. If we use = default to request a move operation, it will be a deleted function in the derived if the corresponding operation in the base is deleted or inaccessible, because the base class part cannot be moved. The move constructor will also be deleted if the base class destructor is deleted or inaccessible.

As an example, this base class, B,

Click here to view code image
class B {
public:
B();
	B(const B&) = delete;
	// other members, not including a move constructor
};
class D : public B {
	// no constructors
};

D d; // ok: D's synthesized default constructor uses B's default constructor
D d2(d); // error: D's synthesized copy constructor is deleted
D d3(std::move(d)); // error: implicitly uses D's deleted copy constructor

has an accessible default constructor and an explicitly deleted copy constructor. Because the copy constructor is defined, the compiler will not synthesize a move constructor for class B. As a result, we can neither move nor copy objects of type B. If a class derived from B wanted to allow its objects to be copied or moved, that derived class would have to define its own versions of these constructors. Of course, that class would have to decide how to copy or move the members in it base-class part. In practice, if a base class does not have a default, copy, or move constructor, then its derived classes usually don‚Äôt either.

--
Move Operations and Inheritance

As we‚Äôve seen, most base classes define a virtual destructor. As a result, by default, base classes generally do not get synthesized move operations. Moreover, by default, classes derived from a base class that doesn‚Äôt have move operations don‚Äôt get synthesized move operations either.

Because lack of a move operation in a base class suppresses synthesized move for its derived classes, base classes ordinarily should define the move operations if it is sensible to do so. Our Quote class can use the synthesized versions. However, Quote must define these members explicitly. Once it defines its move operations, it must also explicitly define the copy versions as well:

class Quote {
	public:
	Quote() = default; // memberwise default initialize
	Quote(const Quote&) = default; // memberwise copy
	Quote(Quote&&) = default; // memberwise copy
	Quote& operator=(const Quote&) = default; // copy assign
	Quote& operator=(Quote&&) = default; // move assign
	virtual ~Quote() = default;
	// other members as before
};

Now, Quote objects will be memberwise copied, moved, assigned, and destroyed. Moreover, classes derived from Quote will automatically obtain synthesized move operations as well, unless they have members that otherwise preclude move.

--
Derived-Class Copy-Control Members

As we saw later, the initialization phase of a derived-class constructor initializes the base-class part(s) of a derived object as well as initializing its own members. As a result, the copy and move constructors for a derived class mustcopy/move the members of its base part as well as the members in the derived.

Similarly, a derived-class assignment operator must assign the members in the base part of the derived object. Unlike the constructors and assignment operators, the destructor is responsible only
for destroying the resources allocated by the derived class. Recall that the members of an object are implicitly destroyed (¬ß13.1.3, p. 502). Similarly, the base-class part of a
derived object is destroyed automatically.

Warning: When a derived class defines a copy or move operation, that operation is responsible for copying or moving the entire object, including base-class members.

--
Defining a Derived Copy or Move Constructor

When we define a copy or move constructor  for a derived class, we ordinarily use the corresponding base-class constructor to initialize the base part of the object:

class Base { /* ... */ } ;
class D: public Base {
public:
	// by default, the base class default constructor initializes the base part of an object
	// to use the copy or move constructor, we must explicitly call that
	// constructor in the constructor initializer list
	
	D(const D& d): Base(d) // copy the base members
	/* initializers for members of D */ { /* ... */ }
	
	D(D&& d): Base(std::move(d)) // move the base members
	/* initializers for members of D */ { /* ... */ }
};

The initializer Base(d) passes a D object to a base-class constructor. Although in principle, Base could have a constructor that has a parameter of type D, in practice,
that is very unlikely. Instead, Base(d) will (ordinarily) match the Base copy constructor. The D object, d, will be bound to the Base& parameter in that constructor. The Base copy constructor will copy the base part of d into the object
that is being created. Had the initializer for the base class been omitted,

// probably incorrect definition of the D copy constructor
// base-class part is default initialized, not copied
D(const D& d) /* member initializers, but no base-class initializer */
	{ /* ... */ }

the Base default constructor would be used to initialize the base part of a D object. Assuming D‚Äôs constructor copies the derived members from d, this newly constructed object would be oddly configured: Its Base members would hold default values, while its D members would be copies of the data from another object.

Warning: By default, the base-class default constructor initializes the base-class part of a derived object. If we want copy (or move) the base-class part, we must explicitly use the copy (or move) constructor for the base class in the
derived‚Äôs constructor initializer list.

--
Derived-Class Assignment Operator

Like the copy and move constructors, a derived-class assignment operator, must assign its base part explicitly:

// Base::operator=(const Base&) is not invoked automatically
D &D::operator=(const D &rhs)
{
	Base::operator=(rhs); // assigns the base part
	// assign the members in the derived class, as usual,
	// handling self-assignment and freeing existing resources as appropriate
	return *this;
}

This operator starts by explicitly calling the base-class assignment operator to assign the members of the base part of the derived object. The base-class operator will (presumably) correctly handle self-assignment and, if appropriate, will free the old value in the base part of the left-hand operand and assign the new values from rhs. Once that operator finishes, we continue doing whatever is needed to assign the
members in the derived class. It is worth noting that a derived constructor or assignment operator can use its
corresponding base class operation regardless of whether the base defined its own

version of that operator or uses the synthesized version. For example, the call to Base::operator= executes the copy-assignment operator in class Base. It is immaterial whether that operator is defined explicitly by the Base class or is synthesized by the compiler.

--
Derived-Class Destructor

Recall that the data members of an object are implicitly destroyed after the destructor body completes. Similarly, the base-class parts of an object are also implicitly destroyed. As a result, unlike the constructors and assignment operators, a derived destructor is responsible only for destroying the resources allocated by the derived class:

class D: public Base {
public:
	// Base::~Base invoked automatically
	~D() { /* do what it takes to clean up derived members */ }
};

Objects are destroyed in the opposite order from which they are constructed: The derived destructor is run first, and then the base-class destructors are invoked, back up through the inheritance hierarchy.

--
Calls to Virtuals in Constructors and Destructors

As we‚Äôve seen, the base-class part of a derived object is constructed first. While the base-class constructor is executing, the derived part of the object is uninitialized.
Similarly, derived objects are destroyed in reverse order, so that when a base class destructor runs, the derived part has already been destroyed. As a result, while these base-class members are executing, the object is incomplete.

To accommodate this incompleteness, the compiler treats the object as if its type changes during construction or destruction. That is, while an object is being constructed it is treated as if it has the same class as the constructor; calls to virtual functions will be bound as if the object has the same type as the constructor itself. Similarly, for destructors. This binding applies to virtuals called directly or that are called indirectly from a function that the constructor (or destructor) calls.

To understand this behavior, consider what would happen if the derived-class version of a virtual was called from a base-class constructor. This virtual probably
accesses members of the derived object. After all, if the virtual didn‚Äôt need to use members of the derived object, the derived class probably could use the version in its
base class. However, those members are uninitialized while a base constructor is running. If such access were allowed, the program would probably crash.

Note: If a constructor or destructor calls a virtual, the version that is run is the one corresponding to the type of the constructor or destructor itself.

--
Inherited Constructors

Under the new standard, a derived class can reuse the constructors defined by its direct base class. Although, as we‚Äôll see, such constructors are not inherited in the
normal sense of that term, it is nonetheless common to refer to such constructors as ‚Äúinherited.‚Äù For the same reasons that a class may initialize only its direct base class, a class may inherit constructors only from its direct base. A class cannot inherit the default, copy, and move constructors. If the derived class does not directly define these constructors, the compiler synthesizes them as usual.

A derived class inherits its base-class constructors by providing a using declaration that names its (direct) base class. As an example, we can redefine our Bulk_quote
class to inherit its constructors from Disc_quote:

class Bulk_quote : public Disc_quote {
public:
	using Disc_quote::Disc_quote; // inherit Disc_quote's constructors
	double net_price(std::size_t) const;
};

Ordinarily, a using declaration only makes a name visible in the current scope. When applied to a constructor, a using declaration causes the compiler to generate code. The compiler generates a derived constructor corresponding to each constructor in the base. That is, for each constructor in the base class, the compiler generates a constructor in the derived class that has the same parameter list.

These compiler-generated constructors have the form derived(parms) : base(args) { } where derived is the name of the derived class, base is the name of the base class, parms is the parameter list of the constructor, and args pass the parameters from the derived constructor to the base constructor. In our Bulk_quote class, the inherited constructor would be equivalent to, Click here to view code image

Bulk_quote(const std::string& book, double price,
		std::size_t qty, double disc):
	Disc_quote(book, price, qty, disc) { }

If the derived class has any data members of its own, those members are default initialized.

--
Characteristics of an Inherited Constructor

Unlike using declarations for ordinary members, a constructor using declaration does not change the access level of the inherited constructor(s). For example, regardless of where the using declaration appears, a private constructor in the
base is a private constructor in the derived; similarly for protected and public constructors.

Moreover, a using declaration can‚Äôt specify explicit or constexpr. If a constructor in the base is explicit or constexpr the inherited constructor has the same property.

If a base-class constructor has default arguments, those arguments are not inherited. Instead, the derived class gets multiple inherited constructors in which each parameter with a default argument is successively omitted. For example, if
the base has a constructor with two parameters, the second of which has a default, the derived class will obtain two constructors: one with both parameters (and no default argument) and a second constructor with a single parameter corresponding to the left-most, non-defaulted parameter in the base class.

If a base class has several constructors, then with two exceptions, the derived class inherits each of the constructors from its base class. The first exception is that a
derived class can inherit some constructors and define its own versions of other constructors. If the derived class defines a constructor with the same parameters as a constructor in the base, then that constructor is not inherited. The one defined in the derived class is used in place of the inherited constructor.

The second exception is that the default, copy, and move constructors are not inherited. These constructors are synthesized using the normal rules. An inherited constructor is not treated as a user-defined constructor. Therefore, a class that contains only inherited constructors will have a synthesized default constructor.

--
Containers and Inheritance

When we use a container to store objects from an inheritance hierarchy, we generally must store those objects indirectly. We cannot put objects of types related by inheritance directly into a container, because there is no way to define a container
that holds elements of differing types.

As an example, assume we want to define a vector to hold several books that a customer wants to buy. It should be easy to see that we can‚Äôt use a vector that holds Bulk_quote objects. We can‚Äôt convert Quote objects to Bulk_quote, so we wouldn‚Äôt be able to put Quote objects into that vector.

It may be somewhat less obvious that we also can‚Äôt use a vector that holds objects of type Quote. In this case, we can put Bulk_quote objects into the container. However, those objects would no longer be Bulk_quote objects:

vector<Quote> basket;
basket.push_back(Quote("0-201-82470-1", 50));
// ok, but copies only the Quote part of the object into basket
basket.push_back(Bulk_quote("0-201-54848-8", 50, 10, .25));
// calls version defined by Quote, prints 750, i.e., 15 * $50
cout << basket.back().net_price(15) << endl;

The elements in basket are Quote objects. When we add a Bulk_quote object to the vector its derived part is ignored.

Warning: Because derived objects are ‚Äúsliced down‚Äù when assigned to a base-type object, containers and types related by inheritance do not mix well.

--
Put (Smart) Pointers, Not Objects, in Containers

When we need a container that holds objects related by inheritance, we typically define the container to hold pointers (preferably smart pointers (¬ß12.1, p. 450)) to the
base class. As usual, the dynamic type of the object to which those pointers point might be the base-class type or a type derived from that base:

vector<shared_ptr<Quote>> basket;
basket.push_back(make_shared<Quote>("0-201-82470-1", 50));
basket.push_back(
make_shared<Bulk_quote>("0-201-54848-8", 50, 10, .25));
// calls the version defined by Quote; prints 562.5, i.e., 15 * $50 less the discount
cout << basket.back()->net_price(15) << endl;

Because basket holds shared_ptrs, we must dereference the value returned by basket.back() to get the object on which to run net_price. We do so by using -> in the call to net_price. As usual, the version of net_price that is called depends on the dynamic type of the object to which that pointer points.
It is worth noting that we defined basket as shared_ptr<Quote>, yet in the second push_back we passed a shared_ptr to a Bulk_quote object. Just as we can convert an ordinary pointer to a derived type to a pointer to an base-class type,, we can also convert a smart pointer to a derived type to a smart pointer to an base-class type. 

Thus, make_shared<Bulk_quote> returns a shared_ptr<Bulk_quote> object, which is converted to shared_ptr<Quote> when we call push_back. As a result, despite appearances, all of the elements of basket have the same type.

--
Writing a Basket Class

One of the ironies of object-oriented programming in C++ is that we cannot use objects directly to support it. Instead, we must use pointers and references. Because pointers impose complexity on our programs, we often define auxiliary classes to help manage that complexity. We‚Äôll start by defining a class to represent a basket:

class Basket {
public:
	// Basket uses synthesized default constructor and copy-control members

	void add_item(const std::shared_ptr<Quote> &sale)
		{ items.insert(sale); }

	// prints the total price for each book and the overall total for all items in the basket

	double total_receipt(std::ostream&) const;

private:
	// function to compare shared_ptrs needed by the multiset member
	static bool compare(const std::shared_ptr<Quote> &lhs,
	const std::shared_ptr<Quote> &rhs)
	{ return lhs->isbn() < rhs->isbn(); }
	// multiset to hold multiple quotes, ordered by the compare member
	std::multiset<std::shared_ptr<Quote>, decltype(compare)*>
	items{compare};
};

Our class uses a multiset to hold the transactions, so that we can store multiple transactions for the same book, and so that all the transactions for a given book will be kept together.

The elements in our multiset are shared_ptrs and there is no less-than operator for shared_ptr. As a result, we must provide our own comparison operation to order the elements. Here, we define a private static member, named compare, that compares the isbns of the objects to which the shared_ptrs point. We initialize our multiset to use this comparison function through an in-class initializer (¬ß7.3.1, p. 274):

// multiset to hold multiple quotes, ordered by the compare member
std::multiset<std::shared_ptr<Quote>, decltype(compare)*>
			items{compare};

This declaration can be hard to read, but reading from left to right, we see that we are defining a multiset of shared_ptrs to Quote objects. The multiset will use a function with the same type as our compare member to order the elements. The
multiset member is named items, and we‚Äôre initializing items to use our compare function.

--
Defining the Members of Basket

The Basket class defines only two operations. We defined the add_item member inside the class. That member takes a shared_ptr to a dynamically allocated Quote and puts that shared_ptr into the multiset. The second member, total_receipt, prints an itemized bill for the contents of the basket and return the price for all the items in the basket:

double Basket::total_receipt(ostream &os) const
{
	double sum = 0.0; // holds the running total
	// iter refers to the first element in a batch of elements with the same ISBN
	// upper_bound returns an iterator to the element just past the end of that batch
	for (auto iter = items.cbegin();
	iter != items.cend();
	iter = items.upper_bound(*iter)) {
	// we know there's at least one element with this key in the Basket
	// print the line item for this book
		sum += print_total(os, **iter, items.count(*iter));
	}
	os << "Total Sale: " << sum << endl; // print the final overall
	total
	return sum;
}

Our for loop starts by defining and initializing iter to refer to the first element in the multiset. The condition checks whether iter is equal to items.cend(). If so, we‚Äôve processed all the purchases and we drop out of the for. Otherwise, we process the next book.

The interesting bit is the ‚Äúincrement‚Äù expression in the for. Rather than the usual loop that reads each element, we advance iter to refer to the next key. We skip over all the elements that match the current key by calling upper_bound. The call to upper_bound returns the iterator that refers to the element just past the last one with the same key as in iter. The iterator we get back denotes either the end of the set or the next book.

Inside the for loop, we call print_total to print the details for each book in the basket:

sum += print_total(os, **iter, items.count(*iter));

The arguments to print_total are an ostream on which to write, a Quote object to process, and a count. When we dereference iter, we get a shared_ptr that points to the object we want to print. To get that object, we must dereference that shared_ptr. Thus, **iter is a Quote object (or an object of a type derived from Quote). We use the multiset count member to determine how many elements in the multiset have the same key (i.e., the same ISBN).

As we‚Äôve seen, print_total makes a virtual call to net_price, so the resulting price depends on the dynamic type of **iter. The print_total function prints the total for the given book and returns the total price that it calculated. We add that
result into sum, which we print after we complete the for loop.

--
Hiding the Pointers

Users of Basket still have to deal with dynamic memory, because add_item takes a shared_ptr. As a result, users have to write code such as

Basket bsk;

bsk.add_item(make_shared<Quote>("123", 45));
bsk.add_item(make_shared<Bulk_quote>("345", 45, 3, .15));

Our next step will be to redefine add_item so that it takes a Quote object instead of a shared_ptr. This new version of add_item will handle the memory allocation so that our users no longer need to do so. We‚Äôll define two versions, one that will copy its given object and the other that will move from later:

void add_item(const Quote& sale); // copy the given object
void add_item(Quote&& sale); // move the given object

The only problem is that add_item doesn‚Äôt know what type to allocate. When it does its memory allocation, add_item will copy (or move) its sale parameter. Somewhere there will be a new expression such as: 

new Quote(sale)

Unfortunately, this expression won‚Äôt do the right thing: new allocates an object of the type we request. This expression allocates an object of type Quote and copies the Quote portion of sale. However, sale might refer to a Bulk_quote object, in
which case, that object will be sliced down.

--
Simulating Virtual Copy

We‚Äôll solve this problem by giving our Quote classes a virtual member that allocates a copy of itself.

class Quote {
public:
	// virtual function to return a dynamically allocated copy of itself
	// these members use reference qualifiers; see ¬ß13.6.3 (p. 546)
	virtual Quote* clone() const & {return new
	Quote(*this);}
	virtual Quote* clone() &&
	{return new
	Quote(std::move(*this));}
	// other members as before
};

class Bulk_quote : public Quote {
	Bulk_quote* clone() const & {return new
	Bulk_quote(*this);}

	Bulk_quote* clone() &&
	{return new
	Bulk_quote(std::move(*this));}
	// other members as before
};

Because we have a copy and a move version of add_item, we defined lvalue and rvalue versions of clone (¬ß13.6.3, p. 546). Each clone function allocates a new object of its own type. The const lvalue reference member copies itself into that
newly allocated object; the rvalue reference member moves its own data.

Using clone, it is easy to write our new versions of add_item:

class Basket {
public:
	void add_item(const Quote& sale) // copy the given object
	{ items.insert(std::shared_ptr<Quote>(sale.clone())); }
	void add_item(Quote&& sale) // move the given object
	{ items.insert(
	std::shared_ptr<Quote>(std::move(sale).clone())); }
	// other members as before
};

Like add_item itself, clone is overloaded based on whether it is called on an lvalue or an rvalue. Thus, the first version of add_item calls the const lvalue version of clone, and the second version calls the rvalue reference version. Note that in the rvalue version, although the type of sale is an rvalue reference type, sale (like any other variable) is an lvalue.

Therefore, we call move to bind an rvalue reference to sale.
Our clone function is also virtual. Whether the Quote or Bulk_quote function is run, depends (as usual) on the dynamic type of sale. Regardless of whether we copy or move the data, clone returns a pointer to a newly allocated object, of its own
type. We bind a shared_ptr to that object and call insert to add this newly allocated object to items. Note that because shared_ptr supports the derived-tobase conversion, we can bind a shared_ptr<Quote to a Bulk_quote*.

--
Key Concept: Inheritance versus Composition

The design of inheritance hierarchies is a complicated topic in its own right and well beyond the scope of this language Primer. However, there is one important design guide that is so fundamental that every programmer should be familiar with it.

When we define a class as publicly inherited from another, the derived class should reflect an ‚ÄúIs A‚Äù relationship to the base class. In well-designed class hierarchies, objects of a publicly derived class can be used wherever an object of the base class is expected.

Another common relationship among types is a ‚ÄúHas A‚Äù relationship. Types related by a ‚ÄúHas A‚Äù relationship imply membership. In our bookstore example, our base class represents the concept of a quote for a book sold at a stipulated price. Our Bulk_quote ‚Äúis a‚Äù kind of quote, but one with a different pricing strategy. Our bookstore classes ‚Äúhave
a‚Äù price and an ISBN.

==
(findtemplate)
Template

Templates and Generic Programming

Both object-oriented programming (OOP) and generic programming deal with types that are not known at the time the program is written. The distinction between the two is that OOP deals with types that are not known until run time, whereas in generic programming the types become known during compilation.

The containers, iterators, and algorithms described in Part II are all examples of generic programming. When we write a generic program, we write the code in a way that is independent of any particular type. When we use a generic program, we supply the type(s) or value(s) on which that instance of the program will operate.

For example, the library provides a single, generic definition of each container, such as vector. We can use that generic definition to define many different types of vectors, each of which differs from the others as to the type of elements the
vector contains.

Templates are the foundation of generic programming. We can use and have used templates without understanding how they are defined. In this chapter we‚Äôll see how to define our own templates.

Templates are the foundation for generic programming in C++. A template is a blueprint or formula for creating classes or functions. When we use a generic type, such as vector, or a generic function, such as find, we supply the information
needed to transform that blueprint into a specific class or function. That transformation happens during compilation. Earlier we learned how to use templates. In this chapter we‚Äôll learn how to define them.

--
Defining a Template

Imagine that we want to write a function to compare two values and indicate whether the first is less than, equal to, or greater than the second. In practice, we‚Äôd want to define several such functions, each of which will compare values of a given type. Our first attempt might be to define several overloaded functions:

// returns 0 if the values are equal, -1 if v1 is smaller, 1 if v2 is smaller
int compare(const string &v1, const string &v2)
{
	if (v1 < v2) return -1;
	if (v2 < v1) return 1;
	return 0;
}

int compare(const double &v1, const double &v2)
{
	if (v1 < v2) return -1;
	if (v2 < v1) return 1;
	return 0;
}

These functions are nearly identical: The only difference between them is the type of their parameters. The function body is the same in each function.

Having to repeat the body of the function for each type that we compare is tedious and error-prone. More importantly, we need to know when we write the program all the types that we might ever want to compare. This strategy cannot work if we want to be able to use the function on types that our users might supply.

--
Function Templates

Rather than defining a new function for each type, we can define a function template. A function template is a formula from which we can generate type-specific versions of that function. The template version of compare looks like

template <typename T>
int compare(const T &v1, const T &v2)
{
	if (v1 < v2) return -1;
	if (v2 < v1) return 1;
	return 0;
}

A template definition starts with the keyword template followed by a template parameter list, which is a comma-separated list of one or more template parameters bracketed by the less-than (<) and greater-than (>) tokens.

Note: In a template definition, the template parameter list cannot be empty.

The template parameter list acts much like a function parameter list. A function parameter list defines local variable(s) of a specified type but does not say how to
initialize them. At run time, arguments are supplied that initialize the parameters.

Analogously, template parameters represent types or values used in the definition of a class or function. When we use a template, we specify‚Äîeither implicitly or explicitly‚Äîtemplate argument(s) to bind to the template parameter(s).

Our compare function declares one type parameter named T. Inside compare, we use the name T to refer to a type. Which actual type T represents is determined at compile time based on how compare is used.

--
Instantiating(ÂØ¶‰æãÂåñ) a Function Template

When we call a function template, the compiler (ordinarily) uses the arguments of the call to deduce the template argument(s) for us. That is, when we call compare, the compiler uses the type of the arguments to determine what type to bind to the
template parameter T. For example, in this call

cout << compare(1, 0) << endl; // T is int

the arguments have type int. The compiler will deduce int as the template argument and will bind that argument to the template parameter T.

The compiler uses the deduced template parameter(s) to instantiate a specific version of the function for us. When the compiler instantiates a template, it creates a
new ‚Äúinstance‚Äù of the template using the actual template argument(s) in place of the corresponding template parameter(s). For example, given the calls

// instantiates int compare(const int&, const int&)
cout << compare(1, 0) << endl; // T is int
// instantiates int compare(const vector<int>&, const vector<int>&)
vector<int> vec1{1, 2, 3}, vec2{4, 5, 6};
cout << compare(vec1, vec2) << endl; // T is vector<int>

the compiler will instantiate two different versions of compare. For the first call, the compiler will write and compile a version of compare with T replaced by int:

int compare(const int &v1, const int &v2)
{
	if (v1 < v2) return -1;
	if (v2 < v1) return 1;
	return 0;
}

For the second call, it will generate a version of compare with T replaced by vector<int>. These compiler-generated functions are generally referred to as an instantiation of the template.

--
Template Type Parameters

Our compare function has one template type parameter. In general, we can use a type parameter as a type specifier in the same way that we use a built-in or class type specifier. In particular, a type parameter can be used to name the return type or a function parameter type, and for variable declarations or casts inside the function body:

// ok: same type used for the return type and parameter
template <typename T> T foo(T* p)
{
	T tmp = *p; // tmp will have the type to which p points
	// ...
	return tmp;
}

Each type parameter must be preceded by the keyword class or typename:

// error: must precede U with either typename or class
template <typename T, U> T calc(const T&, const U&);

These keywords have the same meaning and can be used interchangeably inside a template parameter list. A template parameter list can use both keywords:

// ok: no distinction between typename and class in a template parameter list
template <typename T, class U> calc (const T&, const U&);

It may seem more intuitive to use the keyword typename rather than class to designate a template type parameter. After all, we can use built-in (nonclass) types as a template type argument. Moreover, typename more clearly indicates that the name that follows is a type name. However, typename was added to C++ after templates were already in widespread use; some programmers continue to use class exclusively.

--
Nontype Template Parameters

In addition to defining type parameters, we can define templates that take nontype parameters. A nontype parameter represents a value rather than a type. Nontype parameters are specified by using a specific type name instead of the class or
typename keyword.

When the template is instantiated, nontype parameters are replaced with a value supplied by the user or deduced by the compiler. These values must be constant expressions, which allows the compiler to instantiate the templates during compile time.

As an example, we can write a version of compare that will handle string literals. Such literals are arrays of const char. Because we cannot copy an array, we‚Äôll define our parameters as references to an array. Because we‚Äôd like
to be able to compare literals of different lengths, we‚Äôll give our template two nontype parameters. The first template parameter will represent the size of the first array, and
the second parameter will represent the size of the second array:

template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M])
{
	return strcmp(p1, p2);
}

When we call this version of compare:

compare("hi", "mom")

the compiler will use the size of the literals to instantiate a version of the template with the sizes substituted for N and M. Remembering that the compiler inserts a null terminator at the end of a string literal, the compiler will instantiate

int compare(const char (&p1)[3], const char (&p2)[4])

A nontype parameter may be an integral type, or a pointer or (lvalue) reference to an object or to a function type. An argument bound to a nontype integral parameter must be a constant expression. Arguments bound to a pointer or reference nontype parameter must have static lifetime. We may not use an ordinary (nonstatic) local object or a dynamic object as a template argument for reference or pointer nontype template parameters. A pointer parameter can also be instantiated
by nullptr or a zero-valued constant expression.

A template nontype parameter is a constant value inside the template definition. A nontype parameter can be used when constant expressions are required, for example, to specify the size of an array.

Note: Template arguments used for nontype template parameters must be constant expressions.

--
inline and constexpr Function Templates

A function template can be declared inline or constexpr in the same ways as nontemplate functions. The inline or constexpr specifier follows the template parameter list and precedes the return type:

// ok: inline specifier follows the template parameter list
template <typename T> inline T min(const T&, const T&);
// error: incorrect placement of the inline specifier
inline template <typename T> T min(const T&, const T&);

--
Writing Type-Independent Code

Simple though it is, our initial compare function illustrates two important principles for
writing generic code:

‚Ä¢ The function parameters in the template are references to const.
‚Ä¢ The tests in the body use only < comparisons.

By making the function parameters references to const, we ensure that our function can be used on types that cannot be copied. Most types‚Äîincluding the built-in types and, except for unique_ptr and the IO types, all the library types we‚Äôve used‚Äîdo allow copying. However, there can be class types that do not allow copying. By making our parameters references to const, we ensure that such types can be used with our compare function. Moreover, if compare is called with large objects, then this design will also make the function run faster.

You might think it would be more natural for the comparisons to be done using both the < and > operators:

// expected comparison
if (v1 < v2) return -1;
if (v1 > v2) return 1;
return 0;

However, by writing the code using only the < operator, we reduce the requirements on types that can be used with our compare function. Those types must support <, but they need not also support >.

In fact, if we were truly concerned about type independence and portability, we probably should have defined our function using the less:

// version of compare that will be correct even if used on pointers
template <typename T> int compare(const T &v1, const T &v2)
{
	if (less<T>()(v1, v2)) return -1;
	if (less<T>()(v2, v1)) return 1;
	return 0;
}

The problem with our original version is that if a user calls it with two pointers and those pointers do not point to the same array, then our code is undefined.

Best Practices: Template programs should try to minimize the number of requirements placed on the argument types.

--
Template Compilation

When the compiler sees the definition of a template, it does not generate code. It generates code only when we instantiate a specific instance of the template. The fact that code is generated only when we use a template (and not when we define it) affects how we organize our source code and when errors are detected.

Ordinarily, when we call a function, the compiler needs to see only a declaration for the function. Similarly, when we use objects of class type, the class definition must be available, but the definitions of the member functions need not be present. As a result, we put class definitions and function declarations in header files and definitions of ordinary and class-member functions in source files.

Templates are different: To generate an instantiation, the compiler needs to have the code that defines a function template or class template member function. As a result, unlike nontemplate code, headers for templates typically include definitions as well as declarations.

Note: Definitions of function templates and member functions of class templates are ordinarily put into header files.

Key Concept: Templates and Headers

Templates contain two kinds of names:
‚Ä¢ Those that do not depend on a template parameter
‚Ä¢ Those that do depend on a template parameter

It is up to the provider of a template to ensure that all names that do not depend on a template parameter are visible when the template is used.

Moreover, the template provider must ensure that the definition of the template, including the definitions of the members of a class template, are visible when the template is instantiated.

It is up to users of a template to ensure that declarations for all functions, types, and operators associated with the types used to instantiate the template are visible.

Both of these requirements are easily satisfied by well-structured programs that make appropriate use of headers. Authors of templates should provide a header that contains the template definition along with declarations for all the
names used in the class template or in the definitions of its members. Users of the template must include the header for the template and for any types used to instantiate that template.

--
Compilation Errors Are Mostly Reported during Instantiation

The fact that code is not generated until a template is instantiated affects when we learn about compilation errors in the code inside the template. In general, there are three stages during which the compiler might flag an error.

The first stage is when we compile the template itself. The compiler generally can‚Äôt find many errors at this stage. The compiler can detect syntax errors‚Äîsuch as forgetting a semicolon or misspelling a variable name‚Äîbut not much else.

The second error-detection time is when the compiler sees a use of the template. At this stage, there is still not much the compiler can check. For a call to a function template, the compiler typically will check that the number of the arguments is appropriate. It can also detect whether two arguments that are supposed to have the same type do so. For a class template, the compiler can check that the right number
of template arguments are provided but not much more.

The third time when errors are detected is during instantiation. It is only then that type-related errors can be found. Depending on how the compiler manages instantiation, these errors may be reported at link time.

When we write a template, the code may not be overtly type specific, but template code usually makes some assumptions about the types that will be used. For example, the code inside our original compare function:

if (v1 < v2) return -1; // requires < on objects of type T
if (v2 < v1) return 1; // requires < on objects of type T
return 0; // returns int; not dependent on T

assumes that the argument type has a < operator. When the compiler processes the body of this template, it cannot verify whether the conditions in the if statements are legal. If the arguments passed to compare have a < operation, then the code is fine, but not otherwise. For example,

Sales_data data1, data2;
cout << compare(data1, data2) << endl; // error: no < on
Sales_data

This call instantiates a version of compare with T replaced by Sales_data. The if conditions attempt to use < on Sales_data objects, but there is no such operator.

This instantiation generates a version of the function that will not compile. However, errors such as this one cannot be detected until the compiler instantiates the definition
of compare on type Sales_data.

Warning: It is up to the caller to guarantee that the arguments passed to the template support any operations that template uses, and that those operations behave correctly in the context in which the template uses them.

--
Class Templates

A class template is a blueprint for generating classes. Class templates differ from function templates in that the compiler cannot deduce the template parameter type(s) for a class template. Instead, as we‚Äôve seen many times, to use a class template we must supply additional information inside angle brackets following the template‚Äôs name. That extra information is the list of template arguments to use in place of the template parameters.

--
Defining a Class Template

As an example, we‚Äôll implement a template version of StrBlob.
We‚Äôll name our template Blob to indicate that it is no longer specific to strings. Like StrBlob, our template will provide shared (and checked) access to the elements it holds. Unlike that class, our template can be used on elements of pretty much any type. As with the library containers, our users will have to specify the element type when they use a Blob.

Like function templates, class templates begin with the keyword template followed by a template parameter list. In the definition of the class template (and its members), we use the template parameters as stand-ins for types or values that will
be supplied when the template is used:

template <typename T> class Blob {
public:
	typedef T value_type;
	typedef typename std::vector<T>::size_type size_type;
	// constructors
	Blob();
	Blob(std::initializer_list<T> il);
	// number of elements in the Blob
	size_type size() const { return data->size(); }
	bool empty() const { return data->empty(); }
	// add and remove elements
	void push_back(const T &t) {data->push_back(t);}
	// move version; see ¬ß 13.6.3 (p. 548)
	void push_back(T &&t) { data->push_back(std::move(t)); }
	void pop_back();
	// element access
	T& back();
	T& operator[](size_type i); // defined in ¬ß 14.5 (p. 566)
	private:
	std::shared_ptr<std::vector<T>> data;
	// throws msg if data[i] isn't valid
	void check(size_type i, const std::string &msg) const;
};

Our Blob template has one template type parameter, named T. We use the type parameter anywhere we refer to the element type that the Blob holds. For example, we define the return type of the operations that provide access to the elements in the
Blob as T&. When a user instantiates a Blob, these uses of T will be replaced by the specified template argument type.

With the exception of the template parameter list, and the use of T instead of string, this class is the same as the version we defined somewhere else.

--
Instantiating a Class Template

As we‚Äôve seen many times, when we use a class template, we must supply extra information. We can now see that that extra information is a list of explicit template arguments that are bound to the template‚Äôs parameters. The compiler uses these
template arguments to instantiate a specific class from the template.

For example, to define a type from our Blob template, we must provide the element type:

Blob<int> ia; // empty Blob<int>
Blob<int> ia2 = {0,1,2,3,4}; // Blob<int> with five elements

Both ia and ia2 use the same type-specific version of Blob (i.e., Blob<int>). From these definitions, the compiler will instantiate a class that is equivalent to

template <> class Blob<int> {
typedef typename std::vector<int>::size_type size_type;
	Blob();
	Blob(std::initializer_list<int> il);
	// ...
	int& operator[](size_type i);
private:
	std::shared_ptr<std::vector<int>> data;
	void check(size_type i, const std::string &msg) const;
};

When the compiler instantiates a class from our Blob template, it rewrites the Blob template, replacing each instance of the template parameter T by the given template argument, which in this case is int.

The compiler generates a different class for each element type we specify:

// these definitions instantiate two distinct Blob types
Blob<string> names; // Blob that holds strings
Blob<double> prices;// different element type

These definitions would trigger instantiations of two distinct classes: The definition of names creates a Blob class in which each occurrence of T is replaced by string.

The definition of prices generates a Blob with T replaced by double.

Note: Each instantiation of a class template constitutes an independent class. The type Blob<string> has no relationship to, or any special access to, the members of any other Blob type.

--
References to a Template Type in the Scope of the Template

In order to read template class code, it can be helpful to remember that the name of a class template is not the name of a type. A class template is used to instantiate a type, and an instantiated type always includes template argument(s).

What can be confusing is that code in a class template generally doesn‚Äôt use the name of an actual type (or value) as a template argument. Instead, we often use the template‚Äôs own parameter(s) as the template argument(s). For example, our data
member uses two templates, vector and shared_ptr. Whenever we use a template, we must supply template arguments. In this case, the template argument we supply is the same type that is used to instantiate the Blob. Therefore, the definition of data

std::shared_ptr<std::vector<T>> data;

uses Blob‚Äôs type parameter to say that data is the instantiation of shared_ptr that points to the instantiation of vector that holds objects of type T. When we instantiate a particular kind of Blob, such as Blob<string>, then data will be

shared_ptr<vector<string>>

If we instantiate Blob<int>, then data will be shared_ptr<vector<int>>, and so on.

--
Member Functions of Class Templates

As with any class, we can define the member functions of a class template either inside or outside of the class body. As with any other class, members defined inside the class body are implicitly inline.

A class template member function is itself an ordinary function. However, each instantiation of the class template has its own version of each member. As a result, a member function of a class template has the same template parameters as the class itself. Therefore, a member function defined outside the class template body starts with the keyword template followed by the class‚Äô template parameter list.

As usual, when we define a member outside its class, we must say to which class the member belongs. Also as usual, the name of a class generated from a template includes its template arguments. When we define a member, the template argument(s) are the same as the template parameter(s). That is, for a given member function of StrBlob that was defined as

ret-type StrBlob::member-name(parm-list)

the corresponding Blob member will look like

template <typename T>
ret-type Blob<T>::member-name(parm-list)

--
The check and Element Access Members

We‚Äôll start by defining the check member, which verifies a given index:

template <typename T>
void Blob<T>::check(size_type i, const std::string &msg)
const
{
	if (i >= data->size())
		throw std::out_of_range(msg);
}

Aside from the differences in the class name and the use of the template parameter list, this function is identical to the original StrBlob member.

The subscript operator and back function use the template parameter to specify the return type but are otherwise unchanged:

template <typename T>
T& Blob<T>::back()
{
	check(0, "back on empty Blob");
	return data->back();
}

template <typename T>
T& Blob<T>::operator[](size_type i)
{
	// if i is too big, check will throw, preventing access to a nonexistent element
	check(i, "subscript out of range");
	return (*data)[i];
}

In our original StrBlob class these operators returned string&. The template versions will return a reference to whatever type is used to instantiate Blob.

The pop_back function is nearly identical to our original StrBlob member:

template <typename T> void Blob<T>::pop_back()
{
	check(0, "pop_back on empty Blob");
	data->pop_back();
}

The subscript operator and back members are overloaded on const. We leave these definition of these members, and of the front members, as an exercise.

--
Blob Constructors

As with any other member defined outside a class template, a constructor starts by declaring the template parameters for the class template of which it is a member:

template <typename T>
Blob<T>::Blob(): data(std::make_shared<std::vector<T>>()) { }

Here we are defining the member named Blob in the scope of Blob<T>. Like our StrBlob default constructor, this constructor allocates an empty vector and stores the pointer to that vector in data. As we‚Äôve seen, we use the class‚Äô own type parameter as the template argument of the vector we allocate.

Similarly, the constructor that takes an initializer_list uses its type parameter T as the element type for its initializer_list parameter:

template <typename T>
Blob<T>::Blob(std::initializer_list<T> il): data(std::make_shared<std::vector<T>>(il)) { }

Like the default constructor, this constructor allocates a new vector. In this case, we initialize that vector from the parameter, il.

To use this constructor, we must pass an initializer_list in which the elements are compatible with the element type of the Blob:

Blob<string> articles = {"a", "an", "the"};

The parameter in this constructor has type initializer_list<string>. Each string literal in the list is implicitly converted to string.

--
Instantiation of Class-Template Member Functions

By default, a member function of a class template is instantiated only if the program uses that member function. For example, this code instantiates Blob<int> and the initializer_list<int> constructor

Blob<int> squares = {0,1,2,3,4,5,6,7,8,9};
// instantiates Blob<int>::size() const
for (size_t i = 0; i != squares.size(); ++i)
	squares[i] = i*i; // instantiates Blob<int>::operator[](size_t)

instantiates the Blob<int> class and three of its member functions: operator[], size, and the initializer_list<int> constructor.

If a member function isn‚Äôt used, it is not instantiated. The fact that members are instantiated only if we use them lets us instantiate a class with a type that may not meet the requirements for some of the template‚Äôs operations.

Note: By default, a member of an instantiated class template is instantiated only if the member is used.

--
Simplifying Use of a Template Class Name inside Class Code

There is one exception to the rule that we must supply template arguments when we use a class template type. Inside the scope of the class template itself, we may use the name of the template without arguments:

// BlobPtr throws an exception on attempts to access a nonexistent element
template <typename T> class BlobPtr
public:
	BlobPtr(): curr(0) { }
	BlobPtr(Blob<T> &a, size_t sz = 0):
	wptr(a.data), curr(sz) { }
	T& operator*() const
	{ auto p = check(curr, "dereference past end");
	return (*p)[curr]; // (*p) is the vector to which this object points
	}
	// increment and decrement
	BlobPtr& operator++(); // prefix operators
	BlobPtr& operator--();
private:
	// check returns a shared_ptr to the vector if the check succeeds
	std::shared_ptr<std::vector<T>>
	check(std::size_t, const std::string&) const;
	// store a weak_ptr, which means the underlying vector might be destroyed
	std::weak_ptr<std::vector<T>> wptr;
	std::size_t curr; // current position within the array
};

Careful readers will have noted that the prefix increment and decrement members of BlobPtr return BlobPtr&, not BlobPtr<T>&. When we are inside the scope of a class template, the compiler treats references to the template itself as if we had supplied template arguments matching the template‚Äôs own parameters. That is, it is as if we had written:

BlobPtr<T>& operator++();
BlobPtr<T>& operator--();

--
Using a Class Template Name outside the Class Template Body

When we define members outside the body of a class template, we must remember that we are not in the scope of the class until the class name is seen:

// postfix: increment/decrement the object but return the unchanged value
template <typename T>
BlobPtr<T> BlobPtr<T>::operator++(int)
{
	// no check needed here; the call to prefix increment will do the check
	BlobPtr ret = *this; // save the current value
	++*this; // advance one element; prefix ++ checks the increment
	return ret; // return the saved state
}

Because the return type appears outside the scope of the class, we must specify that the return type returns a BlobPtr instantiated with the same type as the class.

Inside the function body, we are in the scope of the class so do not need to repeat the template argument when we define ret. When we do not supply template arguments, the compiler assumes that we are using the same type as the member‚Äôs
instantiation. Hence, the definition of ret is as if we had written:

BlobPtr<T> ret = *this;

Note: Inside the scope of a class template, we may refer to the template without specifying template argument(s).

--
Class Templates and Friends

When a class contains a friend declaration, the class and the friend can independently be templates or not. A class template that has a nontemplate friend grants that friend access to all the instantiations of the template. When the friend is itself a template, the class granting friendship controls whether friendship includes all instantiations of the template or only specific instantiation(s).

--
One-to-One Friendship

The most common form of friendship from a class template to another template (class or function) establishes friendship between corresponding instantiations of the class and its friend. For example, our Blob class should declare the BlobPtr class and a template version of the Blob equality operator (originally defined for StrBlob in the exercises as friends.

In order to refer to a specific instantiation of a template (class or function) we must first declare the template itself. A template declaration includes the template‚Äôs template parameter list:

// forward declarations needed for friend declarations in Blob
template <typename> class BlobPtr;
template <typename> class Blob; // needed for parameters in operator==
template <typename T>
bool operator==(const Blob<T>&, const Blob<T>&);
template <typename T> class Blob {
	// each instantiation of Blob grants access to the version of
	// BlobPtr and the equality operator instantiated with the same type
	friend class BlobPtr<T>;
	friend bool operator==<T>
	(const Blob<T>&, const Blob<T>&);
	// other members as in ¬ß 12.1.1 (p. 456)
};

We start by declaring that Blob, BlobPtr, and operator== are templates. These declarations are needed for the parameter declaration in the operator== function and the friend declarations in Blob.

The friend declarations use Blob‚Äôs template parameter as their own template argument. Thus, the friendship is restricted to those instantiations of BlobPtr and the equality operator that are instantiated with the same type:

Blob<char> ca; // BlobPtr<char> and operator==<char> are friends
Blob<int> ia; // BlobPtr<int> and operator==<int> are friends

The members of BlobPtr<char> may access the nonpublic parts of ca (or any other Blob<char> object), but ca has no special access to ia (or any other Blob<int>) or to any other instantiation of Blob.

--
General and Specific Template Friendship

A class can also make every instantiation of another template its friend, or it may limit friendship to a specific instantiation:

// forward declaration necessary to befriend a specific instantiation of a template
template <typename T> class Pal;
class C { // C is an ordinary, nontemplate class
	friend class Pal<C>; // Pal instantiated with class C is a friend to
	C
	// all instances of Pal2 are friends to C;
	// no forward declaration required when we befriend all instantiations
	template <typename T> friend class Pal2;
};

template <typename T> class C2 { // C2 is itself a class template
	// each instantiation of C2 has the same instance of Pal as a friend
	friend class Pal<T>; // a template declaration for Pal must be in
	scope
	// all instances of Pal2 are friends of each instance of C2, prior declaration
	needed
	template <typename X> friend class Pal2;
	// Pal3 is a nontemplate class that is a friend of every instance of C2
	friend class Pal3; // prior declaration for Pal3 not needed
};

To allow all instantiations as friends, the friend declaration must use template parameter(s) that differ from those used by the class itself.

--
Befriending the Template‚Äôs Own Type Parameter

Under the new standard, we can make a template type parameter a friend:

template <typename Type> class Bar {
friend Type; // grants access to the type used to instantiate Bar
	// ...
};

Here we say that whatever type is used to instantiate Bar is a friend. Thus, for some type named Foo, Foo would be a friend of Bar<Foo>, Sales_data a friend of Bar<Sales_data>, and so on.

It is worth noting that even though a friend ordinarily must be a class or a function, it is okay for Bar to be instantiated with a built-in type. Such friendship is allowed so that we can instantiate classes such as Bar with built-in types.

--
Template Type Aliases

An instantiation of a class template defines a class type, and as with any other class type, we can define a typedef that refers to that instantiated class:

typedef Blob<string> StrBlob;

This typedef will let us run the code we wrote earlier using our template version of Blob instantiated with string. Because a template is not a type, we cannot define a typedef that refers to a template. That is, there is no way to define a typedef that refers to Blob<T>.

However, the new standard lets us define a type alias for a class template:

template<typename T> using twin = pair<T, T>;
twin<string> authors; // authors is a pair<string, string>

Here we‚Äôve defined twin as a synonym for pairs in which the members have the same type. Users of twin need to specify that type only once.

A template type alias is a synonym for a family of classes:

twin<int> win_loss; // win_loss is a pair<int, int>
twin<double> area; // area is a pair<double, double>

Just as we do when we use a class template, when we use twin, we specify which particular kind of twin we want.

When we define a template type alias, we can fix one or more of the template parameters:

template <typename T> using partNo = pair<T, unsigned>;
partNo<string> books; // books is a pair<string, unsigned>
partNo<Vehicle> cars; // cars is a pair<Vehicle, unsigned>
partNo<Student> kids; // kids is a pair<Student, unsigned>

Here we‚Äôve defined partNo as a synonym for the family of types that are pairs in which the second member is an unsigned. Users of partNo specify a type for the first member of the pair but have no choice about second.

--
static Members of Class Templates

Like any other class, a class template can declare static members

template <typename T> class Foo {
public:
	static std::size_t count() { return ctr; }
	// other interface members
private:
	static std::size_t ctr;
	// other implementation members
};

Here Foo is a class template that has a public static member function named count and a private static data member named ctr. Each instantiation of Foo has its own instance of the static members. That is, for any given type X, there is one Foo<X>::ctr and one Foo<X>::count member. All objects of type Foo<X> share the same ctr object and count function. For example,

// instantiates static members Foo<string>::ctr and Foo<string>::count
Foo<string> fs;
// all three objects share the same Foo<int>::ctr and Foo<int>::count members
Foo<int> fi, fi2, fi3;

As with any other static data member, there must be exactly one definition of each static data member of a template class. However, there is a distinct object for each instantiation of a class template. As a result, we define a static data member
as a template similarly to how we define the member functions of that template:

template <typename T>
size_t Foo<T>::ctr = 0; // define and initialize ctr

As with any other member of a class template, we start by defining the template parameter list, followed by the type of the member we are defining and the member‚Äôs name. As usual, a member‚Äôs name includes the member‚Äôs class name, which for a
class generated from a template includes its template arguments. Thus, when Foo is instantiated for a particular template argument type, a separate ctr will be instantiated for that class type and initialized to 0.

As with static members of nontemplate classes, we can access a static member of a class template through an object of the class type or by using the scope operator to access the member directly. Of course, to use a static member through the class, we must refer to a specific instantiation:

Foo<int> fi; // instantiates Foo<int> class and the static data member ctr

auto ct = Foo<int>::count(); // instantiates Foo<int>::count

ct = fi.count(); // uses Foo<int>::count
ct = Foo::count(); // error: which template instantiation?

Like any other member function, a static member function is instantiated only if it is used in a program.

--
Template Parameters

Like the names of function parameters, a template parameter name has no intrinsic meaning. We ordinarily name type parameters T, but we can use any name:

template <typename Foo> Foo calc(const Foo& a, const Foo& b)
{
	Foo tmp = a; // tmp has the same type as the parameters and return type
	// ...
	return tmp; // return type and parameters have the same type
}

--
Template Parameters and Scope

Template parameters follow normal scoping rules. The name of a template parameter can be used after it has been declared and until the end of the template declaration or definition. As with any other name, a template parameter hides any declaration of that name in an outer scope. Unlike most other contexts, however, a name used as a template parameter may not be reused within the template:

typedef double A;
template <typename A, typename B> void f(A a, B b)
{
	A tmp = a; // tmp has same type as the template parameter A, not double
	double B; // error: redeclares template parameter B
}

Normal name hiding says that the typedef of A is hidden by the type parameter named A. Thus, tmp is not a double; it has whatever type gets bound to the template parameter A when calc is used. Because we cannot reuse names of template parameters, the declaration of the variable named B is an error.

Because a parameter name cannot be reused, the name of a template parameter can appear only once with in a given template parameter list:

// error: illegal reuse of template parameter name V
template <typename V, typename V> // ...

--
Template Declarations

A template declaration must include the template parameters :

// declares but does not define compare and Blob
template <typename T> int compare(const T&, const T&);
template <typename T> class Blob;

As with function parameters, the names of a template parameter need not be the same across the declaration(s) and the definition of the same template:

// all three uses of calc refer to the same function template
template <typename T> T calc(const T&, const T&); // declaration
template <typename U> U calc(const U&, const U&); // declaration
// definition of the template
template <typename Type>
Type calc(const Type& a, const Type& b) { /* . . . */ }

Of course, every declaration and the definition of a given template must have the same number and kind (i.e., type or nontype) of parameters.

Best Practices: For reasons we‚Äôll explain later, declarations for all the templates needed by a given file usually should appear together at the beginning of a file before any code that uses those names.

--
Using Class Members That Are Types

Recall that we use the scope operator (::) to access both static members and type members. In ordinary (nontemplate) code, the compiler has access to the class defintion. As a result, it knows whether a name accessed through the scope operator is a type or a static member. For example, when we write string::size_type, the compiler has the definition of string and can see that size_type is a type.

Assuming T is a template type parameter, When the compiler sees code such as T::mem it won‚Äôt know until instantiation time whether mem is a type or a static data member. However, in order to process the template, the compiler must know whether a name represents a type. For example, assuming T is the name of a type parameter, when the compiler sees a statement of the following form:

T::size_type * p;

it needs to know whether we‚Äôre defining a variable named p or are multiplying a static data member named size_type by a variable named p.

By default, the language assumes that a name accessed through the scope operator is not a type. As a result, if we want to use a type member of a template type parameter, we must explicitly tell the compiler that the name is a type. We do so by using the keyword typename:

template <typename T>
typename T::value_type top(const T& c)
{
	if (!c.empty())
		return c.back();
	else
		return typename T::value_type();
}

Our top function expects a container as its argument and uses typename to specify its return type and to generate a value initialized element to return if c has no elements.

Note: When we want to inform the compiler that a name represents a type, we must use the keyword typename, not class.

--
Default Template Arguments:

Just as we can supply default arguments to function parameters, we can also supply default template arguments. Under the new standard, we can supply default arguments for both function and class templates. Earlier versions of the
language, allowed default arguments only with class templates.

As an example, we‚Äôll rewrite compare to use the library less function-object template by default:

// compare has a default template argument, less<T>
// and a default function argument, F()
template <typename T, typename F = less<T>>
int compare(const T &v1, const T &v2, F f = F())
{
	if (f(v1, v2)) return -1;
	if (f(v2, v1)) return 1;
	return 0;
}

Here we‚Äôve given our template a second type parameter, named F, that represents the type of a callable object and defined a new function parameter, f, that will be bound to a callable object.

We‚Äôve also provided defaults for this template parameter and its corresponding function parameter. The default template argument specifies that compare will use the library less function-object class, instantiated with the same type parameter as compare. The default function argument says that f will be a default-initialized object of type F.

When users call this version of compare, they may supply their own comparison operation but are not required to do so:

bool i = compare(0, 42); // uses less; i is -1
// result depends on the isbns in item1 and item2
Sales_data item1(cin), item2(cin);
bool j = compare(item1, item2, compareIsbn);

The first call uses the default function argument, which is a default-initialized object of type less<T>. In this call, T is int so that object has type less<int>. This instantiation of compare will use less<int> to do its comparisons.

In the second call, we pass compareIsbn and two objects of type Sales_data. When compare is called with three arguments, the type of the third argument must be a callable object that returns a type that is convertible to bool and takes arguments of a type compatible with the types of the first two arguments. As usual, the types of the template parameters are deduced from their corresponding function arguments. In this call, the type of T is deduced as Sales_data and F is deduced as the type of compareIsbn.

As with function default arguments, a template parameter may have a default argument only if all of the parameters to its right also have default arguments.

--
Template Default Arguments and Class Templates

Whenever we use a class template, we must always follow the template‚Äôs name with brackets. The brackets indicate that a class must be instantiated from a template. In particular, if a class template provides default arguments for all of its template parameters, and we want to use those defaults, we must put an empty bracket pair following the template‚Äôs name:

template <class T = int> class Numbers { // by default T is int
public:
	Numbers(T v = 0): val(v) { }
	// various operations on numbers
private:
	T val;
};

Numbers<long double> lots_of_precision;
Numbers<> average_precision; // empty <> says we want the default type

Here we instantiate two versions of Numbers: average_precision instantiates Numbers with T replaced by int; lots_of_precision instantiates Numbers with T replaced by long double.

--
Member Templates

A class‚Äîeither an ordinary class or a class template‚Äîmay have a member function that is itself a template. Such members are referred to as member templates.

Member templates may not be virtual.

Member Templates of Ordianary (Nontemplate) Classes As an example of an ordinary class that has a member template, we‚Äôll define a class that is similar to the default deleter type used by unique_ptr.

Like the default deleter, our class will have an overloaded function-call operator that will take a pointer and execute delete on the given pointer. Unlike the default deleter, our class will also print a message whenever the deleter is executed. Because we want to use our deleter with any type, we‚Äôll make the call operator a template:

// function-object class that calls delete on a given pointer

class DebugDelete {
public:
	DebugDelete(std::ostream &s = std::cerr): os(s) { }
	// as with any function template, the type of T is deduced by the compiler
	template <typename T> void operator()(T *p) const
	{ os << "deleting unique_ptr" << std::endl; delete p;
	}
private:
	std::ostream &os;
};

Like any other template, a member template starts with its own template parameter list. Each DebugDelete object has an ostream member on which to write, and a member function that is itself a template. We can use this class as a replacement for delete:

double* p = new double;
DebugDelete d; // an object that can act like a delete expression
d(p); // calls DebugDelete::operator()(double*), which deletes p
int* ip = new int;
// calls operator()(int*) on a temporary DebugDelete object
DebugDelete()(ip);

Because calling a DebugDelete object deletes its given pointer, we can also use DebugDelete as the deleter of a unique_ptr. To override the deleter of a unique_ptr, we supply the type of the deleter inside brackets and supply an object
of the deleter type to the constructor:

// destroying the the object to which p points
// instantiates DebugDelete::operator()<int>(int *)
unique_ptr<int, DebugDelete> p(new int, DebugDelete());
// destroying the the object to which sp points
// instantiates DebugDelete::operator()<string>(string*)
unique_ptr<string, DebugDelete> sp(new string,
DebugDelete());

Here, we‚Äôve said that p‚Äôs deleter will have type DebugDelete, and we have supplied an unnamed object of that type in p‚Äôs constructor.

The unique_ptr destructor calls the DebugDelete‚Äôs call operator. Thus, whenever unique_ptr‚Äôs destructor is instantiated, DebugDelete‚Äôs call operator will also be instantiated: Thus, the definitions above will instantiate:

// sample instantiations for member templates of DebugDelete
void DebugDelete::operator()(int *p) const { delete p; }
void DebugDelete::operator()(string *p) const { delete p; }

--
Member Templates of Class Templates

We can also define a member template of a class template. In this case, both the class and the member have their own, independent, template parameters.

As an example, we‚Äôll give our Blob class a constructor that will take two iterators denoting a range of elements to copy. Because we‚Äôd like to support iterators into varying kinds of sequences, we‚Äôll make this constructor a template:

template <typename T> class Blob {
	template <typename It> Blob(It b, It e);
	// ...
};

This constructor has its own template type parameter, It, which it uses for the type of its two function parameters.

Unlike ordinary function members of class templates, member templates are function templates. When we define a member template outside the body of a class template, we must provide the template parameter list for the class template and for the
function template. The parameter list for the class template comes first, followed by the member‚Äôs own template parameter list:

template <typename T> // type parameter for the class
template <typename It> // type parameter for the constructor
	Blob<T>::Blob(It b, It e):
		data(std::make_shared<std::vector<T>>(b, e)) {
}

Here we are defining a member of a class template that has one template type parameter, which we have named T. The member itself is a function template that has a type parameter named It.

--
Instantiation and Member Templates

To instantiate a member template of a class template, we must supply arguments for the template parameters for both the class and the function templates. As usual, argument(s) for the class template parameter(s) are determined by the type of the object through which we call the member template. Also as usual, the compiler typically deduces template argument(s) for the member template‚Äôs own parameter(s) from the arguments passed in the call:

int ia[] = {0,1,2,3,4,5,6,7,8,9};
vector<long> vi = {0,1,2,3,4,5,6,7,8,9};
list<const char*> w = {"now", "is", "the", "time"};
// instantiates the Blob<int> class
// and the Blob<int> constructor that has two int* parameters
Blob<int> a1(begin(ia), end(ia));
// instantiates the Blob<int> constructor that has
// two vector<long>::iterator parameters
Blob<int> a2(vi.begin(), vi.end());
// instantiates the Blob<string> class and the Blob<string>
// constructor that has two (list<const char*>::iterator parameters
Blob<string> a3(w.begin(), w.end());

When we define a1, we explicitly specify that the compiler should instantiate a version of Blob with the template parameter bound to int. The type parameter for the constructor‚Äôs own parameters will be deduced from the type of begin(ia) and end(ia). That type is int*. Thus, the definition of a1 instantiates:

Blob<int>::Blob(int*, int*);

The definition of a2 uses the already instantiated Blob<int> class, and instantiates the constructor with It replaced by vector<short>::iterator. The definition of a3 (explicitly) instantiates the Blob with its template parameter bound to string and (implicitly) instantiates the member template constructor of that class with its parameter bound to list<const char*>.

--
Controlling Instantiations

The fact that instantiations are generated when a template is used means that the same instantiation may appear in multiple object files. When two or more separately compiled source files use the same template with the same template arguments, there is an instantiation of that template in each of those files.

In large systems, the overhead of instantiating the same template in multiple files can become significant. Under the new standard, we can avoid this overhead through an explicit instantiation. An explicit instantiation has the form

extern template declaration; // instantiation declaration
template declaration; // instantiation definition

where declaration is a class or function declaration in which all the template parameters are replaced by the template arguments. For example,

// instantion declaration and definition
extern template class Blob<string>; // declaration
template int compare(const int&, const int&); // definition

When the compiler sees an extern template declaration, it will not generate code for that instantiation in that file. Declaring an instantiation as extern is a promise that there will be a nonextern use of that instantiation elsewhere in the program. There may be several extern declarations for a given instantiation but there must be exactly one definition for that instantiation.

Because the compiler automatically instantiates a template when we use it, the extern declaration must appear before any code that uses that instantiation:

// Application.cc
// these template types must be instantiated elsewhere in the program
extern template class Blob<string>;
extern template int compare(const int&, const int&);
Blob<string> sa1, sa2; // instantiation will appear elsewhere
// Blob<int> and its initializer_list constructor instantiated in this file
Blob<int> a1 = {0,1,2,3,4,5,6,7,8,9};
Blob<int> a2(a1); // copy constructor instantiated in this file
int i = compare(a1[0], a2[0]); // instantiation will appear elsewhere

The file Application.o will contain instantiations for Blob<int>, along with the initializer_list and copy constructors for that class. The compare<int> function and Blob<string> class will not be instantiated in that file. There must be
definitions of these templates in some other file in the program:

// templateBuild.cc
// instantiation file must provide a (nonextern) definition for every
// type and function that other files declare as extern
template int compare(const int&, const int&);
template class Blob<string>; // instantiates all members of the class template

When the compiler sees an instantiation definition (as opposed to a declaration), it generates code. Thus, the file templateBuild.o will contain the definitions for compare instantiated with int and for the Blob<string> class. When we build the application, we must link templateBuild.o with the Application.o files.

Warning: There must be an explicit instantiation definition somewhere in the program for every instantiation declaration.

--
Instantiation Definitions Instantiate All Members

An instantiation definition for a class template instantiates all the members of that template including inline member functions. When the compiler sees an instantiation definition it cannot know which member functions the program uses. Hence, unlike the way it handles ordinary class template instantiations, the compiler instantiates all the members of that class. Even if we do not use a member, that member will be
instantiated. Consequently, we can use explicit instantiation only for types that can be used with all the members of that template.

Note: An instantiation definition can be used only for types that can be used with every member function of a class template.

--
Efficiency and Flexibility

The library smart pointer types offer a good illustration of design choices faced by designers of templates.

The obvious difference between shared_ptr and unique_ptr is the strategy they use in managing the pointer they hold‚Äîone class gives us shared ownership; the other owns the pointer that it holds. This difference is essential to what these classes do.

These classes also differ in how they let users override their default deleter. We can easily override the deleter of a shared_ptr by passing a callable object when we create or reset the pointer. In contrast, the type of the deleter is part of the type of a unique_ptr object. Users must supply that type as an explicit template argument when they define a unique_ptr. As a result, it is more complicated for users of
unique_ptr to provide their own deleter.

The difference in how the deleter is handled is incidental(‰º¥Èö®ÁôºÁîüÁöÑ) to the functionality of these classes. However, as we‚Äôll see, this difference in implementation strategy may
have important performance impacts.

--
Binding the Deleter at Run Time

Although we don‚Äôt know how the library types are implemented, we can infer that shared_ptr must access its deleter indirectly. That is the deleter must be stored as a pointer or as a class (such as function) that encapsulates a pointer.

We can be certain that shared_ptr does not hold the deleter as a direct member, because the type of the deleter isn‚Äôt known until run time. Indeed, we can change the type of the deleter in a given shared_ptr during that shared_ptr‚Äôs lifetime. We
can construct a shared_ptr using a deleter of one type, and subsequently use reset to give that same shared_ptr a different type of deleter. In general, we cannot have a member whose type changes at run time. Hence, the deleter must be
stored indirectly. 

To think about how the deleter must work, let‚Äôs assume that shared_ptr stores the pointer it manages in a member named p, and that the deleter is accessed through a member named del. The shared_ptr destructor must include a statement such as

// value of del known only at run time; call through a pointer
del ? del(p) : delete p; // del(p) requires run-time jump to del's location

Because the deleter is stored indirectly, the call del(p) requires a run-time jump to the location stored in del to execute the code to which del points.

--
Binding the Deleter at Compile Time

Now, let‚Äôs think about how unique_ptr might work. In this class, the type of the deleter is part of the type of the unique_ptr. That is, unique_ptr has two template parameters, one that represents the pointer that the unique_ptr manages
and the other that represents the type of the deleter. Because the type of the deleter is part of the type of a unique_ptr, the type of the deleter member is known at compile time. The deleter can be stored directly in each unique_ptr object.

The unique_ptr destructor operates similarly to its shared_ptr counterpart in that it calls a user-supplied deleter or executes delete on its stored pointer:

// del bound at compile time; direct call to the deleter is instantiated
del(p); // no run-time overhead

The type of del is either the default deleter type or a user-supplied type. It doesn‚Äôt matter; either way the code that will be executed is known at compile time. Indeed, if
the deleter is something like our DebugDelete class this call might even be inlined at compile time.

By binding the deleter at compile time, unique_ptr avoids the run-time cost of an indirect call to its deleter. By binding the deleter at run time, shared_ptr makes it easier for users to override the deleter.

--
Template Argument Deduction

We‚Äôve seen that, by default, the compiler uses the arguments in a call to determine the template parameters for a function template. The process of determining the template arguments from the function arguments is known as template argument
deduction. During template argument deduction, the compiler uses types of the arguments in the call to find the template arguments that generate a version of the function that best matches the given call.

--
Conversions and Template Type Parameters

As with a nontemplate function, the arguments we pass in a call to a function template are used to initialize that function‚Äôs parameters. Function parameters whose type uses a template type parameter have special initialization rules. Only a very limited number of conversions are automatically applied to such arguments. Rather than converting the arguments, the compiler generates a new instantiation.

As usual, top-level consts in either the parameter or the argument are ignored. The only other conversions performed in a call to a function template are

‚Ä¢ const conversions: A function parameter that is a reference (or pointer) to a const can be passed a reference (or pointer) to a nonconst object.

‚Ä¢ Array- or function-to-pointer conversions: If the function parameter is not a reference type, then the normal pointer conversion will be applied to arguments of array or function type. An array argument will be converted to a pointer to its
first element. Similarly, a function argument will be converted to a pointer to the function‚Äôs type.

Other conversions, such as the arithmetic conversions, derived-tobase, and user-defined conversions, are not performed.

As examples, consider calls to the functions fobj and fref. The fobj function copies its parameters, whereas fref‚Äôs parameters are references:

template <typename T> T fobj(T, T); // arguments are copied
template <typename T> T fref(const T&, const T&); // references
string s1("a value");
const string s2("another value");
fobj(s1, s2); // calls fobj(string, string); const is ignored
fref(s1, s2); // calls fref(const string&, const string&)
// uses premissible conversion to const on s1
int a[10], b[42];
fobj(a, b); // calls f(int*, int*)
fref(a, b); // error: array types don't match

In the first pair of calls, we pass a string and a const string. Even though these types do not match exactly, both calls are legal. In the call to fobj, the arguments are copied, so whether the original object is const doesn‚Äôt matter. In the call to fref, the parameter type is a reference to const. Conversion to const for a reference parameter is a permitted conversion, so this call is legal.

In the next pair of calls, we pass array arguments in which the arrays are different sizes and hence have different types. In the call to fobj, the fact that the array types differ doesn‚Äôt matter. Both arrays are converted to pointers. The template parameter type in fobj is int*. The call to fref, however, is illegal. When the parameter is a reference, the arrays are not converted to pointers. The types of a and b don‚Äôt match, so the call is in error.

Note: const conversions and array or function to pointer are the only automatic conversions for arguments to parameters with template types.

--
Function Parameters That Use the Same Template Parameter Type

A template type parameter can be used as the type of more than one function parameter. Because there are limited conversions, the arguments to such parameters must have essentially the same type. If the deduced types do not match, then the call
is an error. For example, our compare function takes two const
T& parameters. Its arguments must have essentially the same type:

long lng;

compare(lng, 1024); // error: cannot instantiate compare(long, int)

This call is in error because the arguments to compare don‚Äôt have the same type. The template argument deduced from the first argument is long; the one for the second is int. These types don‚Äôt match, so template argument deduction fails.

If we want to allow normal conversions on the arguments, we can define the function with two type parameters:

// argument types can differ but must be compatible
template <typename A, typename B>
int flexibleCompare(const A& v1, const B& v2)
{
	if (v1 < v2) return -1;
	if (v2 < v1) return 1;
	return 0;
}

Now the user may supply arguments of different types:

long lng;
flexibleCompare(lng, 1024); // ok: calls flexibleCompare(long, int)

Of course, a < operator must exist that can compare values of those types.

--
Normal Conversions Apply for Ordinary Arguments

A function template can have parameters that are defined using ordinary types‚Äîthat is, types that do not involve a template type parameter. Such arguments have no special processing; they are converted as usual to the corresponding type of the
parameter. For example, consider the following template:

template <typename T> ostream &print(ostream &os, const T
&obj)
{
	return os << obj;
}

The first function parameter has a known type, ostream&. The second parameter, obj, has a template parameter type. Because the type of os is fixed, normal conversions are applied to arguments passed to os when print is called:

print(cout, 42); // instantiates print(ostream&, int)
ofstream f("output");
print(f, 10); // uses print(ostream&, int); converts f to ostream&

In the first call, the type of the first argument exactly matches the type of the first parameter. This call will cause a version of print that takes an ostream& and an int to be instantiated. In the second call, the first argument is an ofstream and there is a conversion from ofstream to ostream&. Because the type of this parameter does not depend on a template parameter, the compiler will implicitly convert f to ostream&.

Note: Normal conversions are applied to arguments whose type is not a template parameter.

--
Function-Template Explicit Arguments

In some situations, it is not possible for the compiler to deduce the types of the template arguments. In others, we want to allow the user to control the template instantiation. Both cases arise most often when a function return type differs from any of those used in the parameter list.

--
Specifying an Explicit Template Argument

As an example in which we want to let the user specify which type to use, we‚Äôll define a function template named sum that takes arguments of two different types. We‚Äôd like to let the user specify the type of the result. That way the user can choose whatever precision is appropriate.

We can let the user control the type of the return by defining a third template parameter to represent the return type:

// T1 cannot be deduced: it doesn't appear in the function parameter list
template <typename T1, typename T2, typename T3>
T1 sum(T2, T3);

In this case, there is no argument whose type can be used to deduce the type of T1. The caller must provide an explicit template argument for this parameter on each call to sum.

We supply an explicit template argument to a call the same way that we define an instance of a class template. Explicit template arguments are specified inside angle brackets after the function name and before the argument list:

// T1 is explicitly specified; T2 and T3 are inferred from the argument types
auto val3 = sum<long long>(i, lng); // long long sum(int, long)

This call explicitly specifies the type for T1. The compiler will deduce the types for T2 and T3 from the types of i and lng.

Explicit template argument(s) are matched to corresponding template parameter(s) from left to right; the first template argument is matched to the first template parameter, the second argument to the second parameter, and so on. An explicit
template argument may be omitted only for the trailing (right-most) parameters, and then only if these can be deduced from the function parameters. If our sum function had been written as

// poor design: users must explicitly specify all three template parameters
template <typename T1, typename T2, typename T3>
T3 alternative_sum(T2, T1);

then we would always have to specify arguments for all three parameters:

// error: can't infer initial template parameters
auto val3 = alternative_sum<long long>(i, lng);
// ok: all three parameters are explicitly specified
auto val2 = alternative_sum<long long, int, long>(i, lng);

--
Normal Conversions Apply for Explicitly Specified Arguments

For the same reasons that normal conversions are permitted for parameters that are defined using ordinary types, normal conversions also apply for arguments whose template type parameter is explicitly specified:

long lng;
compare(lng, 1024); // error: template parameters don't match
compare<long>(lng, 1024); // ok: instantiates compare(long, long)
compare<int>(lng, 1024); // ok: instantiates compare(int, int)

As we‚Äôve seen, the first call is in error because the arguments to compare must have the same type. If we explicitly specify the template parameter type, normal conversions apply. Thus, the call to compare<long> is equivalent to calling a
function taking two const long& parameters. The int parameter is automatically converted to long. In the second call, T is explicitly specified as int, so lng is converted to int.

--
Trailing Return Types and Type Transformation

Using an explicit template argument to represent a template function‚Äôs return type works well when we want to let the user determine the return type. In other cases, requiring an explicit template argument imposes a burden on the user with no
compensating advantage. For example, we might want to write a function that takes a pair of iterators denoting a sequence and returns a reference to an element in the sequence:

template <typename It>
??? &fcn(It beg, It end)
{
	// process the range
	return *beg; // return a reference to an element from the range
}

We don‚Äôt know the exact type we want to return, but we do know that we want that type to be a reference to the element type of the sequence we‚Äôre processing:

vector<int> vi = {1,2,3,4,5};
Blob<string> ca = { "hi", "bye" };
auto &i = fcn(vi.begin(), vi.end()); // fcn should return int&
auto &s = fcn(ca.begin(), ca.end()); // fcn should return string&

Here, we know that our function will return *beg, and we know that we can use decltype(*beg) to obtain the type of that expression. However, beg doesn‚Äôt exist until the parameter list has been seen. To define this function, we must use a trailing return type. Because a trailing return appears after the parameter list, it can use the function‚Äôs parameters:

// a trailing return lets us declare the return type after the parameter list is seen
template <typename It>
auto fcn(It beg, It end) -> decltype(*beg)
{
	// process the range
	return *beg; // return a reference to an element from the range
}

Here we‚Äôve told the compiler that fcn‚Äôs return type is the same as the type returned by dereferencing its beg parameter. The dereference operator returns an lvalue, so the type deduced by decltype is a reference to the type of the element that beg denotes. Thus, if fcn is called on a sequence of strings, the return type will be string&. If the sequence is int, the return will be int&.

--
The Type Transformation Library Template Classes

Sometimes we do not have direct access to the type that we need. For example, we might want to write a function similar to fcn that returns an element by value, rather than a reference to an element.

The problem we face in writing this function is that we know almost nothing about the types we‚Äôre passed. In this function, the only operations we know we can use are iterator operations, and there are no iterator operations that yield elements (as opposed to references to elements).

To obtain the element type, we can use a library type transformation template. These templates are defined in the type_traits header. In general the classes in type_traits are used for so-called template metaprogramming, a topic that is
beyond the scope of this Primer. However, the type transformation templates are useful in ordinary programming as well. These templates are described in Table below and we‚Äôll see how they are implemented later.

Standard Type Transformation Templates

For Mod<T>, where Mod is    If T is                   Then Mod<T>::type is

remove_reference            X& or X&&                 X
                            otherwise                 T

add_const                   X&, constX, or function   T
                            otherwise                 const T

add_lvalue_reference        X&                        T
                            X&&                       X&
                            otherwise                 T&

add_rvalue_reference        X& or X&&                 T
                            otherwise                 T&&

remove_pointer              X*                        X
                            otherwise                 T

add_pointer                 X& or X&&                 X*
                            otherwise                 T*

make_signed                 unsigned X                X
                            otherwise                 T

make_unsigned               signed type               unsigned T
                            otherwise                 T

remove_extent               X[n]                      X
                            otherwise                 T

remove_all_extents          X[n1][n2]...              X
                            otherwise                 T

In this case, we can use remove_reference to obtain the element type. The remove_reference template has one template type parameter and a (public) type member named type. If we instantiate remove_reference with a reference type, then type will be the referred-to type. For example, if we instantiate
remove_reference<int&>, the type member will be int. Similarly, if we instantiate remove_reference<string&>, type will be string, and so on. More generally, given that beg is an iterator:

remove_reference<decltype(*beg)>::type

will be the type of the element to which beg refers: decltype(*beg) returns the reference type of the element type. remove_reference::type strips off the reference, leaving the element type itself.

Using remove_reference and a trailing return with decltype, we can write our function to return a copy of an element‚Äôs value:

// must use typename to use a type member of a template parameter; see ¬ß 16.1.3 (p.
670)
template <typename It>

auto fcn2(It beg, It end) ->
typename remove_reference<decltype(*beg)>::type
{
	// process the range
	return *beg; // return a copy of an element from the range
}

Note that type is member of a class that depends on a template parameter. As a result, we must use typename in the declaration of the return type to tell the compiler that type represents a type.

Each of the type transformation templates described in Table above works similarly to remove_reference. Each template has a public member named type that represents a type. That type may be related to the template‚Äôs own template type parameter in a way that is indicated by the template‚Äôs name. If it is not possible (or not necessary) to transform the template‚Äôs parameter, the type member is the template parameter type itself. For example, if T is a pointer type, then remove_pointer<T>::type is the type to which T points. If T isn‚Äôt a pointer, then no transformation is needed. In this case, type is the same type as T.

--
Function Pointers and Argument Deduction

When we initialize or assign a function pointer from a function
template, the compiler uses the type of the pointer to deduce the template argument(s).

As an example, assume we have a function pointer that points to a function returning an int that takes two parameters, each of which is a reference to a const int. We can use that pointer to point to an instantiation of compare:

template <typename T> int compare(const T&, const T&);
// pf1 points to the instantiation int compare(const int&, const int&)
int (*pf1)(const int&, const int&) = compare;

The type of the parameters in pf1 determines the type of the template argument for T. The template argument for T is int. The pointer pf1 points to the instantiation of compare with T bound to int. It is an error if the template arguments cannot be determined from the function pointer type:

// overloaded versions of func; each takes a different function pointer type
void func(int(*)(const string&, const string&));
void func(int(*)(const int&, const int&));
func(compare); // error: which instantiation of compare?

The problem is that by looking at the type of func‚Äôs parameter, it is not possible to determine a unique type for the template argument. The call to func could instantiate
the version of compare that takes ints or the version that takes strings. Because it is not possible to identify a unique instantiation for the argument to func, this call won‚Äôt compile.

We can disambiguate the call to func by using explicit template arguments:

// ok: explicitly specify which version of compare to instantiate
func(compare<int>); // passing compare(const int&, const int&)

This expression calls the version of func that takes a function pointer with two const int& parameters.

Note: When the address of a function-template instantiation is taken, the context must be such that it allows a unique type or value to be determined for each template parameter.

--
Template Argument Deduction and References

In order to understand type deduction from a call to a function such as

template <typename T> void f(T &p);

in which the function‚Äôs parameter p is a reference to a template type parameter T, it is important to keep in mind two points: Normal reference binding rules apply; and consts are low level, not top level.

--
Type Deduction from Lvalue Reference Function Parameters

When a function parameter is an ordinary (lvalue) reference to a template type parameter (i.e., that has the form T&), the binding rules say that we can pass only an lvalue (e.g., a variable or an expression that returns a reference type). That argument might or might not have a const type. If the argument is const, then T will be deduced as a const type:

template <typename T> void f1(T&); // argument must be an lvalue
// calls to f1 use the referred-to type of the argument as the template parameter type
f1(i); // i is an int; template parameter T is int
f1(ci); // ci is a const int; template parameter T is const int
f1(5); // error: argument to a & parameter must be an lvalue

If a function parameter has type const T&, normal binding rules say that we can pass any kind of argument‚Äîan object (const or otherwise), a temporary, or a literal value. When the function parameter is itself const, the type deduced for T will not be a const type. The const is already part of the function parameter type; therefore, it does not also become part of the template parameter type:

template <typename T> void f2(const T&); // can take an rvalue
// parameter in f2 is const &; const in the argument is irrelevant
// in each of these three calls, f2's function parameter is inferred as const int&
f2(i); // i is an int; template parameter T is int
f2(ci); // ci is a const int, but template parameter T is int
f2(5); // a const & parameter can be bound to an rvalue; T is int

--
Type Deduction from Rvalue Reference Function Parameters

When a function parameter is an rvalue reference (i.e., has the
form T&&), normal binding rules say that we can pass an rvalue to this parameter. When we do so, type deduction behaves similarly to deduction for an ordinary lvalue reference function parameter. The deduced type for T is the type of the rvalue:

template <typename T> void f3(T&&);
f3(42); // argument is an rvalue of type int; template parameter T is int

--
Reference Collapsing and Rvalue Reference Parameters

Assuming i is an int object, we might think that a call such as f3(i) would be illegal. After all, i is an lvalue, and normally we cannot bind an rvalue reference to an lvalue. However, the language defines two exceptions to normal binding rules that allow this kind of usage. These exceptions are the foundation for how library facilities such as move operate.

The first exception affects how type deduction is done for rvalue reference parameters. When we pass an lvalue (e.g., i) to a function parameter that is an rvalue reference to a template type parameter (e.g, T&&), the compiler deduces the
template type parameter as the argument‚Äôs lvalue reference type. So, when we call f3(i), the compiler deduces the type of T as int&, not int.

Deducing T as int& would seem to mean that f3‚Äôs function parameter would be an rvalue reference to the type int&. Ordinarily, we cannot (directly) define a reference
to a reference. However, it is possible to do so indirectly through a type alias or through a template type parameter.

In such contexts, we see the second exception to the normal binding rules: If we indirectly create a reference to a reference, then those references ‚Äúcollapse.‚Äù In all but
one case, the references collapse to form an ordinary lvalue reference type. The new standard, expanded the collapsing rules to include rvalue references. References collapse to form an rvalue reference only in the specific case of an rvalue reference to an rvalue reference. That is, for a given type X:

‚Ä¢ X& &, X& &&, and X&& & all collapse to type X&
‚Ä¢ The type X&& && collapses to X&&

Note: Reference collapsing applies only when a reference to a reference is created indirectly, such as in a type alias or a template parameter.

The combination of the reference collapsing rule and the special rule for type deduction for rvalue reference parameters means that we can call f3 on an lvalue. When we pass an lvalue to f3‚Äôs (rvalue reference) function parameter, the compiler will deduce T as an lvalue reference type:

f3(i); // argument is an lvalue; template parameter T is int&
f3(ci); // argument is an lvalue; template parameter T is const int&

When a template parameter T is deduced as a reference type, the collapsing rule says that the function parameter T&& collapses to an lvalue reference type. For example, the resulting instantiation for f3(i) would be something like

// invalid code, for illustration purposes only
void f3<int&>(int& &&); // when T is int&, function parameter is int& &&

The function parameter in f3 is T&& and T is int&, so T&& is int& &&, which collapses to int&. Thus, even though the form of the function parameter in f3 is an rvalue reference (i.e., T&&), this call instantiates f3 with an lvalue reference type
(i.e., int&):

void f3<int&>(int&); // when T is int&, function parameter collapses to int&

There are two important consequences from these rules:

‚Ä¢ A function parameter that is an rvalue reference to a template type parameter (e.g., T&&) can be bound to an lvalue; and

‚Ä¢ If the argument is an lvalue, then the deduced template argument type will be an lvalue reference type and the function parameter will be instantiated as an (ordinary) lvalue reference parameter (T&)

It is also worth noting that by implication, we can pass any type of argument to a T&& function parameter. A parameter of such a type can (obviously) be used with rvalues, and as we‚Äôve just seen, can be used by lvalues as well.

Note: An argument of any type can be passed to a function parameter that is an rvalue reference to a template parameter type (i.e., T&&). When an lvalue is passed to such a parameter, the function parameter is instantiated as an
ordinary, lvalue reference (T&).

--
Writing Template Functions with Rvalue Reference Parameters

The fact that the template parameter can be deduced to a reference type can have surprising impacts on the code inside the template:

template <typename T> void f3(T&& val)
{
	T t = val; // copy or binding a reference?
	t = fcn(t); // does the assignment change only t or val and t?
	if (val == t) { /* ... */ } // always true if T is a reference type
}

When we call f3 on an rvalue, such as the literal 42, T is int. In this case, the local variable t has type int and is initialized by copying the value of the parameter val. When we assign to t, the parameter val remains unchanged.

On the other hand, when we call f3 on the lvalue i, then T is int&. When we define and initialize the local variable t, that variable has type int&. The initialization of t binds t to val. When we assign to t, we change val at the same time. In this instantiation of f3, the if test will always yield true.

It is surprisingly hard to write code that is correct when the types involved might be plain (nonreference) types or reference types (although the type transformation classes such as remove_reference can help).

In practice, rvalue reference parameters are used in one of two contexts: Either the template is forwarding its arguments, or the template is overloaded. We‚Äôll look at forwarding later and at template overloading later.

For now, it‚Äôs worth noting that function templates that use rvalue references often use overloading in the same way as we saw earlier:

template <typename T> void f(T&&); // binds to nonconst
rvalues
template <typename T> void f(const T&); // lvalues and const
rvalues

As with nontemplate functions, the first version will bind to modifiable rvalues and the second to lvalues or to const rvalues.

--
Understanding std::move

The library move function is a good illustration of a template that uses rvalue references. Fortunately, we can use move without understanding the template mechanisms that it uses. However, looking at how move works can help cement our general understanding, and use, of templates.

Earlier we noted that although we cannot directly bind an rvalue reference to an lvalue, we can use move to obtain an rvalue reference bound to an lvalue. Because move can take arguments of essentially any type, it should not be surprising that move is a function template.

--
How std::move Is Defined

The standard defines move as follows:

// for the use of typename in the return type and the cast see later
// remove_reference is covered later
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
	// static_cast covered earlier
	return static_cast<typename
	remove_reference<T>::type&&>(t);
}

This code is short but subtle. First, move‚Äôs function parameter, T&&, is an rvalue reference to a template parameter type. Through reference collapsing, this parameter can match arguments of any type. In particular, we can pass either an lvalue or an rvalue to move:

string s1("hi!"), s2;
s2 = std::move(string("bye!")); // ok: moving from an rvalue
s2 = std::move(s1); // ok: but after the assigment s1 has indeterminate value

--
How std::move Works

In the first assignment, the argument to move is the rvalue result of the string constructor, string("bye"). As we‚Äôve seen, when we pass an rvalue to an rvalue reference function parameter, the type deduced from that argument is the referred-to type. Thus, in std::move(string("bye!")):

‚Ä¢ The deduced type of T is string.
‚Ä¢ Therefore, remove_reference is instantiated with string.
‚Ä¢ The type member of remove_reference<string> is string.
‚Ä¢ The return type of move is string&&.
‚Ä¢ move‚Äôs function parameter, t, has type string&&.

Accordingly, this call instantiates move<string>, which is the function 

string&& move(string &&t)

The body of this function returns static_cast<string&&>(t). The type of t is already string&&, so the cast does nothing. Therefore, the result of this call is the rvalue reference it was given.

Now consider the second assignment, which calls std::move(s1). In this call, the argument to move is an lvalue. This time:

‚Ä¢ The deduced type of T is string& (reference to string, not plain string).
‚Ä¢ Therefore, remove_reference is instantiated with string&.
‚Ä¢ The type member of remove_reference<string&> is string,
‚Ä¢ The return type of move is still string&&.
‚Ä¢ move‚Äôs function parameter, t, instantiates as string& &&, which collapses to string&.

Thus, this call instantiates move<string&>, which is 

string&& move(string &t) 

and which is exactly what we‚Äôre after‚Äîwe want to bind an rvalue reference to an lvalue. The body of this instantiation returns static_cast<string&&>(t). In this case, the type of t is string&, which the cast converts to string&&.

--
static_cast from an Lvalue to an Rvalue Reference Is Permitted

Ordinarily, a static_cast can perform only otherwise legitimate conversions. However, there is again a special dispensation for rvalue references: Even though we cannot implicitly convert an lvalue to an rvalue reference, we can
explicitly cast an lvalue to an rvalue reference using static_cast.

Binding an rvalue reference to an lvalue gives code that operates on the rvalue reference permission to clobber the lvalue. There are times, such as in our StrVec reallocate function later, when we know it is safe to clobber an lvalue. By letting us do the cast, the language allows this usage. By forcing us to use a cast, the language tries to prevent us from doing so accidentally.

Finally, although we can write such casts directly, it is much easier to use the library move function. Moreover, using std::move consistently makes it easy to find the places in our code that might potentially clobber lvalues.

--
Forwarding

Some functions need to forward one or more of their arguments with their types unchanged to another, forwarded-to, function. In such cases, we need to preserve everything about the forwarded arguments, including whether or not the argument
type is const, and whether the argument is an lvalue or an rvalue.

As an example, we‚Äôll write a function that takes a callable expression and two additional arguments. Our function will call the given callable with the other two arguments in reverse order. The following is a first cut at our flip function:

// template that takes a callable and two parameters
// and calls the given callable with the parameters ''flipped''
// flip1 is an incomplete implementation: top-level const and references are lost
template <typename F, typename T1, typename T2>
void flip1(F f, T1 t1, T2 t2)
{
	f(t2, t1);
}

This template works fine until we want to use it to call a function that has a reference parameter:

void f(int v1, int &v2) // note v2 is a reference
{
	cout << v1 << " " << ++v2 << endl;
}

Here f changes the value of the argument bound to v2. However, if we call f through flip1, the changes made by f do not affect the original argument:

f(42, i); // f changes its argument i
flip1(f, j, 42); // f called through flip1 leaves j unchanged

The problem is that j is passed to the t1 parameter in flip1. That parameter has is a plain, nonreference type, int, not an int&. That is, the instantiation of this call to flip1 is

void flip1(void(*fcn)(int, int&), int t1, int t2);

The value of j is copied into t1. The reference parameter in f is bound to t1, not to j.

--
Defining Function Parameters That Retain Type Information

To pass a reference through our flip function, we need to rewrite our function so that its parameters preserve the ‚Äúlvalueness‚Äù of its given arguments. Thinking ahead a bit,
we can imagine that we‚Äôd also like to preserve the constness of the arguments as well.

We can preserve all the type information in an argument by defining its corresponding function parameter as an rvalue reference to a template type parameter. Using a reference parameter (either lvalue or rvalue) lets us preserve constness, because the const in a reference type is low-level. Through reference collapsing, if we define the function parameters as T1&& and T2&&, we can preserve the lvalue/rvalue property of flip‚Äôs arguments:

template <typename F, typename T1, typename T2>
void flip2(F f, T1 &&t1, T2 &&t2)
{
	f(t2, t1);
}

As in our earlier call, if we call flip2(f, j, 42), the lvalue j is passed to the parameter t1. However, in flip2, the type deduced for T1 is int&, which means that the type of t1 collapses to int&. The reference t1 is bound to j. When flip2
calls f, the reference parameter v2 in f is bound to t1, which in turn is bound to j. When f increments v2, it is changing the value of j.

Note: A function parameter that is an rvalue reference to a template type parameter (i.e., T&&) preserves the constness and lvalue/rvalue property of its corresponding argument.

This version of flip2 solves one half of our problem. Our flip2 function works fine for functions that take lvalue references but cannot be used to call a function that has an rvalue reference parameter. For example:

void g(int &&i, int& j)
{
	cout << i << " " << j << endl;
}

If we try to call g through flip2, we will be passing the parameter t2 to g‚Äôs rvalue reference parameter. Even if we pass an rvalue to flip2:

flip2(g, i, 42); // error: can't initialize int&& from an lvalue

what is passed to g will be the parameter named t2 inside flip2. A function parameter, like any other variable, is an lvalue expression. As a result, the call to g in flip2 passes an lvalue to g‚Äôs rvalue reference parameter.

--
Using std::forward to Preserve Type Information in a Call

We can use a new library facility named forward to pass flip2‚Äôs parameters in a way that preserves the types of the original arguments. Like move, forward is defined in the utility header. Unlike move, forward must be called with an
explicit template argument. forward returns an rvalue reference to that explicit argument type. That is, the return type of forward<T> is T&&.

Ordinarily, we use forward to pass a function parameter that is defined as an rvalue reference to a template type parameter. Through reference collapsing on its return type, forward preserves the lvalue/rvalue nature of its given argument:

template <typename Type> intermediary(Type &&arg)
{
	finalFcn(std::forward<Type>(arg));
	// ...
}

Here we use Type‚Äîwhich is deduced from arg‚Äîas forward‚Äôs explicit template argument type. Because arg is an rvalue reference to a template type parameter, Type will represent all the type information in the argument passed to arg. If that
argument was an rvalue, then Type is an ordinary (nonreference) type and forward<Type> will return Type&&. If the argument was an lvalue, then‚Äîthrough reference collapsing‚ÄîType itself is an lvalue reference type. In this case, the return type is an rvalue reference to an lvalue reference type. Again through reference collapsing‚Äîthis time on the return type‚Äîforward<Type> will return an lvalue
reference type.

Note: When used with a function parameter that is an rvalue reference to template type parameter (T&&), forward preserves all the details about an argument‚Äôs type.

Using forward, we‚Äôll rewrite our flip function once more:

template <typename F, typename T1, typename T2>
void flip(F f, T1 &&t1, T2 &&t2)
{
	f(std::forward<T2>(t2), std::forward<T1>(t1));
}

If we call flip(g, i, 42), i will be passed to g as an int& and 42 will be passed as an int&&.

Note: As with std::move, it‚Äôs a good idea not to provide a using declaration for std::forward. Later will explain why.

--
Overloading and Templates

Function templates can be overloaded by other templates or by ordinary, nontemplate functions. As usual, functions with the same name must differ either as to the number or the type(s) of their parameters. 

Function matching is affected by the presence of function templates in the following ways:

‚Ä¢ The candidate functions for a call include any function-template instantiation for which template argument deduction succeeds.

‚Ä¢ The candidate function templates are always viable, because template argument deduction will have eliminated any templates that are not viable.

‚Ä¢ As usual, the viable functions (template and nontemplate) are ranked by the conversions, if any, needed to make the call. Of course, the conversions used to call a function template are quite limited.

‚Ä¢ Also as usual, if exactly one function provides a better match than any of the others, that function is selected. However, if there are several functions that provide an equally good match, then:

‚Äì If there is only one nontemplate function in the set of equally good matches, the nontemplate function is called.

‚Äì If there are no nontemplate functions in the set, but there are multiple function templates, and one of these templates is more specialized than any of the others, the more specialized function template is called.

‚Äì Otherwise, the call is ambiguous.

Warning: Correctly defining a set of overloaded function templates requires a good understanding of the relationship among types and of the restricted conversions applied to arguments in template functions.

--
Writing Overloaded Templates

As an example, we‚Äôll build a set of functions that might be useful during debugging. We‚Äôll name our debugging functions debug_rep, each of which will return a string representation of a given object. We‚Äôll start by writing the most general version of this function as a template that takes a reference to a const object:

// print any type we don't otherwise handle
template <typename T> string debug_rep(const T &t)
{
	ostringstream ret; // see ¬ß 8.3 (p. 321)
	ret << t; // uses T's output operator to print a representation of t
	return ret.str(); // return a copy of the string to which ret is bound
}

This function can be used to generate a string corresponding to an object of any type that has an output operator.

Next, we‚Äôll define a version of debug_rep to print pointers:

// print pointers as their pointer value, followed by the object to which the pointer points
// NB: this function will not work properly with char*; 
template <typename T> string debug_rep(T *p)
{
	ostringstream ret;
	ret << "pointer: " << p; // print the pointer's own value
	if (p)
		ret << " " << debug_rep(*p); // print the value to which p
	points
	else
		ret << " null pointer"; // or indicate that the p is null
	return ret.str(); // return a copy of the string to which ret is bound
}

This version generates a string that contains the pointer‚Äôs own value and calls debug_rep to print the object to which that pointer points. Note that this function can‚Äôt be used to print character pointers, because the IO library defines a version of the << for char* values. That version of << assumes the pointer denotes a nullterminated character array, and prints the contents of the array, not its address. We‚Äôll see later how to handle character pointers.

We might use these functions as follows:

string s("hi");
cout << debug_rep(s) << endl;

For this call, only the first version of debug_rep is viable. The second version of debug_rep requires a pointer parameter, and in this call we passed a nonpointer object. There is no way to instantiate a function template that expects a pointer type from a nonpointer argument, so argument deduction fails. Because there is only one viable function, that is the one that is called.

If we call debug_rep with a pointer:

cout << debug_rep(&s) << endl;

both functions generate viable instantiations:
‚Ä¢ debug_rep(const string* &), which is the instantiation of the first version of debug_rep with T bound to string*

‚Ä¢ debug_rep(string*), which is the instantiation of the second version of debug_rep with T bound to string

The instantiation of the second version of debug_rep is an exact match for this call. The instantiation of the first version requires a conversion of the plain pointer to a pointer to const. Normal function matching says we should prefer the second template, and indeed that is the one that is run.

--
Multiple Viable Templates

As another example, consider the following call:

const string *sp = &s;
cout << debug_rep(sp) << endl;

Here both templates are viable and both provide an exact match:

‚Ä¢ debug_rep(const string* &), the instantiation of the first version of the template with T bound to const string*

‚Ä¢ debug_rep(const string*), the instantiation of the second version of the template with T bound to const string

In this case, normal function matching can‚Äôt distinguish between these two calls. We might expect this call to be ambiguous. However, due to the special rule for overloaded function templates, this call resolves to debug_rep(T*), which is the more specialized template.

The reason for this rule is that without it, there would be no way to call the pointer version of debug_rep on a pointer to const. The problem is that the template debug_rep(const T&) can be called on essentially any type, including pointer types. That template is more general than debug_rep(T*), which can be called only on pointer types. Without this rule, calls that passed pointers to const would always be ambiguous.

Note: When there are several overloaded templates that provide an equally good match for a call, the most specialized version is preferred.

--
Nontemplate and Template Overloads

For our next example, we‚Äôll define an ordinary nontemplate version of debug_rep to print strings inside double quotes:

// print strings inside double quotes
string debug_rep(const string &s)
{
	return '"' + s + '"';
}

Now, when we call debug_rep on a string,

string s("hi");
cout << debug_rep(s) << endl;

there are two equally good viable functions:

‚Ä¢ debug_rep<string>(const string&), the first template with T bound to string

‚Ä¢ debug_rep(const string&), the ordinary, nontemplate function

In this case, both functions have the same parameter list, so obviously, each function provides an equally good match for this call. However, the nontemplate version is selected. For the same reasons that the most specialized of equally good function templates is preferred, a nontemplate function is preferred over equally good match(es) to a function template.

Note: When a nontemplate function provides an equally good match for a call as a function template, the nontemplate version is preferred.

--
Overloaded Templates and Conversions

There‚Äôs one case we haven‚Äôt covered so far: pointers to C-style character strings and string literals. Now that we have a version of debug_rep that takes a string, we might expect that a call that passes character strings would match that version.

However, consider this call:

cout << debug_rep("hi world!") << endl; // calls debug_rep(T*)

Here all three of the debug_rep functions are viable:
‚Ä¢ debug_rep(const T&), with T bound to char[10]
‚Ä¢ debug_rep(T*), with T bound to const char
‚Ä¢ debug_rep(const string&), which requires a conversion from const char* to string

Both templates provide an exact match to the argument‚Äîthe second template requires a (permissible) conversion from array to pointer, and that conversion is considered as an exact match for function-matching purposes. The nontemplate version is viable but requires a user-defined conversion. That function is less good than an exact match, leaving the two templates as the possible functions to call. As before, the T* version is more specialized and is the one that will be selected.

If we want to handle character pointers as strings, we can define two more nontemplate overloads:

// convert the character pointers to string and call the string version of debug_rep

string debug_rep(char *p)
{
	return debug_rep(string(p));
}

string debug_rep(const char *p)
{
	return debug_rep(string(p));
}

--
Missing Declarations Can Cause the Program to Misbehave

It is worth noting that for the char* versions of debug_rep to work correctly, a declaration for debug_rep(const string&) must be in scope when these functions are defined. If not, the wrong version of debug_rep will be called:

template <typename T> string debug_rep(const T &t);
template <typename T> string debug_rep(T *p);
// the following declaration must be in scope
// for the definition of debug_rep(char*) to do the right thing
string debug_rep(const string &);
string debug_rep(char *p)
{
	// if the declaration for the version that takes a const string& is not in scope
	// the return will call debug_rep(const T&) with T instantiated to string
	return debug_rep(string(p));
}

Ordinarily, if we use a function that we forgot to declare, our code won‚Äôt compile. Not so with functions that overload a template function. If the compiler can instantiate the call from the template, then the missing declaration won‚Äôt matter. In this example, if we forget to declare the version of debug_rep that takes a string, the compiler will silently instantiate the template version that takes a const T&.

Tip: Declare every function in an overload set before you define any of the functions. That way you don‚Äôt have to worry whether the compiler will instantiate a call before it sees the function you intended to call.

--
Variadic(ÂèØËÆäÂèÉÊï∏) Templates

A variadic template is a template function or class that can take a varying number of parameters. The varying parameters are known as a parameter pack. There are two kinds of parameter packs: A template parameter pack represents zero or more template parameters, and a function parameter pack represents zero or more function parameters.

We use an ellipsis to indicate that a template or function parameter represents a pack. In a template parameter list, class... or typename... indicates that the following parameter represents a list of zero or more types; the name of a type
followed by an ellipsis represents a list of zero or more nontype parameters of the given type. In the function parameter list, a parameter whose type is a template parameter pack is a function parameter pack. For example:

// Args is a template parameter pack; rest is a function parameter pack
// Args represents zero or more template type parameters
// rest represents zero or more function parameters 
template <typename T, typename... Args>
void foo(const T &t, const Args& ... rest);

declares that foo is a variadic function that has one type parameter named T and a template parameter pack named Args. That pack represents zero or more additional type parameters. The function parameter list of foo has one parameter, whose type is a const & to whatever type T has, and a function parameter pack named rest. That pack represents zero or more function parameters.

As usual, the compiler deduces the template parameter types from the function‚Äôs arguments. For a variadic template, the compiler also deduces the number of parameters in the pack. For example, given these calls:

int i = 0; double d = 3.14; string s = "how now brown cow";
foo(i, s, 42, d); // three parameters in the pack
foo(s, 42, "hi"); // two parameters in the pack
foo(d, s); // one parameter in the pack
foo("hi"); // empty pack

the compiler will instantiate four different instances of foo:

void foo(const int&, const string&, const int&, const
double&);
void foo(const string&, const int&, const char[3]&);
void foo(const double&, const string&);
void foo(const char[3]&);

In each case, the type of T is deduced from the type of the first argument. The remaining arguments (if any) provide the number of, and types for, the additional arguments to the function.

--
The sizeof... Operator

When we need to know how many elements there are in a pack, we can use the sizeof... operator. Like sizeof, sizeof... returns a constant expression and does not evaluate its argument:

template<typename ... Args> void g(Args ... args) {
	cout << sizeof...(Args) << endl; // number of type parameters
	cout << sizeof...(args) << endl; // number of function
	parameters
}

--
Writing a Variadic Function Template

Earlier we saw that we can use an initializer_list to define a
function that can take a varying number of arguments. However, the arguments must have the same type (or types that are convertible to a common type). Variadic functions are used when we know neither the number nor the types of the arguments
we want to process. As an example, we‚Äôll define a function like our earlier error_msg function, only this time we‚Äôll allow the argument types to vary as well. We‚Äôll start by defining a variadic function named print that will print the contents of a given list of arguments on a given stream.

Variadic functions are often recursive. The first call processes the first argument in the pack and calls itself on the remaining arguments. Our print function will execute this way‚Äîeach call will print its second argument on the stream
denoted by its first argument. To stop the recursion, we‚Äôll also need to define a nonvariadic print function that will take a stream and an object:

// function to end the recursion and print the last element
// this function must be declared before the variadic version of print is defined
template<typename T>
ostream &print(ostream &os, const T &t)
{
	return os << t; // no separator after the last element in the pack
}

// this version of print will be called for all but the last element in the pack
template <typename T, typename... Args>
ostream &print(ostream &os, const T &t, const Args&... rest)
{
	os << t << ", "; // print the first argument
	return print(os, rest...); // recursive call; print the other arguments
}

The first version of print stops the recursion and prints the last argument in the initial call to print. The second, variadic, version prints the argument bound to t and calls itself to print the remaining values in the function parameter pack.

The key part is the call to print inside the variadic function:

return print(os, rest...); // recursive call; print the other arguments

The variadic version of our print function takes three parameters: an ostream&, a const T&, and a parameter pack. Yet this call passes only two arguments. What happens is that the first argument in rest gets bound to t. The remaining arguments
in rest form the parameter pack for the next call to print. Thus, on each call, the first argument in the pack is removed from the pack and becomes the argument bound to t. That is, given:

print(cout, i, s, 42); // two parameters in the pack

the recursion will execute as follows:

Call                      t     rest...
print(cout, i, s, 42)     i     s, 42
print(cout, s, 42)        s     42
print(cout, 42) calls the nonvariadic version of print

The first two calls can match only the variadic version of print because the nonvariadic version isn‚Äôt viable. These calls pass four and three arguments, respectively, and the nonvariadic print takes only two arguments.

For the last call in the recursion, print(cout, 42), both versions of print are viable. This call passes exactly two arguments, and the type of the first argument is ostream&. Thus, the nonvariadic version of print is viable.

The variadic version is also viable. Unlike an ordinary argument, a parameter pack can be empty. Hence, the variadic version of print can be instantiated with only two parameters: one for the ostream& parameter and the other for the const T&
parameter.

Both functions provide an equally good match for the call. However, a nonvariadic template is more specialized than a variadic template, so the nonvariadic version is chosen for this call.

Warning: A declaration for the nonvariadic version of print must be in scope when the variadic version is defined. Otherwise, the variadic function will recurse indefinitely.

--
Pack Expansion

Aside from taking its size, the only other thing we can do with a parameter pack is to expand it. When we expand a pack, we also provide a pattern to be used on each expanded element. Expanding a pack separates the pack into its constituent elements, applying the pattern to each element as it does so. We trigger an expansion by putting an ellipsis (. . . ) to the right of the pattern.

For example, our print function contains two expansions:

template <typename T, typename... Args>
ostream &
print(ostream &os, const T &t, const Args&... rest)// expand
Args
{
	os << t << ", ";
	return print(os, rest...); // expand rest
}

The first expansion expands the template parameter pack and generates the function parameter list for print. The second expansion appears in the call to print. That pattern generates the argument list for the call to print.

The expansion of Args applies the pattern const Args& to each element in the template parameter pack Args. The expansion of this pattern is a comma-separated list of zero or more parameter types, each of which will have the form const type&.
For example:

print(cout, i, s, 42); // two parameters in the pack

The types of the last two arguments along with the pattern determine the types of the trailing parameters. This call is instantiated as

ostream& print(ostream&, const int&, const string&, const int&);

The second expansion happens in the (recursive) call to print. In this case, the pattern is the name of the function parameter pack (i.e., rest). This pattern expands to a comma-separated list of the elements in the pack. Thus, this call is equivalent to 

print(os, s, 42);

--
Understanding Pack Expansions

The expansion of the function parameter pack in print just expanded the pack into its constituent parts. More complicated patterns are also possible when we expand a function parameter pack. For example, we might write a second variadic function that calls debug_rep on each of its arguments and then calls print to print the resulting strings:

// call debug_rep on each argument in the call to print
template <typename... Args>
ostream &errorMsg(ostream &os, const Args&... rest)
{
	// print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an)
	return print(os, debug_rep(rest)...);
}

The call to print uses the pattern debug_rep(rest). That pattern says that we want to call debug_rep on each element in the function parameter pack rest. The resulting expanded pack will be a comma-separated list of calls to debug_rep. That
is, a call such as

errorMsg(cerr, fcnName, code.num(), otherData, "other",
item);

will execute as if we had written

print(cerr, debug_rep(fcnName), debug_rep(code.num()), debug_rep(otherData), debug_rep("otherData"), debug_rep(item));

In contrast, the following pattern would fail to compile:

// passes the pack to debug_rep; print(os, debug_rep(a1, a2, ..., an))

print(os, debug_rep(rest...)); // error: no matching function to call

The problem here is that we expanded rest in the call to debug_rep. This call would execute as if we had written

print(cerr, debug_rep(fcnName, code.num(), otherData, "otherData", item));

In this expansion, we attempted to call debug_rep with a list of five arguments. There is no version of debug_rep that matches this call. The debug_rep function is not variadic and there is no version of debug_rep that has five parameters.

Note: The pattern in an expansion applies separately to each element in the pack.

--
Forwarding Parameter Packs

Under the new standard, we can use variadic templates together with forward to write functions that pass their arguments unchanged to some other function. To illustrate such functions, we‚Äôll add an emplace_back member to our StrVec class. The emplace_back member of the library containers is a variadic member template that uses its arguments to construct an element directly in space managed by the container.

Our version of emplace_back for StrVec will also have to be variadic, because string has a number of constructors that differ in terms of their parameters. Because we‚Äôd like to be able to use the string move constructor, we‚Äôll also need to
preserve all the type information about the arguments passed to emplace_back.

As we‚Äôve seen, preserving type information is a two-step process. First, to preserve type information in the arguments, we must define emplace_back‚Äôs function parameters as rvalue references to a template type parameter:

class StrVec {
public:
	template <class... Args> void emplace_back(Args&&...);
	// remaining members as earlier
};

The pattern in the expansion of the template parameter pack, &&, means that each function parameter will be an rvalue reference to its corresponding argument.

Second, we must use forward to preserve the arguments‚Äô original types when emplace_back passes those arguments to construct:

template <class... Args>
inline
void StrVec::emplace_back(Args&&... args)
{
	chk_n_alloc(); // reallocates the StrVec if necessary
	alloc.construct(first_free++,
	std::forward<Args>(args)...);
}

The body of emplace_back calls chk_n_alloc to ensure that
there is enough room for an element and calls construct to create an element in the first_free spot. The expansion in the call to construct:

std::forward<Args>(args)...

expands both the template parameter pack, Args, and the function parameter pack, args. This pattern generates elements with the form

std::forward<Ti>(ti)

where Ti represents the type of the ith element in the template parameter pack and ti represents the ith element in the function parameter pack. For example, assuming svec is a StrVec, if we call

svec.emplace_back(10, 'c'); // adds cccccccccc as a new last element

the pattern in the call to construct will expand to

std::forward<int>(10), std::forward<char>(c)

By using forward in this call, we guarantee that if emplace_back is called with an rvalue, then construct will also get an rvalue. For example, in this call:

svec.emplace_back(s1 + s2); // uses the move constructor

the argument to emplace_back is an rvalue, which is passed to construct as

std::forward<string>(string("the end"))

The result type from forward<string> is string&&, so construct will be called with an rvalue reference. The construct function will, in turn, forward this argument to the string move constructor to build this element.

Advice: Forwarding and Variadic Templates
Variadic functions often forward their parameters to other functions. Such functions typically have a form similar to our emplace_back function:

// fun has zero or more parameters each of which is
// an rvalue reference to a template parameter type
template<typename... Args>
void fun(Args&&... args) // expands Args as a list of rvalue references
{
	// the argument to work expands both Args and args
	work(std::forward<Args>(args)...);
}

Here we want to forward all of fun‚Äôs arguments to another function named work that presumably does the real work of the function. Like our call to construct inside emplace_back, the expansion in the call to work expands both the template parameter pack and the function parameter pack.

Because the parameters to fun are rvalue references, we can pass arguments of any type to fun; because we use std::forward to pass those arguments, all type information about those arguments will be preserved in the call to work.

--
Template Specializations

It is not always possible to write a single template that is best suited for every possible template argument with which the template might be instantiated. In some cases, the general template definition is simply wrong for a type: The general
definition might not compile or might do the wrong thing. At other times, we may be able to take advantage of some specific knowledge to write more efficient code than would be instantiated from the template. When we can‚Äôt (or don‚Äôt want to) use the template version, we can define a specialized version of the class or function template.

Our compare function is a good example of a function template for which the general definition is not appropriate for a particular type, namely, character pointers. We‚Äôd like compare to compare character pointers by calling strcmp rather than by
comparing the pointer values. Indeed, we have already overloaded the compare function to handle character string literals:

// first version; can compare any two types
template <typename T> int compare(const T&, const T&);

// second version to handle string literals
template<size_t N, size_t M>
int compare(const char (&)[N], const char (&)[M]);

However, the version of compare that has two nontype template parameters will be called only when we pass a string literal or an array. If we call compare with character pointers, the first version of the template will be called:

const char *p1 = "hi", *p2 = "mom";
compare(p1, p2); // calls the first template
compare("hi", "mom"); // calls the template with two nontype parameters

There is no way to convert a pointer to a reference to an array, so the second version of compare is not viable when we pass p1 and p2 as arguments.

To handle character pointers (as opposed to arrays), we can define a template specialization of the first version of compare. A specialization is a separate definition of the template in which one or more template parameters are specified to have particular types.

--
Defining a Function Template Specialization

When we specialize a function template, we must supply arguments for every template parameter in the original template. To indicate that we are specializing a template, we
use the keyword template followed by an empty pair of angle brackets (< >). The empty brackets indicate that arguments will be supplied for all the template parameters of the original template:

// special version of compare to handle pointers to character arrays
template <>
int compare(const char* const &p1, const char* const &p2)
{
	return strcmp(p1, p2);
}

The hard part in understanding this specialization is the function parameter types. When we define a specialization, the function parameter type(s) must match the corresponding types in a previously declared template. Here we are specializing:

template <typename T> int compare(const T&, const T&);

in which the function parameters are references to a const type. As with type aliases, the interaction between template parameter types, pointers, and const can be surprising.

We want to define a specialization of this function with T as const char*. Our function requires a reference to the const version of this type. The const version of a pointer type is a constant pointer as distinct from a pointer to const. The type we need to use in our specialization is const char* const &, which is a reference to a const pointer to const char.

--
Function Overloading versus Template Specializations

When we define a function template specialization, we are essentially taking over the job of the compiler. That is, we are supplying the definition to use for a specific instantiation of the original template. It is important to realize that a specialization is an instantiation; it is not an overloaded instance of the function name.

Note: Specializations instantiate a template; they do not overload it. As a result, specializations do not affect function matching.

Whether we define a particular function as a specialization or as an independent, nontemplate function can impact function matching. For example, we have defined two versions of our compare function template, one that takes references to array
parameters and the other that takes const T&. The fact that we also have a specialization for character pointers has no impact on function matching. When we call compare on a string literal:

compare("hi", "mom")

both function templates are viable and provide an equally good (i.e., exact) match to the call. However, the version with character array parameters is more specialized and is chosen for this call.

Had we defined the version of compare that takes character pointers as a plain nontemplate function (rather than as a specialization of the template), this call would resolve differently. In this case, there would be three viable functions: the two templates and the nontemplate character-pointer version. All three are also equally good matches for this call. As we‚Äôve seen, when a nontemplate provides an equally good match as a function template, the nontemplate is selected.

Key Concept: Ordinary Scope Rules Apply to Specializations

In order to specialize a template, a declaration for the original template must be in scope. Moreover, a declaration for a specialization must be in scope before any code uses that instantiation of the template.

With ordinary classes and functions, missing declarations are (usually) easy to find‚Äîthe compiler won‚Äôt be able to process our code. However, if a specialization declaration is missing, the compiler will usually generate code using the original template. Because the compiler can often instantiate the original template when a specialization is missing, errors in declaration order between a template and its specializations are easy to make but hard to find.

It is an error for a program to use a specialization and an instantiation of the original template with the same set of template arguments. However, it is an error that the compiler is unlikely to detect.

Best Practices: Templates and their specializations should be declared in the same header file. Declarations for all the templates with a given name should appear first, followed by any specializations of those templates.

--
Class Template Specializations

In addition to specializing function templates, we can also specialize class templates. As an example, we‚Äôll define a specialization of the library hash template that we can use to store Sales_data objects in an unordered container. By default, the unordered containers use hash<key_type> to organize their elements. To use this default with our own data type, we must define a specialization of the hash template. A specialized hash class must define

‚Ä¢ An overloaded call operator that returns a size_t and takes
an object of the container‚Äôs key type

‚Ä¢ Two type members, result_type and argument_type, which are the return and argument types, respectively, of the call operator

‚Ä¢ The default constructor and a copy-assignment operator (which can be implicitly defined)

The only complication in defining this hash specialization is that when we specialize a template, we must do so in the same namespace in which the original template is defined. We‚Äôll have more to say about namespaces later. For now, what we need to know is that we can add members to a namespace. To do so, we must first open the namespace:

// open the std namespace so we can specialize std::hash
namespace std {
} // close the std namespace; note: no semicolon after the close curly

Any definitions that appear between the open and close curlies will be part of the std namespace.

The following defines a specialization of hash for Sales_data:

//open the std namespace so we can specialize std::hash
namespace std {
template <> // we're defining a specialization with
struct hash<Sales_data> // the template parameter of Sales_data
{
	// the type used to hash an unordered container must define these types
	typedef size_t result_type;
	typedef Sales_data argument_type; // by default, this type needs ==
	size_t operator()(const Sales_data& s) const;
	// our class uses synthesized copy control and default constructor
};

size_t
hash<Sales_data>::operator()(const Sales_data& s) const
{
	return hash<string>()(s.bookNo) ^
	hash<unsigned>()(s.units_sold) ^
	hash<double>()(s.revenue);
}
} // close the std namespace; note: no semicolon after the close curly

Our hash<Sales_data> definition starts with template<>, which indicates that we are defining a fully specialized template. The template we‚Äôre specializing is named hash and the specialized version is hash<Sales_data>. The members of the class follow directly from the requirements for specializing hash.

As with any other class, we can define the members of a specialization inside the class or out of it, as we did here. The overloaded call operator must define a hashing function over the values of the given type. This function is required to return the same result every time it is called for a given value. A good hash function will (almost always) yield different results for objects that are not equal.

Here, we delegate the complexity of defining a good hash function to the library. The library defines specializations of the hash class for the built-in types and for many of the library types. We use an (unnamed) hash<string> object to generate a hash code for bookNo, an object of type hash<unsigned> to generate a hash from units_sold, and an object of type hash<double> to generate a hash from revenue. We exclusive OR these results to form an overall hash code for the given Sales_data object.

It is worth noting that we defined our hash function to hash all three data members so that our hash function will be compatible with our definition of operator== for Sales_data. By default, the unordered containers use the specialization of hash that corresponds to the key_type along with the equality
operator on the key type.

Assuming our specialization is in scope, it will be used automatically when we use Sales_data as a key to one of these containers:

// uses hash<Sales_data> and Sales_data operator==from ¬ß 14.3.1 (p. 561)
unordered_multiset<Sales_data> SDset;

Because hash<Sales_data> uses the private members of Sales_data, we must make this class a friend of Sales_data:

template <class T> class std::hash; // needed for the friend
declaration
class Sales_data {
friend class std::hash<Sales_data>;
	// other members as before
};

Here we say that the specific instantiation of hash<Sales_data> is a friend. Because that instantiation is defined in the std namespace, we must remember to that this hash type is defined in the std namespace. Hence, our friend declaration
refers to std::hash.

Note: To enable users of Sales_data to use the specialization of hash, we should define this specialization in the Sales_data header.

--
Class-Template Partial Specializations

Differently from function templates, a class template specialization does not have to supply an argument for every template parameter. We can specify some, but not all, of the template parameters or some, but not all, aspects of the parameters. A class template partial specialization is itself a template. Users must supply arguments for those template parameters that are not fixed by the specialization.

Note: We can partially specialize only a class template. We cannot partially specialize a function template.

Earlier we introduced the library remove_reference type. That
template works through a series of specializations:

// original, most general template
template <class T> struct remove_reference {
	typedef T type;
};

// partial specializations that will be used for lvalue and rvalue references
template <class T> struct remove_reference<T&> // lvalue
references
{ typedef T type; };

template <class T> struct remove_reference<T&&> // rvalue
references
{ typedef T type; };

The first template defines the most general version. It can be instantiated with any type; it uses its template argument as the type for its member named type. The next two classes are partial specializations of this original template.

Because a partial specialization is a template, we start, as usual, by defining the template parameters. Like any other specialization, a partial specialization has the same name as the template it specializes. The specialization‚Äôs template parameter list includes an entry for each template parameter whose type is not completely fixed by this partial specialization. After the class name, we specify arguments for the template parameters we are specializing. These arguments are listed inside angle brackets following the template name. The arguments correspond positionally to the parameters
in the original template.

The template parameter list of a partial specialization is a subset of, or a specialization of, the parameter list of the original template. In this case, the specializations have the same number of parameters as the original template. However, the parameter‚Äôs type in the specializations differ from the original template. The specializations will be used for lvalue and rvalue reference types, respectively:

int i;
// decltype(42) is int, uses the original template
remove_reference<decltype(42)>::type a;
// decltype(i) is int&, uses first (T&) partial specialization
remove_reference<decltype(i)>::type b;
// decltype(std::move(i)) is int&&, uses second (i.e., T&&) partial specialization
remove_reference<decltype(std::move(i))>::type c;

All three variables, a, b, and c, have type int.

--
Specializing Members but Not the Class

Rather than specializing the whole template, we can specialize just specific member function(s). For example, if Foo is a template class with a member Bar, we can specialize just that member:

template <typename T> struct Foo {
	Foo(const T &t = T()): mem(t) { }
	void Bar() { /* ... */ }
	T mem;
	// other members of Foo
};

template<> // we're specializing a template

void Foo<int>::Bar() // we're specializing the Bar member of Foo<int>
{
	// do whatever specialized processing that applies to ints
}

Here we are specializing just one member of the Foo<int> class. The other members of Foo<int> will be supplied by the Foo template:

Foo<string> fs; // instantiates Foo<string>::Foo()
fs.Bar(); // instantiates Foo<string>::Bar()
Foo<int> fi; // instantiates Foo<int>::Foo()
fi.Bar(); // uses our specialization of Foo<int>::Bar()

When we use Foo with any type other than int, members are instantiated as usual. When we use Foo with int, members other than Bar are instantiated as usual. If we use the Bar member of Foo<int>, then we get our specialized definition.

*** The end of this note ***