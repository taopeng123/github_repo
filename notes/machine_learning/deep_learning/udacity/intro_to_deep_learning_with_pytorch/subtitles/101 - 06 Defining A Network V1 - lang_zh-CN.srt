1
00:00:00,000 --> 00:00:04,360
你已经学了关于如何完成图像分类任务的很多知识

2
00:00:04,360 --> 00:00:07,725
下面我将介绍如何加载图像数据

3
00:00:07,725 --> 00:00:09,880
如何定义模型和训练模型

4
00:00:09,880 --> 00:00:12,220
在之前的“深度学习工具 PyTorch”课程中

5
00:00:12,220 --> 00:00:14,960
你可能已经学过这个流程

6
00:00:14,960 --> 00:00:18,955
但还是建议你继续听下去 这样可以通过另一个示例加深理解

7
00:00:18,955 --> 00:00:21,325
我将代码变成练习内容

8
00:00:21,325 --> 00:00:23,710
这样你就可以更改代码

9
00:00:23,710 --> 00:00:24,790
并在 Jupyter Notebook 中

10
00:00:24,790 --> 00:00:28,065
定义自定义模型

11
00:00:28,065 --> 00:00:30,460
首先 我在此 notebook 中

12
00:00:30,460 --> 00:00:33,305
加载了必要的 torch 和 NumPy 库

13
00:00:33,305 --> 00:00:37,630
下面我将导入 torchvision 数据库和转换库

14
00:00:37,630 --> 00:00:39,400
我将使用它们

15
00:00:39,400 --> 00:00:42,835
加载 MNIST 数据集并转换为张量数据类型

16
00:00:42,835 --> 00:00:47,065
在这里使用 transforms.ToTensor() 定义转换操作

17
00:00:47,065 --> 00:00:51,450
张量和 NumPy 数组很像

18
00:00:51,450 --> 00:00:53,720
但是张量可以移到 GPU 上来加快计算过程

19
00:00:53,720 --> 00:00:56,515
稍后我会详细讲解张量

20
00:00:56,515 --> 00:01:00,620
我还设定了加载图像数据的参数

21
00:01:00,620 --> 00:01:03,110
批次大小

22
00:01:03,110 --> 00:01:06,175
表示在 1 次训练迭代中看到的图像数量

23
00:01:06,175 --> 00:01:09,200
1 次训练迭代表示网络出现错误

24
00:01:09,200 --> 00:01:12,430
并通过反向传播汲取教训的一个流程

25
00:01:12,430 --> 00:01:15,550
工作器数量表示是否并行加载数据

26
00:01:15,550 --> 00:01:18,430
在大部分情形下 设为 0 即可

27
00:01:18,430 --> 00:01:23,415
现在我将使用 datasets.MNIST 加载训练和测试数据

28
00:01:23,415 --> 00:01:25,460
我将下载每个数据集

29
00:01:25,460 --> 00:01:28,685
并转换为在这里定义的张量数据类型

30
00:01:28,685 --> 00:01:32,670
将下载的数据放在 data 目录中

31
00:01:32,670 --> 00:01:36,260
最后 创建训练和测试加载器

32
00:01:36,260 --> 00:01:39,140
加载器的输入参数包括上面定义的数据

33
00:01:39,140 --> 00:01:41,270
批次大小和工作器数量

34
00:01:41,270 --> 00:01:43,640
训练和测试加载器

35
00:01:43,640 --> 00:01:46,615
使我们能够按批次遍历数据

36
00:01:46,615 --> 00:01:49,560
下载数据可能需要一两分钟时间

37
00:01:49,560 --> 00:01:51,715
下载数据后

38
00:01:51,715 --> 00:01:54,590
执行任何图像分类任务都会执行的第一步

39
00:01:54,590 --> 00:01:56,055
即可视化数据

40
00:01:56,055 --> 00:01:58,640
我获取了一批图像和正确标签

41
00:01:58,640 --> 00:02:01,525
然后绘制出 20 个样本图像

42
00:02:01,525 --> 00:02:05,635
这些是各种 MNIST 图像及其标签

43
00:02:05,635 --> 00:02:08,120
这一步使我能够检查并确保

44
00:02:08,120 --> 00:02:10,730
图像跟我的期望相符合

45
00:02:10,730 --> 00:02:13,095
也可以更详细地查看图像

46
00:02:13,095 --> 00:02:18,520
我在这里仅查看数据集中的一张图像并显示灰阶值

47
00:02:18,520 --> 00:02:21,335
可以看出这些值已标准化

48
00:02:21,335 --> 00:02:23,930
最亮的像素值接近 1

49
00:02:23,930 --> 00:02:26,330
黑色像素值为 0

50
00:02:26,330 --> 00:02:30,710
下面是最有趣的过程 即定义 MLP 模型

51
00:02:30,710 --> 00:02:34,130
我们已经讨论了如何定义输入层 隐藏层和输出层

52
00:02:34,130 --> 00:02:37,430
你需要完成这部分的大多数代码

53
00:02:37,430 --> 00:02:39,960
但是要注意几个事项

54
00:02:39,960 --> 00:02:41,740
首先是 init 函数

55
00:02:41,740 --> 00:02:45,260
要在 PyTorch 中定义任何神经网络

56
00:02:45,260 --> 00:02:48,890
我们需要在 Init 函数中定义并列出学习权重值的层级

57
00:02:48,890 --> 00:02:52,940
在此例中是我们定义的所有全连接线性层级

58
00:02:52,940 --> 00:02:58,160
我定义了一个示例层级 即第一个输入层 命名为 fc1

59
00:02:58,160 --> 00:03:04,250
它有 28 x 28 = 784 个输入和一些隐藏节点

60
00:03:04,250 --> 00:03:07,755
这个数字表示这一层将生成的输出数量

61
00:03:07,755 --> 00:03:10,010
暂时我将它设成了 1

62
00:03:10,010 --> 00:03:12,380
你需要更改此数字 才能创建可行的模型

63
00:03:12,380 --> 00:03:16,145
接下来需要定义网络的前馈行为

64
00:03:16,145 --> 00:03:21,215
也就是如何将输入 x 传入各种层级并进行转换

65
00:03:21,215 --> 00:03:24,440
我假设输入 x 是 MNIST 图像这样的灰阶图像

66
00:03:24,440 --> 00:03:28,335
我在此提供了一些起始代码

67
00:03:28,335 --> 00:03:32,705
首先使用 view 函数扁平化输入图像 x

68
00:03:32,705 --> 00:03:35,270
view 的参数是行数和列数

69
00:03:35,270 --> 00:03:38,120
然后将输入图像变成期望的形状

70
00:03:38,120 --> 00:03:40,760
列数是 28x28= 784

71
00:03:40,760 --> 00:03:44,480
这里的 -1 表示

72
00:03:44,480 --> 00:03:49,120
此函数将自动将所有 x 值变成这个列形状

73
00:03:49,120 --> 00:03:53,930
结果是这个 x 将是一个向量 有 784 个值

74
00:03:53,930 --> 00:03:56,300
然后将这个扁平化向量

75
00:03:56,300 --> 00:03:58,810
传入在这里定义的第一个全连接层

76
00:03:58,810 --> 00:04:00,690
按名称调用此层级

77
00:04:00,690 --> 00:04:04,395
传入输入图像并应用 ReLu 激活函数

78
00:04:04,395 --> 00:04:06,680
通常应向每个隐藏层的输出

79
00:04:06,680 --> 00:04:09,140
应用 ReLu 激活函数

80
00:04:09,140 --> 00:04:13,950
使这些输出值变成连续正数 最后返回转换后的 x

81
00:04:13,950 --> 00:04:15,485
要完成此模型

82
00:04:15,485 --> 00:04:18,410
应该添加到 init 和 forward 函数里

83
00:04:18,410 --> 00:04:22,135
确保最后返回的 x 是类别分数列表

84
00:04:22,135 --> 00:04:25,115
接下来我将讲解

85
00:04:25,115 --> 00:04:28,530
如何训练定义的模型并完成此任务

