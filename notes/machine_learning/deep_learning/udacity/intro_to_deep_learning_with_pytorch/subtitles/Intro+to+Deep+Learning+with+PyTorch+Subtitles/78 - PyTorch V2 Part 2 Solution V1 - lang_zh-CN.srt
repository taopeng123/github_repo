1
00:00:00,000 --> 00:00:02,685
下面说说

2
00:00:02,685 --> 00:00:04,695
我如何使用多层神经网络

3
00:00:04,695 --> 00:00:08,505
分类 MNIST 数据集中的手写数字

4
00:00:08,505 --> 00:00:11,850
像之前一样定义激活函数

5
00:00:11,850 --> 00:00:15,465
这是 S 型函数 在这里扁平化图像

6
00:00:15,465 --> 00:00:19,860
还记得如何变形张量吧

7
00:00:19,860 --> 00:00:21,285
使用 .view

8
00:00:21,285 --> 00:00:23,580
传入批次大小

9
00:00:23,580 --> 00:00:25,185
images.shape()

10
00:00:25,185 --> 00:00:27,720
第一个图像是 0

11
00:00:27,720 --> 00:00:32,925
获得图像张量里的批次数量

12
00:00:32,925 --> 00:00:35,460
我希望批次数量可以不变

13
00:00:35,460 --> 00:00:38,385
但是我要扁平化其他维度

14
00:00:38,385 --> 00:00:41,150
所以 可以在这里输入 -1

15
00:00:41,150 --> 00:00:44,600
其实我也可以在这里输入 784

16
00:00:44,600 --> 00:00:48,410
但是更简便的方式是输入 -1

17
00:00:48,410 --> 00:00:54,980
在这里传入批次大小 64

18
00:00:54,980 --> 00:00:58,100
当你在这里输入 -1 时

19
00:00:58,100 --> 00:01:02,270
它将设定相应的大小 保持元素总数不变

20
00:01:02,270 --> 00:01:07,220
它将自己判断第二个维度必须是 784

21
00:01:07,220 --> 00:01:10,220
这样的话 变形之后

22
00:01:10,220 --> 00:01:13,675
元素的数量和变形之前的一样

23
00:01:13,675 --> 00:01:17,135
这样可以快速扁平化张量

24
00:01:17,135 --> 00:01:21,245
我们不需要知道第二个维度的大小是多少

25
00:01:21,245 --> 00:01:25,025
在这里设置权重和偏差参数

26
00:01:25,025 --> 00:01:33,020
我们希望有 784 个输入单元 256 个隐藏单元

27
00:01:33,020 --> 00:01:37,070
第一个权重矩阵将是 784 x 256

28
00:01:37,070 --> 00:01:41,360
每个隐藏单元都需要一个偏差项

29
00:01:41,360 --> 00:01:45,120
因此 b1 中有 256 个偏差项

30
00:01:45,120 --> 00:01:48,830
第二个权重连接的是隐藏层和输出层

31
00:01:48,830 --> 00:01:53,570
我们希望有 256 个输入和 10 个输出

32
00:01:53,570 --> 00:01:55,685
偏差是 10 个元素

33
00:01:55,685 --> 00:02:02,630
和之前一样 我们可以进行矩阵乘法运算

34
00:02:02,630 --> 00:02:04,190
将输入与第一组权重参数相乘

35
00:02:04,190 --> 00:02:07,640
加上偏差项

36
00:02:07,640 --> 00:02:10,940
然后传入激活函数 得出隐藏层的输出

37
00:02:10,940 --> 00:02:15,395
然后将该输出当做输出层的输入

38
00:02:15,395 --> 00:02:19,970
再次与第二组权重相乘并加上第二组偏差项

39
00:02:19,970 --> 00:02:23,135
获得网络的输出好了

40
00:02:23,135 --> 00:02:26,210
来看下网络的输出

41
00:02:26,210 --> 00:02:29,450
有 64 行

42
00:02:29,450 --> 00:02:32,630
先输出形状 确保操作正确

43
00:02:32,630 --> 00:02:40,165
有 64 行 表示 64 个输入样本 然后是 10 个值

44
00:02:40,165 --> 00:02:42,530
这个值表示

45
00:02:42,530 --> 00:02:46,415
图像属于这个类别/数字

46
00:02:46,415 --> 00:02:50,530
我们查看下输出张量

47
00:02:50,530 --> 00:02:53,640
有大量的值

48
00:02:53,640 --> 00:02:57,145
6 -11 等等

49
00:02:57,145 --> 00:03:00,470
但是我们希望给定某个图像后

50
00:03:00,470 --> 00:03:04,160
网络能告诉我们图像属于各个类别的概率是多少

51
00:03:04,160 --> 00:03:09,500
如果我们向网络中传入图像

52
00:03:09,500 --> 00:03:12,050
输出应该是一个概率分布

53
00:03:12,050 --> 00:03:16,565
告诉我们图像最有可能属于哪个类别/数字

54
00:03:16,565 --> 00:03:19,255
如果图像是 6

55
00:03:19,255 --> 00:03:21,830
那么输出应该是一个概率分布

56
00:03:21,830 --> 00:03:24,995
最高的概率是第六个类别

57
00:03:24,995 --> 00:03:27,115
告诉我们它是数字 6

58
00:03:27,115 --> 00:03:29,375
我们希望网络的判断是

59
00:03:29,375 --> 00:03:31,520
基于每个类别的概率

60
00:03:31,520 --> 00:03:33,725
给定传入的图像后

61
00:03:33,725 --> 00:03:37,815
该图像属于不同类别的概率是多少

62
00:03:37,815 --> 00:03:39,605
可以看出

63
00:03:39,605 --> 00:03:41,450
每个类别的概率大致相同

64
00:03:41,450 --> 00:03:43,985
因此是一个正态分布

65
00:03:43,985 --> 00:03:46,310
表明网络没有经过训练

66
00:03:46,310 --> 00:03:49,165
所以是正态概率分布

67
00:03:49,165 --> 00:03:51,050
这是因为网络尚未见过任何数据

68
00:03:51,050 --> 00:03:53,495
还没有学习关于这些图像的任何规律

69
00:03:53,495 --> 00:03:57,005
即使你传入一个图像  无论传入的图像是什么

70
00:03:57,005 --> 00:04:00,950
它都不知道图像是什么 

71
00:04:00,950 --> 00:04:03,370
只是给出每个类别概率相等的分布 

72
00:04:03,370 --> 00:04:07,355
我们希望网络的输出

73
00:04:07,355 --> 00:04:10,670
是一个概率分布

74
00:04:10,670 --> 00:04:14,960
告诉我们图像属于任何一个类别的概率

75
00:04:14,960 --> 00:04:17,945
所以 我们将使用 softmax 函数

76
00:04:17,945 --> 00:04:20,540
这是指数函数

77
00:04:20,540 --> 00:04:22,670
传入 10 个值

78
00:04:22,670 --> 00:04:24,455
对于每个值

79
00:04:24,455 --> 00:04:26,765
我们都使该值的指数

80
00:04:26,765 --> 00:04:29,555
除以所有值的指数之和

81
00:04:29,555 --> 00:04:33,140
该函数的作用是

82
00:04:33,140 --> 00:04:36,680
将输入值 x 压缩到 0 和 1 之间

83
00:04:36,680 --> 00:04:39,470
然后标准化所有值

84
00:04:39,470 --> 00:04:42,870
使概率之和为 1

85
00:04:42,870 --> 00:04:44,940
即所有值相加为 1

86
00:04:44,940 --> 00:04:47,525
这样就获得了我们想要的概率和为1的正态分布

87
00:04:47,525 --> 00:04:50,225
下面你的任务是

88
00:04:50,225 --> 00:04:54,310
实现这个 softmax 函数并完成这一计算过程

89
00:04:54,310 --> 00:04:57,800
即获取这个简单神经网络的输出

90
00:04:57,800 --> 00:05:02,705
形状为 64 x 10

91
00:05:02,705 --> 00:05:06,695
将其传入函数 softmax 中

92
00:05:06,695 --> 00:05:11,660
确保对于传入的每个样本 

93
00:05:11,660 --> 00:05:13,130
它都会计算样本的概率分布加油！

