1
00:00:00,000 --> 00:00:04,940
这是我完成的 get_batches 代码 它会生成迷你批次的数据

2
00:00:04,940 --> 00:00:07,530
首先

3
00:00:07,530 --> 00:00:11,170
我想获取能够创建的完整批次数量 n_batches

4
00:00:11,170 --> 00:00:16,040
第一步是计算完整的迷你批次中有多少个字符

5
00:00:16,040 --> 00:00:17,430
在一个迷你批次中

6
00:00:17,430 --> 00:00:21,200
字符数量是 batch_size * seq_length

7
00:00:21,200 --> 00:00:24,270
我们能够创建的完整批次数量是

8
00:00:24,270 --> 00:00:28,470
数组长度除以迷你批次中的字符数

9
00:00:28,470 --> 00:00:31,085
这个双斜杠表示整数除法

10
00:00:31,085 --> 00:00:34,365
它会对除法结果向下舍入

11
00:00:34,365 --> 00:00:37,640
这样就获得了能够创建的完整批次数量

12
00:00:37,640 --> 00:00:40,550
然后获取数组并从该数组中拿出

13
00:00:40,550 --> 00:00:45,275
直到 n_batches * batch_size_total 个字符前的字符

14
00:00:45,275 --> 00:00:47,390
在这里确保仅保留

15
00:00:47,390 --> 00:00:49,850
创建完整批次所需的足够字符

16
00:00:49,850 --> 00:00:51,715
我们可能会丢失一些字符

17
00:00:51,715 --> 00:00:54,410
但是通常数据都足够

18
00:00:54,410 --> 00:00:57,345
删除最后一个不完整的批次影响不大

19
00:00:57,345 --> 00:01:00,350
接下来 对于 reshape()

20
00:01:00,350 --> 00:01:03,465
我们可以获取数组并使行数等于 batch_size

21
00:01:03,465 --> 00:01:06,920
表示我们希望在一个迷你批次中包含的序列数量

22
00:01:06,920 --> 00:01:09,200
我们希望行数等于 batch_size

23
00:01:09,200 --> 00:01:12,110
然后在这里传入 -1

24
00:01:12,110 --> 00:01:15,360
-1 是一种维度占位符

25
00:01:15,360 --> 00:01:17,975
它将自动填充第二个维度

26
00:01:17,975 --> 00:01:21,145
从而包含所有数据

27
00:01:21,145 --> 00:01:26,555
最后 使用长度为 seq_length 的窗口遍历批次数据

28
00:01:26,555 --> 00:01:31,855
在这里接受变形后的完整数组 然后查看所有行（所有批次）

29
00:01:31,855 --> 00:01:36,980
列数范围是从 n 到 n+seq_length

30
00:01:36,980 --> 00:01:38,790
表示长度为 seq_length 的窗口

31
00:01:38,790 --> 00:01:41,650
这样就获得了输入迷你批次 x

32
00:01:41,650 --> 00:01:44,930
然后对于目标 y

33
00:01:44,930 --> 00:01:48,860
将数组中的值全初始化为零 并且形状和 x 一样

34
00:01:48,860 --> 00:01:52,730
然后用 x 数组中的值填充该数组并且偏移一个位置

35
00:01:52,730 --> 00:01:54,440
从到到尾

36
00:01:54,440 --> 00:01:56,775
使 x 偏移一个位置

37
00:01:56,775 --> 00:01:59,840
如果抵达数组的末尾

38
00:01:59,840 --> 00:02:04,310
则使 y 的最后一个元素等于该数组中的第一个元素

39
00:02:04,310 --> 00:02:06,425
很多人喜欢将数组前后连起来

40
00:02:06,425 --> 00:02:11,095
使 y 的最后一个元素等于 x 的第一个元素 我不太确定为何这么做

41
00:02:11,095 --> 00:02:12,495
但是我多次见到这种做法

42
00:02:12,495 --> 00:02:14,450
所以我也这么循环

43
00:02:14,450 --> 00:02:16,580
似乎网络训练效果很好

44
00:02:16,580 --> 00:02:18,435
所以这么做不成问题

45
00:02:18,435 --> 00:02:21,775
我们的目标是希望 x 和 y 一样大

46
00:02:21,775 --> 00:02:24,940
如果你的代码正确并且想要测试代码

47
00:02:24,940 --> 00:02:27,595
你的批次数据应该看起来这样

48
00:02:27,595 --> 00:02:29,450
批次大小是 8

49
00:02:29,450 --> 00:02:30,920
所以这里有 8 行

50
00:02:30,920 --> 00:02:33,495
我们按顺序输出前 10 项

51
00:02:33,495 --> 00:02:35,205
所以这里应该有 10 项

52
00:02:35,205 --> 00:02:39,955
最重要的是确保 x 中的元素

53
00:02:39,955 --> 00:02:41,750
即实际编码值

54
00:02:41,750 --> 00:02:43,915
在 y 中向右偏移一个位置

55
00:02:43,915 --> 00:02:48,965
所以 51 在这里是第 1 项 在这里是第 0 项

56
00:02:48,965 --> 00:02:51,140
然后是 23 和 23

57
00:02:51,140 --> 00:02:55,280
同理 55 在这里 然后在 y 中 55 在这里我希望

58
00:02:55,280 --> 00:02:57,245
所有值都正确偏移

59
00:02:57,245 --> 00:02:59,420
看起来没问题

60
00:02:59,420 --> 00:03:01,160
获得批次数据后

61
00:03:01,160 --> 00:03:04,530
下一步我们将讨论如何实际构建网络

