Stopa: p216, The sizeof operator

==
findcbegin                   C begin
findscanfc                   scanf in C
findstringc                  Strin in C
findboolc                    Bool in C
findincludec                 Include in C
findheaderc                  Header in C
findmathc                    math.h in C
findifc                      if in C
findswitchc                  switch in C
findwhilec                   while in C
findforc                     for in C
findcontinuec                C has "continue" and "break"
findbreakc                   C has "continue" and "break"
findgotoc                    goto in C
findarrayc                   Array in C
findfunctionc                Function in C
findstaticc                  static & extern in C
findexternc                  static & extern in C
findpointerc                 Pointer in C
findargsc                    Command line argument C
findcommandlineargumentc     Command line argument C
findstructc                  Struct in C
findunionc                   Union in C
findtypedefc                 typedef in C
findmallocc                  Dynamic memory allocation and free in C
findmemoryc                  Dynamic memory allocation and free in C
findconstantc                Constant(宏) in C
findfilec                    File in C
findreadfromfilec            Read from file in C
findwritetofilec             Write to file in C

findcppbegin                 C++ begin
findinclude                  Need to include
findheader                   Headers
findcout                     cout
findcin                      cin 
findmath                     Math operators
findreadfromfile             Read from file and output to file
findwritetofile              Read from file and output to file
finddeclaration              declaration vs definition
finddefinition               declaration vs definition
findcast                     Cast
findconvertdatatype          Convert data types
findfor                      Range for 
findrangefor                 Range for 
findintialization            Intialization
findstaticallytyped          Statically typed launage
finddatatype                 Data types
findbool                     bool
findtypedef                  typedef
findreference                Reference
findpointer                  Pointer
findconst                    Constant
findconstant                 Constant
findconstantexpression       Constant expression
findstruct                   Struct
findclass                    Class
findnew                      The new operator
findsleep                    Sleep
findescape                   Escape sequence
findstring                   string
findsubstring                Substring (get and find substring)
findsplit                    split a string
findvector                   vector
finditerator                 iterator
findarray                    array
findand                      AND operator
findoperator                 operators
findincrement                ++ and -- operators
finddecrement                ++ and -- operators
find++                       ++ and -- operators
find--                       ++ and -- operators

=============
(findcbegin)
C begins

//Sample C program, printf example:

#include<stdio.h>

void main() {
	int i, sum = 0;	
	for(i = 1; i <= 100; i++) 
		sum = sum + i;	
	printf("sum = %d\n", sum);		
}

printf("%d, %d", a, b + c);

Format:
d: int
f: float
e,E: exponential
c: single character
s: string

==
(findscanfc)
scanf in C:

scanf is also in stdio.h

scanf("%d, %d, %d", &x, &y, &z); <- Input should be deliminated by ,
scanf("%d%d%d", &x, &y, &z); <- Input should be deliminated by any number of white spaces
s = max(x, y, z);
printf("max = %d\n", s);

Format is the same as printf

==
(finddatatypec)
Data types in C

type   number of bytes
char       1


==
(findstringc)
No string type in C:

There is no String variable type in C, but there is String constant type in C (eg, "abc").

The length of "ab" is 3, because it is stored as "ab\0"

string and char array:

char a[15];
char a[5] = {"BOY"}; 
char a[5] = "BOY";
char a[] = {"string!"};
char a[] = "string";
char a[4][8] = {"ZHANG", "ZHONG", "HUANG", "LIANG"};

char *hostname = "localhost";

//a is a string:
scanf("%s", a);
printf("%s\n", a);

The following string functions are in <string.h>:

strcat(s1, s2):  Catenate s1 and s2, return the address of the first element of the new char array. s1 can not be a string constant.

strcpy(s1, s2): Copy s2 into s1. s1 can not be a string constant.

strcmp(s1, s2): Compare two strings. Note that "s1 == s2" is wrong. Should use "strcmp(s1, s2) == 0".

strlen(s): Return the length of s, excluding the "\0" at end.

strlwr(s): Replace the uppercase chars in s to lowercase.

strupr(s): Replace the lowercase chars in s to uppercase.

==
(findboolc)
There is no bool type in C, it uses 1 to represent true, 0 to represent false.

==
(findincludec)
(findheaderc)
(findmathc)
Include in C
Headers in C
math.h in C

stdio.h, math.h, string.h:

math.h has the following functions:

cos(0.2), exp(0.2), fabs(0.2), log(0.2), log10(0.2), 
pow(0.2, 3.0) <- 0.2^3.0, 
sin(0.2), sqrt(0.2), tan(0.2)

--
When to use header files: when many programs use some common constants, data, etc, can put them into .h files.

Difference between the following two:
#include <xxx.h>
#include "xxx.h"

The difference is that: 
If use <xxx.h>, then the system will only search for the header file in the designated directory for header files (the include directory). For the header files provided by C, it saves searching time to use this way.
If use "xxx.h", then the system will first search for the header file in the current directory, then in the designated directory for header files (the include directory).

==
(findifc)
if in C

if(a < b) a = b;

if(...) {
	...
} else {
	...
}

--
string finalgrade = (grade < 60) ? "fail" : "pass";

==
(findswitchc)
Switch in C

switch(grade) {
	case 'A': printf("Excellent\n");
	case 'B': printf("Good\n");
	case 'C': printf("Pass\n");
	case 'D': printf("Fail\n");
	default: printf("Invalid input.\n");
}

==
(findwhilec)
While in C

while(x > 0) printf("Helo\n");

--
do {
	i--;
	printf("a");
} while(i >= 0);

==
(findforc)
for in C

for(i = 1; i <= 100; i++) 
	sum = sum + i;	

==
(findcontinuec)
(findbreakc)

C has "continue" and "break"

==
(findgotoc)
goto in C

s = 0.0;
goto cal;
s = 0.5 * 2;
cal: printf("a");

==
(findarrayc)
Array in C

int a[10];
a[0] = 1;
int x[3] = {1, 2, 3};
int x[] = {1, 2, 3}; //Can omit the length

int x[3] = {0, 0, 0}; 
can be written as 
int x[3] = {0};

double s[5][5]

int x[2][4] = {{1,2,3,4}, {6,7,8,9}};
is equivalent as
int x[2][4] = {1,2,3,4,5,6,7,8,9};

Array name is the address of the 0-th element
These two expressions are equivalent: a, &a[0]
These two expressions are equivalent: a[i], *(a+i)

2-D array name is the address of the 0-th row.

==
(findfunctionc)
Function in C

int max(int a, int b) {
    if(a > b) return a;
    else return b;
}

If no returned value, use void. 
If no parameters, use ():

void func() {
    printf("a");
}

main function usually has no parameters, unlike Java.

Function parameters are often passed by value. But for array names, it passes its address, so it is passed by reference.

For array as parameter, can define an empty array (tao: in the parameter parenthesis). If need to operate on its elemets, can use another parameter to denote its length:

void sort_string(char str[], int n) {
    ...
}

// Call the above function in another functin:
char str[30]=”ABCDEFGHIJKLMNOPQRSTUVWXYZ”;
int i=26;
sort_string(str, i);

==
(findstaticc)
(findexternc)
static & extern in C

Static variable: 
Static variable in a function will have their values kept even after this function is been called.
Exmaple: 
static int i;

Extern variable: 
Can be used in two cases:
1. In a file, can define a variable as extern and use this variable before its definition. Before using it, need to declare it using "extern". 
2. In a file, can define a variable as extern and use this variable in another file. Before using it, need to declare it using "extern". 
Example: none.

Static function:
Can only be used in the same file.
Example: none.

Extern function:
Can be used in other files. If a function definition has no keyword "extern", then it is still extern by default. Before using extern function in another file, need to declare it using "extern". 
Example: none.

==
(findpointerc)
Pointer in C

int *p = &i;
// Pointer p equals the address of i
// Then *p is i, *p = 100 is equivalent to i = 100

If a pointer = 0, it means it does not point to anything.

Print the address of a variable:
printf("%p\n",(void*)&a);

Pointers must be initialized.

int a[20], *p;
p = &a[0]; // p points to the address of a[0]
p += 2; // p points to the address of a[2]

a = &a[1];
b = &a[3];
Then (b - a) equals 2

int* p[3]: p is an array of pointers (can be easily understood)
int (*p)[3]: p is a pointer which points to an array (because the above is array of pointers, so here it is a pointer which...)

Pointer to functions can be rememebered in the save way as above:
int* f(int x); //f is a function which returns pointer
int (*f)(int x); //f is a pointer which points to a function

int func(int x);
int (*f)(int x);
f = func; <- func has no (), no parameters. Function name is the address of the entrance of function.
(*f) is equivalent as func, eg (*f)(x)

Array name as function parameter (in a similar way as Java):

// Tao remembers online says this way passes by copying the array and this way should be avoided, needs to confirm
void sort(int x[], int n) {
	...
}

void main() {
	int a[10];
	...
	sort(a, 10);
}

A pointer to a string is the address of the first character in the string.

==
(findargsc)
(findcommandlineargumentc)
Convert command line argument to string in C

#include <iostream>
#include <string>
#include <vector>

int main(int argc, char *argv[]) // Don't forget first integral argument 'argc', which is count of arguments plus the current exec file.
{
  std::string current_exec_name = argv[0]; // Name of the current exec program
  std::string first_arge;
  std::vector<std::string> all_args;

  if (argc > 1) {
    first_arge = argv[1];
    all_args.assign(argv + 1, argv + argc);
  }
}


==
(findstructc)
Struct in C

From online:
Should struct definitions go in .h or .c file?
Private structures for that file should go in the .c file, 
with a declaration in the .h file if they are used by any functions in the .h .
Public structures should go in the .h file.

struct date {
    int year;
    int month;
    int day;
}; // Don't forget the ;

struct date d;

The above two statements can be written together:

struct date {
    int year;
    int month;
    int day;
} d;

Initialize struct:

struct date {
    int year;
    int month;
    int day;
} d = {1977, 11, 14};

int y = date.year;

struct array (every element is a struct type):

struct date d[3];
struct date d[3] = {{1977, 11, 14}, {1980, 3, 5};
struct date d[] = {{1977, 11, 14}, {1980, 3, 5}; //Can omit the length

A pointer to a struct points to the initial address of the struct.

struct date d;
struct date *p;
p = &d;
(*p).year
p->year

Linked list node (note the next pointer):

struct student {
    char name[8];
    float score;
    struct student *next;
}

==
(findunionc)
Union in C

union utag {
    int i;
    float f;
    char c;
};

The definition of union is the same as struct.
The reference to memebers of union (including pointers) is also the same as struct.

The difference between struct and union:
The members in a struct have their own memory units. The size of a struct is the sum of the size of its members.
The members in a union share the same memory unit. The size of a union is the size of its largest member. Tao's understanding is that a union can be different types (any of its member type) at different times. Just like 精神分裂症.

Can only initialize the first member of a union, can not initialize all members:

Correct:

union utag {
    int i;
    float f;
    char c;
} u1 = {100};

Wrong:

union utag u2 = {100, 31.6, 'a'};

==
(findtypedefc)
typedef in C

typedef defines new type which is equivalent as original types, like an alias:

typedef int INTEGER;
INTEGER x, y;

typedef char *POINTER;
POINTER p;
//Equivalent as: char *p;

typedef struct {
    int year;
    int month;
    int day;
} DATE;

DATE birthday;

//Equivalent as:

struct {
    int year;
    int month;
    int day;
} birthday;

typedef char STRING[50];
STRING s1, s2;
//Equivalent to: char s1[50], s2[50];

Good:
Steps to use typedef:
1. Write down the ordinary definition of a variale, like: char str[50];
2. Replace the variable name with new type name, like replace "str" with "STRING" -> char STRING[50];
3. Add "typedef" in front, like: typedef char STRING[50];
4. Then can use the new type name to define variables, like: STRING s1, s2;


==
(findmallocc)
(findmemoryc)
Dynamic memory allocation and free in C

#include <stdlib.h>

int *p;
p = (int *) malloc(sizeof(int)); //Allocates a memory of size int type, p points to this memory

struct date {
    int year;
    int month;
    int day;
} *q;

q = (struct date *) malloc(sizeof(struct date));

free(p); //Free the memory pointed by p

==
(findconstantc)
Constant in C
宏 in C

#define PI 3.14
int a = PI;

==
(findfilec)
(findreadfromfilec)
(findwritetofilec)
File in C
Read from file in C
Write to file in C

All the following should include:
#include "sdio.h"

//Open a file:
FILE *fp;
fp = fopen("file1", "r");

//Close a file:
fclose(fp); //Now fp no longer points to this file

//Close all files:
fcloseall();

//Get a character from file:
ch = fgetc(fp);

//Returns whether fp points to the end of file:
feof(fp);

//Write a character to file at location pointed by fp:
fputc("a", fp);
fputc(c, stdout)//Outputs character c to terminal (screen), no "" around c.

//Read a string:
fgets()

//Write a string:
fputs()

//Read and print to file
fscanf(), fprintf()

//Read binary files:
fread(), fwrite()

//Foce the pointer fp to point to the beginning of file:
rewind(fp);

//Set the pointer position
fseek(file-pinter, offset, start-point)

*** C all recorded ***

====
(findcppbegin)
C++ begins

Common suffix for C++ programs: 
.cc .cpp .C .cxx .cp <- tao: .cpp is the most common I have seen online

Compile:
g++ -o file_name file_name.cc

Simpler way to compile and run:
g++ foo.c
./a.out

==
Sample C++ program:

#include<iostream>
using namespace std;
//using std::cout; <- can also use this

int main() {
    double a = 2.6;
    cout << a << endl;
    return 0;
}

==
(finddatatype)                 
Data types

--
(findbool)
bool:

bool b = 42;
int i = b; // i has value 1

When we assign one non-bool types to a bool, the result is false if the value is 0, and true otherwise.
When we use a bool in an arithmetic expression, its value always converts to either 0 or 1.

The words true and false are literals of type bool:
bool test = false;

The word nullptr is a pointer literal.

It is usually a bad idea to use the boolean literals true and false as operands in a comparison. For example:
if (val == true) { /* ...   */ }

Better way:
if (val)  { /*  ...  */ }


--
(findcast)
(findconvertdatatype)
Cast
Convert data types

//string -> int
#include <string>  
string str1 = "45";
int myint1 = stoi(str1); // myint1 = 45

//string -> double
string stest = "0.21";
double dtest = stod(stest);

//double -> string
string pi = std::to_string(3.1415926); // pi = "3.1415926" 

//int -> string
int a = std::to_string(28); // a = "28"

//int -> double
int a = 2;
double b = (double) a;

//double -> int
double a = 3.0;
double b = (int) a;

==
(findtypedef)
typedef

typedef double wages; // wages is a synonym for double

==
(findinclude)
Need to include

INT_MIN, INT_MAX: need to #include <climits>
max(1, 2): need to #include <algorithm>  

==
(findheader)
Headers

Need to include when use:

#include <iostream>
#include <string>
#include <vector>
#include <iterator>
cctype //islower(c), tolower(c)
container header
container adaptor
iterator
algorithm
tuple
bind

using namespace std;

--
#include <iostream>
#include "Sales_item.h"

Headers from the standard library are enclosed in <>
Headers that are not part of the library are enclosed in ""

The standard library headers typically have no suffix.
Header files that we write usually have a suffix of .h

Headers (usually) contain entities (such as class definitions and const variables) that can be defined only once in any given file.

Code inside headers ordinarily should not use "using declarations". The reason is that the contents of a header are copied into the including program’s text. If a header has a using declaration, then every program that includes that header gets that same using declaration. As a result, a program that didn’t intend to use the specified library name might encounter unexpected name conflicts.

In addition to facilities defined specifically for C++, the C++ library incorporates the C library. Headers in C have names of the form name .h. The C++ versions of these headers are named c name—they remove the .h suffix and precede the name with the letter c. The c indicates that the header is part of the C library. Hence, cctype has the same contents as ctype.h, but in a form that is appropriate for C++ programs. In particular, the names defined in the cname headers are defined inside the std namespace, whereas those defined in the .h versions are not. Ordinarily, C++ programs should use the cname versions of headers and not the name .h versions.

--
preprocessor

The most common technique for making it safe to include a header multiple times relies on the preprocessor. The preprocessor is a program that runs before the compiler and changes the source text of our programs.

Our programs already rely on one preprocessor facility, #include. When the preprocessor sees a #include, it replaces the #include with the contents of the specified header.

C++ programs also use the preprocessor to define header guards. Header guards rely on preprocessor variables. Preprocessor variables have one of two possible states: defined or not defined. The #define directive takes a name and defines that name as a preprocessor variable. There are two other directives that test whether a given preprocessor variable has or has not been defined: #ifdef is true if the variable has been defined, and #ifndef is true if the variable has not been defined. 

If the test is true, then everything following the #ifdef or #ifndef is processed up to the matching #endif.

tao: the following is the .h file which defines Sales_data. The benefit of the preprocessor in this .h file is that this .h file can be included in multiple files, and there will be no conflict, because SALES_DATA_H will be defined in the first file that includes this .h file, other files will have ifndef = false and will not execute this .h file.

#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
#endif

Preprocessor variables, including names of header guards, must be unique throughout the program. To avoid name clashes with other entities in our programs, preprocessor variables usually are written in all uppercase.

Headers should have guards, even if they aren’t (yet) included by another header. Header guards are trivial to write, and by habitually defining them you don’t need to decide whether they are needed.

--
How to include header in another folder (from online):

Just inlcude the path as well:

#include "../../Header/class1.h"

--
Whether to compile header files (from online):

Do I need to compile the header files (.h) in a C program?
No, there's no reason to "compile" these header files independently. 
Header files are intended to be included into implementation files, 
not fed to the compiler as independent translation units.

--
How to compile the files in the following example:

Suppose the files are organized in the following folders:

code
  - main.cpp

utils  
  - Time.h
  - Time.cpp 

Then in folder code, type the followings (list all the other cpp files after main.cpp.):
g++ main.cpp ../utils/Time.cpp 

This makes a compiled file in the same folder as main.cpp: a.out

In file Time.cpp, in the implementation of the Time member functions, it can use the other Time members directly without adding class name, note that the Time class is defined in another file Time.h

--
Separate Header and Implementation Files (from online, tao changed the path in the include for illustration)

How to compile the following files? See above.

In this section, we demonstrate how to make class reusable by separating it into another files.

Header File
Class declarations are stored in a separate file. A file that contains a class declaration is called header file. The name of the class is usually the same as the name of the class, with a .h extension. For example, the Time class would be declared in the file Time .h.

#ifndef TIME_H
#define TIME_H

class Time
{
     private :
          int hour;
          int minute;
          int second;
     public :
          //with default value
          Time(const int h = 0, const int m  = 0, const int s = 0);
          //    setter function
          void setTime(const int h, const int m, const int s);
          // Print a description of object in " hh:mm:ss"
          void print() const;
          //compare two time object
          bool equals(const Time&);
};
 
#endif
 
Implementation File

The member function definitions for a class are stored in a separate .cpp file, which is called the class implementation file. The file usually has the same name as the class, with the .cpp extension. For example the Time class member functions would be defined in the file Time.cpp.

#include <iostream>
#include <iomanip>
#include "Time.h" <- tao: since Time.cpp is in the same folder as Time.h, so no need to include path
using namespace std;
 
Time :: Time(const int h, const int m, const int s) 
  : hour(h), minute (m), second(s)
{}
 
void Time :: setTime(const int h, const int m, const int s) 
{
     hour = h;
     minute = m;
     second = s;     
}       
 
void Time :: print() const
{
     cout << setw(2) << setfill('0') << hour << ":"
    << setw(2) << setfill('0') << minute << ":"
    << setw(2) << setfill('0') << second << "\n";   
 
}
 
bool Time :: equals(const Time &otherTime)
{
     if(hour == otherTime.hour 
          && minute == otherTime.minute 
          && second == otherTime.second)
          return true;
     else
          return false;
}
 
Client Code

client code, is the one that includes the main function. This file should be stored by the name main.cpp
 
#include <iostream>
using namespace std;
#include "../utils/Time.h" <- tao: since main.cpp is in a different folder from Time.h, so need to include path

int main()
{
     Time t1(10, 50, 59);
     t1.print();   // 10:50:59
     Time t2;
     t2.print(); // 06:39:09
     t2.setTime(6, 39, 9);
     t2.print();  // 06:39:09
   
     if(t1.equals(t2))
          cout << "Two objects are equal\n";
     else
          cout << "Two objects are not equal\n";    
  
     return 0;
}
The advanages of storing class definition in separate file are

1. The class is reusable

2. The clients of the class know what member functions the class provides, how to call them and what return types to expect

3. The clients do not know how the class's member functions are implemented.

==
(findcout)
(findcin)
cout, cin 

remember: t looks like <, n can be put into >

The left-hand operand of << must be an ostream object. The operator writes the given value on the given ostream. The result of the output operator is its left-hand operand (the ostream). The following example uses << twice, because << returns ostream.

Writing endl has the effect of ending the current line and flushing the buffer asociated with that device. Flusing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.

Buffer: a region of storage used to hold data. IO facilities often store input (or output) in a buffer and read or write the buffer independently from actions in the program. Output buffers can be explicitly flushed to force the buffer to be written. By default, reading cin flushes cout; cout is also flushed when the program ends normally.

//cout:
#include<iostream>
using namespace std;
//using std::cout; <- can also use this

int main() {
    double a = 2.6;
    cout << a << endl;
    return 0;
}

//cin:
#include<iostream>
using namespace std;

int main() {
    int a = 0;
    cin >> a; //tao: read input into a
    return 0;
}

while(cin >> value) sum += value;

End of file: ctrl+d

// s is a string
os << s //Writes s onto output stream os. Reurns os.
is >> s //Reads whitespace-separated string from is into s. Returns is. 

getline(is, s) //Reads a line of input from is into s. Returns is.

==
(findreadfromfile)
(findwritetofile)
Read from file and output to file

In command line:
$ addItems <infile >outfile

Our program has been compiled into an executable file named "addItems". 
Note it is not infile enclosed in <>, but it is < acting on infile, and > acting on outfile. 

==
(findmath)
Math operators:

power:

#include <cmath>
pow(3.4, 4.4) // Returns: 3.4^4.4 = 218.025

--
std::pow in the <cmath> header has these overloads:

pow(float, float);
pow(float, int);
pow(double, double); // taken over from C
pow(double, int);
pow(long double, long double);
pow(long double, int);

Now you can't just do
pow(2, N)
with N being an int, because it doesn't know which of float, double or long double version it should take, and you would get an ambiguity error. All three would need a conversion from int to floating point, and all three are equally costly!

Therefor, be sure to have the first argument typed so it matches one of those three perfectly. I usually use double

pow(2.0, N)
Some lawyer crap from me again. I've often fallen in this pitfall myself, so i'm going to warn you about it.


==
(finddeclaration)
(finddefinition)
declaration vs definition:

A declaration makes a name known to the program. We must declare the type of a variable before we can use that variable.  A file that wants to use a name defined elsewhere includes a declaration for that name. 

A definition creates the associated entity.

A variable declaration specifies the type and name of a varaible. A variable definition is a declaration. In addition to specifying the name and type, a definition also allocates storage and may provide the variable with an initial value.

To obtain a declaration that is not also a definition, we add the extern keyword and may not provide an explicit initializer:

extern int i; //delcares but does not define i
int j; //declares and defines j

Any declaration that includes an explicit initializer is a definition. 

Variables must be defined exactly once but can be declared many times.

To use a variable in more than one file requires declarations. To use the same variable in multiple files, we must define that variable in one—and only one—file. Other files that use that variable must declare—but not define—that variable.

==
(findintialization)
Intialization:

//The followings are all equivalent:
int a = 0;
int a = {0};
int a{0};
int a(0);

If we do not initialize a string, then it is an empty string. (Seems different from Java).

We recommend initializing every object of built-in type.

==
(findstaticallytyped)
Type checking (statically typed launage):

Some languages, such as Smalltalk and Python, check types at run time. In contrast, C++ is a statically typed language; type checking is done at compile time.

In C++, if we try to do things that the type does not support, the compiler generates an error message and does not produce an executable file.

==
(findreference)
Reference

int &refVal = ival; // refVal refers to (is another name for) ival

A reference defines an alternative name for an object:
A reference must be initialized (Avado, same as const types)
There is no way to rebind a reference to refer to a different object.
Because references are not objects, they don’t have addresses. Hence, we may not define a pointer to a reference.

==
(findpointer)
Pointer

A pointer holds the address of another object. 
A pointer is an object in its own right. 
A pointer can be assigned and copied.
A pointer can point to several different objects over its lifetime.
A pointer do NOT need to be initialized at the time it is defined.

We can use the address operator & to get the address of an object.
We can use the dereference operator * to access the object being pointed.

   declaration  operator
&  reference    obtain address
*  pointer      yield object

int ival = 42;
int *p = &ival; // p holds the address of ival; p is a pointer to ival
int v = *p; //v = 42, dereference operator *
*p = 0; //Assign new value to ival

//Null pointer. The following three lines are equivalent, to assign null pointer to p.
int *p = 0;
int *p = nullptr; 
int *p = NULL;//Must #include<cstdlib>, modern programs should avoid using NULL <- tao: practice confirms that cstdlib is also included in std namespace, so if we already wrote "using namespace std;", then we do not need to #include<cstdlib>

Recommended: If there is no object to bind to a pointer, then initialize the pointer to nullptr or 0.

if(p) {...}//If p == 0, then it is false. Any nonzero pointer evaluates as true. This is consistent with converting int to bool.

Two pointers are equal (using ==) if they hold the same address.

double obj = 3.14;
void *pv = &obj; // The type void* is a special pointer type that can hold the address of any object.

Avadoles:
Variables defined inside a function ordinarily are not stored at a fixed address.
Tao: this is also the reason why my program did something wrong when I tried to return a pointer to a variable defined inside a function (see more below).

--
Return pointer from a function (from online):

It is not good idea to return the address of a local variable to outside of the function, so you would have to define the local variable as static variable. Tao: otherwise the caller function would get a pointer containing wrong address value (from practice).

Example:

#include <iostream>
#include <ctime>
 
using namespace std;
 
// function to generate and retrun random numbers.
int * getRandom( ) {
   static int  r[10];
 
   // set the seed
   srand( (unsigned)time( NULL ) );
   
   for (int i = 0; i < 10; ++i) {
      r[i] = rand();
      cout << r[i] << endl;
   }
 
   return r;
}
 
// main function to call above defined function.
int main () {
   // a pointer to an int.
   int *p;
 
   p = getRandom();
   for ( int i = 0; i < 10; i++ ) {
      cout << "*(p + " << i << ") : ";
      cout << *(p + i) << endl;
   }
 
   return 0;
}

==
(findconst)
(findconstant)
const

We can make a variable unchangeable by defining the variable’s type as const.
const object MUST be initilized after being created.

const int bufSize = 512;
extern const int bufSize = 512; // A const that is accessible to other files

//Reference to const:
const int ci = 1024;
const int &r1 = ci; // Both reference and underlying object are const. See following summary for remember.

//const refrence: no such thing

//Pointer to const:
const double pi = 3.14;
const double *cptr = &pi; // Store the address of a const object only in a pointer to const. See following summary for remember.

//const pointer:
int *const curErr = &errNumb; // curErr will always point to errNumb. See following summary for remember.

Summary from the above:
1. int is always on the left of *, like int *
2. const can be on the left or right of int *, like const int *, int * const
3. Principle: the symbol that is closest to the variable name is comes to the first in the type name: 
   const double *cptr = &pi: cptr is a pointer to const
   int *const curErr = &errNumb: curErr is a const pointer

We use the term top-level const to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a low-level const.

The distinction between top-level and low-level matters when we copy an object.
When we copy an object, top-level consts are ignored. Example:

const int ci = i, &cr = ci;
auto b = ci; // b is an int (top-level const in ci is dropped)

On the other hand, low-level const is never ignored. When we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects. In general, we can convert a nonconst to const but not the other way round.

--
(findconstantexpression)
Constant expression

A constant expression is an expression whose value cannot change and that can be evaluated at compile time. A literal is a constant expression. A const object that is initialized from a constant expression is also a constant expression. Examples:

const int max_files = 20; // max_files is a constant expression
const int limit = max_files + 1; // limit is a constant expression
int staff_size = 27; // staff_size is not a constant expression
const int sz = get_size(); // sz is not a constant expression

Even though sz is a const, the value of its initializer is not known until run time. Hence, sz is not a constant expression.

==
(findfor)
(findrangefor)

Range for in C++ 2011:

vector<int> v = {1, 3, 5, 7, 9};

for (auto x : v)
    cout << x << ' ';

==
(findstruct)
Struct

struct Sales_data {
    string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
}; //Tao: note the ;

Sales_data accum;
Sales_data* salesptr;

==
(findclass)
Class

Classes ordinarily are not defined inside functions.

In order to ensure that the class definition is the same in each file, classes are usually defined in header files.

Tao: note public and private has no identitation (from online examples, and sublime also removes these identitaction automatically).
Tao: note the ; at the end of a class.

class Sales_data {
public:
    Sales_data() = default; // default constructor
    Sales_data(string &s, double p) : bookNo(s), revenue(p) {}  

private:
    string bookNo;
    double revenue = 0.0;
    
    double price() {
        ...
    }
};

If our class does not explicitly define any constructors, the compiler will implicitly define the default constructor for us (know as the synthesized default constructor).

Sales_data item;
Screen myScreen(5, 3);

--
(findnew)
The new operator

From online:
Using the new operator returns a pointer to the object:
Node *n = new Node(); 

==
(findsleep)
Sleep

Compile the following file:

g++ -o sleep sleep.cc -std=c++0x -D_GLIBCXX_USE_NANOSLEEP

--- File sleep.cc starts ---
#include <iostream>
#include <chrono>
#include <thread>
using namespace std;

int main() {
    std::this_thread::sleep_for(std::chrono::milliseconds(5000));
    cout << "Hello world" << endl;
}
--- File sleep.cc ends ---

==
(findescape)
Escape sequence:

newline:       \n
double quote:  \"
single quote:  \'
backslash:     \\
question mark: \?

Examples: 
cout << '\n'; //prints a newline
cout << "Hi \n"

==
(findstring)
string

#include <string>
using std::string;

string s1;
string s2 = s1; //copy initialization, s2 is a copy of s1
string s3 = "hiya"; //direct initialization

When we initialize a variable using =, we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created. Otherwise, when we omit the =, we use direct initialization.

string literal: the compiler appends a null character ('\0') to every string literal. Thus, the actual size of a string literal is one more than its apparent size.

s.empty() //Returns bool
s.size() //Returns number, which is a string::size_type, see below
s[3] //Returns a reference to the char. The subscript operator (the [ ] operator) takes a string::size_type.
s[0] = 'a'; //strings in C++ can be changed! Different from Java.
s1 + s2 //Returns string
s1 += s2 //Equivalent to s1 = s1 + s2
s1 = s2 //Replaces characters in s1 with a copy of s2.
s1 == s2 //s1 and s2 are equal if they contain the same characters. Equality is case-sensitive.
s1 != s2
s1 <= s2 //Comparisons are case-sensitive and use dictionary ordering.

From online: create a string with five dot characters:
string foo = string(5, '.') // foo = "....."

string::size_type:
The string class—and most other library types—defines several companion types. These companion types make it possible to use the library types in a machine-independent manner. The type size_type is one of these companion types. Although we don’t know the precise type of string::size_type, we do know that it is an unsigned type big enough to hold the size of any string. Because size returns an unsigned type, it is essential to remember that expressions that mix signed and unsigned data can have surprising results. You can avoid problems due to conversion between unsigned and int by not using ints in expressions that use size().

The string library lets us convert both character literals and character string literals to strings. Because we can use these literals where a string is expected.

When we mix strings and string or character literals, at least one operand to each
+ operator must be of string type: 
string s4 = s1 + ", "; // ok: adding a string and a literal
string s5 = "hello" + ", "; // error: no string operand (tao: both are string literals, which are not string type variables, see below)

For historical reasons, and for compatibility with C, string literals are not standard library strings. It is important to remember that these types differ when you use string literals and library strings.

//The followings should include the "cctype" header:
//c is a character
isalnum(c) //true if c is a letter or a digit.
isalpha(c) //true if c is a letter
isdigit(c) //true if c is a digit
islower(c) //true if c is a lowercase letter
isupper(c) //true if c is an uppercase letter
tolower(c) //If c is an upercase letter, returns its lowercase equivalent, otherwise returns c unchanged
toupper(c) //If c is a lowercase letter, returns its upercase equivalent, otherwise returns c unchanged
isspace(c) //true if c is whitespace (ie, a space, tab, vertical tab, return, newline, or formfeed)

string s2 = s.erase (pos, len); //Erases the portion of the string value that begins at the character position pos and spans len characters (or until the end of the string, from online)

s2.append("helo"); // equivalent as below. The parameter of append() can only be string, it can not be char.
s.insert(s.size(), "helo"); 

--
(findsubstring)
Substring (get and find)

Get a substring:

string s2 = s.substr(pos, n) // return a string containing n characters fro s starting at pos. pos defaults to 0. n defaults to a value that causes the library to copy all the characters in s starting from pos.

Find a substring in a string:

Use std::string::find as follows:

if (s1.find(s2) != std::string::npos) {
    std::cout << "found!" << '\n';
}
Note: "found!" will be printed if s2 is a substring of s1, both s1 and s2 are of type std::string. 

--
(findsplit)
split a string

Problem: Split a string by a delim, and return a vector of strings containing no delim

Use stringstream getline
Signature istream& getline (istream&& is, string& str, char delim)

#include <sstream>

vector<string> split(const string &s, char delim) {
    stringstream ss(s);
    string item;
    vector<string> tokens;
    while (getline(ss, item, delim)) {
        tokens.push_back(item);
    }
    return tokens;
}

Tao's example of using the above function split:

string test_str = "Helo,how,are,you";
vector<string> strs = split(test_str, ',');
for(int i = 0; i < strs.size(); i++) cout << strs[i] << " ";
cout << endl;

Output:
Helo how are you

--
C-style charater strings are null terminated char arrays. 

C-style charater string functions: 
strlen, strcmp, strcat, strcpy.

For most applications, in addition to being safer, it is also more efficient to use library strings rather than C-style strings.

tao: convert a char array to string (from online: Note that this only works for constant NULL-terminated C-strings.)
char a1[2] = {'a', 'b', '\0'};
string str1(a1);

from online: convert a string to char array:
string temp = "cat";
char * tab2 = new char [temp.length()+1];
strcpy (tab2, temp.c_str());

==
(findvector)
vector

#include <vector>
using std::vector;

vector<int> v1; //v1 is empty
vector<int> v2 = v1; //v2 is a copy of the elements in v1
vector<int> v1(10); //v1 has n copies of a value-initialized object. 10 elements, each initialized to 0.
vector<string> v1(10); //10 elements, each an empty string
vector<int> v1(n, val); //v1 has n elements with value val
vector<int> v1 = {1, 2, 3};//C++11, does not work in the old C++ version
vector<int> v1{1,2,3};//Does not work

Searched online, in the old C++ version, to initialize a vector, we can only use push_back(). 

vector<vector<double> > v1 //correct, note the space between > >
vector<vector<double>> v1 //wrong <- tao: in the Mac (or C++11?), this is also correct.

vector< vector<int> > a(n,vector<int>(n)); //a is an 2D (n*n) vector, from HackerRank

v.push_back(3) //Adds an element with value 3 to end of v
v.empty() //Returns a bool
v.size() //Returns a number, which is of type vector<int>::size_type
v[5] //Returns a reference to the element
v1 = v2 //Replaces the elements in v1 with a copy of the elements in v2
v1 == v2 //Equal if each element in v1 is equal to the corresponding element in v2. 
v1 != v2
v1 <= v2 //Have their normal meanings using dictionary ordering.
vec.clear() //Removes all elements from the vector (which are destroyed), leaving the container with a size of 0.

We can define vectors to hold objects of most any type. Because references are not objects, we cannot have a vector of references.

vector is a template, not a type. Types generated from vector must include the element type, for example, vector<int>.

--
Convert array to vector:

#include <iterator>
#include <vector>
int x[] = { 1, 2, 3, 4, 5 };
std::vector<int> v(std::begin(x), std::end(x));

--
Pass a vector to a function (from online):

It depends on if you want to pass the vector as a reference or as a pointer (I am disregarding the option of passing it by value as clearly undesirable).

As a pointer:

int binarySearch(int first, int last, int search4, vector<int>* random);

vector<int> random(100);
// ...
found = binarySearch(first, last, search4, &random);

As a reference:

int binarySearch(int first, int last, int search4, vector<int>& random);

vector<int> random(100);
// ...
found = binarySearch(first, last, search4, random);

--
vector<int> v;
for(vector<int>::size_type i = 0; i < 10; ++i) {
    v[i] = i; // Wrong. Segmentation fault: 11. Because v is always an empty vector, so can not assign.
    v.push_back(i); // Correct
}

==
(finditerator)
iterator

Although we can use subscripts to access the characters of a string or the elements in a vector, there is a more general mechanism—known as iterators—that we can use for the same purpose. 

In addition to vector, the library defines several other kinds of containers. All of the library containers have iterators, but only a few of them support the subscript operator.

Like pointers, iterators give us indirect access to an object. In the case of an iterator, that object is an element in a container or a character in a string.

Types that have iterators have members that return iterators. In particular, these types have members named begin and end. The begin member returns an iterator that denotes the first element (or first character).

auto b = v.begin(), e = v.end(); //Note that auto is C++11

The iterator returned by end is an iterator positioned “one past the end” of the associated container (or string). This iterator denotes a nonexistent element “off the end” of the container. It is used as a marker indicating when we have processed all the elements. The iterator returned by end is often referred to as the off-the-end iterator or abbreviated as “the end iterator.” If the container is empty, begin returns the same iterator as the one returned by end.

Iterators support only a few operations, which are listed below (tao: these operations are very similar to pointers):

(In the folllowng, an example of iter is: auto iter = v.begin())
*iter //Returns a reference to the element denoted by the iterator iter.
iter->mem //Dereferences iter and fetches the memeber named mem from the underlying element. Equivalent to (*iter).mem
++iter //Increments iter to refer to the next element in the container.
--iter //Decrements iter to refer to the previous element in the container.
iter1 == iter2 //Two iterators are equal if they denote the same element or if they are the off-the-end iterator for the same container.
iter1 != iter2
iter + n // Adding (substracting) an integral value n to (from) an iterator yields an iterator that many elements forward (backward) within the container.
iter - n
iter += n
iter -= n
iter1 - iter2 //Returns the distance between the iterators. The result type is a signed integral type named difference_type. Both vector and string define difference_type. This type is signed, because subtraction might have a negative result.
iter1 <= iter2 //One iterator is less than another if it refers to an element that appears in the container before the one referred to by the other iterator.

Example: capitalize the first character of a string:

string s("some string");
if (s.begin() != s.end()) { // make sure s is not empty
    auto it = s.begin(); // it denotes the first character in s
    *it = toupper(*it); // make that character uppercase, tao: note the characters in a string can be changed in C++
}

Example: capitalize the first word in a string:

for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
    *it = toupper(*it); // capitalize the current character

Programmers coming to C++ from C or Java might be surprised that we used != rather than < in our for loops. C++ programmers use != as a matter of habit. They do so for the same reason that they use iterators rather than subscripts: This coding style applies equally well to various kinds of containers provided by the library. As we’ve seen, only a few library types, vector and string being among them, have the subscript operator. Similarly, all of the library containers have iterators that define the == and != operators. Most of those iterators do not have the < operator. By routinely using iterators and !=, we don’t have to worry about the precise type of container we’re processing.

As with size_type, the library types that have iterators define types named iterator and const_iterator that represent actual iterator types:

vector<int>::iterator it; // it can read and write vector<int> elements
string::iterator it2; // it2 can read and write characters in a string
vector<int>::const_iterator it3; // it3 can read but not write elements
string::const_iterator it4; // it4 can read but not write characters

A const_iterator behaves like a const pointer. Like a const pointer, a const_iterator may read but not write the element it denotes; an object of type iterator can both read and write. If a vector or string is const, we may use only its const_iterator type. With a nonconst vector or string, we can use either iterator or const_iterator.

The type returned by begin and end depends on whether the object on which they operator is const. If the object is const, then begin and end return a const_iterator; if the object is not const, they return iterator:

vector<int> v;
const vector<int> cv;
auto it1 = v.begin(); // it1 has type vector<int>::iterator
auto it2 = cv.begin(); // it2 has type vector<int>::const_iterator

It is important to realize that loops that use iterators should not add elements to the container to which the iterators refer.

==
(findarray)
array

int a[10]; // array of 10 ints. The elements are default initialized.
int a[3] = {0,1,2};
int a[] = {0,1,2};
unsigned scores[11] = {}; // 11 buckets, all value initialized to 0
int *p = a;

int arr[3][4];
int arr[2][3] = {{1,2},{3,4},{5,6}};

Fill in an array with the same values:
int arr[5];
std::fill_n(arr, 5, 2); //Now arr = {2, 2, 2, 2, 2}

As in the case of string or vector, it is best to use a range for when we want to traverse the entire array.

for (auto i : scores)
    cout << i << " ";  

--
tao: practice shows that the type of the array size can be int, but it should be const:
const int aSize = 3;
char a[aSize] = {'A', 'B', 'C'};

The number of elements in an array is part of the array’s type. As a result, the dimension must be known at compile time, which means that the dimension must be a constant expression. 

Because arrays have fixed size, they sometimes offer better run-time performance for specialized applications. However, that run-time advantage comes at the cost of lost flexibility.

Tao: in C++, there is no function to find array size (different from Java). So if need to use size, should not use array in the beginning, use vector instead. <- Confirmed later from online (including recommending using vector). If you must use the size of an array, you can do it as below:

int num_files = sizeof(file_names) / sizeof(file_names[0]);

Character arrays have an additional form of initialization: We can initialize such arrays from a string literal. When we use this form of initialization, it is important to remember that string literals end with a null character. That null character is copied into the array along with the characters in the literal:

char a1[] = {'C', '+', '+'}; // size = 3. 
char a2[] = {'C', '+', '+', '\0'}; // size = 4
char a3[] = "C++"; // size = 4, null terminator added automatically

--
When we use a variable to subscript an array, we normally should define that variable to have type size_t. size_t is a machine-specific unsigned type that is guaranteed to be large enough to hold the size of any object in memory. The size_t type is defined in the cstddef header.

--
//Principle: the symbol that is closest to the variable name comes to the first in the type name
int* parr[42]; // parr is an array of 42 pointers to int. From this, tao sees why tao likes to write "int*" rather than "int *"
int (*parr)[10] = &arr; // parr is a pointer, which points to an array of ten ints
int& refs[10] = ... // error: no arrays of references
int (&arrRef)[10] = arr; // arrRef is a reference, which refers to an array of ten ints
int* (&arry)[10] = ptrs; // arry is a reference to an array of ten pointers

As with vector, arrays hold objects. Thus, there are no arrays of references. Because an array is an object, we can define both pointers and references to arrays.

When we use an array, the compiler ordinarily converts the array to a pointer.

--
Although we can compute an off-the-end pointer, doing so is error-prone. To make it easier and safer to use pointers, the new library includes two functions, named begin and end.

int *beg = begin(ia); // pointer to the first element in ia
int *last = end(ia);  // pointer one past the last element in ia

These functions are defined in the iterator header.

A pointer “one past” the end of a built-in array behaves the same way as the iterator returned by the end operation of a vector.

As with iterators, subtracting two pointers gives us the distance between those pointers. 

The result of subtracting two pointers is a library type named ptrdiff_t. Like size_t,the ptrdiff_t type is a machine-specific type and is defined in the cstddef header. Because subtraction might yield a negative distance, ptrdiff_t is a signed integral type.

We can use the subscript operator on any pointer, as long as that pointer points to an element (or one past the last element) in an array:

int *p = &ia[2];  // p points to the element indexed by 2
int j = p[1];     // p[1] is equivalent to *(p + 1),
                  // p[1] is the same element as ia[3]
int k = p[-2];    // p[-2] is the same element as ia[0]

--
string *p = &nums[0];   // p points to the first element in nums

When we use an array, the compiler automatically substitutes a pointer to the first element:

string *p2 = nums;      // equivalent to p2 = &nums[0]

when we use an array as an
initializer for a variable defined using auto (§ 2.5.2, p. 68), the deduced type is a
pointer, not an array:

int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia is an array of ten ints
auto ia2(ia); // ia2 is an int* that points to the first element in ia

It is worth noting that this conversion does not happen when we use decltype. The type returned by decltype(ia) is array of ten ints:

decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9}; //Tao: decltype(ia) returns a type name
ia3[4] = i; // ok: assigns the value of i to an element in ia3

Pointers to array elements support the same operations as iterators on vectors or strings. For example, we can use the increment operator to move from one element in an array to the next:
  
int arr[] = {0,1,2,3,4,5,6,7,8,9};
int *p = arr; // p points to the first element in arr
++p;          // p points to arr[1]

--
Using an Array to Initialize a vector
 
We noted that we cannot initialize a built-in array from another array. Nor can we initialize an array from a vector. However, we can use an array to initialize a vector. To do so, we specify the address of the first element and one past the last element that we wish to copy:

int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));

The specified range can be a subset of the array:
vector<int> subVec(int_arr + 1, int_arr + 4);

--
Modern C++ programs should use vectors and iterators instead of built-in arrays and pointers, and use strings rather than C-style array-based character strings.

--
Multidimensional Arrays

Strictly speaking, there are no multidimensional arrays in C++. What are commonly referred to as multidimensional arrays are actually arrays of arrays.

int ia[3][4]; // array of size 3; each element is an array of ints of size 4

int arr[10][20][30] = {0}; // initialize all elements to 0

In a two-dimensional array, the first dimension is usually referred to as the row and the second as the column.

Multidimensional arrays may be initialized by specifying bracketed values for each row:

int ia[3][4] = {    
    {0, 1, 2, 3},   
    {4, 5, 6, 7},   
    {8, 9, 10, 11}  
};

The nested braces are optional. The following initialization is equivalent, although considerably less clear:

int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};

Under the new standard we can simplify the previous loop by using a range for:

size_t cnt = 0;

for (auto &row : ia)        
    for (auto &col : row) { 
        col = cnt;          
        ++cnt;            
    }

In the previous example, we used references as our loop control variables because we wanted to change the elements in the array. However, there is a deeper reason for using references.

Had we neglected the reference and written these loops as:
 
for (auto row : ia)
    for (auto col : row)
 
our program would not compile. As before, the first for iterates through ia, whose elements are arrays of size 4. As a result, in this loop the type of row is int*. The inner for loop is illegal, it attempts to iterate over an int*

As with any array, when we use the name of a multidimensional array, it is automatically converted to a pointer to the first element in the array (tao: note this is not an actual element, but an inner array):

int ia[3][4]
int (*p)[4] = ia; // p points to an array of four ints

The result of *p is an array of four ints. As usual, when we use an array, it is converted automatically to a pointer to its first element.

==
(findoperator)
(findand)
Operators

Logical operators:
AND: &&
OR:  ||
NOT: !

--
Bitwise operators:
AND: &
OR:  |
XOR: ^ (eg: expr1 ^ expr2)
NOT: ~ (eg: ~expr) 
Left shift: << (eg: expr1 << expr2)
Right shift: >> (eg: expr1 >> expr2)

a^b is equivalent as a != b

The left-shift operator (the << operator) inserts 0-valued bits on the right. The behavior of the right-shift operator (the >> operator) depends on the type of the left-hand operand: If that operand is unsigned, then the operator inserts 0-valued
bits on the left; if it is a signed type, the result is implementation defined—either copies of the sign bit or 0-valued bits are inserted on the left.

The bitwise NOT operator (the ~ operator) generates a new value with the bits of its operand inverted. Each 1 bit is set to 0; each 0 bit is set to 1.

Because there are no guarantees for how the sign bit is handled, we strongly recommend using unsigned types with the bitwise operators.

Overloaded versions of these operators for IO: 
cout << "Helo" << endl;

--
Remainder (modulus) operator: %

--
Order of Evaluation

Rember: ->|

--
Lvalues and Rvalues

Every expression in C++ is either an rvalue or an lvalue. lvalues could stand on the left-hand side of an assignment whereas rvalues could not. In C++, the distinction is less simple. Roughly speaking, when we use an object as an rvalue, we use the object’s value (its contents). When we use an object as an lvalue, we use
the object’s identity (its location in memory).

--
In assignment, if the types of the left and right operands differ, the right-hand operand is converted to the type of the left.

--
Compound assignments:
+=   -=   *=   /=   %=   (arithmetic operators)
<<=  >>=   &=   ^=   |=  (bitwise operators)

--
(findincrement)
(finddecrement)
(find++)
(find--)
The increment (++) and decrement (--) operators

int i = 0;
++i; // i = 1. Prefix returns new value 1 (remeber: ee)
i++; // i = 1. Postfix returns old value 0 (remember: oo)

Readers from a C background might be surprised that we use the prefix increment in the programs we’ve written. The reason is simple: The prefix version avoids unnecessary work. It increments the value and returns the incremented version. The postfix operator must store the original value so that it can return the unincremented value as its result. If we don’t need the
unincremented value, there’s no need for the extra work done by the postfix operator.

--
p->size() is equivalent to (*p).size()


