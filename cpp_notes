stopa 313:
6.5.2. Inline and constexpr Functions

==
findcbegin                   C begin
findscanfc                   scanf in C
findstringc                  Strin in C
findboolc                    Bool in C
findincludec                 Include in C
findheaderc                  Header in C
findmathc                    math.h in C
findifc                      if in C
findswitchc                  switch in C
findwhilec                   while in C
findforc                     for in C
findcontinuec                C has "continue" and "break"
findbreakc                   C has "continue" and "break"
findgotoc                    goto in C
findarrayc                   Array in C
findfunctionc                Function in C
findstaticc                  static & extern in C
findexternc                  static & extern in C
findpointerc                 Pointer in C
findargsc                    Command line argument C
findcommandlineargumentc     Command line argument C
findstructc                  Struct in C
findunionc                   Union in C
findtypedefc                 typedef in C
findmallocc                  Dynamic memory allocation and free in C
findmemoryc                  Dynamic memory allocation and free in C
findconstantc                Constant(宏) in C
findfilec                    File in C
findreadfromfilec            Read from file in C
findwritetofilec             Write to file in C

findcppbegin                 C++ begin
findinclude                  Need to include
findheader                   Headers
findcout                     cout
findcin                      cin 
findmath                     Math operators
findreadfromfile             Read from file and output to file
findwritetofile              Read from file and output to file
finddeclaration              declaration vs definition
finddefinition               declaration vs definition
findcast                     Cast
findconvertdatatype          Convert data types
findfor                      Range for 
findrangefor                 Range for 
findintialization            Intialization
findstaticallytyped          Statically typed launage
finddatatype                 Data types
findbool                     bool
findtypedef                  typedef
findreference                Reference
findpassbyvalue              Pass by value
findpassbyreference          Pass by reference
findpointer                  Pointer
findconst                    Constant
findconstant                 Constant
findconstantexpression       Constant expression
findstruct                   Struct
findclass                    Class
findnew                      The new operator
findsleep                    Sleep
findescape                   Escape sequence
findstring                   string
findsubstring                Substring (get and find substring)
findsplit                    split a string
findfind                     find the position of a substring in a string
findtrim                     trim
findargs                     Command line argument 
findcommandlineargument      Command line argument 
findvector                   vector
findset                      set
findmap                      map
findstack                    stack
findqueue                    queue
findpriorityqueue            priority_queue
finditerator                 iterator
findarray                    array
findand                      AND operator
findoperator                 operators
findincrement                ++ and -- operators
finddecrement                ++ and -- operators
find++                       ++ and -- operators
find--                       ++ and -- operators
findsizeof                   sizeof
commaoperator                Comma operator
findif                       if 
findswitch                   switch
findwhile                    while
findfor                      for
findbreak                    break
findcontinue                 continue
findgoto                     goto
findexception                Exception
findfunction                 function
findreturn                   return
findstatic                   Static variables
findoverload                 Overloaded Functions

=============
(findcbegin)
C begins

//Sample C program, printf example:

#include<stdio.h>

void main() {
	int i, sum = 0;	
	for(i = 1; i <= 100; i++) 
		sum = sum + i;	
	printf("sum = %d\n", sum);		
}

printf("%d, %d", a, b + c);

Format:
d: int
f: float
e,E: exponential
c: single character
s: string

==
(findscanfc)
scanf in C:

scanf is also in stdio.h

scanf("%d, %d, %d", &x, &y, &z); <- Input should be deliminated by ,
scanf("%d%d%d", &x, &y, &z); <- Input should be deliminated by any number of white spaces
s = max(x, y, z);
printf("max = %d\n", s);

Format is the same as printf

==
(finddatatypec)
Data types in C

type   number of bytes
char       1


==
(findstringc)
No string type in C:

There is no String variable type in C, but there is String constant type in C (eg, "abc").

The length of "ab" is 3, because it is stored as "ab\0"

string and char array:

char a[15];
char a[5] = {"BOY"}; 
char a[5] = "BOY";
char a[] = {"string!"};
char a[] = "string";
char a[4][8] = {"ZHANG", "ZHONG", "HUANG", "LIANG"};

char *hostname = "localhost";

//a is a string:
scanf("%s", a);
printf("%s\n", a);

The following string functions are in <string.h>:

strcat(s1, s2):  Catenate s1 and s2, return the address of the first element of the new char array. s1 can not be a string constant.

strcpy(s1, s2): Copy s2 into s1. s1 can not be a string constant.

strcmp(s1, s2): Compare two strings. Note that "s1 == s2" is wrong. Should use "strcmp(s1, s2) == 0".

strlen(s): Return the length of s, excluding the "\0" at end.

strlwr(s): Replace the uppercase chars in s to lowercase.

strupr(s): Replace the lowercase chars in s to uppercase.

==
(findboolc)
There is no bool type in C, it uses 1 to represent true, 0 to represent false.

==
(findincludec)
(findheaderc)
(findmathc)
Include in C
Headers in C
math.h in C

stdio.h, math.h, string.h:

math.h has the following functions:

cos(0.2), exp(0.2), fabs(0.2), log(0.2), log10(0.2), 
pow(0.2, 3.0) <- 0.2^3.0, 
sin(0.2), sqrt(0.2), tan(0.2)

--
When to use header files: when many programs use some common constants, data, etc, can put them into .h files.

Difference between the following two:
#include <xxx.h>
#include "xxx.h"

The difference is that: 
If use <xxx.h>, then the system will only search for the header file in the designated directory for header files (the include directory). For the header files provided by C, it saves searching time to use this way.
If use "xxx.h", then the system will first search for the header file in the current directory, then in the designated directory for header files (the include directory).

==
(findifc)
if in C

if(a < b) a = b;

if(...) {
	...
} else {
	...
}

--
string finalgrade = (grade < 60) ? "fail" : "pass";

==
(findswitchc)
Switch in C

switch(grade) {
	case 'A': printf("Excellent\n");
	case 'B': printf("Good\n");
	case 'C': printf("Pass\n");
	case 'D': printf("Fail\n");
	default: printf("Invalid input.\n");
}

==
(findwhilec)
While in C

while(x > 0) printf("Helo\n");

--
do {
	i--;
	printf("a");
} while(i >= 0);

==
(findforc)
for in C

for(i = 1; i <= 100; i++) 
	sum = sum + i;	

==
(findcontinuec)
(findbreakc)

C has "continue" and "break"

==
(findgotoc)
goto in C

s = 0.0;
goto cal;
s = 0.5 * 2;
cal: printf("a");

==
(findarrayc)
Array in C

int a[10];
a[0] = 1;
int x[3] = {1, 2, 3};
int x[] = {1, 2, 3}; //Can omit the length

int x[3] = {0, 0, 0}; 
can be written as 
int x[3] = {0};

double s[5][5]

int x[2][4] = {{1,2,3,4}, {6,7,8,9}};
is equivalent as
int x[2][4] = {1,2,3,4,5,6,7,8,9};

Array name is the address of the 0-th element
These two expressions are equivalent: a, &a[0]
These two expressions are equivalent: a[i], *(a+i)

2-D array name is the address of the 0-th row.

==
(findfunctionc)
Function in C

int max(int a, int b) {
    if(a > b) return a;
    else return b;
}

If no returned value, use void. 
If no parameters, use ():

void func() {
    printf("a");
}

main function usually has no parameters, unlike Java.

Function parameters are often passed by value. But for array names, it passes its address, so it is passed by reference.

For array as parameter, can define an empty array (tao: in the parameter parenthesis). If need to operate on its elemets, can use another parameter to denote its length:

void sort_string(char str[], int n) {
    ...
}

// Call the above function in another functin:
char str[30]=”ABCDEFGHIJKLMNOPQRSTUVWXYZ”;
int i=26;
sort_string(str, i);

==
(findstaticc)
(findexternc)
static & extern in C

Static variable: 
Static variable in a function will have their values kept even after this function is been called.
Exmaple: 
static int i;

Extern variable: 
Can be used in two cases:
1. In a file, can define a variable as extern and use this variable before its definition. Before using it, need to declare it using "extern". 
2. In a file, can define a variable as extern and use this variable in another file. Before using it, need to declare it using "extern". 
Example: none.

Static function:
Can only be used in the same file.
Example: none.

Extern function:
Can be used in other files. If a function definition has no keyword "extern", then it is still extern by default. Before using extern function in another file, need to declare it using "extern". 
Example: none.

==
(findpassbyvalue)              
(findpassbyreference)          
Pass by value vs Pass by reference

From online:

C++ Passing by value vs. passing by reference

First of all, this article is NOT going to explain C++ references and pointers. If you are not clear on what these are then this is quite probably the wrong article for you and you really should probably go read here, here or here.

In C++ all arguments are passed to functions by value. In other words, a copy of the value is taken and that is what the function has to work with. If you want to modify the original value you must either pass a pointer or reference to the original value you wish to modify. Of course, even the pointer or reference are still passed by value. Pointers and references are just another C++ type and when they are passed around you do so by value.

Now, what about the case where we don't want to modify the value? There's no need to pass by reference or pointer, right? Wrong! Now, in the case of fundemental types it probably doesn't make a huge deal of difference since these are unlikely to be any more complicated that a pointer or reference type; howver, in the case of fully blown class objects, such as string, vector, map, set or any other (including your own class objects) it can make a huge difference. You see, passing by value can be very expensive both in terms of memory usage and performance (time / space complexity)

Classes have copy constructors, which are defined to facilitate the correct copying semantics for a class. Now in C++ there are two types of copy, shallow and deep. A shallow copy is where all the values of the class are copied but pointers are not followed. A deep copy is where pointers are followed and all the objects that they point to are also copied, thus creating a copy of all the "deep" objects, too. Any class that contains references to other objects should (unless there is a very good reason not to) provide both an assignment and copy constructor such that the class is always copied deeply.

Consider the std::vector class. This class contains an internal buffer of memory that is managed by the vector. In reality, we can assume that the vector contains a pointer that points to memory allocated on the heap. The vector class implements a copy constructor that will perform a deep copy on a vector object if a copy is taken. This is the only sane thing to do, otherwise we have two objects referencing the same memory and then we have issues of ownership. In other words, which of the vectors is now responsible for managing and freeing that memory and what happens to the other vector if that memory is released? Of course, it'll be left with a dangling pointer that is referencing invalid memory! Bad mojo for all!!!

Now, imagine we have a vector class that contains thousands of items. If we pass this object to a function by value the whole of the internal buffer will be copied. Not only is this really very inefficient in terms of the time it will take to allocate the memory and copy the values from the original vector to the copy it also increases memory usage greatly and, as a side effect, the risk of memory fragmentation. Imagine if this same vector is copied around again and again (maybe in a loop); it should be pretty clear just how inefficient this is.

The solution is to pass things around by const reference (or const pointer in C). The cost of passing things around by const reference is trivial and about as expensive as passing around an int value. Not only is it so much more efficient to pass objects in this way, but the semantics of your function become way clearer. Just looking at the function prototype tells us that the value being passed is never meant to be modified by this function. You are helping to enforce your objects interface contract.

Let's see a trivial example. 
#include <vector>
#include <chrono>
#include <iostream>

void foo(std::vector<int> byValue)
{
// do nothing
}

void bar(std::vector<int> const & byRef)
{
// do nothing
}

int main()
{
   auto && v = std::vector<int>(0x7FFFFFF);

   auto && x1 = std::chrono::steady_clock::now();
   foo(v);
   auto && x2 = std::chrono::steady_clock::now();
   bar(v);
   auto && x3 = std::chrono::steady_clock::now();

   auto && d1 = std::chrono::duration_cast<std::chrono::nanoseconds>(x2 - x1);
   auto && d2 = std::chrono::duration_cast<std::chrono::nanoseconds>(x3 - x2);

   std::cout
         << "Time to call foo: " << d1.count() << std::endl
         << "Time to call bar: " << d2.count() << std::endl;
}

Select all
 
Open in new window


When running this on my Windows 7 laptop, build with Visual Studio 2013 and executed in as a Release build the call by value takes approximately 1 second whilst the call by reference takes less than a nanosecond. That makes the pass by value a billion times slower! Of course, this is a contrived example and on different machines with different compilers YMMV, but hopefully it serves to demonstrate just how slow passing by value can, when compared to passing by reference!

In the case of passing by value the cost in terms of both time and space complexity is O(N), where N is the number of bytes to be copied. Passing by reference will cost O(1), which is a significant improvement. Okay, the pedants amongst you may wish to argue that even for a reference it's O(N), because a reference is composed of bytes. True, but the big (massive) difference that the size of a reference is always constant and will be in the order of a few bytes (4 on a 32 bit machine, 8 on a 64 bit machine) and not hundreds, thousands, millions or even billion in the case of non-fundamental objects.

Note: that some compilers may optimize out the calls to the functions foo and bar due to the fact they don't do anything. This is most likely to happen if you have aggressive optimisation enabled on your compiler. You can either disable this or add some code to these functions to make use of the passed references. Whilst disabling optimisation may skew the results in an absolute sense, the relative comparison should still hold up because what we're truly interested in here is the asymtoptic variance (Big O) rather than wall clock time!


==
(findpointerc)
Pointer in C

int *p = &i;
// Pointer p equals the address of i
// Then *p is i, *p = 100 is equivalent to i = 100

If a pointer = 0, it means it does not point to anything.

Print the address of a variable:
printf("%p\n",(void*)&a);

Pointers must be initialized.

int a[20], *p;
p = &a[0]; // p points to the address of a[0]
p += 2; // p points to the address of a[2]

a = &a[1];
b = &a[3];
Then (b - a) equals 2

int* p[3]: p is an array of pointers (can be easily understood)
int (*p)[3]: p is a pointer which points to an array (because the above is array of pointers, so here it is a pointer which...)

Pointer to functions can be rememebered in the save way as above:
int* f(int x); //f is a function which returns pointer
int (*f)(int x); //f is a pointer which points to a function

int func(int x);
int (*f)(int x);
f = func; <- func has no (), no parameters. Function name is the address of the entrance of function.
(*f) is equivalent as func, eg (*f)(x)

Array name as function parameter (in a similar way as Java):

// Tao remembers online says this way passes by copying the array and this way should be avoided, needs to confirm
void sort(int x[], int n) {
	...
}

void main() {
	int a[10];
	...
	sort(a, 10);
}

A pointer to a string is the address of the first character in the string.

==
(findargsc)
(findcommandlineargumentc)
Convert command line argument to string in C

#include <iostream>
#include <string>
#include <vector>

int main(int argc, char *argv[]) // Don't forget first integral argument 'argc', which is count of arguments plus the current exec file.
{
  std::string current_exec_name = argv[0]; // Name of the current exec program
  std::string first_arge;
  std::vector<std::string> all_args;

  if (argc > 1) {
    first_arge = argv[1];
    all_args.assign(argv + 1, argv + argc);
  }
}


==
(findstructc)
Struct in C

From online:
Should struct definitions go in .h or .c file?
Private structures for that file should go in the .c file, 
with a declaration in the .h file if they are used by any functions in the .h .
Public structures should go in the .h file.

struct date {
    int year;
    int month;
    int day;
}; // Don't forget the ;

struct date d;

The above two statements can be written together:

struct date {
    int year;
    int month;
    int day;
} d;

Initialize struct:

struct date {
    int year;
    int month;
    int day;
} d = {1977, 11, 14};

int y = date.year;

struct array (every element is a struct type):

struct date d[3];
struct date d[3] = {{1977, 11, 14}, {1980, 3, 5};
struct date d[] = {{1977, 11, 14}, {1980, 3, 5}; //Can omit the length

A pointer to a struct points to the initial address of the struct.

struct date d;
struct date *p;
p = &d;
(*p).year
p->year

Linked list node (note the next pointer):

struct student {
    char name[8];
    float score;
    struct student *next;
}

==
(findunionc)
Union in C

union utag {
    int i;
    float f;
    char c;
};

The definition of union is the same as struct.
The reference to memebers of union (including pointers) is also the same as struct.

The difference between struct and union:
The members in a struct have their own memory units. The size of a struct is the sum of the size of its members.
The members in a union share the same memory unit. The size of a union is the size of its largest member. Tao's understanding is that a union can be different types (any of its member type) at different times. Just like 精神分裂症.

Can only initialize the first member of a union, can not initialize all members:

Correct:

union utag {
    int i;
    float f;
    char c;
} u1 = {100};

Wrong:

union utag u2 = {100, 31.6, 'a'};

==
(findtypedefc)
typedef in C

typedef defines new type which is equivalent as original types, like an alias:

typedef int INTEGER;
INTEGER x, y;

typedef char *POINTER;
POINTER p;
//Equivalent as: char *p;

typedef struct {
    int year;
    int month;
    int day;
} DATE;

DATE birthday;

//Equivalent as:

struct {
    int year;
    int month;
    int day;
} birthday;

typedef char STRING[50];
STRING s1, s2;
//Equivalent to: char s1[50], s2[50];

Good:
Steps to use typedef:
1. Write down the ordinary definition of a variale, like: char str[50];
2. Replace the variable name with new type name, like replace "str" with "STRING" -> char STRING[50];
3. Add "typedef" in front, like: typedef char STRING[50];
4. Then can use the new type name to define variables, like: STRING s1, s2;


==
(findmallocc)
(findmemoryc)
Dynamic memory allocation and free in C

#include <stdlib.h>

int *p;
p = (int *) malloc(sizeof(int)); //Allocates a memory of size int type, p points to this memory

struct date {
    int year;
    int month;
    int day;
} *q;

q = (struct date *) malloc(sizeof(struct date));

free(p); //Free the memory pointed by p

==
(findconstantc)
Constant in C
宏 in C

#define PI 3.14
int a = PI;

==
(findfilec)
(findreadfromfilec)
(findwritetofilec)
File in C
Read from file in C
Write to file in C

All the following should include:
#include "sdio.h"

//Open a file:
FILE *fp;
fp = fopen("file1", "r");

//Close a file:
fclose(fp); //Now fp no longer points to this file

//Close all files:
fcloseall();

//Get a character from file:
ch = fgetc(fp);

//Returns whether fp points to the end of file:
feof(fp);

//Write a character to file at location pointed by fp:
fputc("a", fp);
fputc(c, stdout)//Outputs character c to terminal (screen), no "" around c.

//Read a string:
fgets()

//Write a string:
fputs()

//Read and print to file
fscanf(), fprintf()

//Read binary files:
fread(), fwrite()

//Foce the pointer fp to point to the beginning of file:
rewind(fp);

//Set the pointer position
fseek(file-pinter, offset, start-point)

*** C all recorded ***

====
(findcppbegin)
C++ begins

Common suffix for C++ programs: 
.cc .cpp .C .cxx .cp <- tao: .cpp is the most common I have seen online

Compile:
g++ -o file_name file_name.cc

Using C++ 11, in my Thinkpad (recommended to always compile in this way in my Thinkpad):
g++ -std=c++0x -o file_name file_name.cc

When writing leetcode, I can still compile using -std=c++11 in my Thinkpad.

Using C++ 11, in Mac:
g++ -std=c++11 -o file_name file_name.cc

Simpler way to compile and run:
g++ foo.c
./a.out

==
Sample C++ program:

#include<iostream>
using namespace std;
//using std::cout; <- can also use this

int main() {
    double a = 2.6;
    cout << a << endl;
    return 0;
}

Note that the main() function should be outside any class, which is opposite to Java.

==
(finddatatype)                 
Data types

The arithmetic types are divided into two categories: integral types (which include character and boolean types, tao: should also include int) and floating-point types.

Tao: integral types means: int, character, boolean types. The concept of integral types will be used later.

--
(findbool)
bool:

bool test = false; // The words true and false are literals of type bool

bool b = 42;
int i = b; // i has value 1

When we assign one non-bool types to a bool, the result is false if the value is 0, and true otherwise.

When we use a bool in an arithmetic expression, its value always converts to either 0 or 1.

The word nullptr is a pointer literal.

It is usually a bad idea to use the boolean literals true and false as operands in a comparison. For example:
if (val == true) { /* ...   */ }

Better way:
if (val)  { /*  ...  */ }

--
(findcast)
(findconvertdatatype)
Cast
Convert data types

//string -> int
#include <string>  
string str1 = "45";
int myint1 = stoi(str1); // myint1 = 45

//string -> double
string stest = "0.21";
double dtest = stod(stest);

//double -> string
string pi = std::to_string(3.1415926); // pi = "3.1415926" 

//int -> string
int a = std::to_string(28); // a = "28"

//int -> double
int a = 2;
double b = (double) a;

//double -> int
double a = 3.0;
double b = (int) a;

--
cast:

The above "(int) a" is the old-style C++ casts. New styles are followings.

Although necessary at times, casts are inherently dangerous constructs.

Named Casts

A named cast has the following form:
cast-name<type>(expression);

where type is the target type of the conversion, and expression is the value to be cast. The cast-name may be one of static_cast, dynamic_cast, const_cast, and reinterpret_cast.

Old-style casts are less visible than are named casts. Because they are easily overlooked, it is more difficult to track down a rogue(流氓) cast.

==
(findtypedef)
typedef

typedef double wages; // wages is a synonym for double

==
(findinclude)
Need to include

INT_MIN, INT_MAX: need to #include <climits>
max(1, 2): need to #include <algorithm>  

==
(findheader)
Headers

Need to include when use:

#include <iostream>
#include <string>
#include <vector>
#include <iterator>
cctype //islower(c), tolower(c)
container header
container adaptor
iterator
algorithm
tuple
bind

using namespace std;

--
#include <iostream>
#include "Sales_item.h"

Headers from the standard library are enclosed in <>
Headers that are not part of the library are enclosed in ""

The standard library headers typically have no suffix.
Header files that we write usually have a suffix of .h

Headers (usually) contain entities (such as class definitions and const variables) that can be defined only once in any given file.

Code inside headers ordinarily should not use "using declarations". The reason is that the contents of a header are copied into the including program’s text. If a header has a using declaration, then every program that includes that header gets that same using declaration. As a result, a program that didn’t intend to use the specified library name might encounter unexpected name conflicts.

In addition to facilities defined specifically for C++, the C++ library incorporates the C library. Headers in C have names of the form name .h. The C++ versions of these headers are named c name—they remove the .h suffix and precede the name with the letter c. The c indicates that the header is part of the C library. Hence, cctype has the same contents as ctype.h, but in a form that is appropriate for C++ programs. In particular, the names defined in the cname headers are defined inside the std namespace, whereas those defined in the .h versions are not. Ordinarily, C++ programs should use the cname versions of headers and not the name .h versions.

--
preprocessor

The most common technique for making it safe to include a header multiple times relies on the preprocessor. The preprocessor is a program that runs before the compiler and changes the source text of our programs.

Our programs already rely on one preprocessor facility, #include. When the preprocessor sees a #include, it replaces the #include with the contents of the specified header.

C++ programs also use the preprocessor to define header guards. Header guards rely on preprocessor variables. Preprocessor variables have one of two possible states: defined or not defined. The #define directive takes a name and defines that name as a preprocessor variable. There are two other directives that test whether a given preprocessor variable has or has not been defined: #ifdef is true if the variable has been defined, and #ifndef is true if the variable has not been defined. 

If the test is true, then everything following the #ifdef or #ifndef is processed up to the matching #endif.

tao: the following is the .h file which defines Sales_data. The benefit of the preprocessor in this .h file is that this .h file can be included in multiple files, and there will be no conflict, because SALES_DATA_H will be defined in the first file that includes this .h file, other files will have ifndef = false and will not execute this .h file.

#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
#endif

Preprocessor variables, including names of header guards, must be unique throughout the program. To avoid name clashes with other entities in our programs, preprocessor variables usually are written in all uppercase.

Headers should have guards, even if they aren’t (yet) included by another header. Header guards are trivial to write, and by habitually defining them you don’t need to decide whether they are needed.

--
How to include header in another folder (from online):

Just inlcude the path as well:

#include "../../Header/class1.h"

--
Whether to compile header files (from online):

Do I need to compile the header files (.h) in a C program?
No, there's no reason to "compile" these header files independently. 
Header files are intended to be included into implementation files, 
not fed to the compiler as independent translation units.

--
How to compile the files in the following example:

Suppose the files are organized in the following folders:

code
  - main.cpp

utils  
  - Time.h
  - Time.cpp 

Then in folder code, type the followings (list all the other cpp files after main.cpp.):
g++ main.cpp ../utils/Time.cpp 

This makes a compiled file in the same folder as main.cpp: a.out

In file Time.cpp, in the implementation of the Time member functions, it can use the other Time members directly without adding class name, note that the Time class is defined in another file Time.h

--
Separate Header and Implementation Files (from online, tao changed the path in the include for illustration)

How to compile the following files? See above.

In this section, we demonstrate how to make class reusable by separating it into another files.

Header File
Class declarations are stored in a separate file. A file that contains a class declaration is called header file. The name of the class is usually the same as the name of the class, with a .h extension. For example, the Time class would be declared in the file Time .h.

#ifndef TIME_H
#define TIME_H

class Time
{
     private :
          int hour;
          int minute;
          int second;
     public :
          //with default value
          Time(const int h = 0, const int m  = 0, const int s = 0);
          //    setter function
          void setTime(const int h, const int m, const int s);
          // Print a description of object in " hh:mm:ss"
          void print() const;
          //compare two time object
          bool equals(const Time&);
};
 
#endif
 
Implementation File

The member function definitions for a class are stored in a separate .cpp file, which is called the class implementation file. The file usually has the same name as the class, with the .cpp extension. For example the Time class member functions would be defined in the file Time.cpp.

#include <iostream>
#include <iomanip>
#include "Time.h" <- tao: since Time.cpp is in the same folder as Time.h, so no need to include path
using namespace std;
 
Time :: Time(const int h, const int m, const int s) 
  : hour(h), minute (m), second(s)
{}
 
void Time :: setTime(const int h, const int m, const int s) 
{
     hour = h;
     minute = m;
     second = s;     
}       
 
void Time :: print() const
{
     cout << setw(2) << setfill('0') << hour << ":"
    << setw(2) << setfill('0') << minute << ":"
    << setw(2) << setfill('0') << second << "\n";   
 
}
 
bool Time :: equals(const Time &otherTime)
{
     if(hour == otherTime.hour 
          && minute == otherTime.minute 
          && second == otherTime.second)
          return true;
     else
          return false;
}
 
Client Code

client code, is the one that includes the main function. This file should be stored by the name main.cpp
 
#include <iostream>
using namespace std;
#include "../utils/Time.h" <- tao: since main.cpp is in a different folder from Time.h, so need to include path

int main()
{
     Time t1(10, 50, 59);
     t1.print();   // 10:50:59
     Time t2;
     t2.print(); // 06:39:09
     t2.setTime(6, 39, 9);
     t2.print();  // 06:39:09
   
     if(t1.equals(t2))
          cout << "Two objects are equal\n";
     else
          cout << "Two objects are not equal\n";    
  
     return 0;
}
The advanages of storing class definition in separate file are

1. The class is reusable

2. The clients of the class know what member functions the class provides, how to call them and what return types to expect

3. The clients do not know how the class's member functions are implemented.

--
Separate Compilation

As our programs get more complicated, we’ll want to store the various parts of the program in separate files. For example, we might store the functions we wrote in one file and store code that uses these functions in other source files. To allow programs to be written in logical parts, C++ supports what is commonly known as separate compilation. Separate compilation lets us split our programs into several files, each of which can be compiled independently.

As an example, assume that the definition of our fact function is in a file named fact.cc and its declaration is in a header file named Chapter6.h. Our fact.cc file, like any file that uses these functions, will include the Chapter6.h header. We’ll store a main function that calls fact in a second file named factMain.cc. We might compile these files as follows:

g++ factMain.cc fact.cc -o main // generates main

If we have changed only one of our source files, we’d like to recompile only the file that actually changed. Most compilers provide a way to separately compile each file. This process usually yields a file with the .o file extension, indicating that the file contains object code.
 
The compiler lets us link object files together to form an executable. On the system we use, we would separately compile our program as follows:
 
g++ -c factMain.cc     // generates factMain.o
g++ -c fact.cc         // generates fact.o
g++ factMain.o fact.o -o main // generates main

==
(findcout)
(findcin)
cout, cin 

remember: t looks like <, n can be put into >

The left-hand operand of << must be an ostream object. The operator writes the given value on the given ostream. The result of the output operator is its left-hand operand (the ostream). The following example uses << twice, because << returns ostream.

Writing endl has the effect of ending the current line and flushing the buffer asociated with that device. Flusing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.

Buffer: a region of storage used to hold data. IO facilities often store input (or output) in a buffer and read or write the buffer independently from actions in the program. Output buffers can be explicitly flushed to force the buffer to be written. By default, reading cin flushes cout; cout is also flushed when the program ends normally.

//cout:
#include<iostream>
using namespace std;
//using std::cout; <- can also use this

int main() {
    double a = 2.6;
    cout << a << endl;
    return 0;
}

//cin:
#include<iostream>
using namespace std;

int main() {
    int a = 0;
    cin >> a; //tao: read input into a
    return 0;
}

while(cin >> value) sum += value;

End of file: ctrl+d

// s is a string
os << s //Writes s onto output stream os. Reurns os.
is >> s //Reads whitespace-separated string from is into s. Returns is. 

getline(is, s) //Reads a line of input from is into s. Returns is.

==
(findreadfromfile)
(findwritetofile)
Read from file and output to file

The following function reads all contents in the input file, and write them into output file. Note that if in my Thinkpad, it needs to be compiled in C++ 11.

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
using namespace std;

// g++ -std=c++0x -o convert convert.cc
void process_one_file(string input_file_name, string output_file) { 
    ifstream input_file(input_file_name);
    ofstream output_file(output_file_name);

    string line;

    while(getline(input_file, line)) {
        output_file << line << endl;
    }

    output_file.close();
    input_file.close();
}

==
(findmath)
Math operators:

power:

#include <cmath>
pow(3.4, 4.4) // Returns: 3.4^4.4 = 218.025

--
std::pow in the <cmath> header has these overloads:

pow(float, float);
pow(float, int);
pow(double, double); // taken over from C
pow(double, int);
pow(long double, long double);
pow(long double, int);

Now you can't just do
pow(2, N)
with N being an int, because it doesn't know which of float, double or long double version it should take, and you would get an ambiguity error. All three would need a conversion from int to floating point, and all three are equally costly!

Therefor, be sure to have the first argument typed so it matches one of those three perfectly. I usually use double

pow(2.0, N)
Some lawyer crap from me again. I've often fallen in this pitfall myself, so i'm going to warn you about it.


==
(finddeclaration)
(finddefinition)
declaration vs definition:

A declaration makes a name known to the program. We must declare the type of a variable before we can use that variable.  A file that wants to use a name defined elsewhere includes a declaration for that name. 

A definition creates the associated entity.

A variable declaration specifies the type and name of a varaible. A variable definition is a declaration. In addition to specifying the name and type, a definition also allocates storage and may provide the variable with an initial value.

To obtain a declaration that is not also a definition, we add the extern keyword and may not provide an explicit initializer:

extern int i; //delcares but does not define i
int j; //declares and defines j

Any declaration that includes an explicit initializer is a definition. 

Variables must be defined exactly once but can be declared many times.

To use a variable in more than one file requires declarations. To use the same variable in multiple files, we must define that variable in one—and only one—file. Other files that use that variable must declare—but not define—that variable.

==
(findintialization)
Intialization:

//The followings are all equivalent:
int a = 0;
int a = {0};
int a{0};
int a(0);

If we do not initialize a string, then it is an empty string. (Seems different from Java).

We recommend initializing every object of built-in type.

==
(findstaticallytyped)
Type checking (statically typed launage):

Some languages, such as Smalltalk and Python, check types at run time. In contrast, C++ is a statically typed language; type checking is done at compile time.

In C++, if we try to do things that the type does not support, the compiler generates an error message and does not produce an executable file.

==
(findreference)
Reference

int &refVal = ival; // refVal refers to (is another name for) ival

A reference defines an alternative name for an object:
A reference must be initialized (Avado, same as const types)
There is no way to rebind a reference to refer to a different object.
Because references are not objects, they don’t have addresses. Hence, we may not define a pointer to a reference.

==
(findpointer)
Pointer

A pointer holds the address of another object. 
A pointer is an object in its own right. 
A pointer can be assigned and copied.
A pointer can point to several different objects over its lifetime.
A pointer do NOT need to be initialized at the time it is defined.

We can use the address operator & to get the address of an object.
We can use the dereference operator * to access the object being pointed.

   declaration  operator
&  reference    obtain address
*  pointer      yield object

int ival = 42;
int *p = &ival; // p holds the address of ival; p is a pointer to ival
int v = *p; //v = 42, dereference operator *
*p = 0; //Assign new value to ival

//Null pointer. The following three lines are equivalent, to assign null pointer to p.
int *p = 0;
int *p = nullptr; 
int *p = NULL;//Must #include<cstdlib>, modern programs should avoid using NULL <- tao: practice confirms that cstdlib is also included in std namespace, so if we already wrote "using namespace std;", then we do not need to #include<cstdlib>

Recommended: If there is no object to bind to a pointer, then initialize the pointer to nullptr or 0.

There is an automatic conversion from arithmetic or pointer
types to bool. If the pointer or arithmetic value is zero, the conversion yields false; any other value yields true

if(p) {...} is equivalent to if(p != NULL) {...}. If p == 0, then p = false. Any nonzero pointer evaluates as true. This is consistent with converting int to bool.

if(!p) is equivalent to if(p == NULL) <- Remember: if p buxin, ie p == NULL
if(p) is equivalent to if(p != NULL) <- Rememebr: if p xin, ie p != NULL


Two pointers are equal (using ==) if they hold the same address.

double obj = 3.14;
void *pv = &obj; // The type void* is a special pointer type that can hold the address of any object.

Avadoles:
Variables defined inside a function ordinarily are not stored at a fixed address.
Tao: this is also the reason why my program did something wrong when I tried to return a pointer to a variable defined inside a function (see more below).

--
//Principle: the symbol that is closest to the variable name comes to the first in the type name

int* parr[42]; // parr is an array of 42 pointers to int. From this, tao sees why tao likes to write "int*" rather than "int *"
int (*parr)[10] = &arr; // parr is a pointer, which points to an array of ten ints

int& refs[10] = ... // error: no arrays of references
int (&arrRef)[10] = arr; // arrRef is a reference, which refers to an array of ten ints

int* (&arry)[10] = ptrs; // arry is a reference to an array of ten pointers

As with vector, arrays hold objects. Thus, there are no arrays of references. Because an array is an object, we can define both pointers and references to arrays.

When we use an array, the compiler ordinarily converts the array to a pointer.

--
Pointer to vector: vector<int> *t; t->push_back(10);
Vector of pointers: vector<int*> movies = ...

--
Reference to a vector: vector<int>& = ...
There is no vector of references. 

--
Return pointer from a function (from online):

It is not good idea to return the address of a local variable to outside of the function, so you would have to define the local variable as static variable. Tao: otherwise the caller function would get a pointer containing wrong address value (from practice).

Example:

#include <iostream>
#include <ctime>
 
using namespace std;
 
// function to generate and retrun random numbers.
int * getRandom( ) {
   static int  r[10];
 
   // set the seed
   srand( (unsigned)time( NULL ) );
   
   for (int i = 0; i < 10; ++i) {
      r[i] = rand();
      cout << r[i] << endl;
   }
 
   return r;
}
 
// main function to call above defined function.
int main () {
   // a pointer to an int.
   int *p;
 
   p = getRandom();
   for ( int i = 0; i < 10; i++ ) {
      cout << "*(p + " << i << ") : ";
      cout << *(p + i) << endl;
   }
 
   return 0;
}

==
(findconst)
(findconstant)
const

We can make a variable unchangeable by defining the variable’s type as const.
const object MUST be initilized after being created.

const int bufSize = 512;
extern const int bufSize = 512; // A const that is accessible to other files

//Reference to const:
const int ci = 1024;
const int &r1 = ci; // Both reference and underlying object are const. See following summary for remember.

//const refrence: no such thing

//Pointer to const:
const double pi = 3.14;
const double *cptr = &pi; // Store the address of a const object only in a pointer to const. See following summary for remember.

//const pointer:
int *const curErr = &errNumb; // curErr will always point to errNumb. See following summary for remember.

Summary from the above:
1. int is always on the left of *, like int *
2. const can be on the left or right of int *, like const int *, int * const
3. Principle: the symbol that is closest to the variable name is comes to the first in the type name: 
   const double *cptr = &pi: cptr is a pointer to const
   int *const curErr = &errNumb: curErr is a const pointer

We use the term top-level const to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a low-level const.

The distinction between top-level and low-level matters when we copy an object.
When we copy an object, top-level consts are ignored. Example:

const int ci = i, &cr = ci;
auto b = ci; // b is an int (top-level const in ci is dropped)

On the other hand, low-level const is never ignored. When we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects. In general, we can convert a nonconst to const but not the other way round.

--
(findconstantexpression)
Constant expression

A constant expression is an expression whose value cannot change and that can be evaluated at compile time. A literal is a constant expression. A const object that is initialized from a constant expression is also a constant expression. Examples:

const int max_files = 20; // max_files is a constant expression
const int limit = max_files + 1; // limit is a constant expression
int staff_size = 27; // staff_size is not a constant expression
const int sz = get_size(); // sz is not a constant expression

Even though sz is a const, the value of its initializer is not known until run time. Hence, sz is not a constant expression.

==
(findfor)
(findrangefor)

Range for in C++ 2011:

vector<int> v = {1, 3, 5, 7, 9};

for (auto x : v)
    cout << x << ' ';

==
(findstruct)
Struct

struct Sales_data {
    string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
}; //Tao: note the ;

Sales_data accum;
Sales_data* salesptr;

==
(findclass)
Class

Classes ordinarily are not defined inside functions.

In order to ensure that the class definition is the same in each file, classes are usually defined in header files.

Tao: note public and private has no identitation (from online examples, and sublime also removes these identitaction automatically).
Tao: note the ; at the end of a class.

class Sales_data {
public:
    Sales_data() = default; // default constructor
    Sales_data(string &s, double p) : bookNo(s), revenue(p) {}  

private:
    string bookNo;
    double revenue = 0.0;
    
    double price() {
        ...
    }
};

If our class does not explicitly define any constructors, the compiler will implicitly define the default constructor for us (know as the synthesized default constructor).

Sales_data item;
Screen myScreen(5, 3);

--
(findnew)
The new operator

From online:
Using the new operator returns a pointer to the object:
Node *n = new Node(); 

==
(findsleep)
Sleep

Compile the following file:

g++ -o sleep sleep.cc -std=c++0x -D_GLIBCXX_USE_NANOSLEEP

--- File sleep.cc starts ---
#include <iostream>
#include <chrono>
#include <thread>
using namespace std;

int main() {
    std::this_thread::sleep_for(std::chrono::milliseconds(5000));
    cout << "Hello world" << endl;
}
--- File sleep.cc ends ---

==
(findescape)
Escape sequence:

newline:       \n
double quote:  \"
single quote:  \'
backslash:     \\
question mark: \?

Examples: 
cout << '\n'; //prints a newline
cout << "Hi \n"

==
(findstring)
string

#include <string>
using std::string;

string s1;
string s2 = s1; //copy initialization, s2 is a copy of s1
string s3 = "hiya"; //direct initialization

When we initialize a variable using =, we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created. Otherwise, when we omit the =, we use direct initialization.

string literal: the compiler appends a null character ('\0') to every string literal. Thus, the actual size of a string literal is one more than its apparent size.

s.empty() //Returns bool
s.size() //Returns number, which is a string::size_type, see below
s[3] //Returns a reference to the char. The subscript operator (the [ ] operator) takes a string::size_type.
s[0] = 'a'; //Charaters in a string can be changed in C++! Different from Java.
s1 + s2 //Returns string
s1 += s2 //Equivalent to s1 = s1 + s2
s1 = s2 //Replaces characters in s1 with a copy of s2.
s1 == s2 //s1 and s2 are equal if they contain the same characters. Equality is case-sensitive.
s1 != s2
s1 <= s2 //Comparisons are case-sensitive and use dictionary ordering.

From online: create a string with five dot characters:
string foo = string(5, '.') // foo = "....."

string::size_type:
The string class—and most other library types—defines several companion types. These companion types make it possible to use the library types in a machine-independent manner. The type size_type is one of these companion types. Although we don’t know the precise type of string::size_type, we do know that it is an unsigned type big enough to hold the size of any string. Because size returns an unsigned type, it is essential to remember that expressions that mix signed and unsigned data can have surprising results. You can avoid problems due to conversion between unsigned and int by not using ints in expressions that use size().

The string library lets us convert both character literals and character string literals to strings. Because we can use these literals where a string is expected.

When we mix strings and string or character literals, at least one operand to each
+ operator must be of string type: 
string s4 = s1 + ", "; // ok: adding a string and a literal
string s5 = "hello" + ", "; // error: no string operand (tao: both are string literals, which are not string type variables, see below)

For historical reasons, and for compatibility with C, string literals are not standard library strings. It is important to remember that these types differ when you use string literals and library strings.

//The followings should include the "cctype" header:
//c is a character
isalnum(c) //true if c is a letter or a digit.
isalpha(c) //true if c is a letter
isdigit(c) //true if c is a digit
islower(c) //true if c is a lowercase letter
isupper(c) //true if c is an uppercase letter
tolower(c) //If c is an upercase letter, returns its lowercase equivalent, otherwise returns c unchanged
toupper(c) //If c is a lowercase letter, returns its upercase equivalent, otherwise returns c unchanged
isspace(c) //true if c is whitespace (ie, a space, tab, vertical tab, return, newline, or formfeed)

string s2 = s.erase (pos, len); //Erases the portion of the string value that begins at the character position pos and spans len characters (or until the end of the string, from online)

s2.append("helo"); // equivalent as below. The parameter of append() can only be string, it can not be char.
s.insert(s.size(), "helo"); 

--
In some computers (like my Thinkpad), some functions (like ifstream) needs the input to string to be defined as type: const char*, for example:

const char* filename = "helo";
ifstream input_file(filename);

However, I can use string instead of const char* if compile using std C++ 11.

In some computers (like the Mac), it can be written as:

string filename = "helo";
ifstream input_file(filename);

--
(findsubstring)
Substring (get and find)

Get a substring:

string s2 = s.substr(pos, n) // return a string containing n characters fro s starting at pos. pos defaults to 0. n defaults to a value that causes the library to copy all the characters in s starting from pos.

Find a substring in a string:

Use std::string::find as follows:

if (s1.find(s2) != std::string::npos) {
    std::cout << "found!" << '\n';
}
Note: "found!" will be printed if s2 is a substring of s1, both s1 and s2 are of type std::string. 

string test = "123";
string res = test.substr(1, 0);
res.size(); //returns: 0

--
(findsplit)
split a string

** Split by a char **

Problem: Split a string by a delim, and return a vector of strings containing no delim

Use stringstream getline
Signature istream& getline (istream&& is, string& str, char delim)

#include <sstream>

//tao: notice the function parameter uses reference to a string
vector<string> split(const string &s, char delim) {
    stringstream ss(s);
    string item;
    vector<string> tokens;
    while (getline(ss, item, delim)) {
        tokens.push_back(item);
    }
    return tokens;
}

Tao's example of using the above function split:

string test_str = "Helo,how,are,you";
vector<string> strs = split(test_str, ',');
for(int i = 0; i < strs.size(); i++) cout << strs[i] << " ";
cout << endl;

Output:
Helo how are you

** Split by a string **

You can use the string::find() function to find the position of your string delimiter, then use string::substr() to get a token.

Example:

string s = "scott>=tiger";
string delimiter = ">=";
string token = s.substr(0, s.find(delimiter)); // token is "scott"

The substr(size_t pos = 0, size_t n = npos) function returns a substring of the object, starting at position pos and of length npos.

(findfind)
The find(const string& str, size_t pos = 0) function returns the position of the first occurrence of str in the string, or npos if the string is not found.
Tao's example:
string s = "helo";
s.find("lo")// Returns: 2
while((pos = s.find(delimiter)) != string::npos) {...}

If you have multiple delimiters, after you have extracted one token, you can remove it (delimiter included) to proceed with subsequent extractions (if you want to preserve the original string, just use  s = s.substr(pos + delimiter.length());):

s.erase(0, s.find(delimiter) + delimiter.length());
This way you can easily loop to get each token.

Complete Example
string s = "scott>=tiger>=mushroom";
string delimiter = ">=";

size_t pos = 0;
string token;
while ((pos = s.find(delimiter)) != string::npos) {
    token = s.substr(0, pos);
    cout << token << endl;
    s.erase(0, pos + delimiter.length());
}
cout << s << endl;
Output:

scott
tiger
mushroom

--
C-style charater strings are null terminated char arrays. 

C-style charater string functions: 
strlen, strcmp, strcat, strcpy.

For most applications, in addition to being safer, it is also more efficient to use library strings rather than C-style strings.

tao: convert a char array to string (from online: Note that this only works for constant NULL-terminated C-strings.)
char a1[2] = {'a', 'b', '\0'};
string str1(a1);

from online: convert a string to char array:
string temp = "cat";
char * tab2 = new char [temp.length()+1];
strcpy (tab2, temp.c_str());

==
(findtrim)
trim

There is no standard way of trimming a string, but it’s possible to implement using the methods in the string class:

Left trim: Use find_first_not_of() to find the characters to erase
Right trim: Use find_first_of() to find the characters to erase
Trim: Do a right trim followed by a left trim (or vice-versa)
Use erase() to actually erase the characters.

Here is my implementation. It defaults to trimming whitespace characters but you can specify any string of characters as the second argument.

string& ltrim(string& str, const string& chars = "\t\n\v\f\r ") {
    str.erase(0, str.find_first_not_of(chars));
    return str;
}
 
string& rtrim(string& str, const string& chars = "\t\n\v\f\r ") {
    str.erase(str.find_last_not_of(chars) + 1);
    return str;
}

string& trim(string& str, const string& chars = "\t\n\v\f\r ") {
    return ltrim(rtrim(str, chars), chars);
}

string extract_column_names(string line) {
    return line + "\n";
}

Example:

string str = " test ";
trim(str);

==
(findargs)                    
(findcommandlineargument)      
Command line argument 

Note that if in my Thinkpad, the following should be compiled in C++ 11.

#include <string>
using namespace std;

int main(int argc, char** argv) {
    int nfiles = stoi(argv[1]); // If run as: ./main 5, then argv[1] = "5"
    cout << "nfiles = " << nfiles << endl;
    return 0;
}

Run the program:
./main 5

Then the output is:
nfiles = 5

==
(findvector)
vector

#include <vector>
using std::vector;

--
vector<int> v1; //v1 is empty
vector<int> v2 = v1; //v2 is a copy of the elements in v1 (tao: copies the values of v1 to v2)
vector<int> v1(10); //v1 has n copies of a value-initialized object. 10 elements, each initialized to 0.
vector<string> v1(10); //10 elements, each an empty string
vector<int> v1(n, val); //v1 has n elements with value val
vector<int> v1 = {1, 2, 3};//C++11, does not work in the old C++ version
vector<int> v1{1,2,3};//Does not work

Searched online, in the old C++ version, to initialize a vector, we can only use push_back(). 

vector<vector<double> > v1 //correct, note the space between > >
vector<vector<double>> v1 //wrong <- tao: in the Mac (or C++11?), this is also correct.

vector< vector<int> > a(n,vector<int>(n)); //a is an 2D (n*n) vector, from HackerRank

v.push_back(3) //Adds an element with value 3 to end of v
v.empty() //Returns a bool
v.size() //Returns a number, which is of type vector<int>::size_type
v[5] //Returns a reference to the element
v1 = v2 //Replaces the elements in v1 with a copy of the elements in v2
v1 == v2 //Equal if each element in v1 is equal to the corresponding element in v2. 
v1 != v2
v1 <= v2 //Have their normal meanings using dictionary ordering.
vec.clear() //Removes all elements from the vector (which are destroyed), leaving the container with a size of 0.

We can define vectors to hold objects of most any type. Because references are not objects, we cannot have a vector of references.

vector is a template, not a type. Types generated from vector must include the element type, for example, vector<int>.

--
Traverse a vector (in C++ 11):

//vec is type vector<Person*>
for(auto p : vec) {
  cout << p->height << endl;
}

--
Vector iterator:

#include <iostream>
#include <vector>
using namespace std;

int main ()
{
  vector<int> myvector;
  for (int i=1; i<=5; i++) myvector.push_back(i);

  cout << "myvector contains:";
  for (vector<int>::iterator it = myvector.begin() ; it != myvector.end(); ++it)
    cout << ' ' << *it;
  cout << '\n';

  return 0;
}
Edit & Run


--
Sort a vector:

// C++ program to sort a vector in non-decreasing 
// order. 
#include <iostream>
#include <vector>
using namespace std; 
  
int main() 
{ 
    vector<int> v{ 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 }; 
  
    sort(v.begin(), v.end()); 
  
    for (auto x : v) cout << x << " "; //Ouptut: 0 1 2 3 4 5 6 7 8 9
  
    return 0; 
} 

How to sort in descending order?
sort() takes a third parameter that is used to specify the order in which elements are to be sorted. We can pass “greater()” function to sort in descending order. This function does comparison in a way that puts greater element before.

// C++ program to sort a vector in non-increasing 
// order. 
#include <iostream>
#include <vector>
using namespace std; 
  
int main() 
{ 
    vector<int> v{ 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 }; 
  
    sort(v.begin(), v.end(), greater<int>()); 
  
    for (auto x : v) cout << x << " "; //Ouptut: 9 8 7 6 5 4 3 2 1 0
  
    return 0; 
} 

How to sort in particular order?
We can also write our own comparator function and pass it as a third parameter.

// A C++ program to sort vector using 
// our own comparator 
#include <iostream>
#include <vector>
using namespace std; 
  
// An interval has start time and end time 
struct Interval { 
    int start, end; 
}; 
  
// Tao's experience shows that the following function compareInterval should be defined outside of a class (it can be used either inside or outside a class).
// Compares two intervals according to staring times. 
bool compareInterval(Interval i1, Interval i2) 
{ 
    return (i1.start < i2.start); 
} 
  
int main() 
{ 
    vector<Interval> v { { 6, 8 }, { 1, 9 }, { 2, 4 }, { 4, 7 } }; 
  
    // sort the intervals in increasing order of 
    // start time 
    sort(v.begin(), v.end(), compareInterval); 
  
    cout << "Intervals sorted by start time : \n"; 
    for (auto x : v) 
        cout << "[" << x.start << ", " << x.end << "] "; 
  
    return 0; 
} 

Output :

Intervals sorted by start time : 
[1, 9] [2, 4] [4, 7] [6, 8] 


--
Concatenating two vectors:

vector1.insert( vector1.end(), vector2.begin(), vector2.end() );

--
Convert array to vector:

#include <iterator>
#include <vector>
using namespace std;

int x[] = { 1, 2, 3, 4, 5 };
vector<int> v(begin(x), end(x));

--
Pass a vector to a function (from online):

It depends on if you want to pass the vector as a reference or as a pointer (I am disregarding the option of passing it by value as clearly undesirable).

As a pointer:

int binarySearch(int first, int last, int search4, vector<int>* random);

vector<int> random(100);
// ...
found = binarySearch(first, last, search4, &random);

As a reference:

int binarySearch(int first, int last, int search4, vector<int>& random);

vector<int> random(100);
// ...
found = binarySearch(first, last, search4, random);

--
vector<int> v;
for(vector<int>::size_type i = 0; i < 10; ++i) {
    v[i] = i; // Wrong. Segmentation fault: 11. Because v is always an empty vector, so can not assign.
    v.push_back(i); // Correct
}

--
From geeksforgeeks:

Certain functions associated with the vector are:
Iterators

begin() – Returns an iterator pointing to the first element in the vector
end() – Returns an iterator pointing to the theoretical element that follows the last element in the vector
rbegin() – Returns a reverse iterator pointing to the last element in the vector (reverse beginning). It moves from last to first element
rend() – Returns a reverse iterator pointing to the theoretical element preceding the first element in the vector (considered as reverse end)
cbegin() – Returns a constant iterator pointing to the first element in the vector.
cend() – Returns a constant iterator pointing to the theoretical element that follows the last element in the vector.
crbegin() – Returns a constant reverse iterator pointing to the last element in the vector (reverse beginning). It moves from last to first element
crend() – Returns a constant reverse iterator pointing to the theoretical element preceding the first element in the vector (considered as reverse end)

// C++ program to illustrate the 
// iterators in vector 
#include <iostream> 
#include <vector> 
  
using namespace std; 
  
int main() 
{ 
    vector<int> g1; 
  
    for (int i = 1; i <= 5; i++) 
        g1.push_back(i); 
  
    cout << "Output of begin and end: "; 
    for (auto i = g1.begin(); i != g1.end(); ++i) 
        cout << *i << " "; 
  
    cout << "\nOutput of cbegin and cend: "; 
    for (auto i = g1.cbegin(); i != g1.cend(); ++i) 
        cout << *i << " "; 
  
    cout << "\nOutput of rbegin and rend: "; 
    for (auto ir = g1.rbegin(); ir != g1.rend(); ++ir) 
        cout << *ir << " "; 
  
    cout << "\nOutput of crbegin and crend : "; 
    for (auto ir = g1.crbegin(); ir != g1.crend(); ++ir) 
        cout << *ir << " "; 
  
    return 0; 
} 

Output:
Output of begin and end: 1 2 3 4 5 
Output of cbegin and cend: 1 2 3 4 5 
Output of rbegin and rend: 5 4 3 2 1 
Output of crbegin and crend : 5 4 3 2 1

Capacity

size() – Returns the number of elements in the vector.
max_size() – Returns the maximum number of elements that the vector can hold.
capacity() – Returns the size of the storage space currently allocated to the vector expressed as number of elements.
resize() – Resizes the container so that it contains ‘g’ elements.
empty() – Returns whether the container is empty.
shrink_to_fit() – Reduces the capacity of the container to fit its size and destroys all elements beyond the capacity.
reserve() – Requests that the vector capacity be at least enough to contain n elements.

// C++ program to illustrate the 
// capacity function in vector 
#include <iostream> 
#include <vector> 
  
using namespace std; 
  
int main() 
{ 
    vector<int> g1; 
  
    for (int i = 1; i <= 5; i++) 
        g1.push_back(i); 
  
    cout << "Size : " << g1.size(); 
    cout << "\nCapacity : " << g1.capacity(); 
    cout << "\nMax_Size : " << g1.max_size(); 
  
    // resizes the vector size to 4 
    g1.resize(4); 
  
    // prints the vector size after resize() 
    cout << "\nSize : " << g1.size(); 
  
    // checks if the vector is empty or not 
    if (g1.empty() == false) 
        cout << "\nVector is not empty"; 
    else
        cout << "\nVector is empty"; 
  
    // Shrinks the vector 
    g1.shrink_to_fit(); 
    cout << "\nVector elements are: "; 
    for (auto it = g1.begin(); it != g1.end(); it++) 
        cout << *it << " "; 
  
    return 0; 
} 

Output:
Size : 5
Capacity : 8
Max_Size : 4611686018427387903
Size : 4
Vector is not empty
Vector elements are: 1 2 3 4

Element access:

reference operator [g] – Returns a reference to the element at position ‘g’ in the vector
at(g) – Returns a reference to the element at position ‘g’ in the vector
front() – Returns a reference to the first element in the vector
back() – Returns a reference to the last element in the vector
data() – Returns a direct pointer to the memory array used internally by the vector to store its owned elements.

// C++ program to illustrate the 
// element accesser in vector 
#include <bits/stdc++.h> 
using namespace std; 
  
int main() 
{ 
    vector<int> g1; 
  
    for (int i = 1; i <= 10; i++) 
        g1.push_back(i * 10); 
  
    cout << "\nReference operator [g] : g1[2] = " << g1[2]; 
  
    cout << "\nat : g1.at(4) = " << g1.at(4); 
  
    cout << "\nfront() : g1.front() = " << g1.front(); 
  
    cout << "\nback() : g1.back() = " << g1.back(); 
  
    // pointer to the first element 
    int* pos = g1.data(); 
  
    cout << "\nThe first element is " << *pos; 
    return 0; 
} 

Output:
Reference operator [g] : g1[2] = 30
at : g1.at(4) = 50
front() : g1.front() = 10
back() : g1.back() = 100
The first element is 10
Modifiers:

assign() – It assigns new value to the vector elements by replacing old ones
push_back() – It push the elements into a vector from the back
pop_back() – It is used to pop or remove elements from a vector from the back.
insert() – It inserts new elements before the element at the specified position
erase() – It is used to remove elements from a container from the specified position or range.
swap() – It is used to swap the contents of one vector with another vector of same type and size.
clear() – It is used to remove all the elements of the vector container
emplace() – It extends the container by inserting new element at position
emplace_back() – It is used to insert a new element into the vector container, the new element is added to the end of the vector
.

// C++ program to illustrate the 
// Modifiers in vector 
#include <bits/stdc++.h> 
#include <vector> 
using namespace std; 
  
int main() 
{ 
    // Assign vector 
    vector<int> v; 
  
    // fill the array with 10 five times 
    v.assign(5, 10); 
  
    cout << "The vector elements are: "; 
    for (int i = 0; i < v.size(); i++) 
        cout << v[i] << " "; 
  
    // inserts 15 to the last position 
    v.push_back(15); 
    int n = v.size(); 
    cout << "\nThe last element is: " << v[n - 1]; 
  
    // removes last element 
    v.pop_back(); 
  
    // prints the vector 
    cout << "\nThe vector elements are: "; 
    for (int i = 0; i < v.size(); i++) 
        cout << v[i] << " "; 
  
    // inserts 5 at the beginning 
    v.insert(v.begin(), 5); 
  
    cout << "\nThe first element is: " << v[0]; 
  
    // removes the first element 
    v.erase(v.begin()); 
  
    cout << "\nThe first element is: " << v[0]; 
  
    // inserts at the beginning 
    v.emplace(v.begin(), 5); 
    cout << "\nThe first element is: " << v[0]; 
  
    // Inserts 20 at the end 
    v.emplace_back(20); 
    n = v.size(); 
    cout << "\nThe last element is: " << v[n - 1]; 
  
    // erases the vector 
    v.clear(); 
    cout << "\nVector size after erase(): " << v.size(); 
  
    // two vector to perform swap 
    vector<int> v1, v2; 
    v1.push_back(1); 
    v1.push_back(2); 
    v2.push_back(3); 
    v2.push_back(4); 
  
    cout << "\n\nVector 1: "; 
    for (int i = 0; i < v1.size(); i++) 
        cout << v1[i] << " "; 
  
    cout << "\nVector 2: "; 
    for (int i = 0; i < v2.size(); i++) 
        cout << v2[i] << " "; 
  
    // Swaps v1 and v2 
    v1.swap(v2); 
  
    cout << "\nAfter Swap \nVector 1: "; 
    for (int i = 0; i < v1.size(); i++) 
        cout << v1[i] << " "; 
  
    cout << "\nVector 2: "; 
    for (int i = 0; i < v2.size(); i++) 
        cout << v2[i] << " "; 
} 

Output:
The vector elements are: 10 10 10 10 10 
The last element is: 15
The vector elements are: 10 10 10 10 10 
The first element is: 5
The first element is: 10
The first element is: 5
The last element is: 20
Vector size after erase(): 0

Vector 1: 1 2 
Vector 2: 3 4 
After Swap 
Vector 1: 3 4 
Vector 2: 1 2

==
(findset)
set

From geeksforgeeks:

Functions associated with Set:

pair <iterator, bool> insert(const g) – Adds a new element ‘g’ to the set
find(const g) – Returns an iterator to the element ‘g’ in the set if found, else returns the iterator to end
begin() – Returns an iterator to the first element in the set
end() – Returns an iterator to the theoretical element that follows last element in the set

size() – Returns the number of elements in the set
empty() – Returns whether the set is empty

iterator insert (iterator position, const g) – Adds a new element ‘g’ at the position pointed by iterator
max_size() – Returns the maximum number of elements that the set can hold
erase(iterator position) – Removes the element at the position pointed by the iterator
erase(const g)- Removes the value ‘g’ from the set
clear() – Removes all the elements from the set
key_comp() / value_comp() – Returns the object that determines how the elements in the set are ordered (‘<‘ by default)
count(const g) – Returns 1 or 0 based on the element ‘g’ is present in the set or not.
lower_bound(const g) – Returns an iterator to the first element that is equivalent to ‘g’ or definitely will not go before the element ‘g’ in the set
upper_bound(const g) – Returns an iterator to the first element that is equivalent to ‘g’ or definitely will go after the element ‘g’ in the set

Example:

#include <iostream> 
#include <set> 
#include <iterator> 
  
using namespace std; 
  
int main() 
{ 
    // empty set container 
    set <int, greater <int> > gquiz1;         
  
    // insert elements in random order 
    gquiz1.insert(40); 
    gquiz1.insert(30); 
    gquiz1.insert(60); 
    gquiz1.insert(20); 
    gquiz1.insert(50); 
    gquiz1.insert(50); // only one 50 will be added to the set 
    gquiz1.insert(10); 
  
    // printing set gquiz1 
    set <int, greater <int> > :: iterator itr; 
    cout << "\nThe set gquiz1 is : "; 
    for (itr = gquiz1.begin(); itr != gquiz1.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
    cout << endl; 
  
    // assigning the elements from gquiz1 to gquiz2 
    set <int> gquiz2(gquiz1.begin(), gquiz1.end()); 
  
    // print all elements of the set gquiz2 
    cout << "\nThe set gquiz2 after assign from gquiz1 is : "; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
    cout << endl; 
  
    // remove all elements up to 30 in gquiz2 
    cout << "\ngquiz2 after removal of elements less than 30 : "; 
    gquiz2.erase(gquiz2.begin(), gquiz2.find(30)); 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
  
    // remove element with value 50 in gquiz2 
    int num; 
    num = gquiz2.erase (50); 
    cout << "\ngquiz2.erase(50) : "; 
    cout << num << " removed \t" ; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
  
    cout << endl; 
  
    //lower bound and upper bound for set gquiz1 
    cout << "gquiz1.lower_bound(40) : "
         << *gquiz1.lower_bound(40) << endl; 
    cout << "gquiz1.upper_bound(40) : "
         << *gquiz1.upper_bound(40) << endl; 
  
    //lower bound and upper bound for set gquiz2 
    cout << "gquiz2.lower_bound(40) : "
         << *gquiz2.lower_bound(40) << endl; 
    cout << "gquiz2.upper_bound(40) : "
         << *gquiz2.upper_bound(40) << endl; 
  
    return 0; 
  
} 

==
(findmap)
map

From geeksforgeeks:

Functions associated with Map:

pair insert(keyvalue,mapvalue) – Adds a new element to the map
find(const g) – Returns an iterator to the element with key value ‘g’ in the map if found, else returns the iterator to end
begin() – Returns an iterator to the first element in the map
end() – Returns an iterator to the theoretical element that follows last element in the map

size() – Returns the number of elements in the map
empty() – Returns whether the map is empty

max_size() – Returns the maximum number of elements that the map can hold
erase(iterator position) – Removes the element at the position pointed by the iterator
erase(const g)– Removes the key value ‘g’ from the map
clear() – Removes all the elements from the map
key_comp() / value_comp() – Returns the object that determines how the elements in the map are ordered (‘<' by default)
count(const g) – Returns the number of matches to element with key value ‘g’ in the map
lower_bound(const g) – Returns an iterator to the first element that is equivalent to mapped value with key value ‘g’ or definitely will not go before the element with key value ‘g’ in the map
upper_bound(const g) – Returns an iterator to the first element that is equivalent to mapped value with key value ‘g’ or definitely will go after the element with key value ‘g’ in the map


Example:

#include <iostream> 
#include <map> 
#include <iterator> 
  
using namespace std; 
  
int main() 
{ 
    map <int, int> gquiz1;        // empty map container 
  
    // insert elements in random order 
    gquiz1.insert(pair <int, int> (1, 40)); 
    gquiz1.insert(pair <int, int> (2, 30)); 
    gquiz1.insert(pair <int, int> (3, 60)); 
    gquiz1.insert(pair <int, int> (4, 20)); 
    gquiz1.insert(pair <int, int> (5, 50)); 
    gquiz1.insert(pair <int, int> (6, 50));  
    gquiz1.insert(pair <int, int> (7, 10)); 
  
    // printing map gquiz1 
    map <int, int> :: iterator itr; 
    cout << "\nThe map gquiz1 is : \n"; 
    cout << "\tKEY\tELEMENT\n"; 
    for (itr = gquiz1.begin(); itr != gquiz1.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
    cout << endl; 
  
    // assigning the elements from gquiz1 to gquiz2 
    map <int, int> gquiz2(gquiz1.begin(), gquiz1.end()); 
  
    // print all elements of the map gquiz2 
    cout << "\nThe map gquiz2 after assign from gquiz1 is : \n"; 
    cout << "\tKEY\tELEMENT\n"; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
    cout << endl; 
  
    // remove all elements up to element with key=3 in gquiz2 
    cout << "\ngquiz2 after removal of elements less than key=3 : \n"; 
    cout << "\tKEY\tELEMENT\n"; 
    gquiz2.erase(gquiz2.begin(), gquiz2.find(3)); 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
  
    // remove all elements with key = 4 
    int num; 
    num = gquiz2.erase (4); 
    cout << "\ngquiz2.erase(4) : "; 
    cout << num << " removed \n" ; 
    cout << "\tKEY\tELEMENT\n"; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
  
    cout << endl; 
  
    //lower bound and upper bound for map gquiz1 key = 5 
    cout << "gquiz1.lower_bound(5) : " << "\tKEY = "; 
    cout << gquiz1.lower_bound(5)->first << '\t'; 
    cout << "\tELEMENT = " << gquiz1.lower_bound(5)->second << endl; 
    cout << "gquiz1.upper_bound(5) : " << "\tKEY = "; 
    cout << gquiz1.upper_bound(5)->first << '\t'; 
    cout << "\tELEMENT = " << gquiz1.upper_bound(5)->second << endl; 
      
    return 0; 
  
} 

==
(findstack)
stack

From geeksforgeeks:

The functions associated with stack are:

push(g) – Adds the element ‘g’ at the top of the stack – Time Complexity : O(1)
top() – Returns a reference to the top most element of the stack – Time Complexity : O(1)
pop() – Deletes the top most element of the stack – Time Complexity : O(1)

empty() – Returns whether the stack is empty – Time Complexity : O(1)
size() – Returns the size of the stack – Time Complexity : O(1)


Example:

// CPP program to demonstrate working of STL stack 
#include <iostream> 
#include <stack> 
using namespace std; 
  
void showstack(stack <int> s) 
{ 
    while (!s.empty()) 
    { 
        cout << '\t' << s.top(); 
        s.pop(); 
    } 
    cout << '\n'; 
} 
  
int main () 
{ 
    stack <int> s; 
    s.push(10); 
    s.push(30); 
    s.push(20); 
    s.push(5); 
    s.push(1); 
  
    cout << "The stack is : "; 
    showstack(s); 
  
    cout << "\ns.size() : " << s.size(); 
    cout << "\ns.top() : " << s.top(); 
  
  
    cout << "\ns.pop() : "; 
    s.pop(); 
    showstack(s); 
  
    return 0; 
} 

==
(findqueue)
queue

From geeksforgeeks:

The functions supported by queue are :

push(g) – Adds the element ‘g’ at the end of the queue
front() – Returns a reference to the first element of the queue
pop() – Deletes the first element of the queue

back() – Returns a reference to the last element of the queue

empty() – Returns whether the queue is empty
size() – Returns the size of the queue

Example:

// CPP code to illustrate  
// Queue in Standard Template Library (STL) 
#include <iostream> 
#include <queue> 
  
using namespace std; 
  
void showq(queue <int> gq) 
{ 
    queue <int> g = gq; 
    while (!g.empty()) 
    { 
        cout << '\t' << g.front(); 
        g.pop(); 
    } 
    cout << '\n'; 
} 
  
int main() 
{ 
    queue <int> gquiz; 
    gquiz.push(10); 
    gquiz.push(20); 
    gquiz.push(30); 
  
    cout << "The queue gquiz is : "; 
    showq(gquiz); 
  
    cout << "\ngquiz.size() : " << gquiz.size(); 
    cout << "\ngquiz.front() : " << gquiz.front(); 
    cout << "\ngquiz.back() : " << gquiz.back(); 
  
    cout << "\ngquiz.pop() : "; 
    gquiz.pop(); 
    showq(gquiz); 
  
    return 0; 
}

==
(findpriorityqueue)
priority_queue

From geeksforgeeks:

The functions associated with priority queue are:

push(g) – Adds the element ‘g’ at the end of the queue
top() – Returns a reference to the top most element of the queue
pop() – Deletes the first element of the queue

empty() – Returns whether the queue is empty
size() – Returns the size of the queue

Example:

#include <iostream> 
#include <queue> 
  
using namespace std; 
  
void showpq(priority_queue <int> gq) 
{ 
    priority_queue <int> g = gq; 
    while (!g.empty()) 
    { 
        cout << '\t' << g.top(); 
        g.pop(); 
    } 
    cout << '\n'; 
} 
  
int main () 
{ 
    priority_queue <int> gquiz; 
    gquiz.push(10); 
    gquiz.push(30); 
    gquiz.push(20); 
    gquiz.push(5); 
    gquiz.push(1); 
  
    cout << "The priority queue gquiz is : "; 
    showpq(gquiz); 
  
    cout << "\ngquiz.size() : " << gquiz.size(); 
    cout << "\ngquiz.top() : " << gquiz.top(); 
  
  
    cout << "\ngquiz.pop() : "; 
    gquiz.pop(); 
    showpq(gquiz); 
  
    return 0; 
} 

==
(finditerator)
iterator

Although we can use subscripts to access the characters of a string or the elements in a vector, there is a more general mechanism—known as iterators—that we can use for the same purpose. 

In addition to vector, the library defines several other kinds of containers. All of the library containers have iterators, but only a few of them support the subscript operator.

Like pointers, iterators give us indirect access to an object. In the case of an iterator, that object is an element in a container or a character in a string.

Types that have iterators have members that return iterators. In particular, these types have members named begin and end. The begin member returns an iterator that denotes the first element (or first character).

auto b = v.begin(), e = v.end(); //Note that auto is C++11

The iterator returned by end is an iterator positioned “one past the end” of the associated container (or string). This iterator denotes a nonexistent element “off the end” of the container. It is used as a marker indicating when we have processed all the elements. The iterator returned by end is often referred to as the off-the-end iterator or abbreviated as “the end iterator.” If the container is empty, begin returns the same iterator as the one returned by end.

Iterators support only a few operations, which are listed below (tao: these operations are very similar to pointers):

(In the folllowng, an example of iter is: auto iter = v.begin())
*iter //Returns a reference to the element denoted by the iterator iter.
iter->mem //Dereferences iter and fetches the memeber named mem from the underlying element. Equivalent to (*iter).mem
++iter //Increments iter to refer to the next element in the container.
--iter //Decrements iter to refer to the previous element in the container.
iter1 == iter2 //Two iterators are equal if they denote the same element or if they are the off-the-end iterator for the same container.
iter1 != iter2
iter + n // Adding (substracting) an integral value n to (from) an iterator yields an iterator that many elements forward (backward) within the container.
iter - n
iter += n
iter -= n
iter1 - iter2 //Returns the distance between the iterators. The result type is a signed integral type named difference_type. Both vector and string define difference_type. This type is signed, because subtraction might have a negative result.
iter1 <= iter2 //One iterator is less than another if it refers to an element that appears in the container before the one referred to by the other iterator.

Example: capitalize the first character of a string:

string s("some string");
if (s.begin() != s.end()) { // make sure s is not empty
    auto it = s.begin(); // it denotes the first character in s
    *it = toupper(*it); // make that character uppercase, tao: note the characters in a string can be changed in C++
}

Example: capitalize the first word in a string:

for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
    *it = toupper(*it); // capitalize the current character

Programmers coming to C++ from C or Java might be surprised that we used != rather than < in our for loops. C++ programmers use != as a matter of habit. They do so for the same reason that they use iterators rather than subscripts: This coding style applies equally well to various kinds of containers provided by the library. As we’ve seen, only a few library types, vector and string being among them, have the subscript operator. Similarly, all of the library containers have iterators that define the == and != operators. Most of those iterators do not have the < operator. By routinely using iterators and !=, we don’t have to worry about the precise type of container we’re processing.

As with size_type, the library types that have iterators define types named iterator and const_iterator that represent actual iterator types:

vector<int>::iterator it; // it can read and write vector<int> elements
string::iterator it2; // it2 can read and write characters in a string
vector<int>::const_iterator it3; // it3 can read but not write elements
string::const_iterator it4; // it4 can read but not write characters

A const_iterator behaves like a const pointer. Like a const pointer, a const_iterator may read but not write the element it denotes; an object of type iterator can both read and write. If a vector or string is const, we may use only its const_iterator type. With a nonconst vector or string, we can use either iterator or const_iterator.

The type returned by begin and end depends on whether the object on which they operator is const. If the object is const, then begin and end return a const_iterator; if the object is not const, they return iterator:

vector<int> v;
const vector<int> cv;
auto it1 = v.begin(); // it1 has type vector<int>::iterator
auto it2 = cv.begin(); // it2 has type vector<int>::const_iterator

It is important to realize that loops that use iterators should not add elements to the container to which the iterators refer.

==
(findarray)
array

int a[10]; // array of 10 ints. The elements are default initialized.
int a[3] = {0,1,2};
int a[] = {0,1,2};
unsigned scores[11] = {}; // 11 buckets, all value initialized to 0
int *p = a;

int arr[3][4];
int arr[2][3] = {{1,2},{3,4},{5,6}};

Fill in an array with the same values:
int arr[5];
std::fill_n(arr, 5, 2); //Now arr = {2, 2, 2, 2, 2}

As in the case of string or vector, it is best to use a range for when we want to traverse the entire array.

for (auto i : scores)
    cout << i << " ";  

--
tao: practice shows that the type of the array size can be int, but it should be const:
const int aSize = 3;
char a[aSize] = {'A', 'B', 'C'};

The number of elements in an array is part of the array’s type. As a result, the dimension must be known at compile time, which means that the dimension must be a constant expression. 

Because arrays have fixed size, they sometimes offer better run-time performance for specialized applications. However, that run-time advantage comes at the cost of lost flexibility.

Tao: in C++, there is no function to find array size (different from Java). So if need to use size, should not use array in the beginning, use vector instead. <- Confirmed later from online (including recommending using vector). If you must use the size of an array, you can do it as below:

int num_files = sizeof(file_names) / sizeof(file_names[0]);

Character arrays have an additional form of initialization: We can initialize such arrays from a string literal. When we use this form of initialization, it is important to remember that string literals end with a null character. That null character is copied into the array along with the characters in the literal:

char a1[] = {'C', '+', '+'}; // size = 3. 
char a2[] = {'C', '+', '+', '\0'}; // size = 4
char a3[] = "C++"; // size = 4, null terminator added automatically

--
When we use a variable to subscript an array, we normally should define that variable to have type size_t. size_t is a machine-specific unsigned type that is guaranteed to be large enough to hold the size of any object in memory. The size_t type is defined in the cstddef header.


--
Although we can compute an off-the-end pointer, doing so is error-prone. To make it easier and safer to use pointers, the new library includes two functions, named begin and end.

int *beg = begin(ia); // pointer to the first element in ia
int *last = end(ia);  // pointer one past the last element in ia

These functions are defined in the iterator header.

A pointer “one past” the end of a built-in array behaves the same way as the iterator returned by the end operation of a vector.

As with iterators, subtracting two pointers gives us the distance between those pointers. 

The result of subtracting two pointers is a library type named ptrdiff_t. Like size_t,the ptrdiff_t type is a machine-specific type and is defined in the cstddef header. Because subtraction might yield a negative distance, ptrdiff_t is a signed integral type.

We can use the subscript operator on any pointer, as long as that pointer points to an element (or one past the last element) in an array:

int *p = &ia[2];  // p points to the element indexed by 2
int j = p[1];     // p[1] is equivalent to *(p + 1),
                  // p[1] is the same element as ia[3]
int k = p[-2];    // p[-2] is the same element as ia[0]

--
string *p = &nums[0];   // p points to the first element in nums

When we use an array, the compiler automatically substitutes a pointer to the first element:

string *p2 = nums;      // equivalent to p2 = &nums[0]

when we use an array as an
initializer for a variable defined using auto (§ 2.5.2, p. 68), the deduced type is a
pointer, not an array:

int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia is an array of ten ints
auto ia2(ia); // ia2 is an int* that points to the first element in ia

It is worth noting that this conversion does not happen when we use decltype. The type returned by decltype(ia) is array of ten ints:

decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9}; //Tao: decltype(ia) returns a type name
ia3[4] = i; // ok: assigns the value of i to an element in ia3

Pointers to array elements support the same operations as iterators on vectors or strings. For example, we can use the increment operator to move from one element in an array to the next:
  
int arr[] = {0,1,2,3,4,5,6,7,8,9};
int *p = arr; // p points to the first element in arr
++p;          // p points to arr[1]

--
Using an Array to Initialize a vector
 
We noted that we cannot initialize a built-in array from another array. Nor can we initialize an array from a vector. However, we can use an array to initialize a vector. To do so, we specify the address of the first element and one past the last element that we wish to copy:

int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));

The specified range can be a subset of the array:
vector<int> subVec(int_arr + 1, int_arr + 4);

--
Modern C++ programs should use vectors and iterators instead of built-in arrays and pointers, and use strings rather than C-style array-based character strings.

--
Multidimensional Arrays

Strictly speaking, there are no multidimensional arrays in C++. What are commonly referred to as multidimensional arrays are actually arrays of arrays.

int ia[3][4]; // array of size 3; each element is an array of ints of size 4

int arr[10][20][30] = {0}; // initialize all elements to 0

In a two-dimensional array, the first dimension is usually referred to as the row and the second as the column.

Multidimensional arrays may be initialized by specifying bracketed values for each row:

int ia[3][4] = {    
    {0, 1, 2, 3},   
    {4, 5, 6, 7},   
    {8, 9, 10, 11}  
};

The nested braces are optional. The following initialization is equivalent, although considerably less clear:

int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};

Under the new standard we can simplify the previous loop by using a range for:

size_t cnt = 0;

for (auto &row : ia)        
    for (auto &col : row) { 
        col = cnt;          
        ++cnt;            
    }

In the previous example, we used references as our loop control variables because we wanted to change the elements in the array. However, there is a deeper reason for using references.

Had we neglected the reference and written these loops as:
 
for (auto row : ia)
    for (auto col : row)
 
our program would not compile. As before, the first for iterates through ia, whose elements are arrays of size 4. As a result, in this loop the type of row is int*. The inner for loop is illegal, it attempts to iterate over an int*

As with any array, when we use the name of a multidimensional array, it is automatically converted to a pointer to the first element in the array (tao: note this is not an actual element, but an inner array):

int ia[3][4]
int (*p)[4] = ia; // p points to an array of four ints

The result of *p is an array of four ints. As usual, when we use an array, it is converted automatically to a pointer to its first element.

==
(findoperator)
(findand)
Operators

Logical operators:
AND: &&
OR:  ||
NOT: !

--
Bitwise operators:
AND: &
OR:  |
XOR: ^ (eg: expr1 ^ expr2)
NOT: ~ (eg: ~expr) 
Left shift: << (eg: expr1 << expr2)
Right shift: >> (eg: expr1 >> expr2)

a^b is equivalent as a != b

The left-shift operator (the << operator) inserts 0-valued bits on the right. The behavior of the right-shift operator (the >> operator) depends on the type of the left-hand operand: If that operand is unsigned, then the operator inserts 0-valued
bits on the left; if it is a signed type, the result is implementation defined—either copies of the sign bit or 0-valued bits are inserted on the left.

The bitwise NOT operator (the ~ operator) generates a new value with the bits of its operand inverted. Each 1 bit is set to 0; each 0 bit is set to 1.

Because there are no guarantees for how the sign bit is handled, we strongly recommend using unsigned types with the bitwise operators.

Overloaded versions of these operators for IO: 
cout << "Helo" << endl;

--
Remainder (modulus) operator: %

--
Order of Evaluation

Rember: ->|

--
Lvalues and Rvalues

Every expression in C++ is either an rvalue or an lvalue. lvalues could stand on the left-hand side of an assignment whereas rvalues could not. In C++, the distinction is less simple. Roughly speaking, when we use an object as an rvalue, we use the object’s value (its contents). When we use an object as an lvalue, we use
the object’s identity (its location in memory).

--
In assignment, if the types of the left and right operands differ, the right-hand operand is converted to the type of the left.

--
Compound assignments:
+=   -=   *=   /=   %=   (arithmetic operators)
<<=  >>=   &=   ^=   |=  (bitwise operators)

--
(findincrement)
(finddecrement)
(find++)
(find--)
The increment (++) and decrement (--) operators

int i = 0;
++i; // i = 1. Prefix returns new value 1 (remeber: ee)
i++; // i = 1. Postfix returns old value 0 (remember: oo)

Readers from a C background might be surprised that we use the prefix increment in the programs we’ve written. The reason is simple: The prefix version avoids unnecessary work. It increments the value and returns the incremented version. The postfix operator must store the original value so that it can return the unincremented value as its result. If we don’t need the
unincremented value, there’s no need for the extra work done by the postfix operator.

--
p->size() is equivalent to (*p).size()

--
(findsizeof)
sizeof

The sizeof operator returns the size, in bytes, of an expression or a type name. The result of sizeof is a constant expression of type size_t. The operator takes one of two forms:
 
sizeof (type)
sizeof expr
 
In the second form, sizeof returns the size of the type returned by the given expression. The sizeof operator is unusual in that it does not evaluate its operand:

sizeof an array is the size of the entire array. It is equivalent to taking the sizeof the element type times the number of elements in the array. Note that sizeof does not convert the array to a pointer.

sizeof a string or a vector returns only the size of the fixed part of these types; it does not return the size used by the object’s elements. Tao's understanding: think of how vector and string is implememted using array and doubles its size when reached maximum, sizeof only takes the fixed part and may not return the correct size of a vector or string.

Example:

constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr2[sz];  // ok sizeof returns a constant expression 

Because sizeof returns a constant expression, we can use the result of a sizeof expression to specify the dimension of an array.

==
(commaoperator)
Comma operator

The comma operator takes two operands, which it evaluates from left to right. Like
the logical AND and logical OR and the conditional operator, the comma operator
guarantees the order in which its operands are evaluated.

The left-hand expression is evaluated and its result is discarded. The result of a
comma expression is the value of its right-hand expression.

Example:

for(vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
ivec[ix] = cnt;

This loop increments ix and decrements cnt in the expression in the for header. Both ix and cnt are changed on each trip through the loop.

==
The simplest statement is the empty statement, also known as a null statement. A null statement is a single semicolon:
; // null statement

A null statement is useful where the language requires a statement but the program’s logic does not. Such usage is most common when a loop’s work can be done within its condition.

while (cin >> s && s != sought)
	; // null statement

Null statements should be commented. That way anyone reading the code can see that the statement was omitted intentionally.

An empty block is equivalent to a null statement:

while (cin >> s && s != sought)
	{ } // empty block

==
(findif)
if 

int a;

if (grade < 60)
	a = 1;
else
	a = 2;


if (grade == 2) {
	a = 5;
} else if (grade == 9) {
	a = 8;
}

It is a common mistake to forget the curly braces when multiple statements must be executed as a block. To avoid such problems, some coding styles recommend always using braces after an if or an else (and also around the bodies of while and for statements).
Doing so avoids any possible confusion. It also means that the braces are already in place if later modifications of the code require adding statements.

==
(findswitch)
switch

A switch statement provides a convenient way of selecting among a (possibly large) number of fixed alternatives.

unsigned aCnt = 0, eCnt = 0, otherCunt = 0;

char ch;

switch (ch) {
	case 'a':
		++aCnt;
		break;
	case 'e':
		++eCnt;
		break;
 	default:
 		++otherCunt;
 		break;
}

In this case, the break transfers control out of the switch. Forgetting a break Is a Common Source of Bugs.

The case keyword and its associated value together are known as the case label. case labels must be integral constant expressions.

char ch = getVal();
int ival = 42;
switch(ch) {
	case 3.14: // error: noninteger as case label
	case ival: // error: nonconstant as case label
// . . .

It can be useful to define a default label even if there is no work for the default case. Defining an empty default section indicates to subsequent readers that the case was considered. If a switch ends with a default case that has no work to do, then the default label must be followed by a null statement or an empty block.

==
(findwhile)
while

while(a > 3) {
	cout << a << endl;
}

--
do while

A do while statement is like a while but the condition is tested after the statement body completes. Regardless of the value of the condition, we execute the loop at least once.

A do while ends with a semicolon after the parenthesized condition.

Variables used in condition must be defined outside the body of the do while statement.

// repeatedly ask the user for a pair of numbers to sum
string rsp;  // used in the condition; can't be defined inside the do

do {
    cout << "please enter two values: ";
    int val1 = 0, val2 = 0;
    cin  >> val1 >> val2;
    cout << "The sum of " << val1 << " and " << val2
         << " = " << val1 + val2 << "\n\n"
         << "More? Enter yes or no: ";
    cin  >> rsp;
} while (!rsp.empty() && rsp[0] != 'n');

==
(findfor)
for

for(int i = 0; i < 5; ++i) {
	cout << i << endl;
}

for (decltype(v.size()) i = 0, sz = v.size(); i != sz; ++i)
    v.push_back(v[i]);

--
Range for (in C++11):

If we want to write to the elements in the sequence, the
loop variable must be a reference type.

vector<int> v = {0,1,2,3,4,5,6,7,8,9};

// range variable must be a reference so we can write to the elements
for (auto &r : v)   // for each element in v
    r *= 2; // double the value of each element in v

we cannot use a range for to add elements to a vector (or
other container). 

==
(findbreak)
break

A break statement terminates the nearest enclosing while, do while, for, or switch statement. Execution resumes at the statement immediately following the terminated statement.

for (auto it = buf.begin()+1; it != buf.end(); ++it) {
	  if (*it == ' ')
	       break; // leaves the for loop
}

==
(findcontinue)
continue

A continue statement terminates the current iteration of the nearest enclosing loop and immediately begins the next iteration. A continue can appear only inside a for, while, or do while loop. 

In the case of a while or a do while, execution continues by evaluating the condition. In a traditional for loop, execution continues at the expression inside the for header.

==
(findgoto)
goto

A goto statement provides an unconditional jump from the goto to a another statement in the same function. Programs should not use gotos. gotos make programs hard to understand and hard to modify.


goto label;
 
where label is an identifier that identifies a statement. A labeled statement is any statement that is preceded by an identifier followed by a colon:

end: return;  // labeled statement; may be the target of a goto

Label identifiers are independent of names used for variables and other identifiers.

==
(findexception)
Exception

Exceptions are run-time anomalies—such as losing a database connection or encountering unexpected input—that exist outside the normal functioning of a program. Dealing with anomalous behavior can be one of the most difficult parts of designing any system.

Exception handling is generally used when one part of a program detects a problem that it cannot resolve and the problem is such that the detecting part of the program cannot continue. In such cases, the detecting part needs a way to signal that something happened and that it cannot continue. Moreover, the detecting part needs a way to signal the problem without knowing what part of the program will deal with the exceptional condition. Having signaled what happened, the detecting part stops processing.
 
A program that contains code that might raise an exception (usually) has another part to handle whatever happened. For example, if the problem is invalid input, the handling part might ask the user to provide correct input. If the database was lost, the handling part might alert an operator.
 
Exception handling supports this cooperation between the detecting and handling parts of a program. In C++, exception handling involves
 
- throw expressions, which the detecting part uses to indicate that it encountered something it can’t handle. We say that a throw raises an exception.
 
- try blocks, which the handling part uses to deal with an exception. A try block starts with the keyword try and ends with one or more catch clauses.Exceptions thrown from code executed inside a try block are usually handled by one of the catch clauses. Because they “handle” the exception, catch clauses are also known as exception handlers.

- A set of exception classes that are used to pass information about what happened between a throw and an associated catch.

--
A throw Expression:

// first check that the data are for the same item
if (item1.isbn() != item2.isbn())
    throw runtime_error("Data must refer to same ISBN");
// if we're still here, the ISBNs are the same
cout << item1 + item2 << endl;
 
In this code, if the ISBN s differ, we throw an expression that is an object of type runtime_error. Throwing an exception terminates the current function and transfers control to a handler that will know how to handle this error.

The type runtime_error is one of the standard library exception types and is defined in the stdexcept header. We must initialize a runtime_error by giving it a string or a C-style character string. That string provides additional information about the problem.

--
The try Block:

The general form of a try block is
 
try {
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
} // . . .

When a catch is selected to handle an exception, the associated block is executed. Once the catch finishes, execution continues with the statement immediately following the last catch clause of the try block.

The program-statements inside the try constitute the normal logic of the program. Like any other blocks, they can contain any C++ statement, including declarations. As with any block, variables declared inside a try block are inaccessible outside the block — in particular, they are not accessible to the catch clauses.

--
Writing a Handler:\
while (cin >> item1 >> item2) {
    try {
        // execute code that will add the two Sales_items
        // if the addition fails, the code throws a runtime_error exception
    } catch (runtime_error err) {
        // remind the user that the ISBNs must match and prompt for another pair
        cout << err.what()
             << "\nTry Again?  Enter y or n" << endl;
        char c;
        cin >> c;
        if (!cin || c == 'n')
            break;      // break out of the while loop
    }
}

The prompt to the user prints the return from err.what(). We know that err has type runtime_error. Each of the library exception classes defines a member function named what. These functions take no arguments and return a C-style character string (i.e., a const char*). The what member of runtime_error
returns a copy of the string used to initialize the particular object.

If no appropriate catch is found, execution is transferred to a library function named terminate. The behavior of that function is system dependent but is guaranteed to stop further execution of the program.

--
Standard Exceptions:

The C++ library defines several classes that it uses to report problems encountered in the functions in the standard library. These classes are defined in four headers:
 
- The "exception" header defines the most general kind of exception class named "exception". It communicates only that an exception occurred but provides no additional information.

- The "stdexcept" header defines several general-purpose exception classes, which are listed below.

- The "new" header dfines the "bad_alloc" exception type.

- The "type_info" header defines the "bad_cast" exception type. 

Standard exception classes defined in <stdexcetp>:

exception: The most general kind of problem

runtime_error: Problem that can be deteced only at run time.

range_error: Run-time error: result generatd outside the range of values that are meaningful.

overflow_error: Run-time error: computation that overflowed.

underflow_error: Run-time error: computation that underflowed.

logic_error: Error in the logic of the program.

domain_error: Logic error: argument for which no result exists.

invalid_argument: Logic error: inappropriate argument.

length_error: Logic error: attempt to create an object larger than the maximum size for that type.

out_of_range: logic error: used a value outside the valid range.

We can only default initialize exception, bad_alloc, and bad_cast objects; it is not possible to provide an initializer for objects of these exception types.
 
The other exception types have the opposite behavior: We can initialize those objects from either a string or a C-style string, but we cannot default initialize them. When we create objects of any of these other exception types, we must supply an
initializer. That initializer is used to provide additional information about the error that occurred.
 
The exception types define only a single operation named what. That function takes no arguments and returns a const char* that points to a C-style character string. The purpose of this C-style character string is to provide some sort of textual description of the exception thrown.

==
(findfunction)
function

Example:

int fact(int val) {
  int ret = 1; 
  while (val > 1)
    ret *= val--; 
  return ret;
}

The statements after the return statement will not be executed (tao's practice).

--
For compatibility with C, we also can use the keyword void to indicate that there are no parameters:

int f1(){ /* ... */ } // implicit void parameter list

int f2(void){ /* ... */ } // explicit void parameter list

--
The return type can be void, which means that the function does not return a value.

The return type may not be an array type or a function type. However, a function may return a pointer to an array or a function. 

--
Argument Passing

If the parameter is a reference, then the parameter is bound to its argument. Otherwise, the argument’s value is copied.

When a parameter is a reference, we say that its corresponding argument is “passed by reference” or that the function is “called by reference.” The parameter is an alias for its corresponding argument.
 
When the argument value is copied, the parameter and argument are independent objects. We say such arguments are “passed by value” or alternatively that the function is “called by value.”

-- 
Passing Arguments by Value

Nothing the function does to the parameter can affect the argument.

Pointer Parameters
 
Pointers behave like any other nonreference type. When we copy a
pointer, the value of the pointer is copied. After the copy, the two pointers are distinct. However, a pointer also gives us indirect access to the object to which that pointer points.

(Avadoles) Programmers accustomed to programming in C often use pointer parameters to access objects outside a function. In C++, programmers generally use reference parameters instead.

--
Passing Arguments by Reference

void reset(int &i)  // i is just another name for the object passed to reset
{
    i = 0;  // changes the value of the object to which i refers
}

int j = 42;
reset(j);  // j is passed by reference; the value in j is changed
cout << "j = " << j  << endl;  // prints j = 0

Using References to Avoid Copies
 
It can be inefficient to copy objects of large class types or large containers. Moreover, some class types (including the IO types) cannot be copied. Functions must use reference parameters to operate on objects of a type that cannot be copied.

As an example, we’ll write a function to compare the length of two strings. Because strings can be long, we’d like to avoid copying them, so we’ll make our parameters references. Because comparing two strings does not involve changing the strings, we’ll make the parameters references to const. Reference parameters that are not changed inside a function should be
references to const.

// compare the length of two strings
bool isShorter(const string &s1, const string &s2) {
    return s1.size() < s2.size();
}

Use Reference to const When Possible

It is a somewhat common mistake to define parameters that a function does not change as (plain) references. Doing so gives the function’s caller the misleading impression that the function might change its argument’s value.

Using Reference Parameters to Return Additional Information
 
A function can return only a single value. However, sometimes a function has more than one value to return. Reference parameters let us effectively return multiple results.

// returns the index of the first occurrence of c in s
// the reference parameter occurs counts how often c occurs
string::size_type find_char(const string &s, char c, string::size_type &occurs) {
    auto ret = s.size();   // position of the first occurrence, if any
    occurs = 0;            // set the occurrence count parameter
    for (decltype(ret) i = 0; i != s.size(); ++i) {
        if (s[i] == c) {
            if (ret == s.size())
                ret = i;   // remember the first occurrence of c
            ++occurs;      // increment the occurrence count
         }
    }
    return ret;            // count is returned implicitly in occurs
}

auto index = find_char(s, 'o', ctr);
 
After the call, the value of ctr will be the number of times o occurs.

--
Array Parameters

Arrays have two special properties that affect how we define and use functions that operate on arrays: We cannot copy an array, and when we use an array it is (usually) converted to a pointer. Because we cannot copy an array, we cannot pass an array by value. Because arrays are converted to pointers, when we pass an array to a function, we are actually passing a pointer to the array’s first element.

Even though we cannot pass an array by value, we can write a parameter that looks like an array:

// despite appearances, these three declarations of print are equivalent:

// each function has a single parameter of type const int*
void print(const int*);
void print(const int[]);   // shows the intent that the function takes an array
void print(const int[10]); // dimension for documentation purposes (at best)

int j[2] = {0, 1};
print(j);  // ok: j is converted to an int* that points to j[0]

Because arrays are passed as pointers, functions ordinarily don’t know the size of the array they are given. They must rely on additional information provided by the caller. There are three common techniques used to manage pointer parameters.

Using a Marker to Specify the Extent of an Array

The first approach to managing array arguments requires the array itself to contain an end marker. C-style character strings are an example of this approach. C-style strings are stored in character arrays in which the last character of the string is followed by a null character. Functions that deal with C-style strings stop processing the array when they see a null character.

Using the Standard Library Conventions
 
A second technique used to manage array arguments is to pass pointers to the first and one past the last element in the array.

Using this approach, we’ll print the elements in an array as follows:

void print(const int *beg, const int *end) {
    // print every element starting at beg up to but not including end
    while (beg != end)
        cout << *beg++ << endl; // print the current element and advance the pointer
}

To call this function, we pass two pointers:

int j[2] = {0, 1};

print(begin(j), end(j));

Explicitly Passing a Size Parameter

A third approach for array arguments, which is common in C programs and older C++ programs, is to define a second parameter that indicates the size of the array.

// const int ia[] is equivalent to const int* ia
// size is passed explicitly and used to control access to elements of ia

void print(const int ia[], size_t size) {
    for (size_t i = 0; i != size; ++i) {
        cout << ia[i] << endl;
    }
}

int j[] = { 0, 1 };  // int array of size 2
print(j, end(j) - begin(j));

--
Array Parameters and const
 
Note that all three versions of our print function defined their array parameters as pointers to const. The discussion in § 6.2.3 applies equally to pointers as to references. When a function does not need write access to the array elements, the array parameter should be a pointer to const. A parameter should be
a plain pointer to a nonconst type only if the function needs to change element values.

--
Array Reference Parameters
 
Just as we can define a variable that is a reference to an array, we can define a parameter that is a reference to an array.

void print(int (&arr)[10]) {
    for (auto elem : arr)
        cout << elem << endl;
}

Because the size of an array is part of its type, it is safe to rely on the dimension in the body of the function. However, the fact that the size is part of the type limits the usefulness of this version of print. We may call this function only for an array of exactly ten ints:

j[2] = {0, 1};
int k[10] = {0,1,2,3,4,5,6,7,8,9};

print(j);    // error: argument is not an array of ten ints
print(k);    // ok: argument is an array of ten ints

--
Passing a Multidimensional Array

As with any array, a multidimensional array is passed as a pointer to its first element. Because we are dealing with an array of arrays, that element is an array, so the pointer is a pointer to an array. The size of the second (and any subsequent) dimension is part of the element type and must be specified:

// matrix points to the first element in an array whose elements are arrays of ten ints
void print(int (*matrix)[10], int rowSize) { /* . . . */ }

declares matrix as a pointer to an array of ten ints.

We can also define our function using array syntax. As usual, the compiler ignores the first dimension, so it is best not to include it:

// equivalent definition
void print(int matrix[][10], int rowSize) { /* . . . */ }

--
Returning a Pointer to an Array

Because we cannot copy an array, a function cannot return an array. However, a function can return a pointer or a reference to an array Unfortunately, the syntax used to define functions that return pointers or references to arrays can be intimidating. Fortunately, there are ways to simplify such declarations. The most straightforward way is to use a type alias

typedef int arrT[10];  // arrT is a synonym for the type array of ten ints

using arrtT = int[10]; // equivalent declaration of arrT; 

arrT* func(int i);     // func returns a pointer to an array of five ints

Declaring a Function That Returns a Pointer to an Array
 
To declare func without using a type alias, we must remember that the dimension of an array follows the name being defined:
  
int arr[10];          // arr is an array of ten ints
int *p1[10];          // p1 is an array of ten pointers
int (*p2)[10] = &arr; // p2 points to an array of ten ints
 
As with these declarations, if we want to define a function that returns a pointer to an array, the dimension must follow the function’s name. However, a function includes a parameter list, which also follows the name. The parameter list precedes the
dimension. Hence, the form of a function that returns a pointer to an array is:

Type (*function(parameter_list))[dimension]

As a concrete example, the following declares func without using a type alias:

int (*func(int i))[10];

Using a Trailing Return Type (C++11)

Under the new standard, another way to simplify the declaration of func is by using a trailing return type.

A trailing return type follows the parameter list and is preceded by ->. To signal that the return follows the parameter list, we use auto where the return type ordinarily appears:

// fcn takes an int argument and returns a pointer to an array of ten ints
auto func(int i) -> int(*)[10];

Using decltype

As another alternative, if we know the array(s) to which our function can return a pointer, we can use decltype to declare the return type.

int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
// returns a pointer to an array of five int elements
decltype(odd) *arrPtr(int i)
{
    return (i % 2) ? &odd : &even; // returns a pointer to the array
}

--
Functions with Varying Parameters

Sometimes we do not know in advance how many arguments we need to pass to a function.

The new standard provides two primary ways to write a function that takes a varying number of arguments: If all the arguments have the same type, we can pass a library type named initializer_list. If the argument types vary, we can write a special kind of function, known as a variadic template.

C++ also has a special parameter type, ellipsis, that can be used to pass a varying number of arguments.

--
initializer_list Parameters (C++11)

We can write a function that takes an unknown number of arguments of a single type by using an initializer_list parameter. An initializer_list is a library type that represents an array of values of the specified type. This type is defined in the initializer_list header. The operations that initializer_list provides are listed below:

initializer_list<T> lst: Default initialization, an empty list of element sof type T.

initializer_list<T> lst(a, b, c...): lst has as many elements as there are initializers, elements are copies of the corresponding initializers. Elements in the list are const.

lst2(lst), lst2 = lst: Copying or assigning an initializer_list does not copy the elements in the list. After the copy, the original and the copy share the elements.

lst.size(): Number of elements in the list.

lst.begin(), lst.end(): Returns a pointer to the first and one past the last elments in the lst.

Example:

initializer_list<int> li;    // initializer_list of ints

Unlike vector, the elements in an initializer_list are always const values; there is no way to change the value of an element in an initializer_list.

void error_msg(initializer_list<string> il) {
    for (auto beg = il.begin(); beg != il.end(); ++beg)
        cout << *beg << " " ;
    cout << endl;
}

When we pass a sequence of values to an initializer_list parameter, we must enclose the sequence in curly braces:

error_msg({"functionX", "okay"});

A function with an initializer_list parameter can have other parameters as well.

void error_msg(ErrCode e, initializer_list<string> il)

error_msg(ErrCode(0), {"functionX", "okay"});

--
Ellipsis Parameters

Ellipsis parameters are in C++ to allow programs to interface to C code that uses a C library facility named varargs. Generally an ellipsis parameter should not be used for other purposes.

Ellipsis parameters should be used only for types that are common to both C and C++. In particular, objects of most class types are not copied properly when passed to an ellipsis parameter.

An ellipsis parameter may appear only as the last element in a parameter list and may take either of two forms:
 
void foo(parm_list, ...);
void foo(...);

--
(findreturn)
return

A return statement terminates the function that is currently executing and returns control to the point from which the function was called. There are two forms of return statements:
 
return;
return expression;

Functions with No Return Value

A return with no value may be used only in a function that has a return type of void. Functions that return void are not required to contain a return. In a void function, an implicit return takes place after the function’s last statement.
  
Typically, void functions use a return to exit the function at an intermediate point. This use of return is analogous to the use of a break statement to exit a loop.

Functions That Return a Value

Every return in a function with a return type other than void must return a value.

Never Return a Reference or Pointer to a Local Object

When a function completes, its storage is freed. After a function
terminates, references to local objects refer to memory that is no longer valid:

// disaster: this function returns a reference to a local object
const string &manip() {
    string ret;
   // transform ret in some way
   if (!ret.empty())
       return ret;     // WRONG: returning a reference to a local object!
   else
       return "Empty"; // WRONG: "Empty" is a local temporary string
}

If a function returns a pointer, reference or object of class type, we can use the result of a call to call a member of the resulting object:

auto sz = shorterString(s1, s2).size();

Reference Returns Are Lvalues. we can assign to the result of a function that returns a reference to nonconst:

char &get_val(string &str, string::size_type ix) {
    return str[ix]; // get_val assumes the given index is valid
}

get_val(s, 0) = 'A'; // changes s[0] to A

It may be surprising to see a function call on the left-hand side of an assignment. However, nothing special is involved.

--
List Initializing the Return Value (C++11)

Under the new standard, functions can return a braced list of values.

vector<string> process() {
    // . . .
    return {"functionX", expected, actual};
}

--
Return from main

There is one exception to the rule that a function with a return type other than void must return a value: The main function is allowed to terminate without a return. If control reaches the end of main and there is no return, then the compiler implicitly
inserts a return of 0.

The value returned from main is treated as a status indicator. A zero return indicates success; most other values indicate failure. A nonzero value has a machine-dependent meaning. To make return values machine independent, the cstdlib header defines two preprocessor variables that we can use to indicate success or failure:

int main() {
    if (some_failure)
        return EXIT_FAILURE;  // defined in cstdlib
    else
        return EXIT_SUCCESS;  // defined in cstdlib
}
 
Because these are preprocessor variables, we must not precede them with std::, nor may we mention them in using declarations.

--
Recursion

A function that calls itself, either directly or indirectly, is a recursive function.

// calculate val!, which is 1 * 2 * 3 . . . * val
int factorial(int val) {
    if (val > 1)
        return factorial(val-1) * val;
    return 1;
}

There must always be a path through a recursive function that does not involve a recursive call; otherwise, the function will recurse “forever”.

The main function may not call itself.


--
(findstatic)
Local static objects
Static variables

It can be useful to have a local variable whose lifetime continues across calls to the function. We obtain such objects by defining a local variable as static. Each local static object is initialized before the first time execution passes through the object’s definition. Local statics are not destroyed when a function ends; they are destroyed when the program terminates.

As a trivial example, here is a function that counts how many times it is called. This program will print the numbers from 1 through 10 inclusive.
 
size_t count_calls() {
    static size_t ctr = 0;  // value will persist across calls
    return ++ctr;
}

int main() {
    for (size_t i = 0; i != 10; ++i)
        cout << count_calls() << endl;
    return 0;
}
 
If a local static has no explicit initializer, it is value initialized, meaning that local statics of built-in type are initialized to zero.

--
Function Declarations

Like any other name, the name of a function must be declared before we can use it. As with variables, a function may be defined only once but may be declared multiple times.

A function declaration is just like a function definition except that a declaration has no function body. In a declaration, a semicolon replaces the function body.
 
Because a function declaration has no body, there is no need for parameter names. Hence, parameter names are often omitted in a declaration. Although parameter names are not required, they can be used to help users of the function understand what the function does:
 
void print(vector<int>::const_iterator beg, vector<int>::const_iterator end);

Function declarations are also known as the function prototype.

Function Declarations Go in Header Files
 
Recall that variables are declared in header files and defined in source files. For the same reasons, functions should be declared in header files and defined in source files.

It may be tempting—and would be legal—to put a function declaration directly in each source file that uses the function. However, doing so is tedious and error-prone. When we use header files for our function declarations, we can ensure that all the
declarations for a given function agree. The source file that defines a function should include the header that contains that function’s declaration.

--
(findoverload)
Overloaded Functions

Functions that have the same name but different parameter lists and that appear in the same scope are overloaded.

Examples:

void print(const char *cp);
void print(const int *beg, const int *end);
void print(const int ia[], size_t size);

When we call these functions, the compiler can deduce which function we want based on the argument type we pass:

print("Hello World");        // calls print(const char*)
print(j, end(j) - begin(j)); // calls print(const int*, size_t)
print(begin(j), end(j));     // calls print(const int*, const int*)

Function overloading eliminates the need to invent—and remember—names that exist only to help the compiler figure out which function to call.

The main function may not be overloaded.

Overloaded functions must differ in the number or the type(s) of their parameters.

It is an error for two functions to differ only in terms of their return types.
 
Two parameter lists can be identical, even if they don’t look the same.

Although overloading lets us avoid having to invent (and remember) names for common operations, we should only overload operations that actually do similar things. There are some cases where providing different function names adds information that makes the program easier to understand.

Function matching (also known as overload resolution) is the process by which a particular function call is associated with a
specific function from a set of overloaded functions.

Names do not overload across scopes.

--
Default Arguments

string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');
 
Here we’ve provided a default for each parameter. A default argument is specified as an initializer for a parameter in the parameter list. We may define defaults for one or more parameters. However, if a parameter has a default argument, all the parameters that follow it must also have default arguments.

If we want to use the default argument, we omit that argument when we call the function.

window = screen();  // equivalent to screen(24,80,' ')

window = screen(66);// equivalent to screen(66,80,' ')
window = screen(66, 256);      // screen(66,256,' ')
window = screen(66, 256, '#'); // screen(66,256,'#')
 
Arguments in the call are resolved by position. 

The default arguments are used for the trailing (right-most) arguments of a call:

window = screen(, , '?'); // error: can omit only trailing arguments
window = screen('?');     // calls screen('?',80,' ')

Part of the work of designing a function with default arguments is ordering the parameters so that those least likely to use a default value appear first and those most likely to use a default appear last.

Default Argument Declarations
 
Although it is normal practice to declare a function once inside a header, it is legal to redeclare a function multiple times. However, each parameter can have its default specified only once in a given scope. Thus, any subsequent declaration can add a
default only for a parameter that has not previously had a default specified. As usual, defaults can be specified only if all parameters to the right already have defaults.

Local variables may not be used as a default argument.

--
Inline and constexpr Functions

