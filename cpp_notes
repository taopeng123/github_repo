stopa search in file

==
findcbegin                   C begin
findcscanf                   scanf in C
findcdatatype                Data types in C
findcstring                  Strin in C
findcbool                    Bool in C
findcinclude                 Include in C
findcheader                  Header in C
findcmath                    math.h in C
findcif                      if in C
findcswitch                  switch in C
findcwhile                   while in C
findcfor                     for in C
findccontinue                C has "continue" and "break"
findcbreak                   C has "continue" and "break"
findcgoto                    goto in C
findcarray                   Array in C
findcfunction                Function in C
findcstatic                  static & extern in C
findcextern                  static & extern in C
findcpointer                 Pointer in C
findcargs                    Command line argument C
findccommandlineargument     Command line argument C
findcstruct                  Struct in C
findcunion                   Union in C
findctypedef                 typedef in C
findcmalloc                  Dynamic memory allocation and free in C
findcmemory                  Dynamic memory allocation and free in C
findcconstant                Constant(ÂÆè) in C
findcfile                    File in C
findcreadfromfile            Read from file in C
findcreadfromfile             Write to file in C

findcppbegin                 C++ begin
findcompile                  Compile
findcompileseparate          Separate Compilation
findcomment                  Comments
findgooglestyle              Google C++ Style Guide
findcout                     cout
findcin                      cin 
findgetline                  getline
findmath                     Math operators
findpow                      power
findmax                      max
findmin                      min
findreadfromfile             Read from file and output to file
findwritetofile              Read from file and output to file
findio                       IO
findnamespace                Using Names from the Standard Library
findistream                  Example of using istream
findostream                  Example of using ostream
findcast                     Cast
findconvertdatatype          Convert data types
findtypeconversion           Convert data types
findfor                      Range for 
findrangefor                 Range for 
findstaticallytyped          Statically typed launage
findtype                     Data types
finddatatype                 Data types
findbool                     bool
findtypealias                Type alias
findtypedef                  typedef
finddecltype                 decltype
findauto                     auto
findliteral                  Literals
findvariable                 Variables
findidentifier               Identifiers
findscope                    Scope of a Name
findinitialization           Intialization
findlistinitialization       List Initialization
finddefaultinitialization    Default Initialization
findvalueinitialization      Value Initialization
finddirectinitialization     Direct Initialization
findcopyinitialization       Copy Initialization
finddeclaration              declaration 
finddefinition               definition
findmax                      max
findintmax                   INT_MAX
findmaxint                   INT_MAX
findintmin                   INT_MIN
findminint                   INT_MIN
findheader                   Headers
findinclude                  Headers
findpreprocessor             preprocessor
findreference                Reference
findpassbyvalue              Pass by value
findpassbyreference          Pass by reference
findpointer                  Pointer
findnull                     null pointer
findpointertoarray           Pointer to array & array of pointers
findreferencetoarray         Reference to array & array of references
findpointertofunction        Pointer to function
finddynamicmemory            Dynamic memory
findnew                      new operator
findconst                    Constant
findconstparameter           const in function parameter
findconstantexpression       Constant expression
findconstexpr                Constant expression
findsleep                    Sleep
findescape                   Escape sequence
findstring                   string
findsubstring                Substring (get and find substring)
findsplit                    split a string
findfind                     find the position of a substring in a string
findtrim                     trim
finderase                    erase
findargs                     Command line argument 
findcommandlineargument      Command line argument 
findcontainer                Sequential containers
findsequentialcontainer      Sequential containers
findcontainerlibrary         Container functions
findcontainerfunctions       Container functions
findcontainermethods         Container functions
findvector                   vector
findsortvector               Sort a vector
findunorderedcontainers      Unordered associative containers
findunorderedset             unordered_set
findset                      set
findunorderedmap             unordered_map
findmap                      map
findcontaineradaptor         Container Adaptors (stack, queue, priority_queue)
findstack                    stack
findqueue                    queue
findpriorityqueue            priority_queue
finddeque                    deque
finddequeue                  deque
findalgorithm                Generic algorithms
findgenericalgorithm         Generic algorithms
finditerator                 iterator
findarray                    array
findand                      AND operator
findoperator                 operators
findincrement                ++ and -- operators
finddecrement                ++ and -- operators
find++                       ++ and -- operators
find--                       ++ and -- operators
findsizeof                   sizeof
commaoperator                Comma operator
findif                       if 
findswitch                   switch
findwhile                    while
findfor                      for
findbreak                    break
findcontinue                 continue
findgoto                     goto
findexception                Exception
findfunction                 function
findparameter                Examples of function input parameters from Leetcode
findreturn                   return
findreturnvector             Return a vector from function
findreturnpointer            Return pointer from a function
findreturnreference          Return reference from a function
findstatic                   Static variables
findoverload                 Overloaded Functions
findinlinefunctions          Inline Functions
findconstexprfunctions       constexpr Functions
findassert                   assert
findndebug                   NDEBUG
findstruct                   struct
findclass                    class
findpublic                   public
findprivate                  private
findmemberfunction           member function
findconstmemberfunction      const member functions
findconstructor              constructor
findfriend                   friend
findstaticmember             static Class Members
finddestructor               destructor

=============
(findcbegin)
C begins

//Sample C program, printf example:

#include<stdio.h>

void main() {
	int i, sum = 0;	
	for(i = 1; i <= 100; i++) 
		sum = sum + i;	
	printf("sum = %d\n", sum);		
}

printf("%d, %d", a, b + c);

Format:
d: int
f: float
e,E: exponential
c: single character
s: string

==
(findcscanf)
scanf in C:

scanf is also in stdio.h

scanf("%d, %d, %d", &x, &y, &z); <- Input should be deliminated by ,
scanf("%d%d%d", &x, &y, &z); <- Input should be deliminated by any number of white spaces
s = max(x, y, z);
printf("max = %d\n", s);

Format is the same as printf

==
(findcdatatype)
Data types in C

type   number of bytes
char       1

==
(findcstring)
No string type in C:

There is no String variable type in C, but there is String constant type in C (eg, "abc").

The length of "ab" is 3, because it is stored as "ab\0"

string and char array:

char a[15];
char a[5] = {"BOY"}; 
char a[5] = "BOY";
char a[] = {"string!"};
char a[] = "string";
char a[4][8] = {"ZHANG", "ZHONG", "HUANG", "LIANG"};

char *hostname = "localhost";

//a is a string:
scanf("%s", a);
printf("%s\n", a);

The following string functions are in <string.h>:

strcat(s1, s2):  Catenate s1 and s2, return the address of the first element of the new char array. s1 can not be a string constant.

strcpy(s1, s2): Copy s2 into s1. s1 can not be a string constant.

strcmp(s1, s2): Compare two strings. Note that "s1 == s2" is wrong. Should use "strcmp(s1, s2) == 0".

strlen(s): Return the length of s, excluding the "\0" at end.

strlwr(s): Replace the uppercase chars in s to lowercase.

strupr(s): Replace the lowercase chars in s to uppercase.

==
(findcbool)
There is no bool type in C, it uses 1 to represent true, 0 to represent false.

==
(findcinclude)
(findcheader)
(findcmath)
Include in C
Headers in C
math.h in C

stdio.h, math.h, string.h:

math.h has the following functions:

cos(0.2), exp(0.2), fabs(0.2), log(0.2), log10(0.2), 
pow(0.2, 3.0) <- 0.2^3.0, 
sin(0.2), sqrt(0.2), tan(0.2)

--
When to use header files: when many programs use some common constants, data, etc, can put them into .h files.

Difference between the following two:
#include <xxx.h>
#include "xxx.h"

The difference is that: 
If use <xxx.h>, then the system will only search for the header file in the designated directory for header files (the include directory). For the header files provided by C, it saves searching time to use this way.
If use "xxx.h", then the system will first search for the header file in the current directory, then in the designated directory for header files (the include directory).

==
(findcif)
if in C

if(a < b) a = b;

if(...) {
	...
} else {
	...
}

--
string finalgrade = (grade < 60) ? "fail" : "pass";

==
(findcswitch)
Switch in C

switch(grade) {
	case 'A': printf("Excellent\n");
	case 'B': printf("Good\n");
	case 'C': printf("Pass\n");
	case 'D': printf("Fail\n");
	default: printf("Invalid input.\n");
}

==
(findcwhile)
While in C

while(x > 0) printf("Helo\n");

--
do {
	i--;
	printf("a");
} while(i >= 0);

==
(findcfor)
for in C

for(i = 1; i <= 100; i++) 
	sum = sum + i;	

==
(findccontinue)
(findcbreak)

C has "continue" and "break"

==
(findcgoto)
goto in C

s = 0.0;
goto cal;
s = 0.5 * 2;
cal: printf("a");

==
(findcarray)
Array in C

int a[10];
a[0] = 1;
int x[3] = {1, 2, 3};
int x[] = {1, 2, 3}; //Can omit the length

int x[3] = {0, 0, 0}; 
can be written as 
int x[3] = {0};

double s[5][5]

int x[2][4] = {{1,2,3,4}, {6,7,8,9}};
is equivalent as
int x[2][4] = {1,2,3,4,5,6,7,8,9};

Array name is the address of the 0-th element
These two expressions are equivalent: a, &a[0]
These two expressions are equivalent: a[i], *(a+i)

2-D array name is the address of the 0-th row.

==
(findcfunction)
Function in C

int max(int a, int b) {
    if(a > b) return a;
    else return b;
}

If no returned value, use void. 
If no parameters, use ():

void func() {
    printf("a");
}

main function usually has no parameters, unlike Java.

Function parameters are often passed by value. But for array names, it passes its address, so it is passed by reference.

For array as parameter, can define an empty array (tao: in the parameter parenthesis). If need to operate on its elemets, can use another parameter to denote its length:

void sort_string(char str[], int n) {
    ...
}

// Call the above function in another functin:
char str[30]=‚ÄùABCDEFGHIJKLMNOPQRSTUVWXYZ‚Äù;
int i=26;
sort_string(str, i);

==
(findcstatic)
(findcextern)
static & extern in C

Static variable: 
Static variable in a function will have their values kept even after this function is been called.
Exmaple: 
static int i;

Extern variable: 
Can be used in two cases:
1. In a file, can define a variable as extern and use this variable before its definition. Before using it, need to declare it using "extern". 
2. In a file, can define a variable as extern and use this variable in another file. Before using it, need to declare it using "extern". 
Example: none.

Static function:
Can only be used in the same file.
Example: none.

Extern function:
Can be used in other files. If a function definition has no keyword "extern", then it is still extern by default. Before using extern function in another file, need to declare it using "extern". 
Example: none.

==
(findcpointer)
Pointer in C

int *p = &i;
// Pointer p equals the address of i
// Then *p is i, *p = 100 is equivalent to i = 100

If a pointer = 0, it means it does not point to anything.

Print the address of a variable:
printf("%p\n",(void*)&a);

Pointers must be initialized.

int a[20], *p;
p = &a[0]; // p points to the address of a[0]
p += 2; // p points to the address of a[2]

a = &a[1];
b = &a[3];
Then (b - a) equals 2

int* p[3]: p is an array of pointers (can be easily understood)
int (*p)[3]: p is a pointer which points to an array (because the above is array of pointers, so here it is a pointer which...)

Pointer to functions can be rememebered in the save way as above:
int* f(int x); //f is a function which returns pointer
int (*f)(int x); //f is a pointer which points to a function

int func(int x);
int (*f)(int x);
f = func; <- func has no (), no parameters. Function name is the address of the entrance of function.
(*f) is equivalent as func, eg (*f)(x)

Array name as function parameter (in a similar way as Java):

// Tao remembers online says this way passes by copying the array and this way should be avoided, needs to confirm
void sort(int x[], int n) {
	...
}

void main() {
	int a[10];
	...
	sort(a, 10);
}

A pointer to a string is the address of the first character in the string.

==
(findcargs)
(findccommandlineargument)
Convert command line argument to string in C

#include <iostream>
#include <string>
#include <vector>

int main(int argc, char *argv[]) // Don't forget first integral argument 'argc', which is count of arguments plus the current exec file.
{
  std::string current_exec_name = argv[0]; // Name of the current exec program
  std::string first_arge;
  std::vector<std::string> all_args;

  if (argc > 1) {
    first_arge = argv[1];
    all_args.assign(argv + 1, argv + argc);
  }
}


==
(findcstruct)
Struct in C

From online:
Should struct definitions go in .h or .c file?
Private structures for that file should go in the .c file, 
with a declaration in the .h file if they are used by any functions in the .h .
Public structures should go in the .h file.

struct date {
    int year;
    int month;
    int day;
}; // Don't forget the ;

struct date d;

The above two statements can be written together:

struct date {
    int year;
    int month;
    int day;
} d;

Initialize struct:

struct date {
    int year;
    int month;
    int day;
} d = {1977, 11, 14};

int y = date.year;

struct array (every element is a struct type):

struct date d[3];
struct date d[3] = {{1977, 11, 14}, {1980, 3, 5};
struct date d[] = {{1977, 11, 14}, {1980, 3, 5}; //Can omit the length

A pointer to a struct points to the initial address of the struct.

struct date d;
struct date *p;
p = &d;
(*p).year
p->year

Linked list node (note the next pointer):

struct student {
    char name[8];
    float score;
    struct student *next;
}

==
(findcunion)
Union in C

union utag {
    int i;
    float f;
    char c;
};

The definition of union is the same as struct.
The reference to memebers of union (including pointers) is also the same as struct.

The difference between struct and union:
The members in a struct have their own memory units. The size of a struct is the sum of the size of its members.
The members in a union share the same memory unit. The size of a union is the size of its largest member. Tao's understanding is that a union can be different types (any of its member type) at different times. Just like Á≤æÁ•ûÂàÜË£ÇÁóá.

Can only initialize the first member of a union, can not initialize all members:

Correct:

union utag {
    int i;
    float f;
    char c;
} u1 = {100};

Wrong:

union utag u2 = {100, 31.6, 'a'};

==
(findctypedef)
typedef in C

typedef defines new type which is equivalent as original types, like an alias:

typedef int INTEGER;
INTEGER x, y;

typedef char *POINTER;
POINTER p;
//Equivalent as: char *p;

typedef struct {
    int year;
    int month;
    int day;
} DATE;

DATE birthday;

//Equivalent as:

struct {
    int year;
    int month;
    int day;
} birthday;

typedef char STRING[50];
STRING s1, s2;
//Equivalent to: char s1[50], s2[50];

Good:
Steps to use typedef:
1. Write down the ordinary definition of a variale, like: char str[50];
2. Replace the variable name with new type name, like replace "str" with "STRING" -> char STRING[50];
3. Add "typedef" in front, like: typedef char STRING[50];
4. Then can use the new type name to define variables, like: STRING s1, s2;


==
(findcmalloc)
(findcmemory)
Dynamic memory allocation and free in C

#include <stdlib.h>

int *p;
p = (int *) malloc(sizeof(int)); //Allocates a memory of size int type, p points to this memory

struct date {
    int year;
    int month;
    int day;
} *q;

q = (struct date *) malloc(sizeof(struct date));

free(p); //Free the memory pointed by p

==
(findcconstant)
Constant in C
ÂÆè in C

#define PI 3.14
int a = PI;

==
(findcfile)
(findcreadfromfile)
(findwritetofilec)
File in C
Read from file in C
Write to file in C

All the following should include:
#include "sdio.h"

//Open a file:
FILE *fp;
fp = fopen("file1", "r");

//Close a file:
fclose(fp); //Now fp no longer points to this file

//Close all files:
fcloseall();

//Get a character from file:
ch = fgetc(fp);

//Returns whether fp points to the end of file:
feof(fp);

//Write a character to file at location pointed by fp:
fputc("a", fp);
fputc(c, stdout)//Outputs character c to terminal (screen), no "" around c.

//Read a string:
fgets()

//Write a string:
fputs()

//Read and print to file
fscanf(), fprintf()

//Read binary files:
fread(), fwrite()

//Foce the pointer fp to point to the beginning of file:
rewind(fp);

//Set the pointer position
fseek(file-pinter, offset, start-point)

*** C all recorded ***

====
(findcppbegin)
C++ begins

Most of this note is from the book "C++ Primer (Fifth Edition)", by Stanley B. Lippman, Josee Lajoie, Barbara E. Moo.

Whenever it says the new standard, it means the C++ 11 standard.

==
Program files are normally referred to as a source files. Different compilers use different suffix conventions; the most common include .cc, .cxx, .cpp, .cp, and .C.

--
(findcompile)
Compile

g++ -o file_name file_name.cc

Using C++ 11, in my Thinkpad (recommended to always compile in this way in my Thinkpad):
g++ -std=c++0x -o file_name file_name.cc

When writing leetcode, I can still compile using -std=c++11 in my Thinkpad.

Using C++ 11, in Mac:
g++ -std=c++11 -o file_name file_name.cc

Simpler way to compile and run:
g++ foo.c
./a.out

--
$ g++ -o prog1 prog1.cc

The -o prog1 is an argument to the compiler and names the file in which to put the executable file. This command generates an executable file named prog1. On UNIX, executable files have no suffix; If the -o prog1 is omitted, the compiler generates an executable named a.out on UNIX systems.

--
UNIX compilers tend to put their executables in files named a.out.

To run an executable on UNIX, we use the full file name, including the file extension:
$ a.out

If we need to specify the file‚Äôs location, we‚Äôd use a ‚Äú.‚Äù followed by a forward slash to indicate that our executable is in the current directory:
$ ./a.out

--
Compilers usually include options to generate warnings about problematic constructs. It is usually a good idea to use these options. Our preference is to use -Wall with the GNU compiler.

--
Often a single error can have a cascading effect and cause a compiler to report more errors than actually are present.

--
Some languages, such as Smalltalk and Python, check types at run time. In contrast, C++ is a statically typed language; type checking is done at compile time. As a consequence, the compiler must know the type of every name used in the program.

Key Concept: Static Typing

C++ is a statically typed language, which means that types are checked at compile time. The process by which types are checked is referred to as type checking.

As we‚Äôve seen, the type of an object constrains the operations that the
object can perform. In C++, the compiler checks whether the operations we write are supported by the types we use. If we try to do things that the type does not support, the compiler generates an error message and does not produce an executable file.

As our programs get more complicated, we‚Äôll see that static type checking can help find bugs. However, a consequence of static checking is that the type of every entity we use must be known to the compiler. As one example, we must declare the type of a variable before we can use that variable.

==
Sample C++ program:

#include<iostream>
using namespace std;
//using std::cout; <- can also use this

int main() {
    double a = 2.6;
    cout << a << endl;
    return 0;
}

Note that the main() function should be outside any class, which is opposite to Java.

--
On most systems, the value returned from main is a status indicator. A return value of 0 indicates success. A nonzero return has a meaning that is defined by the system. Ordinarily a nonzero return indicates what kind of error occurred.

A return value of -1 is often treated as an indicator that the program failed.

--
(findcomment)
Comments

There are two kinds of comments in C++: single-line and paired. A single-line comment starts with a double slash (//) and ends with a newline.

The other kind of comment uses two delimiters (/* and */) that are inherited from C.

Our style is to begin each line in the comment with an asterisk, thus indicating that the entire range is part of a multiline comment.

#include <iostream>
/*
 * Simple main function:
 * Read two numbers and write their sum
 */
int main()
{
    ...
}

When you change your code, be sure to update the comments, too!

A comment that begins with /* ends with the next */. As a result, one comment pair cannot appear inside another. The compiler error messages that result from this kind of mistake can be mysterious and confusing.

We often need to comment out a block of code during debugging. Because that code might contain nested comment pairs, the best way to comment a block of code is to insert single-line comments at the beginning of each line in the section we want to ignore.

==
(findgooglestyle)
Google C++ Style Guide:

https://google.github.io/styleguide/cppguide.html

==
Google's naming conventions:

(https://google.github.io/styleguide/cppguide.html#General_Naming_Rules)

Naming
The most important consistency rules are those that govern naming. The style of a name immediately informs us what sort of thing the named entity is: a type, a variable, a function, a constant, a macro, etc., without requiring us to search for the declaration of that entity. The pattern-matching engine in our brains relies a great deal on these naming rules.

Naming rules are pretty arbitrary, but we feel that consistency is more important than individual preferences in this area, so regardless of whether you find them sensible or not, the rules are the rules.

General Naming Rules
Names should be descriptive; avoid abbreviation.

Give as descriptive a name as possible, within reason. Do not worry about saving horizontal space as it is far more important to make your code immediately understandable by a new reader. Do not use abbreviations that are ambiguous or unfamiliar to readers outside your project, and do not abbreviate by deleting letters within a word. Abbreviations that would be familiar to someone outside your project with relevant domain knowledge are OK. As a rule of thumb, an abbreviation is probably OK if it's listed in Wikipedia.

int price_count_reader;    // No abbreviation.
int num_errors;            // "num" is a widespread convention.
int num_dns_connections;   // Most people know what "DNS" stands for.
int lstm_size;             // "LSTM" is a common machine learning abbreviation.
int n;                     // Meaningless.
int nerr;                  // Ambiguous abbreviation.
int n_comp_conns;          // Ambiguous abbreviation.
int wgc_connections;       // Only your group knows what this stands for.
int pc_reader;             // Lots of things can be abbreviated "pc".
int cstmr_id;              // Deletes internal letters.
FooBarRequestInfo fbri;    // Not even a word.
Note that certain universally-known abbreviations are OK, such as i for an iteration variable and T for a template parameter.

For some symbols, this style guide recommends names to start with a capital letter and to have a capital letter for each new word (a.k.a. "Camel Case" or "Pascal case"). When abbreviations or acronyms appear in such names, prefer to capitalize the abbreviations or acronyms as single words (i.e StartRpc(), not StartRPC()).

Template parameters should follow the naming style for their category: type template parameters should follow the rules for type names, and non-type template parameters should follow the rules for variable names.

File Names

Filenames should be all lowercase and can include underscores (_) or dashes (-). Follow the convention that your project uses. If there is no consistent local pattern to follow, prefer "_".

Examples of acceptable file names:

my_useful_class.cc
my-useful-class.cc
myusefulclass.cc
myusefulclass_test.cc // _unittest and _regtest are deprecated.

C++ files should end in .cc and header files should end in .h. Files that rely on being textually included at specific points should end in .inc (see also the section on self-contained headers).

Do not use filenames that already exist in /usr/include, such as db.h.

In general, make your filenames very specific. For example, use http_server_logs.h rather than logs.h. A very common case is to have a pair of files called, e.g., foo_bar.h and foo_bar.cc, defining a class called FooBar.

Type Names

Type names start with a capital letter and have a capital letter for each new word, with no underscores: MyExcitingClass, MyExcitingEnum.

The names of all types ‚Äî classes, structs, type aliases, enums, and type template parameters ‚Äî have the same naming convention. Type names should start with a capital letter and have a capital letter for each new word. No underscores. For example:

// classes and structs
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedefs
typedef hash_map<UrlTableProperties *, string> PropertiesMap;

// using aliases
using PropertiesMap = hash_map<UrlTableProperties *, string>;

// enums
enum UrlTableErrors { ...

Variable Names

The names of variables (including function parameters) and data members are all lowercase, with underscores between words. Data members of classes (but not structs) additionally have trailing underscores. For instance: a_local_variable, a_struct_data_member, a_class_data_member_.

Common Variable names

For example:

string table_name;  // OK - uses underscore.
string tablename;   // OK - all lowercase.
string tableName;   // Bad - mixed case.

Class Data Members

Data members of classes, both static and non-static, are named like ordinary nonmember variables, but with a trailing underscore.

class TableInfo {
  ...
 private:
  string table_name_;  // OK - underscore at end.
  string tablename_;   // OK.
  static Pool<TableInfo>* pool_;  // OK.
};

Struct Data Members

Data members of structs, both static and non-static, are named like ordinary nonmember variables. They do not have the trailing underscores that data members in classes have.

struct UrlTableProperties {
  string name;
  int num_entries;
  static Pool<UrlTableProperties>* pool;
};
See Structs vs. Classes for a discussion of when to use a struct versus a class.

Constant Names

Variables declared constexpr or const, and whose value is fixed for the duration of the program, are named with a leading "k" followed by mixed case. Underscores can be used as separators in the rare cases where capitalization cannot be used for separation. For example:

const int kDaysInAWeek = 7;
const int kAndroid8_0_0 = 24;  // Android 8.0.0
All such variables with static storage duration (i.e. statics and globals, see Storage Duration for details) should be named this way. This convention is optional for variables of other storage classes, e.g. automatic variables, otherwise the usual variable naming rules apply.

Function Names

Regular functions have mixed case; accessors and mutators may be named like variables.

Ordinarily, functions should start with a capital letter and have a capital letter for each new word.

AddTableEntry()
DeleteUrl()
OpenFileOrDie()

(The same naming rule applies to class- and namespace-scope constants that are exposed as part of an API and that are intended to look like functions, because the fact that they're objects rather than functions is an unimportant implementation detail.)

Accessors and mutators (get and set functions) may be named like variables. These often correspond to actual member variables, but this is not required. For example, int count() and void set_count(int count).

==
(findtype)
(finddatatype)                 
Data types

C++ defines a set of primitive types that include the arithmetic types and a special type named void. The arithmetic types represent characters, integers, boolean values, and floating-point numbers. The void type has no associated values and can be used in only a few circumstances, most commonly as the return type for functions that do
not return a value.

Arithmetic Types

The arithmetic types are divided into two categories: integral types (which include character and boolean types, tao: should also include int) and floating-point types.

Tao: integral types means: int, character, boolean types. The concept of integral types will be used later.

The size of‚Äîthat is, the number of bits in‚Äîthe arithmetic types varies across machines. The standard guarantees minimum sizes as listed in the following table. However, compilers are allowed to use larger sizes for these types. 

Type         Meaning                            Minimum Size   
bool         boolean                            NA
char         character                          8 bits
wchar_t      wide character                     16 bits
char16_t     Unicode character                  16 bits
char32_t     Unicode character                  32 bits
short        short integer                      16 bits
int          integer                            16 bits
long         long integer                       32 bits
long long    long integer                       64 bits
float        single-precision floating-point    6 significant digits
double       double-precision floating-point    10 significant digits
long double  exteneded-precision floating-point 10 significant digits

A simpler version of the above table:

Type     Minimum Size
bool     NA
char     8 bits
int      16 bits
long     32 bits
float    6 significant digits
double   10 siginifcant digits

1 byte = 8 bits
On most machines a byte contains 8 bits and a word is either 32 or 64 bits.
(Remember: "byte" is longer than "bit")

A char is the same size as a single machine byte.

Unicode is a standard for representing characters used in essentially any natural language.

Typically, floats are represented in one word (32 bits), doubles in two words (64 bits).

--
Tao: the following is very helpful on understanding how data types are stored in memory:

Machine-Level Representation of the Built-in Types

Computers store data as a sequence of bits, each holding a 0 or 1, such as

00011011011100010110010000111011 ...

Most computers deal with memory as chunks of bits of sizes that are powers of 2. The smallest chunk of addressable memory is referred to as a ‚Äúbyte.‚Äù The basic unit of storage, usually a small number of bytes, is referred to as a ‚Äúword.‚Äù In C++ a byte has at least as many bits as are needed to hold a character in the machine‚Äôs basic character set. On most machines a byte contains 8 bits and a word is either 32 or 64 bits, that is, 4 or 8 bytes. Tao: So we know the size of byte and word is machine dependent.

Most computers associate a number (called an ‚Äúaddress‚Äù) with each byte in memory. On a machine with 8-bit bytes and 32-bit words, we might view a word of memory as follows

736424: 0 0 1 1 1 0 1 1
736425: 0 0 0 1 1 0 1 1
736426: 0 1 1 1 0 0 0 1
736427: 0 1 1 0 0 1 0 0 

Here, the byte‚Äôs address is on the left, with the 8 bits of the byte following the address.

We can use an address to refer to any of several variously sized collections of bits starting at that address. It is possible to speak of the word at address 736424 or the byte at address 736427. To give meaning to memory at a given address, we must know the type of the value stored there. The type determines how many bits are used and how to interpret those bits.

If the object at location 736424 has type float and if floats on this
machine are stored in 32 bits, then we know that the object at that address spans the entire word. The value of that float depends on the details of how the machine stores floating-point numbers. Alternatively, if the object at location 736424 is an unsigned char on a machine using the ISO-Latin-1 character set, then the byte at that address represents a semicolon.

--
Signed and Unsigned Types

Except for bool and the extended character types, the integral types may be signed or unsigned. A signed type represents negative or positive numbers (including zero); an unsigned type represents only values greater than or equal to zero.

The types int, short, long, and long long are all signed. We obtain the
corresponding unsigned type by adding unsigned to the type, such as unsigned long. The type unsigned int may be abbreviated as unsigned.

Unlike the other integer types, there are three distinct basic character types: char, signed char, and unsigned char. In particular, char is not the same type as signed char. Although there are three character types, there are only two representations: signed and unsigned. The (plain) char type uses one of these representations. Which of the other two character representations is equivalent to char depends on the compiler.

In an unsigned type, all the bits represent the value. For example, an 8-bit unsigned char can hold the values from 0 through 255 inclusive.

Tao: 

 11,111,111 = 255
100,000,000 = 256 (2^8)

The standard does not define how signed types are represented, but does specify that the range should be evenly divided between positive and negative values. Hence, an 8-bit signed char is guaranteed to be able to hold values from ‚Äì127 through 127; most modern machines use representations that allow values from ‚Äì128 through 127.

--
Advice: Deciding which Type to Use

C++, like C, is designed to let programs get close to the hardware when
necessary. 

A few rules of thumb can be useful in deciding which type to use:

‚Ä¢ Use an unsigned type when you know that the values cannot be negative.

‚Ä¢ Use int for integer arithmetic. short is usually too small and, in practice, long often has the same size as int. If your data values are larger than the minimum guaranteed size of an int, then use long long.

‚Ä¢ Do not use plain char or bool in arithmetic expressions. Use them only to hold characters or truth values. Computations using char are especially problematic because char is signed on some machines and unsigned on others. If you need a tiny integer, explicitly specify either signed char or unsigned char.

‚Ä¢ Use double for floating-point computations; float usually does not have enough precision, and the cost of double-precision calculations versus single-precision is negligible. In fact, on some machines, double-precision operations are faster than single. The precision offered by long double usually is unnecessary and often entails considerable run-time cost.

--
(findbool)
bool:

bool test = false; // The words true and false are literals of type bool

bool b = 42;
int i = b; // i has value 1

When we assign one non-bool types to a bool, the result is false if the value is 0, and true otherwise.

When we use a bool in an arithmetic expression, its value always converts to either 0 or 1.

The word nullptr is a pointer literal.

It is usually a bad idea to use the boolean literals true and false as operands in a comparison. For example:
if (val == true) { /* ...   */ }

Better way:
if (val)  { /*  ...  */ }

--
(findcast)
(findconvertdatatype)
(findtypeconversion)
Cast
Convert data types

//string -> int
#include <string>  
string str1 = "45";
int myint1 = stoi(str1); // myint1 = 45

//int -> string
int a = std::to_string(28); // a = "28"

//string -> double
string stest = "0.21";
double dtest = stod(stest);

//double -> string
string pi = std::to_string(3.1415926); // pi = "3.1415926" 

//int -> double
int a = 2;
double b = (double) a;

//double -> int
double a = 3.0;
double b = (int) a;

//char -> string
//constructor string s(int n, char x): Create a string of size n and fill the string with character x.
string s(1, 'a'); //s = "a"

--
cast:

The above "(int) a" is the old-style C++ casts. New styles are followings.

Although necessary at times, casts are inherently dangerous constructs.

Named Casts

A named cast has the following form:
cast-name<type>(expression);

where type is the target type of the conversion, and expression is the value to be cast. The cast-name may be one of static_cast, dynamic_cast, const_cast, and reinterpret_cast.

Old-style casts are less visible than are named casts. Because they are easily overlooked, it is more difficult to track down a rogue(ÊµÅÊ∞ì) cast.

==
Type Conversions

bool b = 42; // b is true

When we assign one of the nonbool arithmetic types to a bool object, the result is false if the value is 0 and true otherwise.

--
int i = b; // i has value 1

When we assign a bool to one of the other arithmetic types, the resulting value is 1 if the bool is true and 0 if the bool is false.

--
i = 3.14; // i has value 3

When we assign a floating-point value to an object of integral type, the value is truncated. The value that is stored is the part before the decimal point.

--
double pi = i; // pi has value 3.0

When we assign an integral value to an object of floating-point type, the fractional part is zero. Precision may be lost if the integer has more bits than the floating-point object can accommodate.

--
unsigned char c = -1; // assuming 8-bit chars, c has value 255

If we assign an out-of-range value to an object of unsigned type, the result is the remainder of the value modulo the number of values the target type can hold. For example, an 8-bit unsigned char can hold values from 0 through 255, inclusive. If we assign a value outside this range, the compiler assigns the remainder of that value modulo 256. Therefore, assigning ‚Äì1 to an 8-bit unsigned char gives that object the value 255.

--
signed char c2 = 256; // assuming 8-bit chars, the value of c2 is undefined

If we assign an out-of-range value to an object of signed type, the result is undefined. The program might appear to work, it might crash, or it might produce garbage values.

--
The compiler applies these same type conversions when we use a value of one arithmetic type where a value of another arithmetic type is expected.

int i = 42;
if (i) // condition will evaluate as true
    i = 0;

By the same token, when we use a bool in an arithmetic expression, its value always converts to either 0 or 1. As a result, using a bool in an arithmetic expression is almost surely incorrect.

// WRONG: u can never be less than 0; the condition will always succeed
for (unsigned u = 10; u >= 0; --u)
    std::cout << u << std::endl;

Caution: Don‚Äôt Mix Signed and Unsigned Types

Expressions that mix signed and unsigned values can yield surprising results when the signed value is negative. It is essential to remember that signed values are automatically converted to unsigned.

--
Programs usually should avoid implementation-defined behavior, such as assuming that the size of an int is a fixed and known value. Such programs are said to be nonportable.

==
(findtypealias)
(findtypedef)
Type alias
typedef

A type alias is a name that is a synonym(ÂêåÁæ©Ë©û) for another type. Type aliases let us simplify complicated type definitions, making those types easier to use. 

We can define a type alias in one of two ways. Traditionally, we use a typedef:

typedef double wages; // wages is a synonym for double
typedef wages base, *p; // base is a synonym for double, p for double*

The new standard introduced a second way to define a type alias, via an alias declaration:

using SI = Sales_item; // SI is a synonym for Sales_item

wages hourly, weekly; // same as double hourly, weekly;
SI item; // same as Sales_item item

using pos = std::string::size_type; // pos is a synonym for std::string::size_type

--
(findauto)
auto

(Tao deliberately put auto in front of decltype)

It is not uncommon to want to store the value of an expression in a variable. To declare the variable, we have to know the type of that expression. When we write a program, it can be surprisingly difficult‚Äîand sometimes even impossible‚Äîto
determine the type of an expression. Under the new standard, we can let the compiler figure out the type for us by using the auto type specifier. Unlike type specifiers, such as double, that name a specific type, auto tells the compiler to deduce the type from the initializer. By implication, a variable that uses auto as its type specifier must have an initializer:

auto item = val1 + val2; // the type of item is deduced from the type of the result of adding val1 and val2, item initialized to the result of val1 + val2

Here the compiler will deduce the type of item from the type returned by applying + to val1 and val2. If val1 and val2 are Sales_item objects, item will have type Sales_item. If those variables are type double, then item has type double, and so on.

As with any other type specifier, we can define multiple variables using auto. Because a declaration can involve only a single base type, the initializers for all the variables in the declaration must have types that are consistent with each other:

auto i = 0, *p = &i; // ok: i is int and p is a pointer to int
auto sz = 0, pi = 3.14; // error: inconsistent types for sz and pi

when we use a reference as an initializer, the initializer is the corresponding object. The compiler uses that object‚Äôs type for auto‚Äôs type deduction:

int i = 0, &r = i;
auto a = r; // a is an int (r is an alias for i, which has type int)

Second, auto ordinarily ignores top-level consts. As usual in
initializations, low-level consts, such as when an initializer is a pointer to const, are kept:

const int ci = i, &cr = ci;
auto b = ci; // b is an int (top-level const in ci is dropped)
auto c = cr; // c is an int (cr is an alias for ci whose const is top-level)
auto d = &i; // d is an int*(& of an int object is int*)
auto e = &ci; // e is const int*(& of a const object is low-level const)

If we want the deduced type to have a top-level const, we must say so explicitly:

const auto f = ci; // deduced type of ci is int; f has type const int

--
(finddecltype)
decltype

Sometimes we want to define a variable with a type that the compiler deduces from an expression but do not want to use that expression to initialize the variable. For such cases, the new standard introduced a second type specifier, decltype, which
returns the type of its operand. The compiler analyzes the expression to determine its type but does not evaluate the expression:

decltype(f()) sum = x; // sum has whatever type f returns

Here, the compiler does not call f, but it uses the type that such a call would return as the type for sum. That is, the compiler gives sum the same type as the type that would be returned if we were to call f.

The way decltype handles top-level const and references differs subtly from the way auto does. When the expression to which we apply decltype is a variable, decltype returns the type of that variable, including top-level const and references:

const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x has type const int
decltype(cj) y = x; // y has type const int& and is bound to x
decltype(cj) z; // error: z is a reference and must be initialized

Because cj is a reference, decltype(cj) is a reference type. Like any other reference, z must be initialized.

It is worth noting that decltype is the only context in which a variable defined as a reference is not treated as a synonym for the object to which it refers.

decltype and References

When we apply decltype to an expression that is not a variable, we get the type that that expression yields. As we‚Äôll see later, some expressions will cause decltype to yield a reference type. Generally speaking, decltype returns a reference type for expressions that yield objects that can stand on the left-hand side of the assignment:

// decltype of an expression can be a reference type
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; // ok: addition yields an int; b is an (uninitialized) int
decltype(*p) c; // error: c is int& and must be initialized. Tao: note &i means the address of i, &i has nothing to do with reference.

Here r is a reference, so decltype(r) is a reference type. If we want the type to which r refers, we can use r in an expression, such as r + 0, which is an expression that yields a value that has a nonreference type.

On the other hand, the dereference operator is an example of an expression for which decltype returns a reference. As we‚Äôve seen, when we dereference a pointer, we get the object to which the pointer points. Moreover, we can assign to that object.
Thus, the type deduced by decltype(*p) is int&, not plain int.

Another important difference between decltype and auto is that the deduction done by decltype depends on the form of its given expression. What can be confusing is that enclosing the name of a variable in parentheses affects the type returned by decltype. When we apply decltype to a variable without any parentheses, we get the type of that variable. If we wrap the variable‚Äôs name in one or more sets of parentheses, the compiler will evaluate the operand as an expression. A variable is an expression that can be the left-hand side of an assignment. As a result, decltype on such an expression yields a reference:

// decltype of a parenthesized variable is always a reference
decltype((i)) d; // error: d is int& and must be initialized
decltype(i) e; // ok: e is an (uninitialized) int

Remember that decltype((variable)) (note, double parentheses) is always a reference type, but decltype(variable) is a reference type only if variable is a reference.

==
(findliteral)
Literals

A value, such as 42, is known as a literal because its value self-evident. Every literal has a type. The form and value of a literal determine its type.

Integer and Floating-Point Literals

We can write an integer literal using decimal(ÂçÅÈÄ≤Âà∂), octal(ÂÖ´ÈÄ≤Âà∂), or hexadecimal(ÂçÅÂÖ≠ÈÄ≤Âà∂) notation (Ê≥®ÊÑèÊ≤íÊúâ‰∫åÈÄ≤Âà∂!). Integer literals that begin with 0 (zero) are interpreted as octal. Those that begin with either 0x or 0X are interpreted as hexadecimal. For example, we can write the value 20 in any of the following three ways:

20: decimal 
024: octal
0x14: hexadecimal

The type of an integer literal depends on its value and notation. By default, decimal literals are signed whereas octal and hexadecimal literals can be either signed or unsigned types. A decimal literal has the smallest type of int, long, or long long (i.e., the first type in this list) in which the literal‚Äôs value fits. We‚Äôll see in the following table that we can override these defaults by using a suffix.

Specifying the Type of a Literal

Character and Character String Literals (tao: note it is prefix, not suffix):

Prefix  Type       Meaning     
u       char16_t   Unicode 16 character
U       char32_t   Unicode 32 character
L       wchar_t    wide character
u8      char       utf-8 (string literals only)

Integer Literals:

Suffix     Minimum Type
u or U     unsinged
l or L     long
ll or LL   long long

Floating-Point Literals:

Suffix     Type
f or F     float
l or L     long double

Although integer literals may be stored in signed types, technically speaking, the value of a decimal literal is never a negative number. If we write what appears to be a negative decimal literal, for example, -42, the minus sign is not part of the literal. The minus sign is an operator that negates the value of its (literal) operand.

Floating-point literals include either a decimal point or an exponent specified using scientific notation. Using scientific notation, the exponent is indicated by either E or e:

3.14159   3.14159E0   0.   0e0   .001

By default, floating-point literals have type double. We can override the default using a suffix from the above table.

--
Character and Character String Literals

A character enclosed within single quotes is a literal of type char. Zero or more characters enclosed in double quotation marks is a string literal:

'a' // character literal
"Hello World!" // string literal

The type of a string literal is array of constant chars (tao: not a library string type!), a type we‚Äôll discuss later. The compiler appends a null character (‚Äô\0‚Äô) (tao: not a null pointer) to every string literal. Thus, the actual size of a string literal is one more than its apparent size. For example, the literal 'A' represents the single character A, whereas the string literal "A" represents an array of two characters, the letter A and the null character.

Two string literals that appear adjacent to one another and that are separated only by spaces, tabs, or newlines are concatenated into a single literal. We use this form of literal when we need to write a literal that would otherwise be too large to fit comfortably on a single line:

// multiline string literal
std::cout << "a really, really long string literal "
             "that spans two lines" << std::endl;

--
(findescape)
Escape Sequences

Some characters, such as backspace or control characters, have no visible image. Such characters are nonprintable. Other characters (single and double quotation marks, question mark, and backslash) have special meaning in the language. Our programs cannot use any of these characters directly. Instead, we use an escape sequence to represent such characters. An escape sequence begins with a backslash. The language
defines several escape sequences:

newline \n 
horizontal tab \t 
alert (bell) \a
vertical tab \v 
backspace \b 
double quote \"
backslash \\ 
question mark \? 
single quote \'
carriage return \r 
formfeed \f

We use an escape sequence as if it were a single character:

std::cout << '\n'; // prints a newline
std::cout << "\tHi!\n"; // prints a tab followd by "Hi!" and a newline

We can also write a generalized escape sequence, which is \x followed by one or more hexadecimal digits or a \ followed by one, two, or three octal digits. The value represents the numerical value of the character. Some examples (assuming the Latin-1 character set):

\7 (bell) \12 (newline) \40 (blank)
\0 (null) \115 ('M') \x4d ('M')

--
Boolean and Pointer Literals

The words true and false are literals of type bool:

bool test = false;

The word nullptr is a pointer literal. We‚Äôll have more to say about pointers and nullptr later.

==
(findvariable)
Variables

A variable provides us with named storage that our programs can manipulate. Each variable in C++ has a type. The type determines the size and layout of the variable‚Äôs memory, the range of values that can be stored within that memory, and the set of operations that can be applied to the variable. C++ programmers tend to refer to variables as ‚Äúvariables‚Äù or ‚Äúobjects‚Äù interchangeably.

C++ programmers tend to be cavalier in their use of the term object. Most generally, an object is a region of memory that can contain data and has a type.

In this book, we‚Äôll follow the more general usage that an object is a region of memory that has a type. We will freely use the term object regardless of whether the object has built-in or class type, is named or unnamed, or can be read or written.

// string is a library type, representing a variable-length sequence of characters
std::string book("0-201-78345-X"); // book initialized from string
literal

The string library gives us several ways to initialize string objects. One of these ways is as a copy of a string literal.

==
(findidentifier)
Identifiers

Identifiers in C++ can be composed of letters, digits, and the underscore character. The language imposes no limit on name length. Identifiers must begin with either a letter or an underscore. Identifiers are case-sensitive; upper- and lowercase letters are
distinct:

// defines four different int variables
int somename, someName, SomeName, SOMENAME;

The identifiers we define in our own programs may not contain two consecutive underscores, nor can an identifier begin with an underscore followed immediately by an uppercase letter. In addition, identifiers defined outside a function may not begin with an underscore.

The language reserves a set of names for its own use. These names may not be used as identifiers.

Conventions for Variable Names

There are a number of generally accepted conventions for naming variables. Following these conventions can improve the readability of a program.

‚Ä¢ An identifier should give some indication of its meaning.
‚Ä¢ Variable names normally are lowercase‚Äîindex, not Index or INDEX.
‚Ä¢ Like Sales_item, classes we define usually begin with an uppercase letter.
‚Ä¢ Identifiers with multiple words should visually distinguish each word, for example, student_loan or studentLoan, not studentloan.

==
(findscope)
Scope of a Name

A scope is a part of the program in which a name has a particular meaning. Most scopes in C++ are delimited by curly braces.

The same name can refer to different entities in different scopes. Names are visible from the point where they are declared until the end of the scope in which the declaration appears.

(Some code here)

The name main‚Äîlike most names defined outside a function‚Äîhas global scope. Once declared, names at the global scope are accessible throughout the program. The name sum is defined within the scope of the block that is the body of the main function. It is accessible from its point of declaration throughout the rest of the main function but not outside of it. The variable sum has block scope.

Scopes can contain other scopes. The contained (or nested) scope is referred to as an inner scope, the containing scope is the outer scope.
Once a name has been declared in a scope, that name can be used by scopes nested inside that scope. Names declared in the outer scope can also be redefined in an inner scope.

It is almost always a bad idea to define a local variable with the same name as a global variable that the function uses or might use.

==
(findinitialization)
Intialization:

An object that is initialized gets the specified value at the moment it is created. The values used to initialize a variable can be arbitrarily complicated expressions.

Initialization in C++ is a surprisingly complicated topic and one we will return to again and again. Many programmers are confused by the use of the = symbol to initialize a variable. It is tempting to think of initialization as a form of assignment, but initialization and assignment are different operations in C++. This concept is particularly confusing because in many languages the distinction is irrelevant and can be ignored. Moreover, even in C++ the distinction often doesn‚Äôt matter. Nonetheless, it is a crucial concept and one we will reiterate throughout the text.

Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object‚Äôs current value and replaces that value with a new one.

--
(findlistinitialization)
List Initialization

One way in which initialization is a complicated topic is that the language defines several different forms of initialization. For example, we can use any of the following four different ways to define an int variable named a and initialize it to 0:

int a = 0;
int a = {0}; // tao: list initialization (confirmed)
int a{0}; // tao: list initialization (confirmed)
int a(0);

The generalized use of curly braces for initialization was introduced as part of the new standard. This form of initialization previously had been allowed only in more restricted ways. For reasons we‚Äôll learn about later, this form of initialization is referred to as list initialization (tao: see example below). Braced lists of initializers can now be used whenever we initialize an object and in some cases when we assign a new value
to an object.

When used with variables of built-in type, this form of initialization has one important property: The compiler will not let us list initialize variables of built-in type if the initializer might lead to the loss of information:

long double ld = 3.1415926536;
int a{ld}, b = {ld}; // error: narrowing conversion required
int c(ld), d = ld; // ok: but value will be truncated

--
(finddefaultinitialization)
Default Initialization

When we define a variable without an initializer, the variable is default initialized. Such variables are given the ‚Äúdefault‚Äù value. What that default value is depends on the type of the variable and may also depend on where the variable is defined.

The value of an object of built-in type that is not explicitly initialized depends on where it is defined. Variables defined outside any function body are initialized to zero. With one exception, which we cover later, variables of built-in type defined inside a function are uninitialized. The value of an uninitialized variable of built-in type is undefined. It is an error to copy or otherwise try to access the value of a variable whose value is undefined.

Each class controls how we initialize objects of that class type. In particular, it is up to the class whether we can define objects of that type without an initializer. If we can, the class determines what value the resulting object will have.

Most classes let us define objects without explicit initializers. Such classes supply an appropriate default value for us. For example, as we‚Äôve just seen, the library string class says that if we do not supply an initializer, then the resulting string is the empty string:

std::string empty; // empty implicitly initialized to the empty string
Sales_item item; // default-initialized Sales_item object

Some classes require that every object be explicitly initialized. The compiler will complain if we try to create an object of such a class with no initializer.

Tao's practice:

If we create an array of built-in type inside a function using new as below (remember we must use new if we want to return the array or its elments, recored in this note), the values of the elements are also undefined:

bool *res = new bool[n];

//Note that the following initialization to res[i] is necessary, otherwise the values of res[i] is not defined (values are different in my computer and Leetcode OJ)
for(int i = 1; i <= n; ++i) res[i] = false;

For the above, I later used vector:
vector<bool> res(n, false);

--
If we do not initialize a string, then it is an empty string. (Seems different from Java).

--
We recommend initializing every object of built-in type. It is not always necessary, but it is easier and safer to provide an initializer until you can be certain it is safe to omit the initializer.

--
(findvalueinitialization)
Value Initialization

Tao: from the following, I conclude that value initialization is just another name of default initialization.

Copied from elsewhere in this note:

If a local static has no explicit initializer, it is value initialized, meaning that local statics of built-in type are initialized to zero.

The default constructor is used automatically whenever an object is default or value initialized.

--
(finddirectinitialization)
(findcopyinitialization)
direct and copy initialization

Sales_data item1(null_book); // direct initialization
Sales_data item2 = null_book; // the copy form of initialization 

Tao: for the direct initialization of primitive types: a(2), think about the initialization via constructor in the direct initialization example above: item1(null_book)

Summary from below (it is a waste of time to suspect this summary):

Direct initialization means to use (), eg: a(b)
Copy initialization means to =, eg: a = b

Copied from "find string":

Direct and Copy Forms of Initialization 

Earlier we saw that C++ has several different forms of initialization. Using strings, we can start to understand how these forms differ from one another. When we initialize a variable using =, we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created. Otherwise, when we omit the =, we use direct initialization.

When we have a single initializer, we can use either the direct or copy form of initialization. When we initialize a variable from more than one value, such as in the initialization of s4 above, we must use the direct form of initialization:

string s5 = "hiya"; // copy initialization
string s6("hiya"); // direct initialization
string s7(10, 'c'); // direct initialization; s7 is cccccccccc

==
(finddeclaration)
(finddefinition)
declaration
definition

Separate compilation lets us split our programs into several files, each of which can be compiled independently.

An uninitialized variable has an indeterminate value. Trying to use the value of an uninitialized variable is an error that is often hard to debug.

To support separate compilation, C++ distinguishes between declarations and definitions. A declaration makes a name known to the program. A file that wants to use a name defined elsewhere includes a declaration for that name. A definition creates the associated entity.

Every name used in a C++ program must be declared before it is used.

A variable declaration specifies the type and name of a variable. A variable definition is a declaration. In addition to specifying the name and type, a definition also allocates storage and may provide the variable with an initial value.

To obtain a declaration that is not also a definition, we add the extern keyword and may not provide an explicit initializer:

extern int i; // declares but does not define i
int j; // declares and defines j

Any declaration that includes an explicit initializer is a definition. We can provide an initializer on a variable defined as extern, but doing so overrides the extern. An extern that has an initializer is a definition:

extern double pi = 3.1416; // definition

It is an error to provide an initializer on an extern inside a function.

Variables must be defined exactly once but can be declared many times.

The distinction between a declaration and a definition may seem obscure at this point but is actually important. To use a variable in more than one file requires declarations that are separate from the variable‚Äôs definition. To use the same variable in multiple files, we must define that variable in one‚Äîand only one‚Äîfile. Other files that use that variable must declare‚Äîbut not define‚Äîthat variable.

It is usually a good idea to define an object near the point at which the object is first used. Doing so improves readability by making it easy to find the definition of the variable. More importantly, it is often easier to give the variable a useful initial value when the variable is defined close to where it is first used.

==
(findmax)
max

#include <algorithm>  

max(1, 2)

==
(findintmax)
(findmaxint)
(findintmin)
(findminint)
INT_MAX and INT_MIN

From geeksforgeeks:

Most of the times, in competitive programming, there is a need to assign the variable, the maximum or minimum value that data type can hold, but remembering such a large and precise number comes out to be a difficult job. Therefore, C++ has certain macros to represent these numbers, so that these can be directly assigned to the variable without actually typing the whole number.

INT_MAX is a macro that specifies that an integer variable cannot store any value beyond this limit.
INT_MIN specifies that an integer variable cannot store any value below this limit.

Values of INT_MAX and INT_MIN may vary from compiler to compiler. Following are typical values in a compiler where integers are stored using 32 bits.

Value of INT_MAX is +2147483647.
Value of INT_MIN is -2147483648.

// C++ program to print values of INT_MAX 
// and INT_MIN 

#include <climits> 

int main() { 
   printf("%d\n", INT_MAX); //Output: 2147483647, which equals 2^31 ‚àí 1
   printf("%d", INT_MIN); //Output: -2147483648, which equals ‚àí2^31
   return 0; 
} 

==
(findheader)
(findinclude)
Headers

Need to include when use:

#include <iostream>
#include <string>
#include <vector>
#include <iterator>
cctype //islower(c), tolower(c)
container header
container adaptor
iterator
algorithm
tuple
bind

using namespace std;

--
Although as we‚Äôll see later, we can define a class inside a function, such classes have limited functionality. As a result, classes ordinarily are not defined inside functions. When we define a class outside of a function, there may be only one
definition of that class in any given source file. In addition, if we use a class in several different files, the class‚Äô definition must be the same in each file.

In order to ensure that the class definition is the same in each file, classes are usually defined in header files. Typically, classes are stored in headers whose name derives from the name of the class. For example, the string library type is defined in
the string header. Similarly, as we‚Äôve already seen, we will define our Sales_data class in a header file named Sales_data.h.

Headers (usually) contain entities (such as class definitions and const and constexpr variables) that can be defined only once in any given file. However, headers often need to use facilities from other headers. For example, because our Sales_data class has a string member, Sales_data.h must #include the string header. As we‚Äôve seen, programs that use Sales_data also need to include the string header in order to use the bookNo member. As a result, programs that use Sales_data will include the string header twice: once directly and once as a side effect of including Sales_data.h. Because a header might be included more than once, we need to write our headers in a way that is safe even if the header is included multiple times (tao: the solution is to use the preprocessor, search for "find preprocessor").

Whenever a header is updated, the source files that use that header must be recompiled to get the new or changed declarations.

--
Advice: Use the C++ Versions of C Library Headers

In addition to facilities defined specifically for C++, the C++ library incorporates the C library. Headers in C have names of the form name .h. The C++ versions of these headers are named c name‚Äîthey remove the .h suffix and precede the name with the letter c. The c indicates that the header is part of the C library.

Hence, cctype has the same contents as ctype.h, but in a form that is appropriate for C++ programs. In particular, the names defined in the cname headers are defined inside the std namespace, whereas those defined in the .h versions are not.

Ordinarily, C++ programs should use the cname versions of headers and not the name .h versions. That way names from the standard library are consistently found in the std namespace. Using the .h headers puts the burden on the programmer to remember which library names are inherited from C and which are unique to C++.

--
(findpreprocessor)
preprocessor

The most common technique for making it safe to include a header multiple times relies on the preprocessor. The preprocessor is a program that runs before the compiler and changes the source text of our programs. Our programs already rely on one preprocessor facility, #include. When the preprocessor sees a #include, it replaces the #include with the contents of the specified header.

C++ programs also use the preprocessor to define header guards. Header guards rely on preprocessor variables. Preprocessor variables have one of two possible states: defined or not defined. The #define directive takes a name and defines that name as a preprocessor variable. There are two other directives that test whether a given preprocessor variable has or has not been defined: #ifdef is true if the variable has been defined, and #ifndef is true if the variable has not been defined. If the test is true, then everything following the #ifdef or #ifndef is processed up to the matching #endif.

We can use these facilities to guard against multiple inclusion as follows:

tao: the following is the .h file which defines Sales_data. The benefit of the preprocessor in this .h file is that this .h file can be included in multiple files, and there will be no conflict, because SALES_DATA_H will be defined in the first file that includes this .h file, other files will have ifndef = false and will not execute this .h file.

#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
#endif

Warning: Preprocessor variable names do not respect C++ scoping rules.

Preprocessor variables, including names of header guards, must be unique throughout the program. To avoid name clashes with other entities in our programs, preprocessor variables usually are written in all uppercase.

Headers should have guards, even if they aren‚Äôt (yet) included by another header. Header guards are trivial to write, and by habitually defining them you don‚Äôt need to decide whether they are needed.

--
#include <iostream>
#include "Sales_item.h"

This program starts with two #include directives. Headers from the standard library are enclosed in angle brackets (< >). Those that are not part of the library are enclosed in double quotes (" ")

--
As we‚Äôve seen, to use a library facility, we must include the associated header. Similarly, we use headers to access classes defined for our own applications. Conventionally, header file names are derived from the name of a class defined in that header. Header files that we write usually have a suffix of .h, but some programmers use .H, .hpp, or .hxx. The standard library headers typically have no suffix at all.
Compilers usually don‚Äôt care about the form of header file names, but IDEs sometimes do.

--
#include <iostream>
#include "Sales_item.h"

Headers from the standard library are enclosed in <>
Headers that are not part of the library are enclosed in ""

The standard library headers typically have no suffix.
Header files that we write usually have a suffix of .h

Headers (usually) contain entities (such as class definitions and const variables) that can be defined only once in any given file.

Code inside headers ordinarily should not use "using declarations". The reason is that the contents of a header are copied into the including program‚Äôs text. If a header has a using declaration, then every program that includes that header gets that same using declaration. As a result, a program that didn‚Äôt intend to use the specified library name might encounter unexpected name conflicts.

In addition to facilities defined specifically for C++, the C++ library incorporates the C library. Headers in C have names of the form name .h. The C++ versions of these headers are named c name‚Äîthey remove the .h suffix and precede the name with the letter c. The c indicates that the header is part of the C library. Hence, cctype has the same contents as ctype.h, but in a form that is appropriate for C++ programs. In particular, the names defined in the cname headers are defined inside the std namespace, whereas those defined in the .h versions are not. Ordinarily, C++ programs should use the cname versions of headers and not the name .h versions.

--
How to include header in another folder (from online):

Just inlcude the path as well:

#include "../../Header/class1.h"

--
Whether to compile header files (from online):

Do I need to compile the header files (.h) in a C program?
No, there's no reason to "compile" these header files independently. 
Header files are intended to be included into implementation files, 
not fed to the compiler as independent translation units.

--
How to compile the files in the following example:

Suppose the files are organized in the following folders:

code
  - main.cpp

utils  
  - Time.h
  - Time.cpp 

Then in folder code, type the followings (list all the other cpp files after main.cpp.):
g++ main.cpp ../utils/Time.cpp 

This makes a compiled file in the same folder as main.cpp: a.out

In file Time.cpp, in the implementation of the Time member functions, it can use the other Time members directly without adding class name, note that the Time class is defined in another file Time.h

--
Separate Header and Implementation Files (from online, tao changed the path in the include for illustration)

How to compile the following files? See above.

In this section, we demonstrate how to make class reusable by separating it into another files.

Header File
Class declarations are stored in a separate file. A file that contains a class declaration is called header file. The name of the class is usually the same as the name of the class, with a .h extension. For example, the Time class would be declared in the file Time .h.

#ifndef TIME_H
#define TIME_H

class Time
{
     private :
          int hour;
          int minute;
          int second;
     public :
          //with default value
          Time(const int h = 0, const int m  = 0, const int s = 0);
          //    setter function
          void setTime(const int h, const int m, const int s);
          // Print a description of object in " hh:mm:ss"
          void print() const;
          //compare two time object
          bool equals(const Time&);
};
 
#endif
 
Implementation File

The member function definitions for a class are stored in a separate .cpp file, which is called the class implementation file. The file usually has the same name as the class, with the .cpp extension. For example the Time class member functions would be defined in the file Time.cpp.

#include <iostream>
#include <iomanip>
#include "Time.h" <- tao: since Time.cpp is in the same folder as Time.h, so no need to include path
using namespace std;
 
Time :: Time(const int h, const int m, const int s) 
  : hour(h), minute (m), second(s)
{}
 
void Time :: setTime(const int h, const int m, const int s) 
{
     hour = h;
     minute = m;
     second = s;     
}       
 
void Time :: print() const
{
     cout << setw(2) << setfill('0') << hour << ":"
    << setw(2) << setfill('0') << minute << ":"
    << setw(2) << setfill('0') << second << "\n";   
 
}
 
bool Time :: equals(const Time &otherTime)
{
     if(hour == otherTime.hour 
          && minute == otherTime.minute 
          && second == otherTime.second)
          return true;
     else
          return false;
}
 
Client Code

client code, is the one that includes the main function. This file should be stored by the name main.cpp
 
#include <iostream>
using namespace std;
#include "../utils/Time.h" <- tao: since main.cpp is in a different folder from Time.h, so need to include path

int main()
{
     Time t1(10, 50, 59);
     t1.print();   // 10:50:59
     Time t2;
     t2.print(); // 06:39:09
     t2.setTime(6, 39, 9);
     t2.print();  // 06:39:09
   
     if(t1.equals(t2))
          cout << "Two objects are equal\n";
     else
          cout << "Two objects are not equal\n";    
  
     return 0;
}
The advanages of storing class definition in separate file are

1. The class is reusable

2. The clients of the class know what member functions the class provides, how to call them and what return types to expect

3. The clients do not know how the class's member functions are implemented.

--
(findcompileseparate)
Separate Compilation

As our programs get more complicated, we‚Äôll want to store the various parts of the program in separate files. For example, we might store the functions we wrote in one file and store code that uses these functions in other source files. To allow programs to be written in logical parts, C++ supports what is commonly known as separate compilation. Separate compilation lets us split our programs into several files, each of which can be compiled independently.

As an example, assume that the definition of our fact function is in a file named fact.cc and its declaration is in a header file named Chapter6.h. Our fact.cc file, like any file that uses these functions, will include the Chapter6.h header. We‚Äôll store a main function that calls fact in a second file named factMain.cc. We might compile these files as follows:

g++ factMain.cc fact.cc -o main // generates main

If we have changed only one of our source files, we‚Äôd like to recompile only the file that actually changed. Most compilers provide a way to separately compile each file. This process usually yields a file with the .o file extension, indicating that the file contains object code.
 
The compiler lets us link object files together to form an executable. On the system we use, we would separately compile our program as follows:
 
g++ -c factMain.cc     // generates factMain.o
g++ -c fact.cc         // generates fact.o
g++ factMain.o fact.o -o main // generates main

==
(findcout)
(findcin)
cout, cin 

remember: t looks like <, n can be put into >

The left-hand operand of << must be an ostream object. The operator writes the given value on the given ostream. The result of the output operator is its left-hand operand (the ostream). The following example uses << twice, because << returns ostream.

Writing endl has the effect of ending the current line and flushing the buffer asociated with that device. Flusing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.

Buffer: a region of storage used to hold data. IO facilities often store input (or output) in a buffer and read or write the buffer independently from actions in the program. Output buffers can be explicitly flushed to force the buffer to be written. By default, reading cin flushes cout; cout is also flushed when the program ends normally.

//cout:
#include<iostream>
using namespace std;
//using std::cout; <- can also use this

int main() {
    double a = 2.6;
    cout << a << endl;
    return 0;
}

//cin:
#include<iostream>
using namespace std;

int main() {
    int a = 0;
    cin >> a; //tao: read input into a
    return 0;
}

while(cin >> value) sum += value;

The input operator returns its left operand, which in this case is cin. This condition, therefore, tests cin.

When we use an istream as a condition, the effect is to test the state of the stream. If the stream is valid‚Äîthat is, if the stream hasn‚Äôt encountered an error‚Äîthen the test succeeds. An istream becomes invalid when we hit end-of-file (tao: ctrl+d) or encounter an invalid input, such as reading a value that is not an integer (tao: because "value" is int type). An istream that is in an invalid state will cause the condition to yield false.

The input operator (the >> operator) behaves analogously to the output operator. It takes an istream as its left-hand operand and an object as its right-hand operand. It reads data from the given istream and stores what was read in the given object. Like the output operator, the input operator returns its left-hand operand as its result. 

cout << v1 + v2 << endl; //Tao: expressions can be in cout.

--
s is a string:

os << s: Writes s onto output stream os. Returns os.
is >> s: Reads whitespace-seperated string from is into s. Returns s.
getline(is, s): Reads a line of input from is into s. Returns s.

string s; // empty string
cin >> s; // read a whitespace-separated string into s. Tao: note that this code does not end with endl.
cout << s << endl; // write s to the output

The string input operator (tao eg: cin) reads and discards any leading whitespace (e.g., spaces, newlines, tabs). It then reads
characters until the next whitespace character is encountered.
So, if the input to this program is Hello World! (note leading and trailing spaces), then the output will be Hello with no extra spaces.

We can chain together multiple reads or writes:

string s1, s2;
cin >> s1 >> s2; // read first input into s1, second into s2
cout << s1 << s2 << endl; // write both strings

If we give this version of the program the same input, Hello World!, our output would
be ‚ÄúHelloWorld!‚Äù

Reading an Unknown Number of strings

string word;
while (cin >> word) // read until end-of-file
cout << word << endl; // write each word followed by a new line

--
(findgetline)
getline

Sometimes we do not want to ignore the whitespace in our input. In such cases, we can use the getline function instead of the >> operator.

int main()
{
	string line;
	// read input a line at a time until end-of-file
	while (getline(cin, line))
		cout << line << endl;
	return 0;
}

Because line does not contain a newline, we must write our own (tao: endl). As usual, we use endl to end the current line and flush the buffer.

--
Printing numbers in binary format:

#include <bitset>
using namespace std;
int v = 5;
cout << bitset<32>(v); //32 means outputs 32 bits

--
Most operating systems support file redirection, which lets us associate a named file with the standard input and the standard output:

$ addItems <infile >outfile

Asuuming our addition program has been compiled into an executable file named addItem. This command will read transactions from a file named infile and write its output to a file named outfile in the current directory.

==
(findio)
IO

The C++ language does not define any statements to do input or output (IO). Instead, C++ includes an extensive standard library that provides IO (and many other facilities).

Most of the examples in this book use the iostream library. Fundamental to the iostream library are two types named istream and ostream, which represent input and output streams, respectively. A stream is a sequence of characters read from or written to an IO device. The term stream is intended to suggest that the characters are generated, or consumed, sequentially over time.

Standard Input and Output Objects

The library defines four (tao: note four) IO objects. To handle input, we use an object of type istream named cin (pronounced see-in). This object is also referred to as the standard input. For output, we use an ostream object named cout (pronounced see-out). This object is also known as the standard output. The library also defines two other ostream objects, named cerr and clog (pronounced see-err and see-log, respectively). We typically use cerr, referred to as the standard error, for warning and error messages and clog for general information about the execution of the program.

Ordinarily, the system associates each of these objects with the window in which the program is executed. So, when we read from cin, data are read from the window in which the program is executing, and when we write to cout, cerr, or clog, the output is written to the same window.

--
#include <iostream> tells the compiler that we want to use the iostream library. The name inside angle brackets (iostream in this case) refers to a header. Every program that uses a library facility must include its associated header. The #include directive must be written on a single line‚Äîthe name of the header and the #include must appear on
the same line. In general, #include directives must appear outside any function. Typically, we put all the #include directives for a program at the beginning of the source file.

--
In C++ an expression yields a result and is composed of one or more operands and (usually) an operator. The expressions in this statement use the output operator (the << operator) to print a message on the standard output:

std::cout << "Enter two numbers:" << std::endl;

The << operator takes two operands: The left-hand operand must be an ostream object; the right-hand operand is a value to print. The operator writes the given value on the given ostream. The result of the output operator is its left-hand operand. That is, the result is the ostream on which we wrote the given value.

Our output statement uses the << operator twice. Because the operator returns its left-hand operand.

endl, which is a special value called a manipulator. Writing endl has the effect of ending the current line and flushing the buffer associated with that device. Flushing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.

Programmers often add print statements during debugging. Such statements
should always flush the stream. Otherwise, if the program crashes, output may be left in the buffer, leading to incorrect inferences about where the program crashed.

--
(findnamespace)
Using Names from the Standard Library

Careful readers will note that this program uses std::cout and std::endl rather than just cout and endl. The prefix std:: indicates that the names cout and endl are defined inside the namespace named std. Namespaces allow us to avoid inadvertent collisions between 'the names we define' and 'uses of those same names inside a library'. All the names defined by the standard library are in the std namespace.

One side effect of the library's use of a namespace is that when we use a name from the library, we must say explicitly that we want to use the name from the std namespace. Writing std::cout uses the scope operator (the :: operator) to say that we want to use the name cout that is defined in the namespace std. Later will show a simpler way to access names from the library.

A using declaration lets us use a name from a namespace without qualifying the name with a namespace_name:: prefix. A using declaration has the form

using namespace::name;

Once the using declaration has been made, we can access name directly:

using std::cin;
cin >> i; // ok: cin is a synonym for std::cin

Code inside headers ordinarily should not use using declarations. The reason is that the contents of a header are copied into the including program‚Äôs text.

--
The C++ language does not deal directly with input and output. Instead, IO is handled by a family of types defined in the standard library.

Our programs have already used many IO library facilities:
‚Ä¢ istream (input stream) type, which provides input operations
‚Ä¢ ostream (output stream) type, which provides output operations
‚Ä¢ cin, an istream object that reads the standard input
‚Ä¢ cout, an ostream object that writes to the standard output
‚Ä¢ cerr, an ostream object, typically used for program error messages, that writes to the standard error
‚Ä¢ The >> operator, which is used to read input from an istream object
‚Ä¢ The << operator, which is used to write output to an ostream object
‚Ä¢ The getline function, which reads a line of input from a given istream into a given string

To support these different kinds of IO processing, the library defines a collection of IO types in addition to the istream and ostream types that we have already used.

These types are defined in three separate headers: iostream defines the basic types used to read from and write to a stream, fstream defines the types used to read and write named files, and sstream defines the types used to read and write in-memory strings.

The library lets us ignore the differences among these different kinds of streams by using inheritance. Ordinarily, we can use an object of an inherited class as if it were an object of the same type as the class from which it inherits.

The types ifstream and istringstream inherit from istream. Thus, we can use objects of type ifstream or istringstream as if they were istream objects. We can use objects of these types in the same ways as we have used cin. For example, we can call getline on an ifstream or istringstream object, and we can use the >> to read data from an ifstream or istringstream. Similarly, the types ofstream and ostringstream inherit from ostream. Therefore, we can use objects of these types in the same ways that we have used cout.

Everything that we cover in the remainder of this section applies equally to plain streams, file streams, and string streams and to the char or widecharacter stream versions.

we cannot copy or assign objects of the IO types:

ofstream out1, out2;
out1 = out2; // error: cannot assign stream objects
ofstream print(ofstream); // error: can't initialize the ofstream parameter. Tao: print is a variable
out2 = print(out2); // error: cannot copy stream objects. Tao: print is a variable

Because we can‚Äôt copy the IO types, we cannot have a parameter or return type that is one of the stream types. Functions that do IO typically pass and return the stream through references. Reading or writing an IO object changes its state, so the reference must NOT be const.

--
Condition States

Inherent in doing IO is the fact that errors can occur. Some errors are recoverable; others occur deep within the system and are beyond the scope of a program to correct. The IO classes define functions and flags, listed in Table below, that let us access and manipulate the condition state of a stream.

strm::iostate: strm is one of (iostream, fstream, sstream) IO types. iostate is a machine-dependent integral type that represents the condition state of a stream.

strm::badit: strm::iostate value used to indicate that a stream is corrupted.

strm::failbit: strm::iostate value used to indicate that an IO operation failed.

strm::eofbit: strm::iostate value used to indicate that a stream hit end-of-file.

strm::goodbit: strm::iostate value used to indicate that a stream is not in an error state. The value is guaranteed to be zero.

s.eof(): true if eofbit in the stream s is set.

s.fail(): true if failbit or badbit in the stream s is set.

s.bad(): true if badbit in the stream s is set.

s.good(): true if the stream s is in a valid state.

s.clear(): Reset all condition values in the stream s to valid state. Returns void.

s.clear(flags): Reset the condition of s to flags. Type of flags is strm:iostate. Returns void.

s.setstate(flags): Adds specified conditions(s) to s. Type of flags is strm::iostate. Returns void.

s.rdstate(): Returns curent condition of s as a strm::iostate value.

As an example of an IO error, consider the following code:

int ival;
cin >> ival;

If we enter Boo on the standard input, the read will fail. The input operator expected to read an int but got the character B instead. As a result, cin will be put in an error state. Similarly, cin will be in an error state if we enter an end-of-file. 

Once an error has occurred, subsequent IO operations on that stream will fail. We can read from or write to a stream only when it is in a non-error state. Because a stream might be in an error state, code ordinarily should check whether a stream is okay before attempting to use it. The easiest way to determine the state of a stream
object is to use that object as a condition:

while (cin >> word) // ok: read operation successful . . .

The while condition checks the state of the stream returned from the >> expression. If that input operation succeeds, the state remains valid and the condition will succeed.

Interrogating the State of a Stream

Using a stream as a condition tells us only whether the stream is valid. It does not tell us what happened. Sometimes we also need to know why the stream is invalid. For example, what we do after hitting end-of-file is likely to differ from what we‚Äôd do if we encounter an error on the IO device.

The IO library defines a machine-dependent integral type named iostate that it uses to convey information about the state of a stream. This type is used as a collection of bits, in the same way that we used the quiz1 variable in ¬ß 4.8 (p. 154). The IO classes define four constexpr values (¬ß 2.4.4, p. 65) of type iostate that represent particular bit patterns. These values are used to indicate particular kinds of IO conditions. They can be used with the bitwise operators (¬ß 4.8, p. 152) to test or set multiple flags in one operation.

The badbit indicates a system-level failure, such as an unrecoverable read or write error. It is usually not possible to use a stream once badbit has been set. The failbit is set after a recoverable error, such as reading a character when numeric data was expected. It is often possible to correct such problems and continue using the stream. Reaching end-of-file sets both eofbit and failbit. The goodbit, which is guaranteed to have the value 0, indicates no failures on the stream. If any of badbit, failbit, or eofbit are set, then a condition that evaluates that stream will fail.

The library also defines a set of functions to interrogate the state of these flags. The good operation returns true if none of the error bits is set. The bad, fail, and eof operations return true when the corresponding bit is on. In addition, fail returns true if bad is set. By implication, the right way to determine the overall state of a stream is to use either good or fail. Indeed, the code that is executed when we use a stream as a condition is equivalent to calling !fail(). The eof and bad operations reveal only whether those specific errors have occurred.

Managing the Condition State

The rdstate member returns an iostate value that corresponds to the current state of the stream. The setstate operation turns on the given condition bit(s) to indicate that a problem occurred. The clear member is overloaded (¬ß 6.4, p. 230): One version takes no arguments and a second version takes a single argument of type iostate.

The version of clear that takes no arguments turns off all the failure bits. After clear(), a call to good returns true. We might use these members as follows:

// remember the current state of cin
auto old_state = cin.rdstate(); // remember the current state of cin
cin.clear(); // make cin valid
process_input(cin); // use cin
cin.setstate(old_state); // now reset cin to its old state

The version of clear that takes an argument expects an iostate value that represents the new state of the stream. To turn off a single condition, we use the rdstate member and the bitwise operators to produce the desired new state.

For example, the following turns off failbit and badbit but leaves eofbit untouched:

// turns off failbit and badbit but all other bits unchanged
cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit);

--
Managing the Output Buffer

Each output stream manages a buffer, which it uses to hold the data that the program reads and writes. For example, when the following code is executed

os << "please enter a value: ";

the literal string might be printed immediately, or the operating system might store the data in a buffer to be printed later. Using a buffer allows the operating system to combine several output operations from our program into a single system-level write.

Because writing to a device can be time-consuming, letting the operating system combine several output operations into a single write can provide an important performance boost.

There are several conditions that cause the buffer to be flushed‚Äîthat is, to be written‚Äîto the actual output device or file:

‚Ä¢ The program completes normally. All output buffers are flushed as part of the return from main.

‚Ä¢ At some indeterminate time, the buffer can become full, in which case it will be flushed before writing the next value.

‚Ä¢ We can flush the buffer explicitly using a manipulator such as endl (¬ß 1.2, p.7).

‚Ä¢ We can use the unitbuf manipulator to set the stream‚Äôs internal state to empty the buffer after each output operation. By default, unitbuf is set for cerr, so that writes to cerr are flushed immediately.

‚Ä¢ An output stream might be tied to another stream. In this case, the buffer of the tied stream is flushed whenever the tied stream is read or written. By default, cin and cerr are both tied to cout. Hence, reading cin or writing to cerr flushes the buffer in cout.

Flushing the Output Buffer

Our programs have already used the endl manipulator, which ends the current line and flushes the buffer. There are two other similar manipulators: flush and ends. flush flushes the stream but adds no characters to the output; ends inserts a null character into the buffer and then flushes it:

cout << "hi!" << endl; // writes hi and a newline, then flushes the buffer
cout << "hi!" << flush; // writes hi, then flushes the buffer; adds no data
cout << "hi!" << ends; // writes hi and a null, then flushes the buffer

The unitbuf Manipulator

If we want to flush after every output, we can use the unitbuf manipulator. This manipulator tells the stream to do a flush after every subsequent write. The nounitbuf manipulator restores the stream to use normal, system-managed buffer flushing:

cout << unitbuf; // all writes will be flushed immediately // any output is flushed immediately, no buffering

cout << nounitbuf; // returns to normal buffering

Caution: Buffers Are Not Flushed If the Program Crashes

Output buffers are not flushed if the program terminates abnormally. When a program crashes, it is likely that data the program wrote may be sitting in an output buffer waiting to be printed.

When you debug a program that has crashed, it is essential to make sure
that any output you think should have been written was actually flushed.
Countless hours of programmer time have been wasted tracking through code that appeared not to have executed when in fact the buffer had not been flushed and the output was pending when the program crashed.

Tying Input and Output Streams Together

When an input stream is tied to an output stream, any attempt to read the input stream will first flush the buffer associated with the output stream. The library ties cout to cin, so the statement

cin >> ival;

causes the buffer associated with cout to be flushed.

Note

Interactive systems usually should tie their input stream to their output stream. Doing so means that all output, which might include prompts to the user, will be written before attempting to read the input.

There are two overloaded (¬ß 6.4, p. 230) versions of tie: One version takes no argument and returns a pointer to the output stream, if any, to which this object is currently tied. The function returns the null pointer if the stream is not tied.

The second version of tie takes a pointer to an ostream and ties itself to that ostream. That is, x.tie(&o) ties the stream x to the output stream o. We can tie either an istream or an ostream object to another ostream:

cin.tie(&cout); // illustration only: the library ties cin and cout for us
// old_tie points to the stream (if any) currently tied to cin
ostream *old_tie = cin.tie(nullptr); // cin is no longer tied
// ties cin and cerr; not a good idea because cin should be tied to cout
cin.tie(&cerr); // reading cin flushes cerr, not cout
cin.tie(old_tie); // reestablish normal tie between cin and cout

To tie a given stream to a new output stream, we pass tie a pointer to the new stream. To untie the stream completely, we pass a null pointer. Each stream can be tied to at most one stream at a time. However, multiple streams can tie themselves to the same ostream.

--
(findreadfromfile)
(findwritetofile)
Read from file and output to file

The following function reads all contents in the input file, and write them into output file. Note that if in my Thinkpad, it needs to be compiled in C++ 11.

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
using namespace std;

// g++ -std=c++0x -o convert convert.cc
void process_one_file(string input_stream_name, string output_file) { 
    ifstream input_stream(input_stream_name);
    ofstream output_file(output_file_name);

    string line;

    while(getline(input_stream, line)) {
        output_file << line << endl;
    }

    output_file.close();
    input_stream.close();
}

--
File Input and Output

The fstream header defines three types to support file IO: ifstream to read from a given file, ofstream to write to a given file, and fstream, which reads and writes a given file. 

These types provide the same operations as those we have previously used on the objects cin and cout. In particular, we can use the IO operators (<< and >>) to read and write files, we can use getline to read an ifstream.

In addition to the behavior that they inherit from the iostream types, the types defined in fstream add members to manage the file associated with the stream. These operations, listed in the following table, can be called on objects of fstream, ifstream, or ofstream but not on the other IO types.

fstream fstrm: Creates an unbound file stream. fstream is one of the types (ifstream, ofstream, fstream) defined in the fstream header.

fstream fstrm(s): Creates an fstream and opens the file named s. s can have type string or can be a pointer to a C-style character string. These constructors are explicit. The default file mode depends on the type of fstream.

fstream fstrm(s, mode): Like the previous constructor, but opens s in the given mode.

fstrm.open(s), fstrm.open(s, mode): Opens the file named by the s and binds that file to fstrm. s can be a string or a pointer to a C-style character string. The default file mode depends on the type of f stream. Returns void.

fstrm.close(): Closes the file to which fstrm is bound. Returns void.

fstrm.is_open(): Returns a bool indicating whether the file associated with fstrm was successfully opened and has not been closed.

Using an fstream in Place of an iostream&

As we noted before, we can use an object of an inherited type in places
where an object of the original type is expected. This fact means that functions that are written to take a reference (or pointer) to one of the iostream types can be called on behalf of the corresponding fstream (or sstream) type. That is, if we have a function that takes an ostream&, we can call that function passing it an ofstream object, and similarly for istream& and ifstream.

ifstream in(ifile); // construct an ifstream and open the given file
ofstream out; // output file stream that is not associated with any file

ifstream in(ifile); // construct an ifstreamand open the given file
ofstream out; // output file stream that is not associated with any file
out.open(ifile + ".copy"); // open the specified file

If a call to open fails, failbit is set. Because a call to open might fail, it is usually a good idea to verify that the open succeeded:

if (out) // check that the open succeeded 

Once a file stream has been opened, it remains associated with the specified file. Indeed, calling open on a file stream that is already open will fail and set failbit. Subsequent attempts to use that file stream will fail. To associate a file stream with a different file, we must first close the existing file. Once the file is closed, we can open
a new one:

in.close(); // close the file
in.open(ifile + "2"); // open another file

If the open succeeds, then open sets the stream‚Äôs state so that good() is true.

// for each file passed to the program
for (auto p = argv + 1; p != argv + argc; ++p) {
	ifstream input(*p); // create input and open the file
	if (input) { // if the file is ok, ''process'' this file
	process(input);
} else
	cerr << "couldn't open: " + string(*p);
} // input goes out of scope and is destroyed on each iteration

Because input is local to the while, it is created and destroyed on each iteration. When an fstream object goes out of scope, the file it is bound to is automatically closed. On the next iteration, input is created anew.

When an fstream object is destroyed, close is called automatically.

--
File Modes

Each stream has an associated file mode that represents how the file may be used:

in: Open for input
out: Open for output
app: Seek to the end before every write
ate: Seet to the end immediately after the open
trunc: Truncate the file
binary: Do IO operations in binary mode

We can supply a file mode whenever we open a file‚Äîeither when we call open or when we indirectly open the file when we initialize a stream from a file name. The modes that we can specify have the following restrictions:

‚Ä¢ out may be set only for an ofstream or fstream object.
‚Ä¢ in may be set only for an ifstream or fstream object.
‚Ä¢ trunc may be set only when out is also specified.
‚Ä¢ app mode may be specified so long as trunc is not. If app is specified, the file is always opened in output mode, even if out was not explicitly specified.
‚Ä¢ By default, a file opened in out mode is truncated even if we do not specify trunc. To preserve the contents of a file opened with out, either we must also specify app, in which case we can write only at the end of the file, or we must also specify in, in which case the file is open for both input and output will cover using the same file for input and output).
‚Ä¢ The ate and binary modes may be specified on any file stream object type and in combination with any other file modes.

Each file stream type defines a default file mode that is used whenever we do not otherwise specify a mode. Files associated with an ifstream are opened in in mode; files associated with an ofstream are opened in out mode; and files associated with an fstream are opened with both in and out modes.

Opening a File in out Mode Discards Existing Data

By default, when we open an ofstream, the contents of the file are discarded. The only way to prevent an ostream from emptying the given file is to specify app.

// to preserve the file's contents, we must explicitly specify app mode
ofstream app("file2", ofstream::app); // out is implicit
ofstream app2("file2", ofstream::out | ofstream::app);

File Mode Is Determined Each Time open Is Called

ofstream out; // no file mode is set
out.open("scratchpad"); // mode implicitly out and trunc
out.close(); // close out so we can use it for a different file
out.open("precious", ofstream::app); // mode is out and app
out.close();

When we open the file named precious, we ask for append mode. Any data in the file remains, and all writes are done at the end of the file.

--
string Streams

The sstream header defines three types to support in-memory IO; these types read from or write to a string as if the string were an IO stream.

The istringstream type reads a string, ostringstream writes a string, and stringstream reads and writes the string. Like the fstream types, the types defined in sstream inherit from the types we have used from the iostream header. In addition to the operations they inherit, the types defined in sstream add members to manage the string associated with the stream. These operations are listed in the following table. They may be called on stringstream objects but not on the other IO types.

sstream strm: strm is an unbounded stringstream. sstream is one of the types defined in the sstream header.

sstream strm(s): strm is an sstream that holds a copy of the string s. This constructor is explicit.

strm.str(): Returns a copy of the string that strm holds.

strm.str(s): Copies the string s into strm. Returns void.

An istringstream is often used when we have some work to do on an entire line, and other work to do with individual words within a line

// members are public by default; see ¬ß 7.2 (p. 268)
struct PersonInfo {
	string name;
	vector<string> phones;
};

string line, word; // will hold a line and word from input, respectively

vector<PersonInfo> people; // will hold all the records from the input
// read the input a line at a time until cin hits end-of-file (or another error)
while (getline(cin, line)) {
	PersonInfo info; // create an object to hold this record's data
	istringstream record(line); // bind record to the line we just read
	record >> info.name; // read the name
	while (record >> word) // read the phone numbers
		info.phones.push_back(word); // and store them
	people.push_back(info); // append this record to people

--
Using ostringstreams

An ostringstream is useful when we need to build up our output a little at a time but do not want to print the output until later.

For example, we might want to validate and reformat the phone numbers we read in the previous example. If all the numbers are valid, we want to print a new file containing the reformatted numbers. If a person
has any invalid numbers, we won‚Äôt put them in the new file. Instead, we‚Äôll write an error message containing the person‚Äôs name and a list of their invalid numbers.

Because we don‚Äôt want to include any data for a person with an invalid number, we can‚Äôt produce the output until we‚Äôve seen and validated all their numbers. We can, however, ‚Äúwrite‚Äù the output to an in-memory ostringstream:

for (const auto &entry : people) { // for each entry in people
	ostringstream formatted, badNums; // objects created on each loop
	for (const auto &nums : entry.phones) { // for each number
		if (!valid(nums)) {
			badNums << " " << nums; // string in badNums
		} else
			// ''writes'' to formatted's string
			formatted << " " << format(nums);
	}
	if (badNums.str().empty()) // there were no bad numbers
		os << entry.name << " " // print the name
		   << formatted.str() << endl; // and reformatted numbers
	else // otherwise, print the name and bad numbers
		cerr << "input error: " << entry.name
			 << " invalid number(s) " << badNums.str() << endl;
}

==
(findmath)
(findpow)
Math operators:

power:

#include <cmath>
pow(3.4, 4.4) // Returns: 3.4^4.4 = 218.025

--
std::pow in the <cmath> header has these overloads:

pow(float, float);
pow(float, int);
pow(double, double); // taken over from C
pow(double, int);
pow(long double, long double);
pow(long double, int);

Now you can't just do
pow(2, N)
with N being an int, because it doesn't know which of float, double or long double version it should take, and you would get an ambiguity error. All three would need a conversion from int to floating point, and all three are equally costly!

Therefor, be sure to have the first argument typed so it matches one of those three perfectly. I usually use double

pow(2.0, N)
Some lawyer crap from me again. I've often fallen in this pitfall myself, so i'm going to warn you about it.

==
(findmax)
(findmin)
The algorithm header:
max, min

include <iostream>     // std::cout
#include <algorithm>    // std::max, std::min

int main () {
  std::cout << "max(1,2)==" << std::max(1,2) << '\n';
  std::cout << "max(2,1)==" << std::max(2,1) << '\n';
  std::cout << "max('a','z')==" << std::max('a','z') << '\n';
  std::cout << "max(3.14,2.73)==" << std::max(3.14,2.73) << '\n';

  std::cout << "min(1,2)==" << std::min(1,2) << '\n';
  std::cout << "min(2,1)==" << std::min(2,1) << '\n';
  std::cout << "min('a','z')==" << std::min('a','z') << '\n';
  std::cout << "min(3.14,2.72)==" << std::min(3.14,2.72) << '\n';

  return 0;
}

==
(findstaticallytyped)
Type checking (statically typed launage):

Some languages, such as Smalltalk and Python, check types at run time. In contrast, C++ is a statically typed language; type checking is done at compile time.

In C++, if we try to do things that the type does not support, the compiler generates an error message and does not produce an executable file.

==
(findreference)
Reference

A compound type is a type that is defined in terms of another type. C++ has several compound types, two of which‚Äîreferences and pointers‚Äîwe‚Äôll cover in this chapter.

Defining variables of compound type is more complicated than the declarations we‚Äôve seen so far. We said that simple declarations consist of a type followed by a list of variable names. More generally, a declaration is a base type followed by a list of declarators. Each declarator names a variable and gives the variable a type that is related to the base type.

A reference defines an alternative name for an object. A reference type ‚Äúrefers to‚Äù another type. We define a reference type by writing a declarator of the form &d, where d is the name being declared:

int ival = 1024;
int &refVal = ival; // refVal refers to (is another name for) ival
int &refVal2; // error: a reference must be initialized

Ordinarily, when we initialize a variable, the value of the initializer is copied into the object we are creating. When we define a reference, instead of copying the initializer‚Äôs value, we bind the reference to its initializer. Once initialized, a reference remains bound to its initial object. There is no way to rebind a reference to refer to a different object. Because there is no way to rebind a reference, references must be initialized (tao: same as const).

Because references are not objects, they don‚Äôt have addresses. Hence, we may not define a pointer to a reference.

A Reference Is an Alias

A reference is not an object. Instead, a reference is just another name for an already existing object. 

After a reference has been defined, all operations on that reference are actually operations on the object to which the reference is bound.

int ival = 1024;
int &refVal = ival;

int &refVal3 = refVal;// ok: refVal3 is bound to the object to which refVal is bound, i.e., to ival

int i = refVal; // ok: initializes i to the same value as ival

Reference Definition

int i = 1024, i2 = 2048; // i and i2 are both ints
int &r = i, r2 = i2; // r is a reference bound to i; r2 is an int

With two exceptions that we‚Äôll cover later, the type of a reference and the object to which the reference refers must match exactly.
Moreover, for reasons we‚Äôll explore later, a reference may be bound only to an object, not to a literal or to the result of a more general expression.

==
(findpassbyvalue)              
(findpassbyreference)          
Pass by value vs Pass by reference

From online:

C++ Passing by value vs. passing by reference

First of all, this article is NOT going to explain C++ references and pointers. If you are not clear on what these are then this is quite probably the wrong article for you and you really should probably go read here, here or here.

In C++ all arguments are passed to functions by value. In other words, a copy of the value is taken and that is what the function has to work with. If you want to modify the original value you must either pass a pointer or reference to the original value you wish to modify. Of course, even the pointer or reference are still passed by value. Pointers and references are just another C++ type and when they are passed around you do so by value.

Now, what about the case where we don't want to modify the value? There's no need to pass by reference or pointer, right? Wrong! Now, in the case of fundemental types it probably doesn't make a huge deal of difference since these are unlikely to be any more complicated that a pointer or reference type; howver, in the case of fully blown class objects, such as string, vector, map, set or any other (including your own class objects) it can make a huge difference. You see, passing by value can be very expensive both in terms of memory usage and performance (time / space complexity)

Classes have copy constructors, which are defined to facilitate the correct copying semantics for a class. Now in C++ there are two types of copy, shallow and deep. A shallow copy is where all the values of the class are copied but pointers are not followed. A deep copy is where pointers are followed and all the objects that they point to are also copied, thus creating a copy of all the "deep" objects, too. Any class that contains references to other objects should (unless there is a very good reason not to) provide both an assignment and copy constructor such that the class is always copied deeply.

Consider the std::vector class. This class contains an internal buffer of memory that is managed by the vector. In reality, we can assume that the vector contains a pointer that points to memory allocated on the heap. The vector class implements a copy constructor that will perform a deep copy on a vector object if a copy is taken. This is the only sane thing to do, otherwise we have two objects referencing the same memory and then we have issues of ownership. In other words, which of the vectors is now responsible for managing and freeing that memory and what happens to the other vector if that memory is released? Of course, it'll be left with a dangling pointer that is referencing invalid memory! Bad mojo for all!!!

Now, imagine we have a vector class that contains thousands of items. If we pass this object to a function by value the whole of the internal buffer will be copied. Not only is this really very inefficient in terms of the time it will take to allocate the memory and copy the values from the original vector to the copy it also increases memory usage greatly and, as a side effect, the risk of memory fragmentation. Imagine if this same vector is copied around again and again (maybe in a loop); it should be pretty clear just how inefficient this is.

The solution is to pass things around by const reference (or const pointer in C). The cost of passing things around by const reference is trivial and about as expensive as passing around an int value. Not only is it so much more efficient to pass objects in this way, but the semantics of your function become way clearer. Just looking at the function prototype tells us that the value being passed is never meant to be modified by this function. You are helping to enforce your objects interface contract.

Let's see a trivial example. 
#include <vector>
#include <chrono>
#include <iostream>

void foo(std::vector<int> byValue)
{
// do nothing
}

void bar(std::vector<int> const & byRef)
{
// do nothing
}

int main()
{
   auto && v = std::vector<int>(0x7FFFFFF);

   auto && x1 = std::chrono::steady_clock::now();
   foo(v);
   auto && x2 = std::chrono::steady_clock::now();
   bar(v);
   auto && x3 = std::chrono::steady_clock::now();

   auto && d1 = std::chrono::duration_cast<std::chrono::nanoseconds>(x2 - x1);
   auto && d2 = std::chrono::duration_cast<std::chrono::nanoseconds>(x3 - x2);

   std::cout
         << "Time to call foo: " << d1.count() << std::endl
         << "Time to call bar: " << d2.count() << std::endl;
}

When running this on my Windows 7 laptop, build with Visual Studio 2013 and executed in as a Release build the call by value takes approximately 1 second whilst the call by reference takes less than a nanosecond. That makes the pass by value a billion times slower! Of course, this is a contrived example and on different machines with different compilers YMMV, but hopefully it serves to demonstrate just how slow passing by value can, when compared to passing by reference!

In the case of passing by value the cost in terms of both time and space complexity is O(N), where N is the number of bytes to be copied. Passing by reference will cost O(1), which is a significant improvement. Okay, the pedants amongst you may wish to argue that even for a reference it's O(N), because a reference is composed of bytes. True, but the big (massive) difference that the size of a reference is always constant and will be in the order of a few bytes (4 on a 32 bit machine, 8 on a 64 bit machine) and not hundreds, thousands, millions or even billion in the case of non-fundamental objects.

Note: that some compilers may optimize out the calls to the functions foo and bar due to the fact they don't do anything. This is most likely to happen if you have aggressive optimisation enabled on your compiler. You can either disable this or add some code to these functions to make use of the passed references. Whilst disabling optimisation may skew the results in an absolute sense, the relative comparison should still hold up because what we're truly interested in here is the asymtoptic variance (Big O) rather than wall clock time!

==
(findpointer)
Pointer

   declaration  operator
&  reference    obtain address
*  pointer      yield object

A pointer is a compound type that ‚Äúpoints to‚Äù another type. Like references, pointers are used for indirect access to other objects. Unlike a reference, a pointer is an object in its own right. Pointers can be assigned and copied; a single pointer can point to several different objects over its lifetime. Unlike a reference, a pointer need NOT be initialized at the time it is defined. Like other built-in types, pointers defined at block scope have undefined value if they are not initialized.

Pointers are often hard to understand. Debugging problems due to pointer
errors bedevil even experienced programmers.

We define a pointer type by writing a declarator of the form *d, where d is the name being defined. The * must be repeated for each pointer variable:

int *ip1, *ip2; // both ip1 and ip2 are pointers to int
double dp, *dp2; // dp2 is a pointer to double; dp is a double
int* p1, p2; //Tao: practice shows this is wrong, should define different pointers in different lines.

A pointer holds the address of another object. We get the address of an object by usin the address-of operator (the & operator):

int ival = 42;
int *p = &ival; // p holds the address of ival; p is a pointer to ival

Because references are not objects, they don‚Äôt have addresses. Hence, we may not define a pointer to a reference.

With two exceptions, which we cover later, the types of the pointer and the object to which it points must match:

double *pd = &dval; // ok: initializer is the address of a double
double *pd2 = pd; // ok: initializer is a pointer to double

--
In Leetcode, the standard position of * is
ListNode* head
not
ListNode *head

So I will following the Leetcode style.

--
Pointer Value

The value (i.e., the address) stored in a pointer can be in one of four states:

1. It can point to an object.

2. It can point to the location just immediately past the end of an object.

3. It can be a null pointer, indicating that it is not bound to any object.

4. It can be invalid; values other than the preceding three are invalid.
It is an error to copy or otherwise try to access the value of an invalid pointer.

--
When a pointer points to an object, we can use the dereference operator (the * operator) to access that object:

int ival = 42;
int *p = &ival; // p holds the address of ival; p is a pointer to ival
int v = *p; //v = 42, dereference operator *

Dereferencing a pointer yields the object to which the pointer points. We can assign to that object by assigning to the result of the dereference:

*p = 0; //Assign new value to ival

We may dereference only a valid pointer that points to an object. 

--
(findnull)
A null pointer does not point to any object. There are several ways to obtain a null pointer:

//Null pointer. The following three lines are equivalent, to assign null pointer to p.
int *p = 0;
int *p = nullptr; // equivalent to int *p = 0. See more below.
int *p = NULL;//// equivalent to int *p = 0. See more below.

nullptr:
The most direct approach is to initialize the pointer using the literal nullptr, which was introduced by the new standard. nullptr is a literal that has a special type that can be converted to any other pointer type.

NULL:
Modern C++ programs generally should avoid using NULL and use nullptr instead. Older programs sometimes use a preprocessor variable named NULL, which the cstdlib header defines as 0. Must #include<cstdlib>.  Tao: practice confirms that cstdlib is also included in std namespace, so if we already wrote "using namespace std;", then we do not need to #include<cstdlib>

We‚Äôll describe the preprocessor in a bit more detail later. What‚Äôs useful to know now is that the preprocessor is a program that runs before the compiler. Preprocessor variables are managed by the preprocessor, and are not part of the std namespace. As a result, we refer to them directly without the std:: prefix.

When we use a preprocessor variable, the preprocessor automatically replaces the variable by its value. Hence, initializing a pointer to NULL is equivalent to initializing it to 0. Modern C++ programs generally should avoid using NULL and use nullptr instead.

It is illegal to assign an int variable to a pointer, even if the variable‚Äôs value happens to be 0.

Our recommendation to initialize all variables is particularly important for pointers. If possible, define a pointer only after the object to which it should point has been defined. If there is no object to bind to a pointer, then initialize the pointer to nullptr or zero.

--
pi = &ival; //we assign a new value to pi, which changes the address that pi holds.
*pi = 0; // value in ival is changed; pi is unchanged

--
We can use a pointer in a condition. If the pointer is 0, then the condition is false. Any nonzero pointer evaluates as true. Tao: for example: if(p) {...}, which is often used in leetcode.

if(p) {...} is equivalent to if(p != NULL) {...}. If p == 0, then p = false. Any nonzero pointer evaluates as true. This is consistent with converting int to bool.

if(!p) is equivalent to if(p == NULL) <- Remember: if p buxin, ie p == NULL
if(p) is equivalent to if(p != NULL) <- Rememebr: if p xin, ie p != NULL

--
Two pointers are equal (using ==) if they hold the same address and unequal otherwise.

--
void* Pointers

The type void* is a special pointer type that can hold the address of any object. Like any other pointer, a void* pointer holds an address, but the type of the object at that address is unknown:

double obj = 3.14, *pd = &obj;

void *pv = &obj; // ok: void* can hold the address value of any data pointer type. obj can be an object of any type

pv = pd; // pv can hold a pointer to any type

There are only a limited number of things we can do with a void* pointer: We can compare it to another pointer, we can pass it to or return it from a function, and we can assign it to another void* pointer. We cannot use a void* to operate on the object it addresses‚Äîwe don‚Äôt know that object‚Äôs type (tao: so we do not know how many bytes to read from memory for the object), and the type determines what operations we can perform on the object.

Generally, we use a void* pointer to deal with memory as memory, rather than using the pointer to access the object stored in that memory. We‚Äôll cover using void* pointers in this way later. Later will show how we can retrieve the address stored in a void* pointer.

--
double obj = 3.14;
void *pv = &obj; // The type void* is a special pointer type that can hold the address of any object.

Avadoles:
Variables defined inside a function ordinarily are not stored at a fixed address.
Tao: this is also the reason why my program did something wrong when I tried to return a pointer to a variable defined inside a function (see more below).

--
Understanding Compound Type Declaration

// i is an int; p is a pointer to int; r is a reference to int
int i = 1024, *p = &i, &r = i;

//tao: the follwing is equivalent to int *p;
int* p; // legal but might be misleading

Pointers to Pointers

In general, there are no limits to how many type modifiers (tao: & and *) can be applied to a declarator. We indicate each pointer level by its own *. That is, we write ** for a pointer to a pointer.

int ival = 1024;
int *pi = &ival; // pi points to an int
int **ppi = &pi; // ppi points to a pointer to an int

ppi -> pi -> ival (has value 1024)

Tao: pointer also has addess.

Dereferencing a pointer to a pointer yields a pointer.

References to Pointers

A reference is not an object. Hence, we may not have a pointer to a reference. However, because a pointer is an object, we can define a reference to a pointer:

int *p; // p is a pointer to int
int *&r = p; // r is a reference to the pointer p

The easiest way to understand the type of r is to read the definition right to left. The symbol closest to the name of the variable (in this case the & in &r) is the one that has the most immediate effect on the variable‚Äôs type. Thus, we know that r is a reference.

--
(findpointertoarray)
(findreferencetoarray)
Pointer to array & array of pointers
Reference to array & array of references

//Principle: the symbol that is closest to the variable name comes to the first in the type name

int* parr[42]; // parr is an array of 42 pointers to int. From this, tao sees why tao likes to write "int*" rather than "int *"
int (*parr)[10] = &arr; // parr is a pointer, which points to an array of ten ints

int& refs[10] = ... // error: no arrays of references
int (&arrRef)[10] = arr; // arrRef is a reference, which refers to an array of ten ints

int* (&arry)[10] = ptrs; // arry is a reference to an array of ten pointers

As with vector, arrays hold objects. Thus, there are no arrays of references. Because an array is an object, we can define both pointers and references to arrays.

When we use an array, the compiler ordinarily converts the array to a pointer.

--
Pointer to vector: vector<int> *t; t->push_back(10);
Vector of pointers: vector<int*> movies = ...

--
Reference to a vector: vector<int>& = ...
There is no vector of references. 

--
(findpointertofunction)
Pointer to function

A function pointer is just that‚Äîa pointer that denotes a function rather than an object. Like any other pointer, a function pointer points to a particular type. A function‚Äôs type is determined by its return type and the types of its parameters. The function‚Äôs name is not part of its type. For example:

// compares lengths of two strings
bool lengthCompare(const string &, const string &);

has type 

bool(const string&, const string&). 

To declare a pointer that can point at this function, we declare a pointer in place of the function name:

// pf points to a function returning bool that takes two const string references
bool (*pf)(const string &, const string &); // uninitialized

// declares a function named pf that returns a bool*
bool *pf(const string &, const string &);

Using Function Pointers

When we use the name of a function as a value, the function is automatically converted to a pointer. For example, we can assign the address of lengthCompare to pf as follows:

pf = lengthCompare; // pf now points to the function named lengthCompare
pf = &lengthCompare; // equivalent assignment: address-of operator is optional

Moreover, we can use a pointer to a function to call the function to which the pointer points. We can do so directly‚Äîthere is no need to dereference the pointer:

bool b1 = pf("hello", "goodbye"); // calls lengthCompare
bool b2 = (*pf)("hello", "goodbye"); // equivalent call

Function Pointer Parameters

Just as with arrays, we cannot define parameters of function type but can have a parameter that is a pointer to function. As with arrays, we can write a parameter that looks like a function type, but it will be treated as a pointer:

// third parameter is a function type and is automatically treated as a pointer to function
void useBigger(const string &s1, const string &s2, bool pf(const string &, const string &));

// equivalent declaration: explicitly define the parameter as a pointer to function
void useBigger(const string &s1, const string &s2, bool (*pf)(const string &, const string &));

Returning a Pointer to Function

As with arrays, we can‚Äôt return a function type but can return a
pointer to a function type.

Using auto or decltype for Function Pointer Types

If we know which function(s) we want to return, we can use decltype to simplify writing a function pointer return type. 

string::size_type sumLength(const string&, const string&);

decltype(sumLength) *getFcn(const string &);

The only tricky part in declaring getFcn is to remember that when we apply decltype to a function, it returns a function type, not a pointer to function type. We must add a * to indicate that we are returning a pointer, not a function.

==
(finddynamicmemory)            
Dynamic memory

(findnew)                      
new operator

Tao: the followings are selected from the book:

Dynamically allocated objects have a lifetime that is independent of where they are created; they exist until they are explicitly freed.

In C++, dynamic memory is managed through a pair of operators: "new", which allocates, and optionally initializes, an object in dynamic memory and returns a pointer to that object; and "delete", which takes a pointer to a dynamic object, destroys that object, and frees the associated memory.

The followings covers all of the section "12.1.2. Managing Memory Directly":

The language itself defines two operators that allocate and free dynamic memory. The new operator allocates memory, and delete frees memory allocated by new.

Objects allocated on the free store are unnamed, so new offers no way to name the objects that it allocates. Instead, new returns a pointer to the object it allocates:

//pi points to a dynamically allocated, unnamed, uninitialized int:
int *pi = new int; 

This new expression constructs an object of type int on the free store and returns a pointer to that object. 

By default, dynamically allocated objects are default initialized, which means that objects of built-in or compound type have undefined value; objects of class type are initialized by their default constructor.

string *ps = new string; // initialized to empty string
int *pi = new int; // pi points to an uninitialized int

We can initialize a dynamically allocated object using direct initialization. We can use traditional construction (using parentheses), and under the new standard, we can also use list initialization (with curly braces):

int *pi = new int(1024); // object to which pi points has value 1024
string *ps = new string(10, '9'); // *ps is "9999999999"

// vector with ten elements with values from 0 to 9
vector<int> *pv = new vector<int>{0,1,2,3,4,5,6,7,8,9};

We can also value initialize a dynamically allocated object by following the type name with a pair of empty parentheses:

string *ps1 = new string; // default initialized to the empty string
string *ps = new string(); // value initialized to the empty string
int *pi1 = new int; // default initialized; *pi1 is undefined
int *pi2 = new int(); // value initialized to 0; *pi2 is 0

For the same reasons as we usually initialize variables, it is also a good idea to initialize dynamically allocated objects.

When we provide an initializer inside parentheses, we can use auto to deduce the type of the object we want to allocate from that initializer. However, because the compiler uses the initializer‚Äôs type to deduce the type to allocate, we can use auto only with a single initializer inside parentheses:

auto p1 = new auto(obj); // p points to an object of the type of obj that object is initialized from obj
auto p2 = new auto{a,b,c}; // error: must use parentheses for the initializer

It is legal to use new to allocate const objects:

// allocate and initialize a const int
const int *pci = new const int(1024);

// allocate a default-initialized const empty string
const string *pcs = new const string;

Like any other const, a dynamically allocated const object must be initialized. A const dynamic object of a class type that defines a default constructor may be initialized implicitly. Objects of other types must be explicitly initialized. Because the allocated object is const, the pointer returned by new is a pointer to const.

Memory Exhaustion

Although modern machines tend to have huge memory capacity, it is always possible
that the free store will be exhausted. Once a program has used all of its available memory, new expressions will fail. By default, if new is unable to allocate the requested storage, it throws an exception of type bad_alloc. We can prevent new from throwing an exception by using a different form of new:

// if allocation fails, new returns a null pointer
int *p1 = new int; // if allocation fails, new throws std::bad_alloc
int *p2 = new (nothrow) int; // if allocation fails, new returns a null pointer

This form of new is referred to as placement new. A placement new expression lets us pass additional arguments to new. In this case, we pass an object named nothrow that is defined by the library.

When we pass nothrow to new, we tell new that it must not throw an exception. If this form of new is unable to allocate the requested storage, it will return a null pointer. Both bad_alloc and nothrow are defined in the new header.

Freeing Dynamic Memory

In order to prevent memory exhaustion, we must return dynamically allocated memory to the system once we are finished using it. We return memory through a delete expression. A delete expression takes a pointer to the object we want to free:

delete p; // p must point to a dynamically allocated object or be null

Like new, a delete expression performs two actions: It destroys the object to which
its given pointer points, and it frees the corresponding memory.

Although the value of a const object cannot be modified, the object itself can be destroyed.

Dynamically Allocated Objects Exist until They Are Freed

As we saw earlier, memory that is managed through a shared_ptr is automatically deleted when the last shared_ptr is destroyed. The same is not true for memory we manage using built-in pointers. A dynamic object managed through a built-in pointer exists until it is explicitly deleted.

Functions that return pointers (rather than smart pointers) to dynamic memory put burden on their callers‚Äîthe caller must remember to delete the memory:

// factory returns a pointer to a dynamically allocated object
Foo* factory(T arg) {
    // process arg as appropriate
    return new Foo(arg); // caller is responsible for deleting this memory
}

Like our earlier factory function, this version of factory allocates an object but does not delete it. Callers of factory are responsible for freeing this memory when they no longer need the allocated object. Unfortunately, all too often the caller forgets to do so:

void use_factory(T arg) {
    Foo *p = factory(arg);
    // use p but do not delete it
} // p goes out of scope, but the memory to which p points is not freed!

Here, our use_factory function calls factory, which allocates a new object of type Foo. When use_factory returns, the local variable p is destroyed. That variable is a built-in pointer, not a smart pointer.

Unlike class types, nothing happens when objects of built-in type are destroyed. In particular, when a pointer goes out of scope, nothing happens to the object to which the pointer points. If that pointer points to dynamic memory, that memory is not automatically freed.

Warning: Dynamic memory managed through built-in pointers (rather than smart
pointers) exists until it is explicitly freed.

In this example, p was the only pointer to the memory allocated by factory. Once use_factory returns, the program has no way to free that memory. Depending on the logic of our overall program, we should fix this bug by remembering to free the memory inside use_factory:

void use_factory(T arg) {
    Foo *p = factory(arg);
    // use p
    delete p; // remember to free the memory now that we no longer need it
}

or, if other code in our system needs to use the object allocated by use_factory,
we should change that function to return a pointer to the memory it allocated:

Foo* use_factory(T arg) {
    Foo *p = factory(arg);
    // use p
    return p; // caller must delete the memory
}

Resetting the Value of a Pointer after a delete ...

When we delete a pointer, that pointer becomes invalid. Although the pointer is invalid, on many machines the pointer continues to hold the address of the (freed) dynamic memory. After the delete, the pointer becomes what is referred to as a
dangling pointer. A dangling pointer is one that refers to memory that once held an object but no longer does so.

Dangling pointers have all the problems of uninitialized pointers (tao: like trying to accessing the object pointed by the dangling pointer). We can avoid the problems with dangling pointers by deleting the memory associated with a pointer just before the pointer itself goes out of scope. That way there is no chance to use the pointer after the memory associated with the pointer is freed. If we need to keep the pointer around, we can assign nullptr to the pointer after we use delete. Doing so makes it clear that the pointer points to no object.

...Provides Only Limited Protection

A fundamental problem with dynamic memory is that there can be several pointers that point to the same memory. Resetting the pointer we use to delete that memory lets us check that particular pointer but has no effect on any of the other pointers that
still point at the (freed) memory. For example:

int *p(new int(42)); // p points to dynamic memory
auto q = p; // p and q point to the same memory
delete p; // invalidates both p and q
p = nullptr; // indicates that p is no longer bound to an object

Here both p and q point at the same dynamically allocated object. We delete that memory and set p to nullptr, indicating that the pointer no longer points to an object. However, resetting p has no effect on q, which became invalid when we deleted the memory to which p (and q!) pointed. In real systems, finding all the pointers that point to the same memory is surprisingly difficult.

==
(findconst)
const

We can make a variable unchangeable by defining the variable‚Äôs type as const. 

Because we can‚Äôt change the value of a const object after we create it, it must be initialized (tao: same as reference). As usual, the initializer may be an arbitrarily complicated expression.

const int bufSize = 512; 

Any attempt to assign to bufSize is an error:

bufSize = 512; // error: attempt to write to const object

--
Reference to const

As with any other object, we can bind a reference to an object of a const type. To do so we use a reference to const, which is a reference that refers to a const type. Unlike an ordinary reference, a reference to const cannot be used to change the object to which the reference is bound:

const int ci = 1024;
const int &r1 = ci; // ok: both reference and underlying object are const
r1 = 42; // error: r1 is a reference to const
int &r2 = ci; // error: non const reference to a const object

See following summary for remember.

we can bind a reference to const to a nonconst object, a literal, or a more general expression:

int i = 42;
const int &r1 = i; // we can bind a const int& to a plain int object
const int &r2 = 42; // ok: r1 is a reference to const
const int &r3 = r1 * 2; // ok: r3 is a reference to const
int &r4 = r * 2; // error: r4 is a plain, non const reference

A Reference to const May Refer to an Object That Is Not const

int i = 42;
int &r1 = i; // r1 bound to i
const int &r2 = i; // r2 also bound to i; but cannot be used to change i
r1 = 0; // r1 is not const; i is now 0
r2 = 0; // error: r2 is a reference to const

Binding r2 to the (nonconst) int i is legal. However, we cannot use r2 to change i. Even so, the value in i still might change. We can change i by assigning to it directly, or by assigning to another reference bound to i, such as r1.

--
const refrence: no such thing

--
Pointer to const:

We may store the address of a const object only in a pointer to const:

onst double pi = 3.14; // pi is const; its value may not be changed
double *ptr = &pi; // error: ptr is a plain pointer
const double *cptr = &pi; // ok: cptr may point to a double that is const
*cptr = 42; // error: cannot assign to *cptr

See following summary for remember.

We can use a pointer to const to point to a nonconst object:

double dval = 3.14; // dval is a double; its value can be changed
cptr = &dval; // ok: but can't change dval through cptr

--
const pointer:

Unlike references, pointers are objects. Hence, as with any other object type, we can have a pointer that is itself const. Like any other const object, a const pointer must be initialized, and once initialized, its value (i.e., the address that it holds) may not be changed. We indicate that the pointer is const by putting the const after the *.

int errNumb = 0;
int *const curErr = &errNumb; // curErr will always point to errNumb
const double pi = 3.14159;
const double *const pip = &pi; // pip is a const pointer to a const
object

See following summary for remember.

The fact that a pointer is itself const says nothing about whether we can use the pointer to change the underlying object.

--
Summary from the above:
1. int is always on the left of *, like int *
2. const can be on the left or right of int *, like: const int *, int * const
3. Principle: the symbol that is closest to the variable name is comes to the first in the type name: 
   const double *cptr = &pi: cptr is a pointer to const
   int *const curErr = &errNumb: curErr is a const pointer

--
Top-Level const

We use the term top-level const to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a low-level const. More generally, top-level const indicates that an object itself is const. Low-level const appears in the base type of compound types such as pointers or references.

int i = 0;
int *const p1 = &i; // we can't change the value of p1; const is top-level
const int ci = 42; // we cannot change ci; const is top-level
const int *p2 = &ci; // we can change p2; const is low-level
const int *const p3 = p2; // right-most const is top-level, left-most is not
const int &r = ci; // const in reference types is always low-level

The distinction between top-level and low-level matters when we copy an object. When we copy an object, top-level consts are ignored. Example:

const int ci = i;
auto b = ci; // b is an int (top-level const in ci is dropped)

On the other hand, low-level const is never ignored. When we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects. In general, we can convert a nonconst to const but not the other way round.

--
const in multiple files

When we split a program into multiple files, every file that uses the const must have access to its initializer. In order to see the initializer, the variable must be defined in every file that wants to use the variable‚Äôs value. To support this usage, yet avoid multiple definitions of the same variable, const variables are defined as local to the file. When we define a const with the same name in multiple files, it is as if we had written definitions for separate variables in each file.

Sometimes we have a const variable that we want to share across multiple files but whose initializer is not a constant expression. In this case, we don‚Äôt want the compiler to generate a separate variable in each file. Instead, we want the const object to behave like other (nonconst) variables. We want to define the const in one file, and declare it in the other files that use that object.

To define a single instance of a const variable, we use the keyword extern on both its definition and declaration(s):

// file_1.cc defines and initializes a const that is accessible to other files
extern const int bufSize = fcn();

// file_1.h
extern const int bufSize; // same bufSize as defined in file_1.cc

--
(findconstantexpression)
(findconstexpr)
Constant expression

A constant expression is an expression whose value cannot change and that can be evaluated at compile time. A literal is a constant expression. A const object that is initialized from a constant expression is also a constant expression. 

Whether a given object (or expression) is a constant expression depends on the types and the initializers. For example:

const int max_files = 20; // max_files is a constant expression
const int limit = max_files + 1; // limit is a constant expression
int staff_size = 27; // staff_size is not a constant expression
const int sz = get_size(); // sz is not a constant expression

Even though sz is a const, the value of its initializer is not known until run time. Hence, sz is not a constant expression.

constexpr Variables

Under the new standard, we can ask the compiler to verify that a variable is a constant expression by declaring the variable in a constexpr declaration. Variables declared as constexpr are implicitly const and must be initialized by constant expressions:

constexpr int mf = 20; // 20 is a constant expression
constexpr int limit = mf + 1; // mf + 1 is a constant expression
constexpr int sz = size(); // ok only if size is a constexpr function

Although we cannot use an ordinary function as an initializer for a constexpr variable, we‚Äôll see later that the new standard lets us define certain functions as constexpr. Such functions must be simple enough that the compiler can evaluate them at compile time. We can use constexpr functions in the initializer of a constexpr variable.

Generally, it is a good idea to use constexpr for variables that you intend to use as constant expressions.

--
Literal Types

Because a constant expression is one that can be evaluated at compile time, there are limits on the types that we can use in a constexpr declaration. The types we can use in a constexpr are known as ‚Äúliteral types‚Äù because they are simple enough to have literal values.

Of the types we have used so far, the arithmetic, reference, and pointer types are literal types. Our Sales_item class and the library IO and string types are not literal types. Hence, we cannot define variables of these types as constexprs. We‚Äôll see other kinds of literal types later.

Although we can define both pointers and reference as constexprs, the objects we use to initialize them are strictly limited. We can initialize a constexpr pointer from the nullptr literal or the literal (i.e., constant expression) 0. We can also point to (or bind to) an object that remains at a fixed address.

For reasons we‚Äôll cover later, variables defined inside a function
ordinarily are not stored at a fixed address. Hence, we cannot use a constexpr pointer to point to such variables. On the other hand, the address of an object defined outside of any function is a constant expression, and so may be used to initialize a constexpr pointer. We‚Äôll see later, that functions may define variables that exist across calls to that function. Like an object defined outside any function, these special local objects also have fixed addresses. Therefore, a constexpr
reference may be bound to, and a constexpr pointer may address, such variables.

--
Pointers and constexpr

It is important to understand that when we define a pointer in a constexpr declaration, the constexpr specifier applies to the pointer, not the type to which the pointer points:

const int *p = nullptr; // p is a pointer to a const int
constexpr int *q = nullptr; // q is a const pointer to int

Despite appearances, the types of p and q are quite different; p is a pointer to const, whereas q is a constant pointer. The difference is a consequence of the fact that constexpr imposes a top-level const on the objects it defines.

Like any other constant pointer, a constexpr pointer may point to a const or a nonconst type.

==
(findfor)
(findrangefor)

Range for in C++ 2011:

vector<int> v = {1, 3, 5, 7, 9};

for (auto x : v)
    cout << x << ' ';

string str("some string");
for (auto c : str) // tao: c is a char
	cout << c << endl; 

Using a Range for to Change the Characters in a string

If we want to change the value of the characters in a string, we must define the loop variable as a reference type. Remember that a reference is just another name for a given object. When we use a reference as our control variable, that variable is bound to each element in the sequence in turn. Using the reference,
we can change the character to which the reference is bound.

string s("Hello World!!!");
// convert s to uppercase
for (auto &c : s) // for every char in s (note: c is a reference)
	c = toupper(c); // c is a reference, so the assignment changes the char in s
cout << s << endl;	

==
(findsleep)
Sleep

Compile the following file:

g++ -o sleep sleep.cc -std=c++0x -D_GLIBCXX_USE_NANOSLEEP

--- File sleep.cc starts ---
#include <iostream>
#include <chrono>
#include <thread>
using namespace std;

int main() {
    std::this_thread::sleep_for(std::chrono::milliseconds(5000));
    cout << "Hello world" << endl;
}
--- File sleep.cc ends ---

==
(findstring)
string

A string literal, which is a sequence of characters enclosed in double quotation marks.

The string and vector types are abstractions of the more primitive built-in array type. Arrays are less convenient to use than the library string and vector types.

A string is a variable-length sequence of characters. To use the string type, we must include the string header.

#include <string>
using std::string;

--
string literal: the compiler appends a null character ('\0') to every string literal. Thus, the actual size of a string literal is one more than its apparent size.

s.empty() //Returns bool
s.size() //Returns number, which is a string::size_type, see below
s[3] //Returns a reference to the char. Type of index is string::size_type. Tao: index can also be int.
s[0] = 'a'; //So long as the string is not const, we can assign a new value to the character that the subscript operator returns.

--
string operations:

s.empty(): Returns true if s is empty; otherwise returns false.
s.size(): Returns the number of characters in s. Tao: returned type is string::size_type.
s[n]: Returns a reference to the char at position n in s; positions start at 0.
s1 + s2: Returns a string that is the concatenation of s1 and s2.
s1 += s2: Tao: equivalent to s1 = s1 + s2
s1 = s2: Replaces characters in s1 with a copy of s2.
s1 == s2, s1 != s2: s1 and s2 are equal if they contain the same characters. Equality is case-sensitive. 
<, <=, <, <=: Comparisons are case-sensitive and use dictionary ordering.

--
Operations to moidfy strings (modify in-place)

s.insert(pos, args): Insert characters specified by args before pos. pos can be an index or an iterator. Versions taking an index returns a reference to s; those taking an iterator return an interator denoting the first inserted character.

s.append(args): Append args to s. Returns a reference to s.

s.erase(pos, len): Remove len characters starting at position pos. If len is omitted. Removes characters from pos to the end of the s. Returns a reference to s.

s.replace(range, args): Remove range of characters form s and replace them with the characters formed by args. range is either an index and a length or a pair of iterators into s. Returns a reference to s.

s.assign(args): Replace characters in s according to args. Returns a reference to s.

args can be one of the following (append and assign can use all forms, str must be distinc from s and the iterators b and e may not refer to s):

str: The string str.

str, pos, len: Up to len characters from str starting at pos.

cp, len: Up to len charactres from the character array pointed to by cp.

cp: Null-terminated array pointed to by pointer cp.

n, c: n copies of character c.

b, e: Characters in the range formed by iterators b and e.

intializer list: Comma-separated list of characters enclosed in braces.

args for replace and insert depend on how range or pos is specified:

replace          replace      insert      insert       args can be
(pos,len,args)   (b,e,args)   (pos,args)  (iter,args)  
yes              yes          yes         no           str
yes              no           yes         no           str,pos,len
yes              yes          yes         no           cp,len
yes              yes          no          no           cp
yes              yes          yes         yes          n,c
no               yes          no          yes          b2,e2
no               yes          no          yes          initializer list

--
append

The append operation is a shorthand way of inserting at the end.
The append changes the contents of a string (tao: in-place).
The parameter of append() can only be string, it can not be char.

s2.append("helo"); 

--
insert

s.insert(s.size(), "helo"); //Inserts "helo" before position 0 in s.

s.insert(s.size(), 5, '!'); //Inserts five exclamatin points at the end of s

s.insert(0, s2, 0, s2.size()); //Inserts s2.size() characters from s2 starting at s2[0] before s[0].

--
replace:

The replace operations are a shorthand way of calling erase and insert: 

// equivalent way to replace "4th" by "5th"
s.erase(11, 3); // s == "C++ Primer Ed."
s.insert(11, "5th"); // s == "C++ Primer 5th Ed."

// starting at position 11, erase three characters and then insert "5th"
s2.replace(11, 3, "5th"); // equivalent: s == s2
s.replace(11, 3, "Fifth"); // s == "C++ Primer Fifth Ed."

--
(findfind)
string Search Operations

The string class provides six different search functions, each of which has four overloaded versions. Table 9.14 describes the search members and their arguments.

Each of these search operations returns a string::size_type value that is the index of where the match occurred. If there is no match, the function returns a static member named string::npos. The library defines npos as a const string::size_type initialized with the value -1. Because npos is an unsigned type, this initializer means npos is equal to the largest possible size any string could have

string search operations:

s.find(args): Find the first occurence of args in s.

s.rfind(args): Find the las occurence of args in s.

s.find_first_of(args): Find the first occurence of any character from args in s.

s.find_last_of(args): Find the last occurence of any character from args in s.

s.find_first_not_of(args): Find the first character in s that is not in args.

s.find_last_not_of(args): Find the last character in s that is not in args.

args must be one of:

c, pos: Look for the character c starting at position pos in s. pos defaults to 0.

s2, pos: Look for string s2 starting at position pos in s. pos default to 0.

cp, pos: Look for the C-style null-terminated string pointed to the pointer cp. Start looking at position pos in s. pos defaults to 0.

cp, pos, n: Look for the first n characters in the array pointed to by the pointer cp. Start looking at position pos in s. No default for pos or n.

Searching (and other string operations) are case sensitive.

The string search functions return string::size_type, which is an
unsigned type. As a result, it is a bad idea to use an int, or other signed type, to hold the return from these functions

string s = "helo"; //Tao's example
s.find("lo")// Returns: 2

while((pos = s.find(delimiter)) != string::npos) {...} //Tao's example of npos

string name("AnnaBelle");
auto pos1 = name.find("Anna"); // pos1 == 0

string numbers("0123456789"), name("r2d2");
auto pos = name.find_first_of(numbers); // returns 1, i.e., the index of the first digit (tao: 2) in name

string dept("03714p3");
auto pos = dept.find_first_not_of(numbers); // returns 5, which is the index to the character 'p'

Searching Backward

The find operations we‚Äôve used so far execute left to right. The library provides analogous operations that search from right to left. The rfind member searches for the last‚Äîthat is, right-most‚Äîoccurrence of the indicated substring:

string river("Mississippi");
auto first_pos = river.find("is"); // returns 1
auto last_pos = river.rfind("is"); // returns 4 (tao: 4 means the 4th character from left, not from right).

--
The compare Functions

In addition to the relational operators, the string library provides a set of compare functions that are similar to the C library strcmp function. Like strcmp, s.compare returns zero or a positive or negative value depending on whether s is equal to, greater than, or less than the string formed from the given arguments.

Possible Arguments to s.compare:

s2: Compares to s2.

pos1, n1, s2: Compares n1 characters starting at pos1 from s to s2.

pos1, n1, s2, pos2, n2: Compares n2 characters starting at pos1 from s to the n2 characters starting at pos2 in s2.

cp: Compares s to the null-terminated array pointed to by cp.

pos1, n1, cp: Compares n1 characters starting at pos1 from s to cp.

pos1, n1, cp, n2: Compares n1 characters starting at pos1 from s to n2 characters starting from the pointer cp.

--
Numeric Conversions

The new standard introduced several functions that convert between numeric data and library strings:

int i = 42;
string s = to_string(i); // converts the int i to its character representation
double d = stod(s); // converts the string s to floating-point

Conversions between strings and Numbers:

to_string(val): Overloaded functions returning the string representation of val. val can be any arithmetic type. There are versions of to_string for each floating-point type and integral type that is int or larger. Small integral types are promoted.

stoi(s, p, b), stol(s, p, b), stoul(s, p, b), stoll(s, p, b), stoull(s, p, b): Return the intial substring of s that has numeric content as an int, long, unsigned long, long long, unsigned long long, respectively. b indicates the numeric base to use for the conversion; b defaults to 10. p is a pointer to a size_t in which to put the index of the first nonnumeric character in s; p defaults to 0, in which case the function does not store the index.

stof(s, p), stod(s, p), stold(s, p): Return the intial numeric substring in s as a float, double, or long double, respectively. p has the same behavior as described for the integer conversions.

The first non-whitespace character in the string we convert to numeric value must be a character that can appear in a number.

The first non-whitespace character in the string must be a sign (+ or -) or a digit. The string can begin with 0x or 0X to indicate hexadecimal. For the functions that convert to floating-point the string may also start with a decimal point (.) and may contain an e or E to designate the exponent. For the functions that convert to integral type, depending on the base, the string can contain alphabetic characters corresponding to numbers beyond the digit 9.

If the string can‚Äôt be converted to a number, These functions throw an invalid_argument exception. If the conversion generates a value that can‚Äôt be represented, they throw out_of_range.

--
string::size_type:

s.size() returns a string::size_type value. This type requires a bit of explanation.

The string class‚Äîand most other library types‚Äîdefines several companion types. These companion types make it possible to use the library types in a machine-independent manner. The type size_type is one of these companion types. 

Although we don‚Äôt know the precise type of string::size_type, we do know that it is an unsigned type big enough to hold the size of any string. Any variable used to store the result from the string size operation should be of type string::size_type.

Admittedly, it can be tedious to type string::size_type. Under the new standard, we can ask the compiler to provide the appropriate type by using auto or decltype:

auto len = line.size(); // len has type string::size_type  

Because size returns an unsigned type, it is essential to remember that expressions that mix signed and unsigned data can have surprising results. For example, if n is an int that holds a negative value, then s.size() < n will almost surely evaluate as true. It yields true because the negative value in n will
convert to a large unsigned value. Tao: Avadoles.

You can avoid problems due to conversion between unsigned and int by not using ints in expressions that use size().

--
The string library lets us convert both character literals and character string literals to strings. Because we can use these literals where a string is expected, we can rewrite the previous program as follows:

string s1 = "hello", s2 = "world"; // no punctuation in s1 or s2
string s3 = s1 + ", " + s2 + '\n';

When we mix strings and string or character literals, at least one operand to each + operator must be of string type:

string s4 = s1 + ", "; // ok: adding a string and a literal
string s5 = "hello" + ", "; // error: no string operand (tao: both are string literals, which are not string type variables)
string s6 = s1 + ", " + "world"; // ok: each + has a string operand
string s7 = "hello" + ", " + s2; // error: can't add string liter

For historical reasons, and for compatibility with C, string literals are not standard library strings. It is important to remember that these types differ when you use string literals and library strings.

--
Dealing with the Characters in a string

The followings should include the "cctype" header:

//c is a character
isalnum(c) //true if c is a letter or a digit.
isalpha(c) //true if c is a letter
isdigit(c) //true if c is a digit
islower(c) //true if c is a lowercase letter
isupper(c) //true if c is an uppercase letter
tolower(c) //If c is an upercase letter, returns its lowercase equivalent, otherwise returns c unchanged
toupper(c) //If c is a lowercase letter, returns its upercase equivalent, otherwise returns c unchanged
isspace(c) //true if c is whitespace (ie, a space, tab, vertical tab, return, newline, or formfeed)

--
#include <string>
using std::string;

string s1; // default initialization; s1 is the empty string
string s2 = s1; //copy initialization, s2 is a copy of s1
string s3 = "hiya"; //direct initialization, s3 is a copy of the string literal. Tao: according to definition, this is copy initialization, this example is arbitrary and misleading, and it is a waste of time to jiujie this example.
string s4(10, 'c'); // s4 is cccccccccc

--
Ways to Initialize a string:

string s1: Default initialization; s1 is the empty string.
string s2(s1): s2 is a copy of s1.
string s2 = s1: Equivalent to s2(s1), s2 is a copy of s1.
string s3("value"): s3 is a copy of the string literal, not including the null (tao: the null at the end of the string).
string s3 = "value": Equivalent to s3("value"), s3 is a copy of the string literal.
string s4(n, 'c'): Initialize s4 with n copies of the character 'c'.

We can default initialize a string, which creates an empty string; that is, a string with no characters. When we supply a string literal, the characters from that literal‚Äîup to but not including the null character at the end of the literal‚Äîare copied into the newly created string. When we supply a count
and a character, the string contains that many copies of the given character.

Direct and Copy Forms of Initialization (tao: the followings are also copied to "find copyinitialization")

Earlier we saw that C++ has several different forms of initialization. Using strings, we can start to understand how these forms differ from one another. When we initialize a variable using =, we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created. Otherwise, when we omit the =, we use direct initialization.

When we have a single initializer, we can use either the direct or copy form of initialization. When we initialize a variable from more than one value, such as in the initialization of s4 above, we must use the direct form of initialization:

string s5 = "hiya"; // copy initialization
string s6("hiya"); // direct initialization
string s7(10, 'c'); // direct initialization; s7 is cccccccccc

When we want to use several values, we can indirectly use the copy form of initialization by explicitly creating a (temporary) object to copy:

string s8 = string(10, 'c'); // copy initialization; s8 is cccccccccc. Tao: note the "string" on the right hand side, it creates a temporary string.

The initializer of s8‚Äîstring(10, 'c')‚Äîcreates a string of the given size and character value and then copies that value into s8. It is as if we had written

string temp(10, 'c'); // temp is cccccccccc
string s8 = temp; // copy temp into s8

Although the code used to initialize s8 is legal, it is less readable and offers no compensating advantage over the way we initialized s7.

--
Addtional ways to construct strings

n, len2 and pos2 are all unsigned values

string s(cp, n): s is a copy of the first n characters in the array to which cp points. That array must have at least n characters.

string s(s2, pos2): s is a copy of the characters in the string s2 starting at the index pos2. Undefined if pos2 > s2.size().

string s(s2, pos2, len2): s is a copy of len2 characters from s2 starting at the index pos2. Undefined if pos2 > s2.size(). Regardless of the value of len2, copies at most s2.size() - pos2 characters.

--
In some computers (like my Thinkpad), some functions (like ifstream) needs the input to string to be defined as type: const char*, for example:

const char* filename = "helo";
ifstream input_file(filename);

However, I can use string instead of const char* if compile using std C++ 11.

In some computers (like the Mac), it can be written as:

string filename = "helo";
ifstream input_file(filename);

--
(findsubstring)
Substring (get and find)

Get a substring:

string s2 = s.substr(pos, n) // return a string containing n characters fro s starting at pos. pos defaults to 0. n defaults to a value that causes the library to copy all the characters in s starting from pos.

Find a substring in a string:

Use std::string::find as follows:

if (s1.find(s2) != std::string::npos) {
    std::cout << "found!" << '\n';
}
Note: "found!" will be printed if s2 is a substring of s1, both s1 and s2 are of type std::string. 

string test = "123";
string res = test.substr(1, 0);
res.size(); //returns: 0

--
(findsplit)
split a string

** Split by a char **

Problem: Split a string by a delim, and return a vector of strings containing no delim

Use stringstream getline
Signature istream& getline (istream&& is, string& str, char delim)

#include <sstream>

//tao: notice the function parameter uses reference to a string
vector<string> split(const string &s, char delim) {
    stringstream ss(s);
    string item;
    vector<string> tokens;
    while (getline(ss, item, delim)) {
        tokens.push_back(item);
    }
    return tokens;
}

Tao's example of using the above function split:

string test_str = "Helo,how,are,you";
vector<string> strs = split(test_str, ',');
for(int i = 0; i < strs.size(); i++) cout << strs[i] << " ";
cout << endl;

Output:
Helo how are you

** Split by a string **

You can use the string::find() function to find the position of your string delimiter, then use string::substr() to get a token.

Example:

string s = "scott>=tiger";
string delimiter = ">=";
string token = s.substr(0, s.find(delimiter)); // token is "scott"

The substr(size_t pos = 0, size_t n = npos) function returns a substring of the object, starting at position pos and of length npos.

The find(const string& str, size_t pos = 0) function returns the position of the first occurrence of str in the string, or npos if the string is not found.
Tao's example:
string s = "helo";
s.find("lo")// Returns: 2
while((pos = s.find(delimiter)) != string::npos) {...}

If you have multiple delimiters, after you have extracted one token, you can remove it (delimiter included) to proceed with subsequent extractions (if you want to preserve the original string, just use  s = s.substr(pos + delimiter.length());):

s.erase(0, s.find(delimiter) + delimiter.length());
This way you can easily loop to get each token.

Complete Example
string s = "scott>=tiger>=mushroom";
string delimiter = ">=";

size_t pos = 0;
string token;
while ((pos = s.find(delimiter)) != string::npos) {
    token = s.substr(0, pos);
    cout << token << endl;
    s.erase(0, pos + delimiter.length());
}
cout << s << endl;
Output:

scott
tiger
mushroom

--
C-style charater strings are null terminated char arrays. 

C-style charater string functions: 
strlen, strcmp, strcat, strcpy.

For most applications, in addition to being safer, it is also more efficient to use library strings rather than C-style strings.

tao: convert a char array to string (from online: Note that this only works for constant NULL-terminated C-strings.)
char a1[2] = {'a', 'b', '\0'};
string str1(a1);

from online: convert a string to char array:
string temp = "cat";
char * tab2 = new char [temp.length()+1];
strcpy (tab2, temp.c_str());

==
(findtrim)
trim

Tao: the simplest way to trim the spaces at beginning and end of a string is:

string str = "   35   ";

str.erase(0, str.find_first_not_of(' '));
str.erase(str.find_last_not_of(' ') + 1);

cout << str << endl; //Output: 35
cout << str.size() << endl; //Ouptut: 2

From online:

There is no standard way of trimming a string, but it‚Äôs possible to implement using the methods in the string class:

Left trim: Use find_first_not_of() to find the characters to erase
Right trim: Use find_first_of() to find the characters to erase
Trim: Do a right trim followed by a left trim (or vice-versa)
Use erase() to actually erase the characters.

Here is my implementation. It defaults to trimming whitespace characters but you can specify any string of characters as the second argument.

string& ltrim(string& str, const string& chars = "\t\n\v\f\r ") {
    str.erase(0, str.find_first_not_of(chars)); //tao: see erase() by searching "find erase"
    return str;
}
 
string& rtrim(string& str, const string& chars = "\t\n\v\f\r ") {
    str.erase(str.find_last_not_of(chars) + 1);
    return str;
}

string& trim(string& str, const string& chars = "\t\n\v\f\r ") {
    return ltrim(rtrim(str, chars), chars);
}

string extract_column_names(string line) {
    return line + "\n";
}

Example:

string str = " test ";
trim(str);

==
(finderase)
erase

std::string::erase in C++

string s2 = s.erase (pos, len); //Erases the portion of the string value that begins at the character position pos and spans len characters (or until the end of the string, from online)

The function erases a part of the string content, shortening the length of the string. The characters affected depend on the member function version used:
Return value : erase() returns *this.

string& string ::erase ()
Erases all characters in a string

string& string ::erase (size_type pos)
Erases all characters after position ‚Äòpos‚Äô. 
Throw out_of_range if idx > size().

string& string ::erase (size_type idx, size_type len ) 
Erases at most, len characters of *this, starting at index idx. 
If len is missing, all remaining characters are removed. 
Throw out_of_range if idx > size().
Example: 
string str("Hello World!");
str.erase(1, 4); //str = "H World!", tao: yes it is in-place, confirmed.
s.erase(s.size() - 5, 5); //Erase the last five characters from s.

string& string ::erase (iterator pos)
Erase the single character at iterator position pos.
Return the first character after the last character removed
If no such character is remaining then, returns 
string::end() i.e. position after the last character.

string& string ::erase (iterator beg, iterator end )
Erase the single character at iterator position pos.
Erases all characters of the range [ beg, end)
Returns end i.e. the first character after the last character removed.
If no such character is remaining then, returns 
string::end() i.e. position after the last character

==
(findargs)                    
(findcommandlineargument)      
Command line argument 

Note that if in my Thinkpad, the following should be compiled in C++ 11.

#include <string>
using namespace std;

int main(int argc, char** argv) {
    int nfiles = stoi(argv[1]); // If run as: ./main 5, then argv[1] = "5"
    cout << "nfiles = " << nfiles << endl;
    return 0;
}

Run the program:
./main 5

Then the output is:
nfiles = 5

==
(findcontainer)
(findsequentialcontainer)
Sequential containers

A container holds a collection of objects of a specified type. The sequential containers let the programmer control the order in which the elements are stored and accessed. That order does not depend on the values of the elements. Instead, the order corresponds to the position at which elements are put into the container. By contrast, the ordered and unordered associative containers, store their elements based on the value of a key.

The sequential containers, which are listed below, all provide fast sequential access to their elements. However, these containers offer different performance tradeoffs relative to

‚Ä¢ The costs to add or delete elements to the container
‚Ä¢ The costs to perform nonsequential access to elements of the container

vector: Flexible-size array. Supports fast random access. Inserting or deleting elements other than at the back may be slow.

deque: Double-ended queue. Supports fast random access. Fast insert/delete at front or back.

list: Doubly linked list. Supports only bidirectional sequential access. Fast inser/delete at any point in the list.

forward_list: Singly linked list. Supports only sequential access in one direction. Fast insert/delete at any point in the list.

array: Fixed-sied array. Supports fast random access. Cannot add or remove elements. Tao: note that this array means the library array, not the build-in array, as explained below.

string: A specialized container, similar to vector, that contains characters. Fast random access. Fast inser/delete at the back.

With the exception of array, which is a fixed-size container, the containers provide efficient, flexible memory management. We can add and remove elements, growing and shrinking the size of the container.

For example, string and vector hold their elements in contiguous memory.
Because elements are contiguous, it is fast to compute the address of an element from its index. However, adding or removing elements in the middle of one of these containers takes time: All the elements after the one inserted or removed have to be moved to maintain contiguity. Moreover, adding an element can sometimes require that additional storage be allocated. In that case, every element must be moved into
the new storage.

The list and forward_list containers are designed to make it fast to add or remove an element anywhere in the container. In exchange, these types do not support random access to elements: We can access an element only by iterating through the container. Moreover, the memory overhead for these containers is often substantial, when compared to vector, deque, and array.

A deque is a more complicated data structure. Like string and vector, deque supports fast random access. As with string and vector, adding or removing elements in the middle of a deque is a (potentially) expensive operation. However, adding or removing elements at either end of the deque is a fast operation, comparable to adding an element to a list or forward_list.

The forward_list and array types were added by the new standard. An array is a safer, easier-to-use alternative to built-in arrays. Like built-in arrays, library arrays have fixed size. As a result, array does not support operations to add and remove elements or to resize the container. A forward_list is intended to be comparable to the best handwritten, singly linked list. Consequently, forward_list does not have the size operation because storing or computing its size would entail overhead compared to a handwritten list. For the other containers, size is guaranteed to be a fast, constant-time operation.

There are a few rules of thumb that apply to selecting which container to use:

‚Ä¢ Unless you have a reason to use another container, use a vector.

‚Ä¢ If your program has lots of small elements and space overhead matters, don‚Äôt use list or forward_list.

‚Ä¢ If the program requires random access to elements, use a vector or a deque.

‚Ä¢ If the program needs to insert or delete elements in the middle of the container, use a list or forward_list.

‚Ä¢ If the program needs to insert or delete elements at the front and the back, but not in the middle, use a deque.

‚Ä¢ If the program needs to insert elements in the middle of the container only while reading input, and subsequently needs random access to the elements:
‚Äì First, decide whether you actually need to add elements in the middle of a container. It is often easier to append to a vector and then call the library sort function to reorder the container when you‚Äôre done with input.
‚Äì If you must insert into the middle, consider using a list for the input phase. Once the input is complete, copy the list into a vector.

--
Defining and intializing a container

Every container type defines a default constructor. With the exception of array, the default constructor creates an empty container of the specified type. Again excepting array, the other constructors take arguments that specify the size of the container and initial values for the elements.

Initializing a Container as a Copy of Another Container

There are two ways to create a new container as a copy of another one: We can directly copy the container, or (excepting array) we can copy a range of elements denoted by a pair of iterators.

To create a container as a copy of another container, the container and element types must match. When we pass iterators, there is no requirement that the container types be identical. Moreover, the element types in the new and original containers can differ as long as it is possible to convert the elements we‚Äôre copying to the element type of the container we are initializing:

// each container has three elements, initialized from the given initializers
list<string> authors = {"Milton", "Shakespeare", "Austen"};

vector<const char*> articles = {"a", "an", "the"};

list<string> list2(authors); // ok: types match

deque<string> authList(authors); // error: container types don't match

vector<string> words(articles); // error: element types must match

// ok: converts const char* elements to string
forward_list<string> words(articles.begin(), articles.end());

The constructor that takes two iterators uses them to denote a range of elements that we want to copy. As usual, the iterators mark the first and one past the last element to be copied. The new container has the same size as the number of elements in the range. Each element in the new container is initialized by the value of the corresponding element in the range.

Because the iterators denote a range, we can use this constructor to copy a subsequence of a container. For example, assuming it is an iterator denoting an element in authors, we can write

// copies up to but not including the element denoted by it
deque<string> authList(authors.begin(), it);

List Initialization

Under the new standard, we can list initialize a container:

list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};

Sequential Container Size-Related Constructors

we can also initialize the sequential containers (other than
array) from a size and an (optional) element initializer. If we do not supply an element initializer, the library creates a value-initialized one for us

vector<int> ivec(10, -1); // ten int elements, each initialized to
-1

list<string> svec(10, "hi!"); // ten strings; each element is "hi!"

forward_list<int> ivec(10); // ten elements, each initialized to 0

deque<string> svec(10); // ten elements, each an empty string

We can use the constructor that takes a size argument if the element type is a builtin type or a class type that has a default constructor. If the element type does not have a default constructor, then we must specify an explicit element initializer along with the size.

The constructors that take a size are valid only for sequential containers; they are not supported for the associative containers.

Library arrays Have Fixed Size

(Tao: library arrays are different from built-in arrays)

Just as the size of a built-in array is part of its type, the size of a library array is part of its type. When we define an array, in addition to specifying the element type, we also specify the container size:

array<int, 42> // type is: array that holds 42 ints

To use an array type we must specify both the element type and the size:

array<int, 10>::size_type i; // array type includes element type and size

Because the size is part of the array‚Äôs type, array does not support the normal container constructors.

Unlike the other containers, a default-constructed array is not
empty: It has as many elements as its size. These elements are default initialized just as are elements in a built-in array.

array<int, 10> ia1; // ten default-initialized ints

array<int, 10> ia2 = {0,1,2,3,4,5,6,7,8,9}; // list initialization

array<int, 10> ia3 = {42}; // ia3[0] is 42, remaining elements are 0

It is worth noting that although we cannot copy or assign objects of built-in array types, there is no such restriction on array:

int digs[10] = {0,1,2,3,4,5,6,7,8,9};

int cpy[10] = digs; // error: no copy or assignment for built-in arrays

array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};

array<int, 10> copy = digits; // ok: so long as array types match

--
Assignment and swap

The assignment operator replaces the entire range of elements in the lefthand container with copies of the elements from the right-hand operand:

c1 = c2; // replace the contents of c1 with a copy of the elements in c2

c1 = {a,b,c}; // after the assignment c1 has size 3

Container Assignment Operations

c1 = c2: Replace the elements in c1 with copies of the elements in c2. c1 and c2 must be the same type.

c = {a, b, c...}: Replace the elements in c1 with copies of the elements in the intializer list. (Not valide for array)

swap(c1, c2): Exchanges elements in c1 with those in c2. c1 and c2 must be the same type. swap is usually much faster than copying elements from c2 to c1.

Assign operations not valide for associative containers or array:

seq.asign(b, e): Replaces elements in seq with those in the range denoted by iterators b and e. The iterators b and e must not refer to elements in seq.

seq.assign(il): Replaces the elements in seq with those in the intializer list il.

seq.assign(n, t): Replaces the elements in seq with n elements with value t.

Unlike built-in arrays, the library array type does allow assignment. The left-and right-hand operands must have the same type:

array<int, 10> a1 = {0,1,2,3,4,5,6,7,8,9};

array<int, 10> a2 = {0}; // elements all have value 0

a1 = a2; // replaces elements in a1

a2 = {0}; // error: cannot assign to an array from a braced list. Tao: ?

Because the size of the right-hand operand might differ from the size of the left-hand operand, the array type does not support assign and it does not allow assignment from a braced list of values.

Using assign (Sequential Containers Only)

The assignment operator requires that the left-hand and right-hand operands have the same type. It copies all the elements from the right-hand operand into the left-hand operand. The sequential containers (except array) also define a member named assign that lets us assign from a different but compatible type, or assign from a subsequence of a container.

list<string> names;

vector<const char*> oldstyle;

names = oldstyle; // error: container types don't match

// ok: can convert from const char*to string
names.assign(oldstyle.cbegin(), oldstyle.cend());

Using swap

The swap operation exchanges the contents of two containers of the same type.

vector<string> svec1(10); // vector with ten elements

vector<string> svec2(24); // vector with 24 elements

swap(svec1, svec2);

After the swap, svec1 contains 24 string elements and svec2 contains ten. With the exception of arrays, swapping two containers is guaranteed to be fast‚Äîthe elements themselves are not swapped; internal data structures are swapped.

The fact that elements are not moved means that, with the exception of string, iterators, references, and pointers into the containers are not invalidated. They refer to the same elements as they did before the swap. However, after the swap, those elements are in a different container. For example, had iter denoted the string at position svec1 [3] before the swap, it will denote the element at position svec2[3] after the swap. Differently from the containers, a call to swap on a string may invalidate iterators, references and pointers.

Unlike how swap behaves for the other containers, swapping two arrays does exchange the elements. As a result, swapping two arrays requires time proportional to the number of elements in the array.

After the swap, pointers, references, and iterators remain bound to the same element they denoted before the swap. Of course, the value of that element has been swapped with the corresponding element in the other array.

In the new library, the containers offer both a member and nonmember version of swap. Earlier versions of the library defined only the member version of swap. The nonmember swap is of most importance in generic programs. As a matter of habit, it
is best to use the nonmember version of swap.

--
Container Size Operations

With one exception, the container types have three size-related operations. The size member returns the number of elements in the container; empty returns a bool that is true if size is zero and false otherwise; and max_size returns a number that is greater than or equal to the number of elements a container
of that type can contain. For reasons we‚Äôll explain in the next section, forward_list provides max_size and empty, but not size.

--
Relational Operators

Every container type supports the equality operators (== and !=); all the containers except the unordered associative containers also support the relational operators (>, >=, <, <=). The right- and left-hand operands must be the same kind of container and must hold elements of the same type. That is, we can compare a vector<int> only with another vector<int>. We cannot compare a vector<int> with a list<int> or a vector<double>.

Comparing two containers performs a pairwise comparison of the elements. These operators work similarly to the string relationals:

‚Ä¢ If both containers are the same size and all the elements are equal, then the two containers are equal; otherwise, they are unequal.

‚Ä¢ If the containers have different sizes but every element of the smaller one is equal to the corresponding element of the larger one, then the smaller one is less than the other.

‚Ä¢ If neither container is an initial subsequence of the other, then the comparison depends on comparing the first unequal elements.

We can use a relational operator to compare two containers only if the appropriate comparison operator is defined for the element type.

For example, the Sales_data type that we defined in Chapter 7
does not define either the == or the < operation. Therefore, we cannot compare two containers that hold Sales_data elements:

--
Sequential Container Operations

Adding Elements to a Sequential Container

Each of these operations will be explained with more details below.

c.push_back(t), c.emplace_back(args): Creates an element with value t or constructed from args at the end of c. Returns void.

c.push_front(t), c.emplace_front(args): Creates an element with value t or constructed from args on the front of c. Returns void.

c.insert(p, t), c.emplace(p, args): Creates an element with value t or constructed from args before the element denoted by iterator p. Returns an iterator referring to the element that was added.

c.insert(p, n, t): Inserts n elements with value t before the element denoted by iterator p. Returns an iterator to the first element inserted; if n is zero, returns p.

c.insert(p, b, e): Inserts the elements from the range denoted by iterators b and e before the element denoted by iterator p. b and e may not refer to elements in c. Returns an iterator to the first element inserted; if the range is empty, returns p.

c.insert(p, il): il is a braced list of element values. Inserts the given values before the element denoted by the iterator p. Returns an iterator to the first inserted elements; if the list is empty returns p.

Note that for container a, a[0] is front, a[size - 1] is back.

When we use an object to initialize a container, or insert an object into a container, a copy of that object‚Äôs value is placed in the container, not the object itself.

These operations change the size of the container, they are not supported by array. forward_list has special versions of insert and emplace. push_back and emplace_back not valid for foward_list. push_front and emplace_front not valid for vector or string.

Adding elements to a vector, string, or deque potentially invalidates all existing iterators, references, and pointers into the container.

--
Using push_front

In addition to push_back, the list, forward_list, and deque containers support an analogous operation named push_front. This operation inserts a new element at
the front of the container.

--
Adding Elements at a Specified Point in the Container

Each of the insert functions takes an iterator as its first argument. element(s) are inserted before the position denoted by the iterator.

slist.insert(iter, "Hello!"); // insert "Hello!" just before iter

Even though some containers do not have a push_front operation, there is no similar constraint on insert.

It is legal to insert anywhere in a vector, deque, or string. However, doing so can be an expensive operation.

--
Inserting a Range of Elements

svec.insert(svec.end(), 10, "Anna");

This code inserts ten elements at the end of svec and initializes each of those elements to the string "Anna".

The versions of insert that take a pair of iterators or an initializer list insert the elements from the given range before the given position:

vector<string> v = {"quasi", "simba", "frollo", "scar"};

// insert the last two elements of v at the beginning of slist
slist.insert(slist.begin(), v.end() - 2, v.end());

slist.insert(slist.end(), {"these", "words", "will",
"go", "at", "the", "end"});

// run-time error: iterators denoting the range to copy from
// must not refer to the same container as the one we are changing
slist.insert(slist.begin(), slist.begin(), slist.end());

Under the new standard, the versions of insert that take a count or a range return an iterator to the first element that was inserted. 

We can use the value returned by insert to repeatedly insert elements at a specified position in the container:

list<string> 1st;
auto iter = 1st.begin();
while (cin >> word)
iter = 1st.insert(iter, word); // same as calling push_front

--
Using the Emplace Operations

The new standard introduced three new members‚Äîemplace_front, emplace, and emplace_back‚Äîthat construct rather than copy elements. 

When we call a push or insert member, we pass objects of the element type and those objects are copied into the container. When we call an emplace member, we pass arguments to a constructor for the element type. The emplace members use
those arguments to construct an element directly in space managed by the container.

c.emplace_back("978-0590353403", 25, 15.99);

--
9.3.2. Accessing Elements

Operations to Access Elements in a Sequential Container

c.back(): Returns a reference to the last element in c. Undefined if c is empty.

c.front(): Returns a reference to the first element in c. Undefined if c is empty.

c[n]: Returns a reference to the element indexed by the unsigned integratal value n. Undefined if n >= c.size().

c.at[n]: Returns a reference to the element indexed by n. If the index is out of range, throws an out_of_range exception.

// check that there are elements before dereferencing an iterator or calling front or back
if (!c.empty()) {
	// val and val2 are copies of the value of the first element in c
	auto val = *c.begin(), val2 = c.front();
	// val3 and val4 are copies of the of the last element in c
	auto last = c.end();
	auto val3 = *(--last); // can't decrement forward_list iterators
	auto val4 = c.back(); // not supported by forward_list
}

Two things are noteworthy in this program: The end iterator refers to the (nonexistent) element one past the end of the container. To fetch the last element we must first decrement that iterator. The other important point is that before calling
front or back (or dereferencing the iterators from begin or end), we check that c isn‚Äôt empty.

The Access Members Return References

if (!c.empty()) {
	c.front() = 42; // assigns 42 to the first element in c
	auto &v = c.back(); // get a reference to the last element
	v = 1024; // changes the element in c
	auto v2 = c.back(); // v2 is not a reference; it's a copy of c.back()
	v2 = 0; // no change to the element in c
}

--
Subscripting and Safe Random Access

The subscript operator takes an index and returns a reference to the element at that position in the container. The subscript operator does not check whether the index is in range.

If we want to ensure that our index is valid, we can use the at member instead. The at member acts like the subscript operator, but if the index is invalid, at throws an out_of_range exception.

--
Erasing Elements (remove elements)

Erase operations on sequential containers

c.pop_back(): Removes last element in c. Undefined if c is empty. Returns void.

c.pop_front(): Removes first element in c. Undefined if c is empty. Returns void.

c.erase(p): Removes the element denoted by the iterator p and returns an iterator to the element after the one deleted or the off-the-end iterator if p denotes the last element. Undefined if p is the off-the-end iterator.

c.erase(b, e): Removes the range of elements denoted by the iterator b and e. Returns an iterator to the elements after the last one that was deleted, or an off-the-end iterator if e is itself and off-the-end iterator.

c.clear(): Removes all the elements in c. Returns void.

There operations change the size of the container and so are not supported by array. forward_list has a special version of erase pop_back not valid for foward_list; pop_front not valid for vector and string. Just as there is no push_front for vector and string, there is also no pop_front for those types. 

Specialized forward_list Operations

To add or remove an element, we need access to its predecessor in order to update that element‚Äôs links. However, forward_list is a singly linked list. In a singly linked list there is no easy way to get to an element‚Äôs predecessor. For this reason, the operations to add or remove elements in a forward_list operate by changing the element after the given element. forward_list does not define insert, emplace, or erase. Instead it defines members (listed in Table 9.8) named insert_after, emplace_after, and erase_after. 

--
Resizing a Container

With the usual exception of arrays, we can use resize, to
make a container larger or smaller. If the current size is greater than the requested size, elements are deleted from the back of the container; if the current size is less than the new size, elements are added to the back of the container:

list<int> ilist(10, 42); // ten ints: each has value 42

ilist.resize(15); // adds five elements of value 0 to the back of ilist

ilist.resize(25, -1); // adds ten elements of value -1 to the back of ilist

ilist.resize(5); // erases 20 elements from the back of ilist

Sequential Container Size Operations

c.resize(n): Resize c so that it has n elements. If n < c.size(), the excess elements are discarded. If new elements must be added, they are value initialized.

c.resize(n, t): Resize c to have n elements. Any elements added have value t.

--
Container Operations May Invalidate Iterators

Operations that add or remove elements from a container can invalidate pointers, references, or iterators to container elements. An invalidated pointer, reference, or iterator is one that no longer denotes an element. Using an invalidated pointer,
reference, or iterator is a serious programming error that is likely to lead to the same kinds of problems as using an uninitialized pointer.

When we add or remove elements in a vector or string, or add elements or remove any but the first element in a deque, the iterator returned by end is always invalidated. Don‚Äôt cache the iterator returned from end() in loops that insert or delete
elements in a deque, string, or vector. Rather than storing the end() iterator, we must recompute it after each insertion.

--
How a vector Grows

To support fast random access, vector elements are stored contiguously‚Äîeach element is adjacent to the previous element. Library implementors use allocation strategies that reduce the
number of times the container is reallocated. When they have to get new memory, vector and string implementations typically allocate capacity beyond what is immediately needed. The container holds this storage in reserve and uses it to allocate new elements as they are added. Thus, there is no need to reallocate the container for each new element.

The vector and string types provide members that let us
interact with the memory-allocation part of the implementation. The capacity operation tells us how many elements the container can hold before it must allocate more space. The reserve operation lets us tell the container how many elements it should be prepared to hold. reserve does not change the number of elements in the container; it affects only how much memory the vector preallocates. A call to reserve changes the capacity of the vector only if the requested space exceeds the current capacity. If the requested size is greater than the current
capacity, reserve allocates at least as much as (and may allocate more than) the requested amount. If the requested size is less than or equal to the existing capacity, reserve does
nothing. Similarly, the resize members change only the
number of elements in the container, not its capacity

capacity and size

It is important to understand the difference between capacity and size. The size of a container is the number of elements it already holds; its capacity is how many elements it can hold before more space must be allocated.

==
(findcontainerlibrary)
(findcontainerfunctions)
(findcontainermethods)
Container functions

Operations that are provided by all container types (sequential containers, associative containers, etc):

** Type Aliases **

iterator: Type of the iterator for this container type

const_iterator: Iterator type that can read but not change its elements

size_type: Unsigned integral type big enough to hold the size of the largest possible container of this container type. Tao: the 5 in a[5] is size_type, others can be understood in the samiliar way.

difference_type: Signed integral type big enough to hold the distance between two iterators.

value_type: Element type

reference: Element's lvalue type; synonym for value_type&

const_reference: Element's const lvalue type (i.e., const value_type&)

** Construction **

C c; Default constructor, empty containder (array: see later).

C c1(c2); Construct c1 as a copy of c2.

C c(b, e); Copy elmeents from the range denoted by iterators b and e (not valid for array)

C c{a, b, c...}; List initialize c

** Assignment and swap **

c1 = c2: Replace elements in c1 with those in c2

c1 = {a, b, c...}: Replace elements in c1 with those in the list (not valid for array)

a.swap(b): Swap elements in a with those in b

swap(a, b): Equivalent to a.swap(b)

** Size **

c.size(): Number of elements in c (not valide for forward_list)

c.max_size(): Maximum number of elements c can hold

c.empty(): false if c has any elments, true otherwise

** Add/Remove Elements (not valid for array) **

Note: the interface to these operations varies by container type

c.insert(args): Copy element(s) as specified by args into c

c.emplace(inits): Use inits to construct an element in c

c.erase(args): Remove element(s) specified by args

c.clear(): Remove all elements from c; returns void

** Equality and Relational Operations **

==, !=  Equality valid for all container types
<, <-, >, >=  Relations (not valid for unordered associative containers)

** Obtain Iterators **

c.begin(): Return iterator to the first element in c
c.end(): Return iterator to one past the last element in c
c.cbegin(), c.cend(): Return const_iterator

** Additional Members of Reversible Containers (not valid for forward_lsit) **

reverse_iterator: Iterator that addresses elements in reverse order
const_reverse_iterator: Reverse iterator that cannot write the elments
c.rbegin(): Return iterator to the last element in c
c.rend(): Return iterator to on past the first element in c
c.crbegin(), crend(): Return const_reverse_iterator

--
Operators that are speciic to the sequential containers:

Defining and Initializing Containers:

C c; Default constructor. If C is array, then the elements in c are default-initialized; otherwise c is empty.

C c1(c2), C c1 = c2: c1 is a copy of c2. c1 and c2 must have the same type (i.e., they must be the same container type and hold the same element type; for array must also have the same size).

C c{a, b, c...}, C c = {a, b, c...}: c is a copy of the element in the initializer list. Type of elements in the list must be compatible with the element type of C. For array, the list must have same number or fewer elements tha the size of the array, any missing elements are value-initialized.

C c(b, e): c is a copy of the elements in the range denoted by iterators b and e. Type of the elements must be compatile with the element type of C. (Not valid for array).

** Construction that take a size are valid for sequential containers (not including array) only **

C seq(n): seq has n value-initialized elements; this constructor is explicit. (Not valid for string).

C seq(n, t): seq has n elements with value t.

--
In this section, we‚Äôll cover aspects common to all of the containers. The remainder of this chapter will then focus solely on sequential containers; we‚Äôll cover operations specific to the associative containers in Chapter 11.

In general, each container is defined in a header file with the same name as the type. That is, deque is in the deque header, list in the list header, and so on.

The containers are class templates. As with vectors, we must supply additional information to generate a particular container type. For most, but not all, of the containers, the information we must supply is the element type:

list<Sales_data> // list that holds Sales_data objects
deque<double> // deque that holds doubles

Almost any type can be used as the element type of a sequential container. In particular, we can define a container whose element type is itself another container.

vector<vector<string>> lines; // vector of vectors

Older compilers may require a space between the angle brackets, for example, vector<vector<string> >.

Although we can store almost any type in a container, some container operations impose requirements of their own on the element type. We can define a container for a type that does not support an operation-specific requirement, but we can use an operation only if the element type meets that operation‚Äôs requirements.

As an example, the sequential container constructor that takes a size argument uses the element type‚Äôs default constructor. Some classes do not have a default constructor. We can define a container that holds objects of such types, but we cannot construct such containers using only an element count:

// assume noDefault is a type without a default constructor
vector<noDefault> v1(10, init); // ok: element initializer supplied
vector<noDefault> v2(10); // error: must supply an element initializer

==
(findvector)
vector

#include <vector>
using std::vector;

--
vector<int> v1; //v1 is empty (tao: ie, v1.size() = 0, proved by many practices)

vector<int> v2 = v1; //v2 is a copy of the elements in v1 (tao: copies the values of v1 to v2)

vector<int> v1(10); //v1 has n copies of a value-initialized object. 10 elements, each initialized to 0.

vector<string> v1(10); //10 elements, each an empty string

vector<int> v1(n, val); //v1 has n elements with value val

vector<vector<int>> v(10, vector<int>(10,1)); //From online. v is a 10*10 vector, all elements initialized to 1.

vector<int> v1 = {1, 2, 3};//C++11 standard.

vector<int> v1{1,2,3};//Define a vector with elements

--
Ways to initialize a vector:

vector<T> v1: vector that holds objects of type T. Default initialization; v1 is empty.

vector<T> v2(v1): v2 has a copy of each element in v1.

vector<T> v2 = v1: Equivalent to v2(v1), v2 is a copy of the elements in v1.

vector<T> v3(n, val): v3 has n elements with value val.

vector<T> v4(n): v4 has n copies of a value-initialized object. See more below.

vector<T> v5{a, b, c...}: v5 has many elements as there are initializers; elements are initialized by corresponding initializers.

vector<T> v5 = {a, b, c...}: Equivalent to v5{a, b, c...}.

Searched online, in the old C++ version, to initialize a vector, we can only use push_back(). 

--
vector<T> v4(n): v4 has n copies of a value-initialized object

A restrictions on this form of initialization is that some classes require that we always supply an explicit initializer. If our vector holds objects of a type that we cannot default initialize, then we must supply an initial element value; it is not possible to create vectors of such types by supplying only a size.

--
v.push_back(3) //Adds an element with value 3 to end of v

v.empty() //Returns a bool

v.size() //Returns a number, which is of type vector<int>::size_type

v[5] //Returns a reference to the element

v1 = v2 //Replaces the elements in v1 with a copy of the elements in v2

v1 == v2 //Equal if each element in v1 is equal to the corresponding element in v2. 

v1 != v2

v1 <= v2 //Have their normal meanings using dictionary ordering.
vec.clear() //Removes all elements from the vector (which are destroyed), leaving the container with a size of 0.

--
vector operations:

In addition to push_back, vector provides only a few other operations, most of which are similar to the corresponding operations on strings.

v.push_back(t): Adds an element with value t to end of v.

v.empty(): Returns true if v is empty; otherwise returns false.

v.size(): Returns the number of elements in v. Returns a value of the size_type, eg: vector<int>::size_type

v[n]: Returns a reference to the element at position n in v. Subscripts for vector start at 0; the type of a subscript is the
corresponding size_type, eg: vector<int>::size_type

v1 = v2: Replaces the elements in v1 with a copy of the elements in v2.

v1 = {a, b, c...}: Replaces the elements in v1 with a copy of the elements in the comma-sperated list.

v1 == v2, v1 != v2: v1 and v2 are equal if they have the same number of elements and each element in v1 is equal to the corresponding element in v2.

<, <=, >, >=: Have their normal meanings using dictionary ordering.

vector_name.insert(position, val): inserts new elements before the element at the specified position, effectively increasing the container size by the number of elements inserted.

--
vector<vector<double> > v1 //correct, note the space between > >
vector<vector<double>> v1 //wrong <- tao: in the Mac (or C++11?), this is also correct.

vector< vector<int> > a(n,vector<int>(n)); //a is an 2D (n*n) vector, from HackerRank

--
We can define vectors to hold objects of most any type. Because references are not objects, we cannot have a vector of references.

vector is a template, not a type. Types generated from vector must include the element type, for example, vector<int>.

We can define vectors to hold objects of most any type. Because references are not objects, we cannot have a vector of references.

The string and vector types are abstractions of the more primitive built-in array type. Arrays are less convenient to use than the library string and vector types.

Some compilers may require the old-style declarations for a vector of vectors, for example, vector<vector<int> > (tao: there is an extra space).

We cannot use a range for if the body of the loop adds elements to the vector. The body of a range for must not change the size of the sequence over which it is iterating.

Attempting to subscript elements that do not exist is, unfortunately, an extremely common and pernicious programming error. So-called buffer overflow errors are the result of subscripting elements that don‚Äôt exist. Such bugs are the most common cause of security problems in PC and other applications.

--
Traverse a vector (in C++ 11):

//vec is type vector<Person*>
for(auto p : vec) {
  cout << p->height << endl;
}

--
Vector iterator:

#include <iostream>
#include <vector>
using namespace std;

int main ()
{
  vector<int> myvector;
  for (int i=1; i<=5; i++) myvector.push_back(i);

  cout << "myvector contains:";
  for (vector<int>::iterator it = myvector.begin() ; it != myvector.end(); ++it)
    cout << ' ' << *it;
  cout << '\n';

  return 0;
}
Edit & Run

--
The following experiment shows that vectors are also saved contiguously in memory, same as array:

vector<int> vec = {1, 2, 3, 4, 5};
int n = vec.size();

for(int *p = &vec[0]; p < &vec[n]; ++p) cout << *p << " ";
cout << endl;

Output: 1 2 3 4 5

--
Vector of objects:

From my leetcode code:

vector<Interval> res;
res.push_back(*iterator); // *iterator is an object of Interval

--
How to find out if an item is present in a vector?

You can use std::find from <algorithm>:

std::find(vector.begin(), vector.end(), item) != vector.end()
This returns a bool (true if present, false otherwise). With your example:

#include <algorithm>

if ( std::find(vector.begin(), vector.end(), item) != vector.end() )
   do_this();
else
   do_that();

Tao's experiment shows that finding an element from a vector is much slower than from a set. 

--
(findsortvector)
Sort a vector:

// C++ program to sort a vector in non-decreasing 
// order. 
#include <iostream>
#include <vector>
using namespace std; 
  
int main() 
{ 
    vector<int> v{ 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 }; 
  
    sort(v.begin(), v.end()); 
  
    for (auto x : v) cout << x << " "; //Ouptut is sorted: 0 1 2 3 4 5 6 7 8 9
  
    return 0; 
} 

How to sort in descending order?
sort() takes a third parameter that is used to specify the order in which elements are to be sorted. We can pass ‚Äúgreater()‚Äù function to sort in descending order. This function does comparison in a way that puts greater element before.

// C++ program to sort a vector in non-increasing 
// order. 
#include <iostream>
#include <vector>
using namespace std; 
  
int main() 
{ 
    vector<int> v{ 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 }; 
  
    sort(v.begin(), v.end(), greater<int>()); 
  
    for (auto x : v) cout << x << " "; //Ouptut: 9 8 7 6 5 4 3 2 1 0
  
    return 0; 
} 

How to sort in particular order?
We can also write our own comparator function and pass it as a third parameter.

// A C++ program to sort vector using 
// our own comparator 
#include <iostream>
#include <vector>
using namespace std; 
  
// An interval has start time and end time 
struct Interval { 
    int start, end; 
}; 
 
// Tao: in the following compare function, if for i1 < i2 it returns true, then in the sort, smaller elements will be put in front.

// Tao's experience shows that the following function compareInterval should be defined outside of a class (it can be used either inside or outside a class). If I must put it inside a class, define it as a static function: static bool compareInterval(Interval i1, Interval i2) {...}
// Compares two intervals according to staring times. 
bool compareInterval(Interval i1, Interval i2) 
{ 
    return (i1.start < i2.start); 
} 
  
int main() 
{ 
    vector<Interval> v { { 6, 8 }, { 1, 9 }, { 2, 4 }, { 4, 7 } }; 
  
    // sort the intervals in increasing order of 
    // start time 
    sort(v.begin(), v.end(), compareInterval); 
  
    cout << "Intervals sorted by start time : \n"; 
    for (auto x : v) 
        cout << "[" << x.start << ", " << x.end << "] "; 
  
    return 0; 
} 

Output :

Intervals sorted by start time : 
[1, 9] [2, 4] [4, 7] [6, 8] 

--
Concatenating two vectors:

vector1.insert( vector1.end(), vector2.begin(), vector2.end() );

--
Convert array to vector:

#include <iterator>
#include <vector>
using namespace std;

int x[] = { 1, 2, 3, 4, 5 };
vector<int> v(begin(x), end(x));

--
vector<int> v;
for(vector<int>::size_type i = 0; i < 10; ++i) {
    v[i] = i; // Wrong. Segmentation fault: 11. Because v is always an empty vector, so can not assign.
    v.push_back(i); // Correct
}

--
From geeksforgeeks:

Certain functions associated with the vector are:
Iterators

begin() ‚Äì Returns an iterator pointing to the first element in the vector
end() ‚Äì Returns an iterator pointing to the theoretical element that follows the last element in the vector
rbegin() ‚Äì Returns a reverse iterator pointing to the last element in the vector (reverse beginning). It moves from last to first element
rend() ‚Äì Returns a reverse iterator pointing to the theoretical element preceding the first element in the vector (considered as reverse end)
cbegin() ‚Äì Returns a constant iterator pointing to the first element in the vector.
cend() ‚Äì Returns a constant iterator pointing to the theoretical element that follows the last element in the vector.
crbegin() ‚Äì Returns a constant reverse iterator pointing to the last element in the vector (reverse beginning). It moves from last to first element
crend() ‚Äì Returns a constant reverse iterator pointing to the theoretical element preceding the first element in the vector (considered as reverse end)

// C++ program to illustrate the 
// iterators in vector 
#include <iostream> 
#include <vector> 
  
using namespace std; 
  
int main() 
{ 
    vector<int> g1; 
  
    for (int i = 1; i <= 5; i++) 
        g1.push_back(i); 
  
    cout << "Output of begin and end: "; 
    for (auto i = g1.begin(); i != g1.end(); ++i) 
        cout << *i << " "; 
  
    cout << "\nOutput of cbegin and cend: "; 
    for (auto i = g1.cbegin(); i != g1.cend(); ++i) 
        cout << *i << " "; 
  
    cout << "\nOutput of rbegin and rend: "; //tao: reverse the vector, note it is ++ir, not --ir
    for (auto ir = g1.rbegin(); ir != g1.rend(); ++ir) 
        cout << *ir << " "; 
  
    cout << "\nOutput of crbegin and crend : "; 
    for (auto ir = g1.crbegin(); ir != g1.crend(); ++ir) 
        cout << *ir << " "; 
  
    return 0; 
} 

Output:
Output of begin and end: 1 2 3 4 5 
Output of cbegin and cend: 1 2 3 4 5 
Output of rbegin and rend: 5 4 3 2 1 
Output of crbegin and crend : 5 4 3 2 1

Capacity

size() ‚Äì Returns the number of elements in the vector.
max_size() ‚Äì Returns the maximum number of elements that the vector can hold.
capacity() ‚Äì Returns the size of the storage space currently allocated to the vector expressed as number of elements.
resize() ‚Äì Resizes the container so that it contains ‚Äòg‚Äô elements.
empty() ‚Äì Returns whether the container is empty.
shrink_to_fit() ‚Äì Reduces the capacity of the container to fit its size and destroys all elements beyond the capacity.
reserve() ‚Äì Requests that the vector capacity be at least enough to contain n elements. Tao: after calling reverse(vec.begin(),vec.end()), vector vec is reversed. reverse() does not return a vector, it reverses the original vector.

// C++ program to illustrate the 
// capacity function in vector 
#include <iostream> 
#include <vector> 
  
using namespace std; 
  
int main() 
{ 
    vector<int> g1; 
  
    for (int i = 1; i <= 5; i++) 
        g1.push_back(i); 
  
    cout << "Size : " << g1.size(); 
    cout << "\nCapacity : " << g1.capacity(); 
    cout << "\nMax_Size : " << g1.max_size(); 
  
    // resizes the vector size to 4 
    g1.resize(4); 
  
    // prints the vector size after resize() 
    cout << "\nSize : " << g1.size(); 
  
    // checks if the vector is empty or not 
    if (g1.empty() == false) 
        cout << "\nVector is not empty"; 
    else
        cout << "\nVector is empty"; 
  
    // Shrinks the vector 
    g1.shrink_to_fit(); 
    cout << "\nVector elements are: "; 
    for (auto it = g1.begin(); it != g1.end(); it++) 
        cout << *it << " "; 
  
    return 0; 
} 

Output:
Size : 5
Capacity : 8
Max_Size : 4611686018427387903
Size : 4
Vector is not empty
Vector elements are: 1 2 3 4

Element access:

reference operator [g] ‚Äì Returns a reference to the element at position ‚Äòg‚Äô in the vector
at(g) ‚Äì Returns a reference to the element at position ‚Äòg‚Äô in the vector
front() ‚Äì Returns a reference to the first element in the vector
back() ‚Äì Returns a reference to the last element in the vector
data() ‚Äì Returns a direct pointer to the memory array used internally by the vector to store its owned elements.

// C++ program to illustrate the 
// element accesser in vector 
#include <bits/stdc++.h> 
using namespace std; 
  
int main() 
{ 
    vector<int> g1; 
  
    for (int i = 1; i <= 10; i++) 
        g1.push_back(i * 10); 
  
    cout << "\nReference operator [g] : g1[2] = " << g1[2]; 
  
    cout << "\nat : g1.at(4) = " << g1.at(4); 
  
    cout << "\nfront() : g1.front() = " << g1.front(); 
  
    cout << "\nback() : g1.back() = " << g1.back(); 
  
    // pointer to the first element 
    int* pos = g1.data(); 
  
    cout << "\nThe first element is " << *pos; 
    return 0; 
} 

Output:
Reference operator [g] : g1[2] = 30
at : g1.at(4) = 50
front() : g1.front() = 10
back() : g1.back() = 100
The first element is 10
Modifiers:

assign() ‚Äì It assigns new value to the vector elements by replacing old ones
push_back() ‚Äì It push the elements into a vector from the back
pop_back() ‚Äì It is used to pop or remove elements from a vector from the back.
insert() ‚Äì It inserts new elements before the element at the specified position. (tao: online example: v1.insert(v1.begin()+i, v2[i]))
erase() ‚Äì It is used to remove elements from a container from the specified position or range. (tao: online example: vec.erase(vec.begin() + 1))
swap() ‚Äì It is used to swap the contents of one vector with another vector of same type and size.
clear() ‚Äì It is used to remove all the elements of the vector container
emplace() ‚Äì It extends the container by inserting new element at position
emplace_back() ‚Äì It is used to insert a new element into the vector container, the new element is added to the end of the vector
.

// C++ program to illustrate the 
// Modifiers in vector 
#include <bits/stdc++.h> 
#include <vector> 
using namespace std; 
  
int main() 
{ 
    // Assign vector 
    vector<int> v; 
  
    // fill the array with 10 five times 
    v.assign(5, 10); 
  
    cout << "The vector elements are: "; 
    for (int i = 0; i < v.size(); i++) 
        cout << v[i] << " "; 
  
    // inserts 15 to the last position 
    v.push_back(15); 
    int n = v.size(); 
    cout << "\nThe last element is: " << v[n - 1]; 
  
    // removes last element 
    v.pop_back(); 
  
    // prints the vector 
    cout << "\nThe vector elements are: "; 
    for (int i = 0; i < v.size(); i++) 
        cout << v[i] << " "; 
  
    // inserts 5 at the beginning 
    v.insert(v.begin(), 5); 
  
    cout << "\nThe first element is: " << v[0]; 
  
    // removes the first element 
    v.erase(v.begin()); 
  
    cout << "\nThe first element is: " << v[0]; 
  
    // inserts at the beginning 
    v.emplace(v.begin(), 5); 
    cout << "\nThe first element is: " << v[0]; 
  
    // Inserts 20 at the end 
    v.emplace_back(20); 
    n = v.size(); 
    cout << "\nThe last element is: " << v[n - 1]; 
  
    // erases the vector 
    v.clear(); 
    cout << "\nVector size after erase(): " << v.size(); 
  
    // two vector to perform swap 
    vector<int> v1, v2; 
    v1.push_back(1); 
    v1.push_back(2); 
    v2.push_back(3); 
    v2.push_back(4); 
  
    cout << "\n\nVector 1: "; 
    for (int i = 0; i < v1.size(); i++) 
        cout << v1[i] << " "; 
  
    cout << "\nVector 2: "; 
    for (int i = 0; i < v2.size(); i++) 
        cout << v2[i] << " "; 
  
    // Swaps v1 and v2 
    v1.swap(v2); 
  
    cout << "\nAfter Swap \nVector 1: "; 
    for (int i = 0; i < v1.size(); i++) 
        cout << v1[i] << " "; 
  
    cout << "\nVector 2: "; 
    for (int i = 0; i < v2.size(); i++) 
        cout << v2[i] << " "; 
} 

Output:
The vector elements are: 10 10 10 10 10 
The last element is: 15
The vector elements are: 10 10 10 10 10 
The first element is: 5
The first element is: 10
The first element is: 5
The last element is: 20
Vector size after erase(): 0

Vector 1: 1 2 
Vector 2: 3 4 
After Swap 
Vector 1: 3 4 
Vector 2: 1 2

==
(findunorderedcontainers)
Unordered associative containers

From the book:
The new standard defines four unordered associative containers.

From wikipedia:

unordered_set (C++11) 
unordered_map (C++11) 
unordered_multiset (C++11) 
unordered_multimap (C++11)

The containers are defined in headers named after the names of the containers, e.g., unordered_set is defined in header <unordered_set>. All containers satisfy the requirements of the Container concept, which means they have begin(), end(), size(), max_size(), empty(), and swap() methods.

==
(findunorderedset)
unordered_set

Tao's impression: the functions of unordered_set are the same as set.

#include <iostream>
#include <unordered_set>
#include <algorithm>

From geeksforgeeks:

unorderd_set in C++ STL
unordered_set is implemented using hash table where keys are hashed into indices of this hash table so it is not possible to maintain an order. All operation on unordered_set takes constant time O(1) on an average which can go up to linear time in worst case which depends on the internally used hash function but practically they perform very well and generally provide constant time lookup operation.
The unordered-set can contain key of any type ‚Äì predefined or user-defined data structure but when we define key of type user define type, we need to specify our comparison function according to which keys will be compared.

set vs unordered_set
Set set is an ordered sequence of unique keys whereas unordered_set is a set in which key can be stored in any order, so unordered.
Set is implemented as balanced tree structure that is why it is possible to maintain an order between the elements (by specific tree traversal). Time complexity of set operations is O(Log n) while for unordered_set, it is O(1).

Methods on unordered_set
For unordered_set many function are defined among which most useful are size and empty for capacity, find for searching a key, insert and erase for modification.
The Unordered_set allows only unique keys, for duplicate keys unordered_multiset should be used.

Example of declaration, find, insert and iteration in unordered_set is given below :

// C++ program to demonstrate various function of unordered_set 
#include <bits/stdc++.h> 
using namespace std; 
  
int main() 
{ 
    // declaring set for storing string data-type 
    unordered_set<string> stringSet; 
  
    // inserting various string, same string will be stored 
    // once in set 
    stringSet.insert("code"); 
    stringSet.insert("in"); 
    stringSet.insert("c++"); 
    stringSet.insert("is"); 
    stringSet.insert("fast"); 
  
    string key = "slow"; 
  
    //     find returns end iterator if key is not found, 
    //  else it returns iterator to that key 
    if (stringSet.find(key) == stringSet.end()) 
        cout << key << " not found\n\n"; 
    else
        cout << "Found " << key << endl << endl; 
  
    key = "c++"; 
    if (stringSet.find(key) == stringSet.end()) 
        cout << key << " not found\n"; 
    else
        cout << "Found " << key << endl; 
  
    // now iterating over whole set and printing its 
    // content 
    cout << "\nAll elements : "; 
    unordered_set<string> :: iterator itr; 
    for (itr = stringSet.begin(); itr != stringSet.end(); itr++) 
        cout << (*itr) << endl; 
} 

==
(findset)
set

From geeksforgeeks:

Functions associated with Set:

pair <iterator, bool> insert(const g) ‚Äì Adds a new element ‚Äòg‚Äô to the set
find(const g) ‚Äì Returns an iterator to the element ‚Äòg‚Äô in the set if found, else returns the iterator to end
begin() ‚Äì Returns an iterator to the first element in the set
end() ‚Äì Returns an iterator to the theoretical element that follows last element in the set

size() ‚Äì Returns the number of elements in the set
empty() ‚Äì Returns whether the set is empty

iterator insert (iterator position, const g) ‚Äì Adds a new element ‚Äòg‚Äô at the position pointed by iterator
max_size() ‚Äì Returns the maximum number of elements that the set can hold
erase(iterator position) ‚Äì Removes the element at the position pointed by the iterator
erase(const g)- Removes the value ‚Äòg‚Äô from the set
clear() ‚Äì Removes all the elements from the set
key_comp() / value_comp() ‚Äì Returns the object that determines how the elements in the set are ordered (‚Äò<‚Äò by default)
count(const g) ‚Äì Returns 1 or 0 based on the element ‚Äòg‚Äô is present in the set or not.
lower_bound(const g) ‚Äì Returns an iterator to the first element that is equivalent to ‚Äòg‚Äô or definitely will not go before the element ‚Äòg‚Äô in the set
upper_bound(const g) ‚Äì Returns an iterator to the first element that is equivalent to ‚Äòg‚Äô or definitely will go after the element ‚Äòg‚Äô in the set

Example:

#include <iostream> 
#include <set> 
#include <iterator> 
  
using namespace std; 
  
int main() 
{ 
    // empty set container 
    set <int, greater <int> > gquiz1;         
  
    // insert elements in random order 
    gquiz1.insert(40); 
    gquiz1.insert(30); 
    gquiz1.insert(60); 
    gquiz1.insert(20); 
    gquiz1.insert(50); 
    gquiz1.insert(50); // only one 50 will be added to the set 
    gquiz1.insert(10); 
  
    // printing set gquiz1 
    set <int, greater <int> > :: iterator itr; 
    cout << "\nThe set gquiz1 is : "; 
    for (itr = gquiz1.begin(); itr != gquiz1.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
    cout << endl; 
  
    // assigning the elements from gquiz1 to gquiz2 
    set <int> gquiz2(gquiz1.begin(), gquiz1.end()); 
  
    // print all elements of the set gquiz2 
    cout << "\nThe set gquiz2 after assign from gquiz1 is : "; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
    cout << endl; 
  
    // remove all elements up to 30 in gquiz2 
    cout << "\ngquiz2 after removal of elements less than 30 : "; 
    gquiz2.erase(gquiz2.begin(), gquiz2.find(30)); 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
  
    // remove element with value 50 in gquiz2 
    int num; 
    num = gquiz2.erase (50); 
    cout << "\ngquiz2.erase(50) : "; 
    cout << num << " removed \t" ; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
  
    cout << endl; 
  
    //lower bound and upper bound for set gquiz1 
    cout << "gquiz1.lower_bound(40) : "
         << *gquiz1.lower_bound(40) << endl; 
    cout << "gquiz1.upper_bound(40) : "
         << *gquiz1.upper_bound(40) << endl; 
  
    //lower bound and upper bound for set gquiz2 
    cout << "gquiz2.lower_bound(40) : "
         << *gquiz2.lower_bound(40) << endl; 
    cout << "gquiz2.upper_bound(40) : "
         << *gquiz2.upper_bound(40) << endl; 
  
    return 0; 
  
} 

==
(findunorderedmap)
unordered_map

Tao's impression: the functions of unordered_map are the same as map.

From geeksforgeeks:

unordered_map in C++ STL
unordered_map is an associated container that stores elements formed by combination of key value and a mapped value. The key value is used to uniquely identify the element and mapped value is the content associated with the key. Both key and value can be of any type predefined or user-defined.

Internally unordered_map is implemented using Hash Table, the key provided to map are hashed into indices of hash table that is why performance of data structure depends on hash function a lot but on an average the cost of search, insert and delete from hash table is O(1).

// C++ program to demonstrate functionality of unordered_map 
#include <iostream> 
#include <unordered_map> 
using namespace std; 
  
int main() 
{ 
    // Declaring umap to be of <string, int> type 
    // key will be of string type and mapped value will 
    // be of double type 
    unordered_map<string, int> umap; 
  
    // inserting values by using [] operator 
    umap["GeeksforGeeks"] = 10; 
    umap["Practice"] = 20; 
    umap["Contribute"] = 30; 
  
    // Traversing an unordered map 
    for (auto x : umap) 
      cout << x.first << " " << x.second << endl; 
  
} 

==
(findmap)
map

Tao: the simplest way to insert into a map is the same as Python (ie, same way as updating an existing element value), no need to use insert function. At least two people in leetcode discussion did in this way.

unordered_map<Node*, Node*> mp;
Node* copy = new Node(node -> label);
mp[node] = copy;

From geeksforgeeks:

Functions associated with Map:

find(const g) ‚Äì Returns an iterator to the element with key value ‚Äòg‚Äô in the map if found, else returns the iterator to end
begin() ‚Äì Returns an iterator to the first element in the map
end() ‚Äì Returns an iterator to the theoretical element that follows last element in the map

size() ‚Äì Returns the number of elements in the map
empty() ‚Äì Returns whether the map is empty

pair insert(keyvalue,mapvalue) ‚Äì Adds a new element to the map
max_size() ‚Äì Returns the maximum number of elements that the map can hold
erase(iterator position) ‚Äì Removes the element at the position pointed by the iterator
erase(const g)‚Äì Removes the key value ‚Äòg‚Äô from the map
clear() ‚Äì Removes all the elements from the map
key_comp() / value_comp() ‚Äì Returns the object that determines how the elements in the map are ordered (‚Äò<' by default)
count(const g) ‚Äì Returns the number of matches to element with key value ‚Äòg‚Äô in the map
lower_bound(const g) ‚Äì Returns an iterator to the first element that is equivalent to mapped value with key value ‚Äòg‚Äô or definitely will not go before the element with key value ‚Äòg‚Äô in the map
upper_bound(const g) ‚Äì Returns an iterator to the first element that is equivalent to mapped value with key value ‚Äòg‚Äô or definitely will go after the element with key value ‚Äòg‚Äô in the map


Example:

#include <iostream> 
#include <map> 
#include <iterator> 
  
using namespace std; 
  
int main() 
{ 
    map <int, int> gquiz1;        // empty map container 
  
    // insert elements in random order 
    gquiz1.insert(pair <int, int> (1, 40)); 
    gquiz1.insert(pair <int, int> (2, 30)); 
    gquiz1.insert(pair <int, int> (3, 60)); 
    gquiz1.insert(pair <int, int> (4, 20)); 
    gquiz1.insert(pair <int, int> (5, 50)); 
    gquiz1.insert(pair <int, int> (6, 50));  
    gquiz1.insert(pair <int, int> (7, 10)); 
  
    // printing map gquiz1 
    map <int, int> :: iterator itr; 
    cout << "\nThe map gquiz1 is : \n"; 
    cout << "\tKEY\tELEMENT\n"; 
    for (itr = gquiz1.begin(); itr != gquiz1.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
    cout << endl; 
  
    // assigning the elements from gquiz1 to gquiz2 
    map <int, int> gquiz2(gquiz1.begin(), gquiz1.end()); 
  
    // print all elements of the map gquiz2 
    cout << "\nThe map gquiz2 after assign from gquiz1 is : \n"; 
    cout << "\tKEY\tELEMENT\n"; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
    cout << endl; 
  
    // remove all elements up to element with key=3 in gquiz2 
    cout << "\ngquiz2 after removal of elements less than key=3 : \n"; 
    cout << "\tKEY\tELEMENT\n"; 
    gquiz2.erase(gquiz2.begin(), gquiz2.find(3)); 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
  
    // remove all elements with key = 4 
    int num; 
    num = gquiz2.erase (4); 
    cout << "\ngquiz2.erase(4) : "; 
    cout << num << " removed \n" ; 
    cout << "\tKEY\tELEMENT\n"; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
  
    cout << endl; 
  
    //lower bound and upper bound for map gquiz1 key = 5 
    cout << "gquiz1.lower_bound(5) : " << "\tKEY = "; 
    cout << gquiz1.lower_bound(5)->first << '\t'; 
    cout << "\tELEMENT = " << gquiz1.lower_bound(5)->second << endl; 
    cout << "gquiz1.upper_bound(5) : " << "\tKEY = "; 
    cout << gquiz1.upper_bound(5)->first << '\t'; 
    cout << "\tELEMENT = " << gquiz1.upper_bound(5)->second << endl; 
      
    return 0; 
  
} 

==
(findcontaineradaptor)
Container Adaptors (stack, queue, priority_queue)

In addition to the sequential containers, the library defines three sequential container adaptors: stack, queue, and priority_queue. An adaptor is a general concept in the library. There are container, iterator, and function adaptors. Essentially, an adaptor is a mechanism for making one thing act like another. A container adaptor takes an existing container type and makes it act like a different type. For example, the stack adaptor takes a sequential container (other than array or
forward_list) and makes it operate as if it were a stack. Table below lists the operations and types that are common to all the container adaptors.

Operations and Types Common to the Container Adaptors:

A a: Create a new empty adaptor named a. Tao: an example of A is stack<int>

A a(c): Create a new adaptor named a with a copy of the container c.

Relational operations: Each adaptor supports all the relational operators: ==, !=, <, <=, >, >=. These operators return the result of comparing the underlying containers.

a.empty(): false if a has any elements, true otherwise.

a.size(): Number of elements in a.

swap(a, b), a.swap(b): Swaps the contents of a and b; a and b must have the same type, including the type of the container on which they are implemented.

size_type: Type large enough to hold the size of the largest object of this type.

value_type: Element type.

container_type: Type of the underlying container on which the adaptor is implemented.

By default both stack and queue are implemented in terms of deque, and a priority_queue is implemented on a vector. We can override the default container type by naming a sequential container as a second type argument when we create the adaptor:

stack<string, vector<string>> str_stk; // empty stack implemented on top of vector

stack<string, vector<string>> str_stk2(svec); // str_stk2 is implemented on top of vector and initially holds a copy of svec

There are constraints on which containers can be used for a given adaptor. All of the adaptors require the ability to add and remove elements. As a result, they cannot be built on an array. Similarly, we cannot use forward_list, because all of the
adaptors require operations that add, remove, or access the last element in the container. A stack requires only push_back, pop_back, and back operations, so we can use any of the remaining container types for a stack. The queue adaptor requires back, push_back, front, and push_front, so it can be built on a list or deque but not on a vector. A priority_queue requires random access in addition to the front, push_back, and pop_back operations; it can be built on a vector or a deque but not on a list.

Each container adaptor defines its own operations in terms of operations provided by the underlying container type. We can use only the adaptor operations and cannot use the operations of the underlying container type.

==
(findstack)
stack

Stack Operations in Addition to the above Table "Operations and Types Common to the Container Adaptors":

s.push(item), s.emplace(args): Creates a new top element on the stack by copying or moving item, or by constructing the element from args.

s.pop(): Removes, but does not return, the top element from the stack.

s.top(): Returns, but does not remove, the top element on the stack.

The stack type is defined in the stack header. 

stack uses deque by default, can be implemented on a list or vector as well.

The following program illustrates the use of stack:

stack<int> intStack; // empty stack

// fill up the stack
for (size_t ix = 0; ix != 10; ++ix)
    intStack.push(ix); // intStackholds 0 ... 9 inclusive

while (!intStack.empty()) { // while there are still values in intStack
    int value = intStack.top(); // code that uses value
    intStack.pop(); // pop the top element, and repeat
}

==
(findqueue)
(findpriorityqueue)
queue, priority_queue

queue, priority_queue Operations in Addition to the above Table "Operations and Types Common to the Container Adaptors":

q.push(item), q.emplace(args): Create an element with value item or constructed from args at the end of the queue or in its appropriate position in priority_queue.

q.pop(): Removes, but does not return, the front element or highest-priority element from the queu or priority_queue, respectively.

q.front(), q.back(): Returns, but does not remove, the front or back element of q. Valid only for queue.

q.top(): Returns, but does not remove, the highest-priority element. Valid only for priority_queue.

The queue and priority_queue adaptors are defined in the queue header.

The library queue uses a first-in, first-out (FIFO) storage and retrieval policy. Objects entering the queue are placed in the back and objects leaving the queue are removed from the front. A restaurant that seats people in the order in which they arrive is an example of a FIFO queue.

A priority_queue lets us establish a priority among the elements held in the queue. Newly added elements are placed ahead of all the elements with a lower priority. A restaurant that seats people according to their reservation time, regardless of when they arrive, is an example of a priority queue. By default, the library uses the < operator on the element type to determine relative priorities. We‚Äôll learn how to override this default later.

By default queue uses deque and priority_queue uses vector; queue can use a list or vector as well, priority_queue cna use a deque.

==
(finddeque)
(finddequeue)
deque

Tao's summary:

#include <deque> 
deque<int> gquiz; 
gquiz.push_back(10); 
gquiz.push_front(20); 
ngquiz.front();
ngquiz.back();
ngquiz.pop_front();
ngquiz.pop_back();
ngquiz.clear();
ngquiz.erase();

1. dequename.erase(position)
2. dequename.erase(startingposition, endingposition)

Examples:

Input: mydeque{1, 2, 3, 4, 5}, pos= 2
mydeque.erase(pos);
Output : 1, 2, 4, 5

Input: mydeque{1, 2, 3, 4, 5, 6, 7, 8}, pos1= 3, pos2= 6
mydeque.erase(pos1, pos2);
Output : 1, 2, 3, 8

--
From geeksforgeeks:

Double ended queues are sequence containers with the feature of expansion and contraction on both the ends. They are similar to vectors, but are more efficient in case of insertion and deletion of elements at the end, and also the beginning. Unlike vectors, contiguous storage allocation may not be guaranteed.

The functions for deque are same as vector, with an addition of push and pop operations for both front and back.

#include <iostream> 
#include <deque> 
  
using namespace std; 
  
void showdq(deque <int> g) 
{ 
    deque <int> :: iterator it; 
    for (it = g.begin(); it != g.end(); ++it) 
        cout << '\t' << *it; 
    cout << '\n'; 
} 
  
int main() 
{ 
    deque <int> gquiz; 
    gquiz.push_back(10); 
    gquiz.push_front(20); 
    gquiz.push_back(30); 
    gquiz.push_front(15); 
    cout << "The deque gquiz is : "; 
    showdq(gquiz); 
  
    cout << "\ngquiz.size() : " << gquiz.size(); 
    cout << "\ngquiz.max_size() : " << gquiz.max_size(); 
  
    cout << "\ngquiz.at(2) : " << gquiz.at(2); 
    cout << "\ngquiz.front() : " << gquiz.front(); 
    cout << "\ngquiz.back() : " << gquiz.back(); 
  
    cout << "\ngquiz.pop_front() : "; 
    gquiz.pop_front(); 
    showdq(gquiz); 
  
    cout << "\ngquiz.pop_back() : "; 
    gquiz.pop_back(); 
    showdq(gquiz); 
  
    return 0;

The output of the above program is :

The deque gquiz is :     15    20    10    30

gquiz.size() : 4
gquiz.max_size() : 4611686018427387903
gquiz.at(2) : 10
gquiz.front() : 15
gquiz.back() : 30
gquiz.pop_front() :     20    10    30

gquiz.pop_back() :     20    10

Methods of Deque:

deque insert() function in C++ STL: Returns an iterator that points to the first of the newly inserted elements.
deque rbegin() function in C++ STL: Returns a reverse iterator which points to the last element of the deque (i.e., its reverse beginning).
deque rend() function in C++ STL: Returns a reverse iterator which points to the position before the beginning of the deque (which is considered its reverse end).
deque cbegin() in C++ STL: Returns an iterator pointing to the first element of the container.
deque max_size() function in C++ STL: Returns the maximum number of elements that a deque container can hold.
deque assign() function in C++ STL: Assign values to the same or different deque container.
deque resize() function in C++ STL: Function which changes the size of the deque.
deque::push_front() in C++ STL: This function is used to push elements into a deque from the front.
deque::push_back() in C++ STL: This function is used to push elements into a deque from the back.
deque::pop_front() and deque::pop_back() in C++ STL: pop_front() function is used to pop or remove elements from a deque from the front. pop_back() function is used to pop or remove elements from a deque from the back.
deque::front() and deque::back() in C++ STL: front() function is used to reference the first element of the deque container. back() function is used to reference the last element of the deque container.
deque::clear() and deque::erase() in C++ STL: clear() function is used to remove all the elements of the deque container, thus making its size 0. erase() function is used to remove elements from a container from the specified position or range.
deque::empty() and deque::size() in C++ STL: empty() function is used to check if the deque container is empty or not. size() function is used to return the size of the deque container or the number of elements in the deque container.
deque::operator= and deque::operator[] in C++ STL:
operator= operator is used to assign new contents to the container by replacing the existing contents. operator[] operator is used to reference the element present at position given inside the operator.
deque::at() and deque::swap() in C++ STL: at() function is used reference the element present at the position given as the parameter to the function. swap() function is used to swap the contents of one deque with another deque of same type and size.
deque::begin() and deque::end in C++ STL: begin() function is used to return an iterator pointing to the first element of the deque container. end() function is used to return an iterator pointing to the last element of the deque container.
deque::emplace_front() and deque::emplace_back() in C++ STL: emplace_front() function is used to insert a new element into the deque container, the new element is added to the beginning of the deque. emplace_back() function is used to insert a new element into the deque container, the new element is added to the end of the deque.

==
(findalgorithm)
(findgenericalgorithm)
Generic algorithms

The library containers define a surprisingly small set of operations. Rather than adding lots of functionality to each container, the library provides a set of algorithms, most of
which are independent of any particular container type. These algorithms are generic: They operate on different types of containers and on elements of various types.

Most of the algorithms are defined in the algorithm header. The library also defines a set of generic numeric algorithms that are defined in the numeric header.

In general, the algorithms do not work directly on a container. Instead, they operate by traversing a range of elements bounded by two iterators. Typically, as the algorithm traverses the range, it does something with each element. For example, suppose we have a vector of ints and we want to know if that vector holds a particular value. The easiest way to answer this question is to call the library find algorithm:

int val = 42; // value we'll look for

// result will denote the element we want if it's in vec, or vec.cend() if not. tao: vec.cend() is the one past the last element.
auto result = find(vec.cbegin(), vec.cend(), val);

// report the result
cout << "The value " << val << (result == vec.cend() ? " is not present" : " is present") << endl;

The first two arguments to find are iterators denoting a range of elements, and the third argument is a value. find compares each element in the given range to the given value. It returns an iterator to the first element that is equal to that value. If
there is no match, find returns its second iterator to indicate failure. Thus, we can determine whether the element was found by comparing the return value with the second iterator argument. 

Because find operates in terms of iterators, we can use the same find function to look for values in any type of container. For example, we can use find to look for a value in a list of strings.

Similarly, because pointers act like iterators on built-in arrays, we can use find to look in an array:

int ia[] = {27, 210, 12, 47, 109, 83};
int val = 83;
int* result = find(begin(ia), end(ia), val);

Here we use the library begin and end functions to pass a pointer
to the first and one past the last elements in ia.

We can also look in a subrange of the sequence by passing iterators (or pointers) to the first and one past the last element of that subrange. For example, this call looks for a match in the elements ia[1], ia[2], and ia[3]:

// search the elements starting from ia[1] up to but not including ia[4]
auto result = find(ia + 1, ia + 4, val);

So long as there is an iterator that can be used to access the elements, find doesn‚Äôt depend in any way on the container type (or even whether the elements are stored in a container).

Iterators Make the Algorithms Container Independent. But Algorithms Do Depend on Element-Type Operations.

Key Concept: Algorithms Never Execute Container Operations.

The generic algorithms do not themselves execute container operations. They operate solely in terms of iterators and iterator operations. The fact that the algorithms operate in terms of iterators and not container operations has a perhaps surprising but essential implication: Algorithms never change the size of the underlying container. Algorithms may change the values of the elements stored in the container, and they may move elements around within the container. They do not, however, ever add or remove elements directly.

With only a few exceptions, the algorithms operate over a range of elements. We‚Äôll refer to this range as the ‚Äúinput range.‚Äù The algorithms that take an input range always use their first two parameters to denote that range. These parameters are iterators denoting the first and one past the last elements to process.

Although most algorithms are similar in that they operate over an input range, they differ in how they use the elements in that range. The most basic way to understand the algorithms is to know whether they read elements, write elements, or rearrange
the order of the elements.

--
Read-Only Algorithms

(Tao: see the find function above)

A number of the algorithms read, but never write to, the elements in their input range. The find function is one such algorithm, as is the count function we used in the exercises.

Another read-only algorithm is accumulate, which is defined in the numeric header. The accumulate function takes three arguments. The first two specify a range of elements to sum. The third is an initial value for the sum. Assuming vec is a sequence of integers, the following sets sum equal to the sum of the elements in vec, using 0 as the starting point for the summation.

// sum the elements in vec starting the summation with the value 0
int sum = accumulate(vec.cbegin(), vec.cend(), 0);

The type of the third argument to accumulate determines which addition operator is used and is the type that accumulate returns.

The fact that accumulate uses its third argument as the starting point for the summation has an important implication: It must be possible to add the element type to the type of the sum. That is, the elements in the sequence must match or be convertible to the type of the third argument.

As another example, because string has a + operator, we can concatenate the elements of a vector of strings by calling accumulate:

string sum = accumulate(v.cbegin(), v.cend(), string(""));

This call concatenates each element in v onto a string that starts out as the empty string. Note that we explicitly create a string as the third parameter. Passing the empty string as a string literal would be a compile-time error:

// error: no + on const char*
string sum = accumulate(v.cbegin(), v.cend(), "");

Ordinarily it is best to use cbegin() and cend() with algorithms that read, but do not write, the elements. However, if you plan to use the iterator returned by the algorithm to change an element‚Äôs value, then you need to pass begin() and end().

Algorithms That Operate on Two Sequences

Another read-only algorithm is equal, which lets us determine whether two sequences hold the same values. It compares each element from the first sequence to the corresponding element in the second. It returns true if the corresponding elements are equal, false otherwise. The algorithm takes three iterators: The first two (as usual) denote the range of elements in the first sequence; the third denotes the first element in the second sequence:

// roster2 should have at least as many elements as roster1
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());

Because equal operates in terms of iterators, we can call equal to compare elements in containers of different types.

However, equal makes one critically important assumption: It assumes that the second sequence is at least as big as the first. This algorithm potentially looks at every element in the first sequence. It assumes that there is a corresponding element
for each of those elements in the second sequence.

Algorithms that take a single iterator denoting a second sequence assume that the second sequence is at least as large at the first.

--
Algorithms That Write Container Elements

Some algorithms assign new values to the elements in a sequence. When we use an algorithm that assigns to elements, we must take care to ensure that the sequence into which the algorithm writes is at least as large as the number of elements we ask the algorithm to write. Remember, algorithms do not perform container operations, so they have no way themselves to change the size of a container.

As one example, the fill algorithm takes a pair of iterators that denote a range and a third argument that is a value. fill assigns the given value to each element in the input sequence:

fill(vec.begin(), vec.end(), 0); // reset each element to 0

fill(vec.begin(), vec.begin() + vec.size()/2, 10); // set a subsequence of the container to 10

Some algorithms take an iterator that denotes a separate destination. These algorithms assign new values to the elements of a sequence starting at the element denoted by the destination iterator. For example, the fill_n function takes a single iterator, a count, and a value. It assigns the given value to the specified number of elements starting at the element denoted to by the iterator. We might use fill_n to assign a new value to the elements in a vector:

vector<int> vec; // empty vector

// use vec giving it various values
fill_n(vec.begin(), vec.size(), 0); // reset all the elements of vec to
0

It is a fairly common beginner mistake to call fill_n (or similar algorithms that write to elements) on a container that has no elements:

vector<int> vec; // empty vector

// disaster: attempts to write to ten (nonexistent) elements in vec
fill_n(vec.begin(), 10, 0);

Algorithms that write to a destination iterator assume the destination is large enough to hold the number of elements being written.

Introducing back_inserter

One way to ensure that an algorithm has enough elements to hold the output is to use an insert iterator. An insert iterator is an iterator that adds elements to a container. Ordinarily, when we assign to a container element through an iterator, we assign to the element that iterator denotes. When we assign through an insert iterator, a new element equal to the right-hand value is added to the container.

We‚Äôll have more to say about insert iterators later. However, in order to illustrate how to use algorithms that write to a container, we will use back_inserter, which is a function defined in the iterator header. 

back_inserter takes a reference to a container and returns an insert iterator bound to that container. When we assign through that iterator, the assignment calls push_back to add an element with the given value to the container:

vector<int> vec; // empty vector

auto it = back_inserter(vec); // assigning through it adds elements to vec

*it = 42; // vec now has one element with value 42

Copy Algorithms

The copy algorithm is another example of an algorithm that writes to the elements of an output sequence denoted by a destination iterator. This algorithm takes three iterators. The first two denote an input range; the third denotes the beginning of the destination sequence. This algorithm copies elements from its input range into elements in the destination. It is essential that the destination passed to copy be at least as large as the input range.

As one example, we can use copy to copy one built-in array to another:

int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)]; // a2 has the same size as a1
// ret points just past the last element copied into a2
auto ret = copy(begin(a1), end(a1), a2); // copy a1 into a2

The value returned by copy is the (incremented) value of its destination iterator. That is, ret will point just past the last element copied into a2.

Several algorithms provide so-called ‚Äúcopying‚Äù versions. These algorithms compute new element values, but instead of putting them back into their input sequence, the algorithms create a new sequence to contain the results.

For example, the replace algorithm reads a sequence and replaces every instance of a given value with another value. This algorithm takes four parameters: two iterators denoting the input range, and two values. It replaces each element that is equal to the first value with the second:

// replace any element with the value 0 with 42
replace(ilst.begin(), ilst.end(), 0, 42);

This call replaces all instances of 0 by 42. If we want to leave the original sequence unchanged, we can call replace_copy. That algorithm takes a third iterator argument denoting a destination in which to write the adjusted sequence:

// use back_inserter to grow destination as needed
replace_copy(ilst.cbegin(), ilst.cend(), back_inserter(ivec), 0, 42);

After this call, ilst is unchanged, and ivec contains a copy of ilst with the exception that every element in ilst with the value 0 has the value 42 in ivec.

--
Algorithms That Reorder Container Elements

Some algorithms rearrange the order of elements within a container. An obvious example of such an algorithm is sort. A call to sort arranges the elements in the input range into sorted order using the element type‚Äôs < operator.

As an example, suppose we want to analyze the words used in a set of children‚Äôs stories. We‚Äôll assume that we have a vector that holds the text of several stories. We‚Äôd like to reduce this vector so that each word appears only once, regardless of how many times that word appears in any of the given stories.

To eliminate the duplicated words, we will first sort the vector so that duplicated words appear adjacent to each other. Once the vector is sorted, we can use another library algorithm, named unique, to reorder the vector so that the unique elements appear in the first part of the vector. Because algorithms cannot do container operations, we‚Äôll use the erase member of vector to actually remove the elements:


void elimDups(vector<string> &words)
{
    // sort words alphabetically so we can find the duplicates
    sort(words.begin(), words.end());

    // unique reorders the input range so that each word appears once in the ront portion of the range and returns an iterator one past the unique range
    auto end_unique = unique(words.begin(), words.end());
    
    // erase uses a vector operation to remove the nonunique elements
    words.erase(end_unique, words.end());
}

The unique algorithm rearranges the input range to ‚Äúeliminate‚Äù adjacent duplicated entries, and returns an iterator that denotes the end of the range of the unique values. The size of words is unchanged; it still has ten elements. The order of those
elements is changed‚Äîthe adjacent duplicates have been ‚Äúremoved.‚Äù We put remove in quotes because unique doesn‚Äôt remove any elements. Instead, it overwrites adjacent duplicates so that the unique elements appear at the front of the sequence. The iterator returned by unique denotes one past the last unique element. The elements beyond that point still exist, but we don‚Äôt know what values they have. The library algorithms operate on iterators, not containers. Therefore, an algorithm cannot (directly) add or remove elements.

To actually remove the unused elements, we must use a container operation, which we do in the call to erase. We erase the range of elements from the one to which end_unique refers through the end of words.

--
stopa: p487, 10.3. Customizing Operations


==
(finditerator)
iterator

Although we can use subscripts to access the characters of a string or the elements in a vector, there is a more general mechanism‚Äîknown as iterators‚Äîthat we can use for the same purpose. 

In addition to vector, the library defines several other kinds of containers. All of the library containers have iterators, but only a few of them support the subscript operator.

Like pointers, iterators give us indirect access to an object. In the case of an iterator, that object is an element in a container or a character in a string.

Types that have iterators have members that return iterators. In particular, these types have members named begin and end. The begin member returns an iterator that denotes the first element (or first character).

auto b = v.begin(), e = v.end(); //Note that auto is C++11

The iterator returned by end is an iterator positioned ‚Äúone past the end‚Äù of the associated container (or string). This iterator denotes a nonexistent element ‚Äúoff the end‚Äù of the container. It is used as a marker indicating when we have processed all the elements. The iterator returned by end is often referred to as the off-the-end iterator or abbreviated as ‚Äúthe end iterator.‚Äù If the container is empty, begin returns the same iterator as the one returned by end.

Iterators support only a few operations, which are listed below (tao: these operations are very similar to pointers):

(In the folllowng, an example of iter is: auto iter = v.begin())
*iter //Returns a reference to the element denoted by the iterator iter.

iter->mem //Dereferences iter and fetches the memeber named mem from the underlying element. Equivalent to (*iter).mem

++iter //Increments iter to refer to the next element in the container.

--iter //Decrements iter to refer to the previous element in the container.

iter1 == iter2 //Two iterators are equal if they denote the same element or if they are the off-the-end iterator for the same container.

iter1 != iter2

iter + n // Adding (substracting) an integral value n to (from) an iterator yields an iterator that many elements forward (backward) within the container.

iter - n
iter += n
iter -= n

iter1 - iter2 //Returns the distance between the iterators. The result type is a signed integral type named difference_type. Both vector and string define difference_type. This type is signed, because subtraction might have a negative result.

iter1 <= iter2 //One iterator is less than another if it refers to an element that appears in the container before the one referred to by the other iterator.

Example: capitalize the first character of a string:

string s("some string");
if (s.begin() != s.end()) { // make sure s is not empty
    auto it = s.begin(); // it denotes the first character in s
    *it = toupper(*it); // make that character uppercase, tao: note the characters in a string can be changed in C++
}

Example: capitalize the first word in a string:

for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
    *it = toupper(*it); // capitalize the current character

Programmers coming to C++ from C or Java might be surprised that we used != rather than < in our for loops. C++ programmers use != as a matter of habit. They do so for the same reason that they use iterators rather than subscripts: This coding style applies equally well to various kinds of containers provided by the library. As we‚Äôve seen, only a few library types, vector and string being among them, have the subscript operator. Similarly, all of the library containers have iterators that define the == and != operators. Most of those iterators do not have the < operator. By routinely using iterators and !=, we don‚Äôt have to worry about the precise type of container we‚Äôre processing.

As with size_type, the library types that have iterators define types named iterator and const_iterator that represent actual iterator types:

vector<int>::iterator it; // it can read and write vector<int> elements
string::iterator it2; // it2 can read and write characters in a string
vector<int>::const_iterator it3; // it3 can read but not write elements
string::const_iterator it4; // it4 can read but not write characters

A const_iterator behaves like a const pointer. Like a const pointer, a const_iterator may read but not write the element it denotes; an object of type iterator can both read and write. If a vector or string is const, we may use only its const_iterator type. With a nonconst vector or string, we can use either iterator or const_iterator.

The type returned by begin and end depends on whether the object on which they operator is const. If the object is const, then begin and end return a const_iterator; if the object is not const, they return iterator:

vector<int> v;
const vector<int> cv;
auto it1 = v.begin(); // it1 has type vector<int>::iterator
auto it2 = cv.begin(); // it2 has type vector<int>::const_iterator

It is important to realize that loops that use iterators should not add elements to the container to which the iterators refer.

If begin equals end, the range is empty.

while (begin != end) {
	*begin = val; // ok: range isn't empty so begin denotes an element
	++begin; // advance the iterator to get the next element
}

--
Reverse iterators:

In addition to the iterator types we‚Äôve already used, most containers provide reverse iterators. Briefly, a reverse iterator is an iterator that goes backward through a container and inverts the meaning of the iterator operations. For example, saying ++ on a reverse iterator yields the previous element.

There are several versions of begin and end: The versions with an r return reverse iterators. Those that start with a c return the const version of the related iterator:

list<string> a = {"Milton", "Shakespeare", "Austen"};
auto it1 = a.begin(); // list<string>::iterator
auto it2 = a.rbegin(); // list<string>::reverse_iterator
auto it3 = a.cbegin(); // list<string>::const_iterator
auto it4 = a.crbegin();// list<string>::const_reverse_iterator

When write access is not needed, use cbegin and cend.

==
(findarray)
array

int a[10]; // array of 10 ints. The elements are default initialized.
int a[3] = {0,1,2};
int a[] = {0,1,2};
unsigned scores[11] = {}; // 11 buckets, all value initialized to 0
int *p = a;

int arr[3][4];
int arr[2][3] = {{1,2},{3,4},{5,6}};

Fill in an array with the same values:
int arr[5];
std::fill_n(arr, 5, 2); //Now arr = {2, 2, 2, 2, 2}

As in the case of string or vector, it is best to use a range for when we want to traverse the entire array.

for (auto i : scores)
    cout << i << " ";  

--
tao: practice shows that the type of the array size can be int, but it should be const:
const int aSize = 3;
char a[aSize] = {'A', 'B', 'C'};

The number of elements in an array is part of the array‚Äôs type. As a result, the dimension must be known at compile time, which means that the dimension must be a constant expression. 

Because arrays have fixed size, they sometimes offer better run-time performance for specialized applications. However, that run-time advantage comes at the cost of lost flexibility.

Tao: in C++, there is no function to find array size (different from Java). So if need to use size, should not use array in the beginning, use vector instead. <- Confirmed later from online (including recommending using vector). If you must use the size of an array, you can do it as below:

int num_files = sizeof(file_names) / sizeof(file_names[0]);

Character arrays have an additional form of initialization: We can initialize such arrays from a string literal. When we use this form of initialization, it is important to remember that string literals end with a null character. That null character is copied into the array along with the characters in the literal:

char a1[] = {'C', '+', '+'}; // size = 3. 
char a2[] = {'C', '+', '+', '\0'}; // size = 4
char a3[] = "C++"; // size = 4, null terminator added automatically

--
When we use a variable to subscript an array, we normally should define that variable to have type size_t. size_t is a machine-specific unsigned type that is guaranteed to be large enough to hold the size of any object in memory. The size_t type is defined in the cstddef header.


--
Although we can compute an off-the-end pointer, doing so is error-prone. To make it easier and safer to use pointers, the new library includes two functions, named begin and end.

int *beg = begin(ia); // pointer to the first element in ia
int *last = end(ia);  // pointer one past the last element in ia

These functions are defined in the iterator header.

A pointer ‚Äúone past‚Äù the end of a built-in array behaves the same way as the iterator returned by the end operation of a vector.

As with iterators, subtracting two pointers gives us the distance between those pointers. 

The result of subtracting two pointers is a library type named ptrdiff_t. Like size_t,the ptrdiff_t type is a machine-specific type and is defined in the cstddef header. Because subtraction might yield a negative distance, ptrdiff_t is a signed integral type.

We can use the subscript operator on any pointer, as long as that pointer points to an element (or one past the last element) in an array:

int *p = &ia[2];  // p points to the element indexed by 2
int j = p[1];     // p[1] is equivalent to *(p + 1),
                  // p[1] is the same element as ia[3]
int k = p[-2];    // p[-2] is the same element as ia[0]

--
string *p = &nums[0];   // p points to the first element in nums

When we use an array, the compiler automatically substitutes a pointer to the first element:

string *p2 = nums;      // equivalent to p2 = &nums[0]

when we use an array as an
initializer for a variable defined using auto (¬ß 2.5.2, p. 68), the deduced type is a
pointer, not an array:

int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia is an array of ten ints
auto ia2(ia); // ia2 is an int* that points to the first element in ia

It is worth noting that this conversion does not happen when we use decltype. The type returned by decltype(ia) is array of ten ints:

decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9}; //Tao: decltype(ia) returns a type name
ia3[4] = i; // ok: assigns the value of i to an element in ia3

Pointers to array elements support the same operations as iterators on vectors or strings. For example, we can use the increment operator to move from one element in an array to the next:
  
int arr[] = {0,1,2,3,4,5,6,7,8,9};
int *p = arr; // p points to the first element in arr
++p;          // p points to arr[1]

--
Using an Array to Initialize a vector
 
We noted that we cannot initialize a built-in array from another array. Nor can we initialize an array from a vector. However, we can use an array to initialize a vector. To do so, we specify the address of the first element and one past the last element that we wish to copy:

int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));

The specified range can be a subset of the array:
vector<int> subVec(int_arr + 1, int_arr + 4);

--
Modern C++ programs should use vectors and iterators instead of built-in arrays and pointers, and use strings rather than C-style array-based character strings.

--
Multidimensional Arrays

Strictly speaking, there are no multidimensional arrays in C++. What are commonly referred to as multidimensional arrays are actually arrays of arrays.

int ia[3][4]; // array of size 3; each element is an array of ints of size 4

int arr[10][20][30] = {0}; // initialize all elements to 0

In a two-dimensional array, the first dimension is usually referred to as the row and the second as the column.

Multidimensional arrays may be initialized by specifying bracketed values for each row:

int ia[3][4] = {    
    {0, 1, 2, 3},   
    {4, 5, 6, 7},   
    {8, 9, 10, 11}  
};

The nested braces are optional. The following initialization is equivalent, although considerably less clear:

int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};

Under the new standard we can simplify the previous loop by using a range for:

size_t cnt = 0;

for (auto &row : ia)        
    for (auto &col : row) { 
        col = cnt;          
        ++cnt;            
    }

In the previous example, we used references as our loop control variables because we wanted to change the elements in the array. However, there is a deeper reason for using references.

Had we neglected the reference and written these loops as:
 
for (auto row : ia)
    for (auto col : row)
 
our program would not compile. As before, the first for iterates through ia, whose elements are arrays of size 4. As a result, in this loop the type of row is int*. The inner for loop is illegal, it attempts to iterate over an int*

As with any array, when we use the name of a multidimensional array, it is automatically converted to a pointer to the first element in the array (tao: note this is not an actual element, but an inner array):

int ia[3][4]
int (*p)[4] = ia; // p points to an array of four ints

The result of *p is an array of four ints. As usual, when we use an array, it is converted automatically to a pointer to its first element.

--
Return array from function

Tao: practice shows that we should do the following even returning an element from a local array:

bool *res = new bool[5]; //Correct way
// bool res[5]; <- wrong way, returned res[2] value will be random
return res[2];

From geeksforgeeks:

How to return a local array from a C/C++ function?

Consider the below C++ program. Is it right way of returning array from a function?

brightness_4
#include<iostream> 
using namespace std; 
  
int *fun() 
{ 
   int arr[100]; 
  
   /* Some operations on arr[] */
   arr[0] = 10; 
   arr[1] = 20; 
     
   return arr; 
} 
  
int main() 
{ 
    int *ptr = fun(); 
    cout << ptr[0] << " " << ptr[1]; 
    return 0; 
} 

In function 'int* fun()':
6:8: warning: address of local variable 'arr' returned [-Wreturn-local-addr]
    int arr[100];
        ^
The above program is WRONG. It may produce values 10 20 as output or may produce garbage values or may crash. The problem is, we return address of a local variable which is not advised as local variables may not exist in memory after function call is over.

Following are some correct ways of returning array:

Using Dynamically Allocated Array :

Dynamically allocated memory (allocated using new or malloc()) remains their until we delete it using delete or free(). So we can create a dynamically allocated array and we can delete it once we come out of function.

#include<iostream> 
using namespace std; 
  
int *fun() 
{ 
   int *arr = new int[100]; 
  
   /* Some operations on arr[] */
   arr[0] = 10; 
   arr[1] = 20; 
     
   return arr; 
} 
  
int main() 
{ 
    int *ptr = fun(); 
    cout << ptr[0] << " " << ptr[1]; 
    return 0; 
} 

Output :

10 20

Using static array:

Lifetime of a static variable is throughout the program. So we can always create a local static array and return it.

#include<iostream> 
using namespace std; 
  
int *fun() 
{ 
   static int arr[100]; 
  
   /* Some operations on arr[] */
   arr[0] = 10; 
   arr[1] = 20; 
     
   return arr; 
} 
  
int main() 
{ 
    int *ptr = fun(); 
    cout << ptr[0] << " " << ptr[1]; 
    return 0; 
} 

Output :

10 20

Using struct:

We can wrap array in a structure/class and return an instance of the struct/class. The reason for this work is, array members of structures are deeply copied. In below program deep copy happens when we returned instance is copied in main.

#include<iostream> 
using namespace std; 
  
struct arrWrap 
{ 
   int arr[100]; 
}; 
  
struct arrWrap fun() 
{ 
   struct arrWrap x; 
  
   x.arr[0] = 10; 
   x.arr[1] = 20; 
     
   return x; 
} 
  
int main() 
{ 
   struct arrWrap x = fun(); 
   cout << x.arr[0] << " " << x.arr[1]; 
   return 0; 
} 

Output :

10 20

==
(findoperator)
(findand)
Operators

Logical operators:
AND: &&
OR:  ||
NOT: !

--
Bitwise operators:
AND: &
OR:  |
XOR: ^ (a^b is equivalent to a != b)
NOT: ~ (eg: ~expr) 
Left shift: << (eg: expr1 << expr2)
Right shift: >> (eg: expr1 >> expr2)

The left-shift operator (the << operator) inserts 0-valued bits on the right. The behavior of the right-shift operator (the >> operator) depends on the type of the left-hand operand: If that operand is unsigned, then the operator inserts 0-valued bits on the left; if it is a signed type, the result is implementation defined‚Äîeither copies of the sign bit or 0-valued bits are inserted on the left.

The bitwise NOT operator (the ~ operator) generates a new value with the bits of its operand inverted. Each 1 bit is set to 0; each 0 bit is set to 1.

Because there are no guarantees for how the sign bit is handled, we strongly recommend using unsigned types with the bitwise operators.

Overloaded versions of these operators for IO: 
cout << "Helo" << endl;

--
Remainder (modulus) operator: %

--
Compound assignments:
+=   -=   *=   /=   %=   (arithmetic operators)
<<=  >>=   &=   ^=   |=  (bitwise operators)

--
Order of Evaluation

Rember: ->|

--
C++ uses = for assignment and == for equality. Both operators can appear
inside a condition. It is a common mistake to write = when you mean ==
inside a condition.

--
Lvalues and Rvalues

Every expression in C++ is either an rvalue or an lvalue. lvalues could stand on the left-hand side of an assignment whereas rvalues could not. In C++, the distinction is less simple. Roughly speaking, when we use an object as an rvalue, we use the object‚Äôs value (its contents). When we use an object as an lvalue, we use
the object‚Äôs identity (its location in memory).

--
In assignment, if the types of the left and right operands differ, the right-hand operand is converted to the type of the left.

--
(findincrement)
(finddecrement)
(find++)
(find--)
The increment (++) and decrement (--) operators

int i = 0;
++i; // i = 1. Prefix returns new value 1 (remeber: ee)
i++; // i = 1. Postfix returns old value 0 (remember: oo)

Readers from a C background might be surprised that we use the prefix increment in the programs we‚Äôve written. The reason is simple: The prefix version avoids unnecessary work. It increments the value and returns the incremented version. The postfix operator must store the original value so that it can return the unincremented value as its result. If we don‚Äôt need the
unincremented value, there‚Äôs no need for the extra work done by the postfix operator.

--
p->size() is equivalent to (*p).size()

--
(findsizeof)
sizeof

The sizeof operator returns the size, in bytes, of an expression or a type name. The result of sizeof is a constant expression of type size_t. The operator takes one of two forms:
 
sizeof (type)
sizeof expr
 
In the second form, sizeof returns the size of the type returned by the given expression. The sizeof operator is unusual in that it does not evaluate its operand:

sizeof an array is the size of the entire array. It is equivalent to taking the sizeof the element type times the number of elements in the array. Note that sizeof does not convert the array to a pointer.

sizeof a string or a vector returns only the size of the fixed part of these types; it does not return the size used by the object‚Äôs elements. Tao's understanding: think of how vector and string is implememted using array and doubles its size when reached maximum, sizeof only takes the fixed part and may not return the correct size of a vector or string.

Example:

constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr2[sz];  // ok sizeof returns a constant expression 

Because sizeof returns a constant expression, we can use the result of a sizeof expression to specify the dimension of an array.

==
(commaoperator)
Comma operator

The comma operator takes two operands, which it evaluates from left to right. Like
the logical AND and logical OR and the conditional operator, the comma operator
guarantees the order in which its operands are evaluated.

The left-hand expression is evaluated and its result is discarded. The result of a
comma expression is the value of its right-hand expression.

Example:

for(vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
ivec[ix] = cnt;

This loop increments ix and decrements cnt in the expression in the for header. Both ix and cnt are changed on each trip through the loop.

==
The simplest statement is the empty statement, also known as a null statement. A null statement is a single semicolon:
; // null statement

A null statement is useful where the language requires a statement but the program‚Äôs logic does not. Such usage is most common when a loop‚Äôs work can be done within its condition.

while (cin >> s && s != sought)
	; // null statement

Null statements should be commented. That way anyone reading the code can see that the statement was omitted intentionally.

An empty block is equivalent to a null statement:

while (cin >> s && s != sought)
	{ } // empty block

==
(findif)
if 

int a;

if (grade < 60)
	a = 1;
else
	a = 2;


if (grade == 2) {
	a = 5;
} else if (grade == 9) {
	a = 8;
}

It is a common mistake to forget the curly braces when multiple statements must be executed as a block. To avoid such problems, some coding styles recommend always using braces after an if or an else (and also around the bodies of while and for statements).
Doing so avoids any possible confusion. It also means that the braces are already in place if later modifications of the code require adding statements.

==
(findswitch)
switch

A switch statement provides a convenient way of selecting among a (possibly large) number of fixed alternatives.

unsigned aCnt = 0, eCnt = 0, otherCunt = 0;

char ch;

switch (ch) {
	case 'a':
		++aCnt;
		break;
	case 'e':
		++eCnt;
		break;
 	default:
 		++otherCunt;
 		break;
}

In this case, the break transfers control out of the switch. Forgetting a break Is a Common Source of Bugs.

The case keyword and its associated value together are known as the case label. case labels must be integral constant expressions.

char ch = getVal();
int ival = 42;
switch(ch) {
	case 3.14: // error: noninteger as case label
	case ival: // error: nonconstant as case label
// . . .

It can be useful to define a default label even if there is no work for the default case. Defining an empty default section indicates to subsequent readers that the case was considered. If a switch ends with a default case that has no work to do, then the default label must be followed by a null statement or an empty block.

==
(findwhile)
while

while(a > 3) {
	cout << a << endl;
}

A condition is an expression that yields a result that is either true or false.

A block is a sequence of zero or more statements enclosed by curly braces.

--
do while

A do while statement is like a while but the condition is tested after the statement body completes. Regardless of the value of the condition, we execute the loop at least once.

A do while ends with a semicolon after the parenthesized condition.

Variables used in condition must be defined outside the body of the do while statement.

// repeatedly ask the user for a pair of numbers to sum
string rsp;  // used in the condition; can't be defined inside the do

do {
    cout << "please enter two values: ";
    int val1 = 0, val2 = 0;
    cin  >> val1 >> val2;
    cout << "The sum of " << val1 << " and " << val2
         << " = " << val1 + val2 << "\n\n"
         << "More? Enter yes or no: ";
    cin  >> rsp;
} while (!rsp.empty() && rsp[0] != 'n');

==
(findfor)
for

for(int i = 0; i < 5; ++i) {
	cout << i << endl;
}

The variable i exists only inside the for; it is not possible to use i after this loop terminates.


for (decltype(v.size()) i = 0, sz = v.size(); i != sz; ++i)
    v.push_back(v[i]);

--
Range for (in C++11):

If we want to write to the elements in the sequence, the
loop variable must be a reference type.

vector<int> v = {0,1,2,3,4,5,6,7,8,9};

// range variable must be a reference so we can write to the elements
for (auto &r : v)   // for each element in v
    r *= 2; // double the value of each element in v

we cannot use a range for to add elements to a vector (or
other container). 

==
(findbreak)
break

A break statement terminates the nearest enclosing while, do while, for, or switch statement. Execution resumes at the statement immediately following the terminated statement.

for (auto it = buf.begin()+1; it != buf.end(); ++it) {
	  if (*it == ' ')
	       break; // leaves the for loop
}

==
(findcontinue)
continue

A continue statement terminates the current iteration of the nearest enclosing loop and immediately begins the next iteration. A continue can appear only inside a for, while, or do while loop. 

In the case of a while or a do while, execution continues by evaluating the condition. In a traditional for loop, execution continues at the expression inside the for header.

==
(findgoto)
goto

A goto statement provides an unconditional jump from the goto to a another statement in the same function. Programs should not use gotos. gotos make programs hard to understand and hard to modify.


goto label;
 
where label is an identifier that identifies a statement. A labeled statement is any statement that is preceded by an identifier followed by a colon:

end: return;  // labeled statement; may be the target of a goto

Label identifiers are independent of names used for variables and other identifiers.

==
(findexception)
Exception

Exceptions are run-time anomalies‚Äîsuch as losing a database connection or encountering unexpected input‚Äîthat exist outside the normal functioning of a program. Dealing with anomalous behavior can be one of the most difficult parts of designing any system.

Exception handling is generally used when one part of a program detects a problem that it cannot resolve and the problem is such that the detecting part of the program cannot continue. In such cases, the detecting part needs a way to signal that something happened and that it cannot continue. Moreover, the detecting part needs a way to signal the problem without knowing what part of the program will deal with the exceptional condition. Having signaled what happened, the detecting part stops processing.
 
A program that contains code that might raise an exception (usually) has another part to handle whatever happened. For example, if the problem is invalid input, the handling part might ask the user to provide correct input. If the database was lost, the handling part might alert an operator.
 
Exception handling supports this cooperation between the detecting and handling parts of a program. In C++, exception handling involves
 
- throw expressions, which the detecting part uses to indicate that it encountered something it can‚Äôt handle. We say that a throw raises an exception.
 
- try blocks, which the handling part uses to deal with an exception. A try block starts with the keyword try and ends with one or more catch clauses.Exceptions thrown from code executed inside a try block are usually handled by one of the catch clauses. Because they ‚Äúhandle‚Äù the exception, catch clauses are also known as exception handlers.

- A set of exception classes that are used to pass information about what happened between a throw and an associated catch.

--
A throw Expression:

// first check that the data are for the same item
if (item1.isbn() != item2.isbn())
    throw runtime_error("Data must refer to same ISBN");
// if we're still here, the ISBNs are the same
cout << item1 + item2 << endl;
 
In this code, if the ISBN s differ, we throw an expression that is an object of type runtime_error. Throwing an exception terminates the current function and transfers control to a handler that will know how to handle this error.

The type runtime_error is one of the standard library exception types and is defined in the stdexcept header. We must initialize a runtime_error by giving it a string or a C-style character string. That string provides additional information about the problem.

--
The try Block:

The general form of a try block is
 
try {
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
} // . . .

When a catch is selected to handle an exception, the associated block is executed. Once the catch finishes, execution continues with the statement immediately following the last catch clause of the try block.

The program-statements inside the try constitute the normal logic of the program. Like any other blocks, they can contain any C++ statement, including declarations. As with any block, variables declared inside a try block are inaccessible outside the block ‚Äî in particular, they are not accessible to the catch clauses.

--
Writing a Handler:\
while (cin >> item1 >> item2) {
    try {
        // execute code that will add the two Sales_items
        // if the addition fails, the code throws a runtime_error exception
    } catch (runtime_error err) {
        // remind the user that the ISBNs must match and prompt for another pair
        cout << err.what()
             << "\nTry Again?  Enter y or n" << endl;
        char c;
        cin >> c;
        if (!cin || c == 'n')
            break;      // break out of the while loop
    }
}

The prompt to the user prints the return from err.what(). We know that err has type runtime_error. Each of the library exception classes defines a member function named what. These functions take no arguments and return a C-style character string (i.e., a const char*). The what member of runtime_error
returns a copy of the string used to initialize the particular object.

If no appropriate catch is found, execution is transferred to a library function named terminate. The behavior of that function is system dependent but is guaranteed to stop further execution of the program.

--
Standard Exceptions:

The C++ library defines several classes that it uses to report problems encountered in the functions in the standard library. These classes are defined in four headers:
 
- The "exception" header defines the most general kind of exception class named "exception". It communicates only that an exception occurred but provides no additional information.

- The "stdexcept" header defines several general-purpose exception classes, which are listed below.

- The "new" header dfines the "bad_alloc" exception type.

- The "type_info" header defines the "bad_cast" exception type. 

Standard exception classes defined in <stdexcetp>:

exception: The most general kind of problem

runtime_error: Problem that can be deteced only at run time.

range_error: Run-time error: result generatd outside the range of values that are meaningful.

overflow_error: Run-time error: computation that overflowed.

underflow_error: Run-time error: computation that underflowed.

logic_error: Error in the logic of the program.

domain_error: Logic error: argument for which no result exists.

invalid_argument: Logic error: inappropriate argument.

length_error: Logic error: attempt to create an object larger than the maximum size for that type.

out_of_range: logic error: used a value outside the valid range.

We can only default initialize exception, bad_alloc, and bad_cast objects; it is not possible to provide an initializer for objects of these exception types.
 
The other exception types have the opposite behavior: We can initialize those objects from either a string or a C-style string, but we cannot default initialize them. When we create objects of any of these other exception types, we must supply an
initializer. That initializer is used to provide additional information about the error that occurred.
 
The exception types define only a single operation named what. That function takes no arguments and returns a const char* that points to a C-style character string. The purpose of this C-style character string is to provide some sort of textual description of the exception thrown.

==
(findfunction)
function

Example:

int fact(int val) {
  int ret = 1; 
  while (val > 1)
    ret *= val--; 
  return ret;
}

The statements after the return statement will not be executed (tao's practice).

--
For compatibility with C, we also can use the keyword void to indicate that there are no parameters:

int f1(){ /* ... */ } // implicit void parameter list

int f2(void){ /* ... */ } // explicit void parameter list

--
The return type can be void, which means that the function does not return a value.

The return type may not be an array type or a function type. However, a function may return a pointer to an array or a function. 

--
(findparameter)

Examples of function input parameters from Leetcode:

Summary of parameter type

string: string
vector: reference to vector
object: pointer or reference to object

** string **

bool isAnagram(string s, string t) {
    
}

int myAtoi(string str) {
    
}

int strStr(string haystack, string needle) {
    
}

** vector **

int firstMissingPositive(vector<int>& nums) {
    
}

vector<vector<string>> groupAnagrams(vector<string>& strs) {
    
}

void rotate(vector<vector<int>>& matrix) {
    
}

** object ** 

vector<int> inorderTraversal(TreeNode* root) {
    
}

UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
    
}

struct Interval {
    int start;
    int end;
    Interval() : start(0), end(0) {}
    Interval(int s, int e) : start(s), end(e) {}
};

vector<Interval> merge(vector<Interval>& intervals) {
    
}

--
Argument Passing

If the parameter is a reference, then the parameter is bound to its argument. Otherwise, the argument‚Äôs value is copied.

When a parameter is a reference, we say that its corresponding argument is ‚Äúpassed by reference‚Äù or that the function is ‚Äúcalled by reference.‚Äù The parameter is an alias for its corresponding argument.
 
When the argument value is copied, the parameter and argument are independent objects. We say such arguments are ‚Äúpassed by value‚Äù or alternatively that the function is ‚Äúcalled by value.‚Äù

-- 
Passing Arguments by Value

Nothing the function does to the parameter can affect the argument.

Pointer Parameters
 
Pointers behave like any other nonreference type. When we copy a
pointer, the value of the pointer is copied. After the copy, the two pointers are distinct. However, a pointer also gives us indirect access to the object to which that pointer points.

(Avadoles) Programmers accustomed to programming in C often use pointer parameters to access objects outside a function. In C++, programmers generally use reference parameters instead.

--
Passing Arguments by Reference

void reset(int &i)  // i is just another name for the object passed to reset
{
    i = 0;  // changes the value of the object to which i refers
}

int j = 42;
reset(j);  // j is passed by reference; the value in j is changed
cout << "j = " << j  << endl;  // prints j = 0

Using References to Avoid Copies
 
It can be inefficient to copy objects of large class types or large containers. Moreover, some class types (including the IO types) cannot be copied. Functions must use reference parameters to operate on objects of a type that cannot be copied.

(findconstparameter)
As an example, we‚Äôll write a function to compare the length of two strings. Because strings can be long, we‚Äôd like to avoid copying them, so we‚Äôll make our parameters references. Because comparing two strings does not involve changing the strings, we‚Äôll make the parameters references to const. Reference parameters that are not changed inside a function should be references to const.

// compare the length of two strings
bool isShorter(const string &s1, const string &s2) {
    return s1.size() < s2.size();
}

Tao did not see any functions returning a const. If I see it, record it here.

Use Reference to const When Possible

It is a somewhat common mistake to define parameters that a function does not change as (plain) references. Doing so gives the function‚Äôs caller the misleading impression that the function might change its argument‚Äôs value.

Using Reference Parameters to Return Additional Information
 
A function can return only a single value. However, sometimes a function has more than one value to return. Reference parameters let us effectively return multiple results.

// returns the index of the first occurrence of c in s
// the reference parameter occurs counts how often c occurs
string::size_type find_char(const string &s, char c, string::size_type &occurs) {
    auto ret = s.size();   // position of the first occurrence, if any
    occurs = 0;            // set the occurrence count parameter
    for (decltype(ret) i = 0; i != s.size(); ++i) {
        if (s[i] == c) {
            if (ret == s.size())
                ret = i;   // remember the first occurrence of c
            ++occurs;      // increment the occurrence count
         }
    }
    return ret;            // count is returned implicitly in occurs
}

auto index = find_char(s, 'o', ctr);
 
After the call, the value of ctr will be the number of times o occurs.

--
Array Parameters

Arrays have two special properties that affect how we define and use functions that operate on arrays: We cannot copy an array, and when we use an array it is (usually) converted to a pointer. Because we cannot copy an array, we cannot pass an array by value. Because arrays are converted to pointers, when we pass an array to a function, we are actually passing a pointer to the array‚Äôs first element.

Even though we cannot pass an array by value, we can write a parameter that looks like an array:

// despite appearances, these three declarations of print are equivalent:

// each function has a single parameter of type const int*
void print(const int*);
void print(const int[]);   // shows the intent that the function takes an array
void print(const int[10]); // dimension for documentation purposes (at best)

int j[2] = {0, 1};
print(j);  // ok: j is converted to an int* that points to j[0]

Because arrays are passed as pointers, functions ordinarily don‚Äôt know the size of the array they are given. They must rely on additional information provided by the caller. There are three common techniques used to manage pointer parameters.

Using a Marker to Specify the Extent of an Array

The first approach to managing array arguments requires the array itself to contain an end marker. C-style character strings are an example of this approach. C-style strings are stored in character arrays in which the last character of the string is followed by a null character. Functions that deal with C-style strings stop processing the array when they see a null character.

Using the Standard Library Conventions
 
A second technique used to manage array arguments is to pass pointers to the first and one past the last element in the array.

Using this approach, we‚Äôll print the elements in an array as follows:

void print(const int *beg, const int *end) {
    // print every element starting at beg up to but not including end
    while (beg != end)
        cout << *beg++ << endl; // print the current element and advance the pointer
}

To call this function, we pass two pointers:

int j[2] = {0, 1};

print(begin(j), end(j));

Explicitly Passing a Size Parameter

A third approach for array arguments, which is common in C programs and older C++ programs, is to define a second parameter that indicates the size of the array.

// const int ia[] is equivalent to const int* ia
// size is passed explicitly and used to control access to elements of ia

void print(const int ia[], size_t size) {
    for (size_t i = 0; i != size; ++i) {
        cout << ia[i] << endl;
    }
}

int j[] = { 0, 1 };  // int array of size 2
print(j, end(j) - begin(j));

--
Array Parameters and const
 
Note that all three versions of our print function defined their array parameters as pointers to const. The discussion in ¬ß 6.2.3 applies equally to pointers as to references. When a function does not need write access to the array elements, the array parameter should be a pointer to const. A parameter should be
a plain pointer to a nonconst type only if the function needs to change element values.

--
Array Reference Parameters
 
Just as we can define a variable that is a reference to an array, we can define a parameter that is a reference to an array.

void print(int (&arr)[10]) {
    for (auto elem : arr)
        cout << elem << endl;
}

Because the size of an array is part of its type, it is safe to rely on the dimension in the body of the function. However, the fact that the size is part of the type limits the usefulness of this version of print. We may call this function only for an array of exactly ten ints:

j[2] = {0, 1};
int k[10] = {0,1,2,3,4,5,6,7,8,9};

print(j);    // error: argument is not an array of ten ints
print(k);    // ok: argument is an array of ten ints

--
Passing a Multidimensional Array

As with any array, a multidimensional array is passed as a pointer to its first element. Because we are dealing with an array of arrays, that element is an array, so the pointer is a pointer to an array. The size of the second (and any subsequent) dimension is part of the element type and must be specified:

// matrix points to the first element in an array whose elements are arrays of ten ints
void print(int (*matrix)[10], int rowSize) { /* . . . */ }

declares matrix as a pointer to an array of ten ints.

We can also define our function using array syntax. As usual, the compiler ignores the first dimension, so it is best not to include it:

// equivalent definition
void print(int matrix[][10], int rowSize) { /* . . . */ }

--
Returning a Pointer to an Array

Because we cannot copy an array, a function cannot return an array. However, a function can return a pointer or a reference to an array Unfortunately, the syntax used to define functions that return pointers or references to arrays can be intimidating. Fortunately, there are ways to simplify such declarations. The most straightforward way is to use a type alias

typedef int arrT[10];  // arrT is a synonym for the type array of ten ints

using arrtT = int[10]; // equivalent declaration of arrT; 

arrT* func(int i);     // func returns a pointer to an array of five ints

Declaring a Function That Returns a Pointer to an Array
 
To declare func without using a type alias, we must remember that the dimension of an array follows the name being defined:
  
int arr[10];          // arr is an array of ten ints
int *p1[10];          // p1 is an array of ten pointers
int (*p2)[10] = &arr; // p2 points to an array of ten ints
 
As with these declarations, if we want to define a function that returns a pointer to an array, the dimension must follow the function‚Äôs name. However, a function includes a parameter list, which also follows the name. The parameter list precedes the
dimension. Hence, the form of a function that returns a pointer to an array is:

Type (*function(parameter_list))[dimension]

As a concrete example, the following declares func without using a type alias:

int (*func(int i))[10];

Using a Trailing Return Type (C++11)

Under the new standard, another way to simplify the declaration of func is by using a trailing return type.

A trailing return type follows the parameter list and is preceded by ->. To signal that the return follows the parameter list, we use auto where the return type ordinarily appears:

// fcn takes an int argument and returns a pointer to an array of ten ints
auto func(int i) -> int(*)[10];

Using decltype

As another alternative, if we know the array(s) to which our function can return a pointer, we can use decltype to declare the return type.

int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
// returns a pointer to an array of five int elements
decltype(odd) *arrPtr(int i)
{
    return (i % 2) ? &odd : &even; // returns a pointer to the array
}

--
Functions with Varying Parameters

Sometimes we do not know in advance how many arguments we need to pass to a function.

The new standard provides two primary ways to write a function that takes a varying number of arguments: If all the arguments have the same type, we can pass a library type named initializer_list. If the argument types vary, we can write a special kind of function, known as a variadic template.

C++ also has a special parameter type, ellipsis, that can be used to pass a varying number of arguments.

--
initializer_list Parameters (C++11)

We can write a function that takes an unknown number of arguments of a single type by using an initializer_list parameter. An initializer_list is a library type that represents an array of values of the specified type. This type is defined in the initializer_list header. The operations that initializer_list provides are listed below:

initializer_list<T> lst: Default initialization, an empty list of element sof type T.

initializer_list<T> lst(a, b, c...): lst has as many elements as there are initializers, elements are copies of the corresponding initializers. Elements in the list are const.

lst2(lst), lst2 = lst: Copying or assigning an initializer_list does not copy the elements in the list. After the copy, the original and the copy share the elements.

lst.size(): Number of elements in the list.

lst.begin(), lst.end(): Returns a pointer to the first and one past the last elments in the lst.

Example:

initializer_list<int> li;    // initializer_list of ints

Unlike vector, the elements in an initializer_list are always const values; there is no way to change the value of an element in an initializer_list.

void error_msg(initializer_list<string> il) {
    for (auto beg = il.begin(); beg != il.end(); ++beg)
        cout << *beg << " " ;
    cout << endl;
}

When we pass a sequence of values to an initializer_list parameter, we must enclose the sequence in curly braces:

error_msg({"functionX", "okay"});

A function with an initializer_list parameter can have other parameters as well.

void error_msg(ErrCode e, initializer_list<string> il)

error_msg(ErrCode(0), {"functionX", "okay"});

--
Ellipsis Parameters

Ellipsis parameters are in C++ to allow programs to interface to C code that uses a C library facility named varargs. Generally an ellipsis parameter should not be used for other purposes.

Ellipsis parameters should be used only for types that are common to both C and C++. In particular, objects of most class types are not copied properly when passed to an ellipsis parameter.

An ellipsis parameter may appear only as the last element in a parameter list and may take either of two forms:
 
void foo(parm_list, ...);
void foo(...);

--
(findreturn)
return

todo: search for return string, return object

--
(findreturnvector)
Return a vector from function (from online):

In leetcode, the default code follows this pattern:
Input parameter is a reference to vector, output is a vector:

vector<vector<int>> permute(vector<int>& nums) { 
    vector<vector<int>> res;
    ...
    return res; //Practice shows it is OK to return a vector defined inside a function (unlike pointer).
}

vector<Interval> merge(vector<Interval>& intervals) {
    ...
    return intervals; //Practice shows it is OK to return the input reference.
}

Question:

Efficient way to return a std::vector in c++

How much data is copied, when returning a std::vector in a function and how big an optimization will it be to place the std::vector in free-store (on the heap) and return a pointer instead i.e. is:

std::vector *f()
{
  std::vector *result = new std::vector();
  /*
    Insert elements into result
  */
  return result;
} 
more efficient than:

std::vector f()
{
  std::vector result;
  /*
    Insert elements into result
  */
  return result;
} 

Answer:

In C++11, this is the preferred way:

std::vector<X> f();

That is, return by value.

With C++11, std::vector has move-semantics, which means the local vector declared in your function will be moved on return and in some cases even the move can be elided by the compiler.

Question:

Why is it OK to return vector from function?

Please consider this code. I have seen this type of code several times. words is a local vector. How is it possible to return it from a function? Can we guarantee it will not die?

 std::vector<std::string> read_file(const std::string& path)
 {
    std::ifstream file("E:\\names.txt");

    if (!file.is_open())
    {
        std::cerr << "Unable to open file" << "\n";
        std::exit(-1);
    }

    std::vector<string> words;//this vector will be returned 
    std::string token;

    while (std::getline(file, token, ','))
    {
        words.push_back(token);
    }

    return words;
}

Pre C++11:
The function will not return the local variable but rather a copy of it. Your compiler might however perform an optimization where no actual copy action is made.

See this question & answer for further details

C++11:
The function will move the value, see this answer for further details

Question:

What is std::move(), and when should it be used?

What is it?
What does it do?
When should it be used?
Good links are appreciated.

Answer:

Wikipedia Page on C++11 R-value references and move constructors

1. In C++11, in addition to copy constructors, objects can have move constructors.
(And in addition to copy assignment operators, they have move assignment operators.)

2. The move constructor is used instead of the copy constructor, if the object has type "rvalue-reference" (Type &&).

3. std::move() is a cast that produces an rvalue-reference to an object, to enable moving from it. It's a new C++ way to avoid copies. For example, using a move constructor, a std::vector could just copy its internal pointer to data to the new object, leaving the moved object in an incorrect state, avoiding to copy all data. This would be C++-valid.

Try googling for move semantics, rvalue, perfect forwarding.

--
(findreturnpointer)
Return pointer from a function (from tutorialspoint):

Tao's summary from below:
1. It is not good idea to return the address of a local variable to outside of the function, so you would have to define the local variable as static variable.
2. Can return a pointer created by the "new" operator. Extracted from "find new": Dynamically allocated objects have a lifetime that is independent of where they are created; they exist until they are explicitly freed. Functions that return pointers (rather than smart pointers) to dynamic memory put burden on their callers‚Äîthe caller must remember to delete the memory. We returned pointer created by "new" in leetcode, like pr_133 (leetcode discussion also did this).

As we have seen in last chapter how C++ allows to return an array from a function, similar way C++ allows you to return a pointer from a function. To do so, you would have to declare a function returning a pointer as in the following example ‚àí

int * myFunction() {
   .
   .
   .
}

Second point to remember is that, it is not good idea to return the address of a local variable to outside of the function, so you would have to define the local variable as static variable. Tao: if return the address of a local variable, the caller function would get a pointer containing wrong address value (from practice).

Now, consider the following function, which will generate 10 random numbers and return them using an array name which represents a pointer i.e., address of first array element.

 Live Demo
#include <iostream>
#include <ctime>
 
using namespace std;
 
// function to generate and retrun random numbers.
int * getRandom( ) {
   static int  r[10];
 
   // set the seed
   srand( (unsigned)time( NULL ) );
   
   for (int i = 0; i < 10; ++i) {
      r[i] = rand();
      cout << r[i] << endl;
   }
 
   return r;
}
 
// main function to call above defined function.
int main () {
   // a pointer to an int.
   int *p;
 
   p = getRandom();
   for ( int i = 0; i < 10; i++ ) {
      cout << "*(p + " << i << ") : ";
      cout << *(p + i) << endl;
   }
 
   return 0;
}
When the above code is compiled together and executed, it produces result something as follows ‚àí

624723190
1468735695
807113585
976495677
613357504
1377296355
1530315259
1778906708
1820354158
667126415
*(p + 0) : 624723190
*(p + 1) : 1468735695
*(p + 2) : 807113585
*(p + 3) : 976495677
*(p + 4) : 613357504
*(p + 5) : 1377296355
*(p + 6) : 1530315259
*(p + 7) : 1778906708
*(p + 8) : 1820354158
*(p + 9) : 667126415

--
(findreturnreference)
Return reference from a function (from tutorialspoint):

Tao's summary from below
1. Using (not limited to returning) reference is recommended rather than using pointer.
2. It is not legal to return a reference to local var. But you can always return a reference on a static variable.

A C++ program can be made easier to read and maintain by using references rather than pointers. A C++ function can return a reference in a similar way as it returns a pointer.

When a function returns a reference, it returns an implicit pointer to its return value. This way, a function can be used on the left side of an assignment statement. For example, consider this simple program ‚àí

#include <iostream>
#include <ctime>
 
using namespace std;
 
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double& setValues( int i ) {
   return vals[i];   // return a reference to the ith element
}
 
// main function to call above defined function.
int main () {
 
   cout << "Value before change" << endl;
   for ( int i = 0; i < 5; i++ ) {
      cout << "vals[" << i << "] = ";
      cout << vals[i] << endl;
   }
 
   setValues(1) = 20.23; // change 2nd element
   setValues(3) = 70.8;  // change 4th element
 
   cout << "Value after change" << endl;
   for ( int i = 0; i < 5; i++ ) {
      cout << "vals[" << i << "] = ";
      cout << vals[i] << endl;
   }
   return 0;
}
When the above code is compiled together and executed, it produces the following result ‚àí

Value before change
vals[0] = 10.1
vals[1] = 12.6
vals[2] = 33.1
vals[3] = 24.1
vals[4] = 50
Value after change
vals[0] = 10.1
vals[1] = 20.23
vals[2] = 33.1
vals[3] = 70.8
vals[4] = 50

When returning a reference, be careful that the object being referred to does not go out of scope. So it is not legal to return a reference to local var. But you can always return a reference on a static variable.

int& func() {
   int q;
   //! return q; // Compile time error
   static int x;
   return x;     // Safe, x lives outside this scope
}

--
A return statement terminates the function that is currently executing and returns control to the point from which the function was called. There are two forms of return statements:
 
return;
return expression;

Functions with No Return Value

A return with no value may be used only in a function that has a return type of void. Functions that return void are not required to contain a return. In a void function, an implicit return takes place after the function‚Äôs last statement.
  
Typically, void functions use a return to exit the function at an intermediate point. This use of return is analogous to the use of a break statement to exit a loop.

Functions That Return a Value

Every return in a function with a return type other than void must return a value.

Never Return a Reference or Pointer to a Local Object

When a function completes, its storage is freed. After a function terminates, references to local objects refer to memory that is no longer valid:

// disaster: this function returns a reference to a local object
const string &manip() {
    string ret;
   // transform ret in some way
   if (!ret.empty())
       return ret;     // WRONG: returning a reference to a local object!
   else
       return "Empty"; // WRONG: "Empty" is a local temporary string
}

If a function returns a pointer, reference or object of class type, we can use the result of a call to call a member of the resulting object:

auto sz = shorterString(s1, s2).size();

Reference Returns Are Lvalues. we can assign to the result of a function that returns a reference to nonconst:

char &get_val(string &str, string::size_type ix) {
    return str[ix]; // get_val assumes the given index is valid
}

get_val(s, 0) = 'A'; // changes s[0] to A

It may be surprising to see a function call on the left-hand side of an assignment. However, nothing special is involved.

--
List Initializing the Return Value (C++11)

Under the new standard, functions can return a braced list of values.

vector<string> process() {
    // . . .
    return {"functionX", expected, actual};
}

--
Return from main

There is one exception to the rule that a function with a return type other than void must return a value: The main function is allowed to terminate without a return. If control reaches the end of main and there is no return, then the compiler implicitly
inserts a return of 0.

The value returned from main is treated as a status indicator. A zero return indicates success; most other values indicate failure. A nonzero value has a machine-dependent meaning. To make return values machine independent, the cstdlib header defines two preprocessor variables that we can use to indicate success or failure:

int main() {
    if (some_failure)
        return EXIT_FAILURE;  // defined in cstdlib
    else
        return EXIT_SUCCESS;  // defined in cstdlib
}
 
Because these are preprocessor variables, we must not precede them with std::, nor may we mention them in using declarations.

--
Recursion

A function that calls itself, either directly or indirectly, is a recursive function.

// calculate val!, which is 1 * 2 * 3 . . . * val
int factorial(int val) {
    if (val > 1)
        return factorial(val-1) * val;
    return 1;
}

There must always be a path through a recursive function that does not involve a recursive call; otherwise, the function will recurse ‚Äúforever‚Äù.

The main function may not call itself.

--
(findstatic)
Local static objects
Static variables

It can be useful to have a local variable whose lifetime continues across calls to the function. We obtain such objects by defining a local variable as static. Each local static object is initialized before the first time execution passes through the object‚Äôs definition. Local statics are not destroyed when a function ends; they are destroyed when the program terminates.

As a trivial example, here is a function that counts how many times it is called. This program will print the numbers from 1 through 10 inclusive.
 
size_t count_calls() {
    static size_t ctr = 0;  // value will persist across calls
    return ++ctr;
}

int main() {
    for (size_t i = 0; i != 10; ++i)
        cout << count_calls() << endl;
    return 0;
}
 
If a local static has no explicit initializer, it is value initialized, meaning that local statics of built-in type are initialized to zero.

--
Function Declarations

Like any other name, the name of a function must be declared before we can use it. As with variables, a function may be defined only once but may be declared multiple times.

A function declaration is just like a function definition except that a declaration has no function body. In a declaration, a semicolon replaces the function body.
 
Because a function declaration has no body, there is no need for parameter names. Hence, parameter names are often omitted in a declaration. Although parameter names are not required, they can be used to help users of the function understand what the function does:
 
void print(vector<int>::const_iterator beg, vector<int>::const_iterator end);

Function declarations are also known as the function prototype.

Function Declarations Go in Header Files
 
Recall that variables are declared in header files and defined in source files. For the same reasons, functions should be declared in header files and defined in source files.

It may be tempting‚Äîand would be legal‚Äîto put a function declaration directly in each source file that uses the function. However, doing so is tedious and error-prone. When we use header files for our function declarations, we can ensure that all the
declarations for a given function agree. The source file that defines a function should include the header that contains that function‚Äôs declaration.

--
(findoverload)
Overloaded Functions

Functions that have the same name but different parameter lists and that appear in the same scope are overloaded.

Examples:

void print(const char *cp);
void print(const int *beg, const int *end);
void print(const int ia[], size_t size);

When we call these functions, the compiler can deduce which function we want based on the argument type we pass:

print("Hello World");        // calls print(const char*)
print(j, end(j) - begin(j)); // calls print(const int*, size_t)
print(begin(j), end(j));     // calls print(const int*, const int*)

Function overloading eliminates the need to invent‚Äîand remember‚Äînames that exist only to help the compiler figure out which function to call.

The main function may not be overloaded.

Overloaded functions must differ in the number or the type(s) of their parameters.

It is an error for two functions to differ only in terms of their return types.
 
Two parameter lists can be identical, even if they don‚Äôt look the same.

Although overloading lets us avoid having to invent (and remember) names for common operations, we should only overload operations that actually do similar things. There are some cases where providing different function names adds information that makes the program easier to understand.

Function matching (also known as overload resolution) is the process by which a particular function call is associated with a
specific function from a set of overloaded functions.

Names do not overload across scopes.

--
Default Arguments

string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');
 
Here we‚Äôve provided a default for each parameter. A default argument is specified as an initializer for a parameter in the parameter list. We may define defaults for one or more parameters. However, if a parameter has a default argument, all the parameters that follow it must also have default arguments.

If we want to use the default argument, we omit that argument when we call the function.

window = screen();  // equivalent to screen(24,80,' ')

window = screen(66);// equivalent to screen(66,80,' ')
window = screen(66, 256);      // screen(66,256,' ')
window = screen(66, 256, '#'); // screen(66,256,'#')
 
Arguments in the call are resolved by position. 

The default arguments are used for the trailing (right-most) arguments of a call:

window = screen(, , '?'); // error: can omit only trailing arguments
window = screen('?');     // calls screen('?',80,' ')

Part of the work of designing a function with default arguments is ordering the parameters so that those least likely to use a default value appear first and those most likely to use a default appear last.

Default Argument Declarations
 
Although it is normal practice to declare a function once inside a header, it is legal to redeclare a function multiple times. However, each parameter can have its default specified only once in a given scope. Thus, any subsequent declaration can add a
default only for a parameter that has not previously had a default specified. As usual, defaults can be specified only if all parameters to the right already have defaults.

Local variables may not be used as a default argument.

--
(findinlinefunctions)
Inline Functions

We can define shorterString as an inline function by putting the keyword inline before the function‚Äôs return type:

// inline version: find the shorter of two strings
inline const string & shorterString(const string &s1, const string &s2) {
	return s1.size() <= s2.size() ? s1 : s2;
}

A function specified as inline (usually) is expanded ‚Äúin line‚Äù at each call. If shorterString were defined as inline, then this call

cout << shorterString(s1, s2) << endl;

(probably) would be expanded during compilation into something like

cout << (s1.size() < s2.size() ? s1 : s2) << endl;

The run-time overhead of making shorterString a function is thus removed.

The inline specification is only a request to the compiler. The compiler may choose to ignore this request.

In general, the inline mechanism is meant to optimize small, straight-line functions that are called frequently. Many compilers will not inline a recursive function. A 75-line function will almost surely not be expanded inline.

--
(findconstexprfunctions)
constexpr Functions

A constexpr function is a function that can be used in a constant expression. A constexpr function is defined like any other function but must meet certain restrictions: The return type and the type of each parameter in a must be a literal type, and the function body must contain exactly one return statement:

constexpr int new_sz() { return 42; }
constexpr int foo = new_sz(); // ok: foo is a constant expression

When it can do so, the compiler will replace a call to a constexpr function with its resulting value. In order to be able to expand the function immediately, constexpr functions are implicitly inline.

A constexpr function body may contain other statements so long as those
statements generate no actions at run time. For example, a constexpr function may contain null statements, type aliases (¬ß 2.5.1, p. 67), and using declarations.

A constexpr function is permitted to return a value that is not a constant:

// scale(arg) is a constant expression if arg is a constant expression
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }

Put inline and constexpr Functions in Header Files 

Unlike other functions, inline and constexpr functions may be defined multiple times in the program. After all, the compiler needs the definition, not just the declaration, in order to expand the code. However, all of the definitions of a given inline or constexpr must match exactly. As a result, inline and constexpr functions normally are defined in headers.

--
(findassert)
The assert Preprocessor Macro

C++ programmers sometimes use a technique similar to header guards to conditionally execute debugging code. The idea is that the program will contain debugging code that is executed only while the program is being developed. When the application is completed and ready to ship, the debugging code is turned off. This approach uses two preprocessor facilities: assert and NDEBUG.

The assert Preprocessor Macro assert is a preprocessor macro. A preprocessor macro is a preprocessor variable that acts somewhat like an inline function. The assert macro takes a single expression, which it uses as a condition:

assert(expr);

evaluates expr and if the expression is false (i.e., zero), then assert writes a message and terminates the program. If the expression is true (i.e., is nonzero), then assert does nothing.

The assert macro is defined in the cassert header. As we‚Äôve seen, preprocessor names are managed by the preprocessor not the compiler. As a result, we use preprocessor names directly and do not provide a using declaration for them. That is, we refer to assert, not std::assert, and provide no using declaration for assert. 

As with preprocessor variables, macro names must be unique within the program. Programs that include the cassert header may not define a variable, function, or other entity named assert. In practice, it is a good idea to avoid using the name assert for our own purposes even if we don‚Äôt include cassert. Many headers include the cassert header, which means that even if you don‚Äôt directly include that file, your programs are likely to have it included anyway.

The assert macro is often used to check for conditions that ‚Äúcannot happen.‚Äù For example, a program that does some manipulation of input text might know that all words it is given are always longer than a threshold. That program might contain a statement such as

assert(word.size() > threshold);

--
(findndebug)
The NDEBUG Preprocessor Variable

The behavior of assert depends on the status of a preprocessor variable named NDEBUG. If NDEBUG is defined, assert does nothing. By default, NDEBUG is not defined, so, by default, assert performs a run-time check.

We can ‚Äúturn off‚Äù debugging by providing a #define to define NDEBUG.
Alternatively, most compilers provide a command-line option that lets us define preprocessor variables:

g++ -D NDEBUG main.C 

has the same effect as writing #define NDEBUG at the beginning of main.C.

In addition to using assert, we can write our own conditional debugging code using NDEBUG. If NDEBUG is not defined, the code between the #ifndef and the #endif is executed. If NDEBUG is defined, that code is ignored:

void print(const int ia[], size_t size) {
	#ifndef NDEBUG

	// _ _func_ _ is a local static defined by the compiler that holds the function's name

	cerr << _ _func_ _ << ": array size is " << size << endl;

	#endif
	// ...
}

Here we use a variable named _ _func_ _ to print the name of the function we are debugging. The compiler defines _ _func_ _ in every function. It is a local static array of const char that holds the name of the function.

In addition to _ _func_ _, which the C++ compiler defines, the preprocessor defines four other names that can be useful in debugging:

_ _FILE_ _ string literal containing the name of the file
_ _LINE_ _ integer literal containing the current line number
_ _TIME_ _ string literal containing the time the file was compiled
_ _DATE_ _ string literal containing the date the file was compiled

We might use these constants to report additional information in error messages:

if (word.size() < threshold)
	cerr << "Error: " << _ _FILE_ _
		 << " : in function " << _ _func_ _
		 << " at line " << _ _LINE_ _ << endl
		 << " Compiled on " << _ _DATE_ _
		 << " at " << _ _TIME_ _ << endl
		 << " Word read was \"" << word
		 << "\": Length too short" << endl;

If we give this program a string that is shorter than the threshold, then the following error message will be generated:

Error: wdebug.cc : in function main at line 27
Compiled on Jul 11 2012 at 20:50:03
Word read was "foo": Length too short

==
(findstruct)
Struct

struct Sales_data {
    string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
}; //Tao: don't forget the ;

We‚Äôll assume that our Sales_data class is defined inside Sales_data.h.

#include <iostream>
#include <string>
#include "Sales_data.h"
int main()
{
	Sales_data data1, data2;
	Sales_data* salesptr;
	// code to read into data1 and data2
	// code to check whether data1 and data2 have the same ISBN
	// and if so print the sum of data1 and data2

	std::cin >> data1.bookNo >> data1.units_sold >> price;
}

Our new program includes the string header. We need that header because our code will have to manage the bookNo member, which has type string.

Under the new standard, we can supply an in-class initializer (tao: like the "double revenue = 0.0" above) for a data member. When we create objects, the in-class initializers will be used to initialize the data members. Members without an initializer are default initialized

Each object has its own copy of the class data members. Modifying the data members of one object does not change the data in any other Sales_data object.

To see the difference between struct and class, search for "find public", and look at the end of that part.

--
From Google C++ Style Guide:

Structs vs. Classes

Use a struct only for passive objects that carry data; everything else is a class.

structs should be used for passive objects that carry data, and may have associated constants, but lack any functionality other than access/setting the data members. The accessing/setting of fields is done by directly accessing the fields rather than through method invocations. Methods should not provide behavior but should only be used to set up the data members, e.g., constructor, destructor, Initialize(), Reset(), Validate().

If more functionality is required, a class is more appropriate. If in doubt, make it a class.

==
(findclass)
class

A class defines a type along with a collection of operations that are related to that type.

Perhaps the most important feature in C++ is the class, which lets programmers define their own types. In C++ such types are sometimes called ‚Äúclass types‚Äù to distinguish them from the types that are built into the language.

Every class defines a type. The type name is the same as the name of the class. Hence, our Sales_item class defines a type named Sales_item. As with the builtin types, we can define a variable of a class type. When we write

Sales_item item;

we are saying that item is an object of type Sales_item.

In general, the class author determines all the operations that can be used on objects of the class type.

#include <iostream>
#include "Sales_item.h"
int main()
{
    Sales_item item1, item2;
    std::cin >> item1 >> item2; // read a pair of transactions
    std::cout << item1 + item2 << std::endl; // print their sum
    return 0;
}

Instead of reading and printing the sum of two integers, we‚Äôre reading and printing the sum of two Sales_item objects. Moreover, the whole idea of ‚Äúsum‚Äù is different.

item1.isbn() == item2.isbn()
calls a member function named isbn. A member function is a function that is defined as part of a class. Member functions are sometimes referred to as methods.

The dot operator applies only to objects of class type. The left-hand operand must be an object of class type, and the right-hand operand must
name a member of that type. We call a function using the call operator (the () operator).

--
Classes ordinarily are not defined inside functions.

In order to ensure that the class definition is the same in each file, classes are usually defined in header files.

Tao: don't foreget the ; at the end of a class!

Tao: note public and private has no identitation. There is no identiation in this book, and in leetcode default code, in online examples, and sublime also removes these identitaction automatically.


class Sales_data {
public:
    Sales_data() = default; // default constructor
    Sales_data(string &s, double p) : bookNo(s), revenue(p) {}  

private:
    string bookNo;
    double revenue = 0.0;
    
    double price() {
        ...
    }
};

If our class does not explicitly define any constructors, the compiler will implicitly define the default constructor for us (know as the synthesized default constructor).

Sales_data item;
Screen myScreen(5, 3);
Screen myScreen = Screen(5, 3);//Added by Tao, works in practice.

Sales_data obj(); // oops! declares a function, not an object
Sales_data obj2; // ok: obj2 is an object, not a function

--
(findpublic)
(findprivate)

Access specifiers (public & private)

public:

Members defined after a public specifier are accessible to all parts of the program. The public members define the interface to the class.

private:

Members defined after a private specifier are accessible to the member functions of the class but are not accessible to code that uses the class. The private sections encapsulate (i.e., hide) the implementation.

Example:

class Sales_data {
public: // tao: this line has no identation (same in leetcode)
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
    Sales_data(const std::string &s): bookNo(s) { }
    Sales_data(std::istream&);
    std::string isbn() const { return bookNo; }
    Sales_data &combine(const Sales_data&);

private: // tao: this line has no identation (same in leetcode)
    double avg_price() const { 
        return units_sold ? revenue/units_sold : 0; 
    }
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

A class may contain zero or more access specifiers, and there are no restrictions on how often an access specifier may appear. Each access specifier specifies the access level of the succeeding members. The specified access level remains in effect until the next access specifier or the end of the class body.

We also made another, more subtle, change: We used the class keyword rather than struct to open the class definition. This change is strictly stylistic; we can define a class type using either keyword. The only difference between struct and class is
the default access level.

If we use the struct keyword, the members defined before the first access specifier are public; if we use class, then
the members are private.

As a matter of programming style, when we define a class intending for all of its members to be public, we use struct. If we intend to have private members, then we use class.

--
(findmemberfunction)
member function

We define and declare member functions similarly to ordinary functions. Member functions must be declared inside the class. Member
functions may be defined inside the class itself or outside the class body. Nonmember functions that are part of the interface, such as add, read, and print, are declared and defined outside the class.

struct Sales_data {
	// new members: operations on Sales_data objects
	std::string isbn() const { return bookNo; } //Tao: will explain const later
	Sales_data& combine(const Sales_data&);
	double avg_price() const;

	// data members:
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};

// nonmember Sales_data interface functions
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);

Note: Functions defined in the class are implicitly inline

Member functions access the object on which they were called through an extra, implicit parameter named this. When we call a member function, this is initialized with the address of the object on which the function was invoked. For example, when we call

total.isbn() //tao: total is an object of Sales_data

the compiler passes the address of total to the implicit this parameter in isbn. It is as if the compiler rewrites this call as

// pseudo-code illustration of how a call to a member function is translated
Sales_data::isbn(&total)

which calls the isbn member of Sales_data passing the address of total.

Inside a member function, we can refer directly to the members of the object on which the function was called. We do not have to use a member access operator to use the members of the object to which this points. Any direct use of a member of the class is assumed to be an implicit reference through this. That is, when isbn uses bookNo, it is implicitly using the member to which this points. It is as if we had written this->bookNo.

The this parameter is defined for us implicitly. Indeed, it is illegal for us to define a parameter or variable named this. Inside the body of a member function, we can use this. It would be legal, although unnecessary, to define isbn as

std::string isbn() const { return this->bookNo; }

Because this is intended to always refer to ‚Äúthis‚Äù object, this is a const pointer. We cannot change the address that this holds.

It is worth noting that isbn can use bookNo even though bookNo is defined after isbn. The compiler processes classes in two steps‚Äî
the member declarations are compiled first, after which the member function bodies, if any, are processed. Thus, member function bodies may use other members of their class regardless of where in the class those members appear.

Defining a Member Function outside the Class

As with any other function, when we define a member function outside the class body, the member‚Äôs definition must match its declaration. If the member was declared as a const member function (search for find constmemberfunction), then the definition must also specify const after the parameter list. The name of a member defined outside the class must include the name of the class of which it is a member:

double Sales_data::avg_price() const {
	if (units_sold)
		return revenue/units_sold;
	else
		return 0;
}

The function name, Sales_data::avg_price, uses the scope operator to say that we are defining the function named avg_price that is declared in the scope of the Sales_data class. Once the compiler sees the function name, the rest of the code is interpreted as being inside the scope of the class. Thus, when avg_price refers to revenue and units_sold, it is implicitly referring to the members of Sales_data.

As with nonmember functions, member functions may be overloaded so long as the functions differ by the number and/or types of parameters.

--
(findconstmemberfunction)
const member functions

Tao's summary:
1. const member function is like the following (note the const)
   string isbn() const { return bookNo; }
2. Purpose of const member function:
   non-const member function can not be called by a const object.
   const member function can be called by a const object.
   
Tao: this was the quesion asked by Teacher Ma's son.
Tao: copied all the content of this topic (const member functions) to the followings.

The other important part about the isbn function is the keyword const that follows the parameter list. The purpose of that const is to modify the type of the implicit this pointer.

By default, the type of this is a const pointer to the nonconst version of the class type. For example, by default, the type of this in a Sales_data member function is Sales_data *const. Although this is implicit, it follows the normal initialization rules, which means that (by default) we cannot bind this to a const object. This fact, in turn, means that we cannot call an ordinary member function on a const object.

If isbn were an ordinary function and if this were an ordinary pointer parameter, we would declare this as const Sales_data *const. After all, the body of isbn doesn‚Äôt change the object to which this points, so our function would be more flexible if this were a pointer to const.

However, this is implicit and does not appear in the parameter list. There is no place to indicate that this should be a pointer to const. The language resolves this problem by letting us put const after the parameter list of a member function. A const following the parameter list indicates that this is a pointer to const. Member functions that use const in this way are const member functions.

We can think of the body of isbn as if it were written as

// pseudo-code illustration of how the implicit this pointer is used
// this code is illegal: we may not explicitly define the this pointer ourselves
// note that this is a pointer to const because isbn is a const member
std::string Sales_data::isbn(const Sales_data *const this)
{ return this->isbn; }

The fact that this is a pointer to const means that const member functions cannot change the object on which they are called. Thus, isbn may read but not write to the data members of the objects on which it is called.

Note: Objects that are const, and references or pointers to const objects, may call only const member functions.

--
Defining a Function to Return ‚ÄúThis‚Äù Object

The combine function is intended to act like the compound assignment operator, +=. The object on which this function is called represents the left-hand operand of the assignment. The right-hand operand is passed as an explicit argument:

Sales_data& Sales_data::combine(const Sales_data &rhs) {
	units_sold += rhs.units_sold; // add the members of rhs into
	revenue += rhs.revenue; // the members of ''this'' object
	return *this; // return the object on which the function was called
}

When our transaction-processing program calls

total.combine(trans); // update the running total

the address of total is bound to the implicit this parameter and rhs is bound to trans. Thus, when combine executes

units_sold += rhs.units_sold; // add the members of rhs into

the effect is to add total.units_sold and trans.units_sold, storing the result back into total.units_sold.

The interesting part about this function is its return type and the return statement. Ordinarily, when we define a function that operates like a built-in operator, our function should mimic the behavior of that operator. The built-in assignment operators return their left-hand operand as an lvalue. To return an lvalue, our combine function must return a reference. Because the left-hand operand is a Sales_data object, the return type is Sales_data&.

As we‚Äôve seen, we do not need to use the implicit this pointer to access the members of the object on which a member function is executing. However, we do need to use this to access the object as a whole:

return *this; // return the object on which the function was called

Here the return statement dereferences this to obtain the object on which the function is executing. That is, for the call above, we return a reference to total.

--
Defining Nonmember Class-Related Functions

Class authors often define auxiliary functions, such as our add, read, and print functions. Although such functions define operations that are conceptually part of the interface of the class, they are not part of the class itself.

We define nonmember functions as we would any other function. As with any other function, we normally separate the declaration of the function from its definition. Functions that are conceptually part of a class, but not defined inside the class, are typically declared (but not defined) in the same header as the class itself. That way users need to include only one file to use any part of the interface.

The read and print functions do the same job as the code in xxx and not surprisingly, the bodies of our functions look a lot like the code presented there:

(findistream)
(findostream)

// input transactions contain ISBN, number of copies sold, and sales price
istream &read(istream &is, Sales_data &item) {
	double price = 0;
	is >> item.bookNo >> item.units_sold >> price;
	item.revenue = price * item.units_sold;
	return is;
}

ostream &print(ostream &os, const Sales_data &item) {
	os << item.isbn() << " " << item.units_sold << " "
	   << item.revenue << " " << item.avg_price();
	return os;
}

The read function reads data from the given stream into the given object. The print function prints the contents of the given object on the given stream.

However, there are two points worth noting about these functions. First, both read and write take a reference to their respective IO class types. The IO classes are types that cannot be copied, so we may only pass them by reference. Moreover, reading or writing to a stream changes that stream, so both functions take ordinary references, not references to const.

The second thing to note is that print does not print a newline. Ordinarily, functions that do output should do minimal formatting. That way user code can decide whether the newline is needed.

--
(findconstructor)              
constructor

Constructors have the same name as the class. Unlike other functions, constructors have no return type. Like other functions, constructors have a (possibly empty) parameter list and a (possibly empty) function body. A class can have multiple constructors. Like any other overloaded function, the constructors must differ from each other in the number or types of their parameters.

Unlike other member functions, constructors may not be declared as const. When we create a const object of a class type, the object does not assume its ‚Äúconstness‚Äù until after the constructor completes the object‚Äôs initialization. Thus, constructors can write to const objects during their construction.

The Synthesized Default Constructor

Our Sales_data class does not define any constructors, yet the programs we‚Äôve written that use Sales_data objects compile and run correctly:

Sales_data total;

We did not supply an initializer for these objects, so we know that they are default initialized. Classes control default initialization by defining a special constructor, known as the default constructor. The default constructor is one that takes no arguments (tao: remember).

As we‚Äôll, see the default constructor is special in various ways, one of which is that if our class does not explicitly define any constructors, the compiler will implicitly define the default constructor for us

The compiler-generated constructor is known as the synthesized default constructor. For most classes, this synthesized constructor initializes each data member of the class as follows:

‚Ä¢ If there is an in-class initializer, use it to initialize the member.
‚Ä¢ Otherwise, default-initialize the member.

Some Classes Cannot Rely on the Synthesized Default Constructor Only fairly simple classes‚Äîsuch as the current definition of Sales_data‚Äîcan rely on the synthesized default constructor. The most common reason that a class must define its own default constructor is that the compiler generates the default for us only if we do not define any other constructors for the class. If we define any constructors, the
class will not have a default constructor unless we define that constructor ourselves. The basis for this rule is that if a class requires control to initialize an object in one case, then the class is likely to require control in all cases.

Note: The compiler generates a default constructor automatically only if a class declares no constructors.

A second reason to define the default constructor is that for some classes, the synthesized default constructor does the wrong thing. Remember that objects of builtin or compound type (such as arrays and pointers) that are defined inside a block have undefined value when they are default initialized. The same rule applies to members of built-in type that are default initialized. Therefore, classes that
have members of built-in or compound type should ordinarily either initialize those members inside the class or define their own version of the default constructor. Otherwise, users could create objects with members that have undefined value.

A third reason that some classes must define their own default constructor is that sometimes the compiler is unable to synthesize one. For example, if a class has a member that has a class type, and that class doesn‚Äôt have a default constructor, then the compiler can‚Äôt initialize that member. For such classes, we must define our own version of the default constructor.

Constructor example:

struct Sales_data {
    // constructors added
    Sales_data() = default;
    Sales_data(const std::string &s): bookNo(s) { } 
    Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
    Sales_data(std::istream &);

    // other members as before
    std::string isbn() const { return bookNo; }
    Sales_data& combine(const Sales_data&);
    double avg_price() const;
    std::string bookNo;
    unsigned units_sold = 0; //Tao: in-class initializer, see below
    double revenue = 0.0; //Tao: in-class initializer, see below
};

Constructor examples from Leetcode default code:

struct Interval {
    int start;
    int end;
    Interval() : start(0), end(0) {}
    Interval(int s, int e) : start(s), end(e) {}
};

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
}; 

In the constructor, the code between the colon and the curly braces is a constructor initializer list, which specifies initial values for one or more data members of the object being created. The constructor initializer is a list of member names, each of which is followed by that member‚Äôs initial value in parentheses (or inside curly braces). Multiple member initializations are separated by commas.

When a member is omitted from the constructor initializer list, it is implicitly initialized using the same process as is used by the synthesized default constructor.

It is usually best for a constructor to use an in-class initializer if one exists and gives the member the correct value. On the other hand, if your compiler does not yet support in-class initializers, then every constructor should explicitly initialize every member of built-in type.

It is worth noting that both constructors have empty function bodies. The only work these constructors need to do is give the data members their values. If there is no further work, then the function body is empty.

Defining a Constructor outside the Class Body

Unlike our other constructors, the constructor that takes an istream does have work to do. Inside its function body, this constructor calls read to give the data members new values:

The function read below will read a transaction from is into this object 

Tao: read is a user defined function. read returns *this. I recorded some notes about functions that return *this somewhere below.

Sales_data::Sales_data(std::istream &is) {
    read(is, *this); 
}

Constructors have no return type, so this definition starts with the name of the function we are defining. As with any other member function, when we define a constructor outside of the class body, we must specify the class of which the
constructor is a member. Thus, Sales_data::Sales_data says that we‚Äôre defining the Sales_data member named Sales_data. This member is a constructor because it has the same name as its class.

In this constructor there is no constructor initializer list, although technically speaking, it would be more correct to say that the constructor initializer list is empty. Even though the constructor initializer list is empty, the members of this object are still initialized before the constructor body is executed.

Members that do not appear in the constructor initializer list are initialized by the corresponding in-class initializer (if there is one) or are default initialized.

Constructor Initializers Are Sometimes Required

We can often, but not always, ignore the distinction between whether a member is initialized or assigned. Members that are const or references must be initialized. Similarly, members that are of a class type that does not define a default constructor also must be initialized. For example:

class ConstRef {
public:
	ConstRef(int ii);

private:
	int i;
	const int ci;
	int &ri;
};

Like any other const object or reference, the members ci and ri must be initialized. As a result, omitting a constructor initializer for these members is an error.

By the time the body of the constructor begins executing, initialization is complete. Our only chance to initialize const or reference data members is in the constructor initializer.

The way to initialize them is:

ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) { }

We must use the constructor initializer list to provide values for members that are const, reference, or of a class type that does not have a default constructor.

Order of Member Initialization

Members are initialized in the order in which they appear in the class definition.  The order in which initializers appear in the constructor initializer list does not change the order of initialization.

The order of initialization often doesn‚Äôt matter. However, if one member is initialized in terms of another, then the order in which members are initialized is crucially important.

It is a good idea to write constructor initializers in the same order as the members are declared. Moreover, when possible, avoid using members to initialize other members.

--
Copy, Assignment, and Destruction

In addition to defining how objects of the class type are initialized, classes also control what happens when we copy, assign, or destroy objects of the class type. 

Objects are copied in several contexts, such as when we initialize a variable (tao: can be either =, or int a(b), confirmed) or when we pass or return an object by value. Objects are assigned when we use the assignment operator (tao: =, confirmed). Objects are destroyed when they cease to exist, such as when a local object is destroyed on exit from the block in which it was created. Objects stored in a vector (or an array) are
destroyed when that vector (or array) is destroyed.

If we do not define these operations, the compiler will synthesize them for us. Ordinarily, the versions that the compiler generates for us execute by copying, assigning, or destroying each member of the object. For example, in our bookstore program, when the compiler executes this assignment

total = trans; // process the next book

it executes as if we had written

// default assignment for Sales_data is equivalent to:
total.bookNo = trans.bookNo;
total.units_sold = trans.units_sold;
total.revenue = trans.revenue;

Some Classes Cannot Rely on the Synthesized Versions

--
Delegating Constructors

The new standard extends the use of constructor initializers to let us define so-called delegating constructors. A delegating constructor uses another constructor from its own class to perform its initialization. It is said to ‚Äúdelegate‚Äù some (or all) of its work to this other constructor.

Like any other constructor, a delegating constructor has a member initializer list and a function body. In a delegating constructor, the member initializer list has a single
entry that is the name of the class itself. Like other member initializers, the name of the class is followed by a parenthesized list of arguments. The argument list must
match another constructor in the class.

As an example, we‚Äôll rewrite the Sales_data class to use delegating constructors as follows:

class Sales_data {
public:
	// nondelegating constructor initializes members from corresponding arguments
	Sales_data(std::string s, unsigned cnt, double price):
	bookNo(s), units_sold(cnt), revenue(cnt*price) {
	}
	// remaining constructors all delegate to another constructor
	Sales_data(): Sales_data("", 0, 0) {}
	Sales_data(std::string s): Sales_data(s, 0,0) {}
	Sales_data(std::istream &is): Sales_data()
	{ read(is, *this); }
	// other members as before
};

In this version of Sales_data, all but one of the constructors delegate their work. The first constructor takes three arguments, uses those arguments to initialize the
data members, and does no further work. In this version of the class, we define the default constructor (the default constructor is one that takes no arguments) to use the three-argument constructor to do its initialization. It too
has no additional work, as indicated by the empty constructor body. The constructor that takes a string also delegates to the three-argument version.

The constructor that takes an istream& also delegates. It delegates to the default constructor, which in turn delegates to the three-argument constructor.

When a constructor delegates to another constructor, the constructor initializer list and function body of the delegated-to constructor are both executed.

--
The Role of the Default Constructor

The default constructor is used automatically whenever an object is default or value initialized. Default initialization happens

‚Ä¢ When we define nonstatic variables or arrays at block scope without initializers

‚Ä¢ When a class that itself has members of class type uses the synthesized default constructor

‚Ä¢ When members of class type are not explicitly initialized in a constructor initializer list  Value initialization happens

‚Ä¢ During array initialization when we provide fewer initializers than the size of the array 

‚Ä¢ When we define a local static object without an initializer 

‚Ä¢ When we explicitly request value initialization by writing an expressions of the form T() where T is the name of a type (

Classes must have a default constructor in order to be used in these contexts.

In practice, it is almost always right to provide a default constructor if other constructors are being defined.

--
(findfriend)                   
friend

A class can allow another class or function to access its nonpublic members by making that class or function a friend. A class makes a function its friend by including a declaration for that function preceded by the keyword friend. Friend declarations may appear only inside a class definition; they may appear anywhere in the class. Ordinarily it is a good idea to group friend declarations together at the beginning or end of the class definition.

Example:

class Sales_data {

// friend declarations for nonmember Sales_data operations added
// tao: the following friend lines have no identation in the book
friend Sales_data add(const Sales_data&, const Sales_data&);
friend std::istream &read(std::istream&, Sales_data&);
friend std::ostream &print(std::ostream&, const Sales_data&);

// other members and access specifiers as before

public:
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
    Sales_data(const std::string &s): bookNo(s) { }
    Sales_data(std::istream&);
    std::string isbn() const { return bookNo; }
    Sales_data &combine(const Sales_data&);

private:
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

// declarations for nonmember parts of the Sales_data interface

Sales_data add(const Sales_data&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);

A class can also make another class its friend or it can declare specific member functions of another (previously defined) class as friends. In addition, a friend function can be defined inside the class body. Such functions are implicitly inline.

As an example of class friendship, our Window_mgr class will have members that will need access to the internal data of the Screen objects it manages. To allow this access, Screen can designate Window_mgr as its friend: 

class Screen {
	// Window_mgr members can access the private parts of class Screen
	friend class Window_mgr;
	// ... rest of the Screen class
};

The member functions of a friend class can access all the members, including the nonpublic members, of the class granting friendship. 

It is important to understand that friendship is not transitive. That is, if class Window_mgr has its own friends, those friends have no special access to Screen.

Rather than making the entire Window_mgr class a friend, Screen can instead specify that only the clear member is allowed access. When we declare a member function to be a friend, we must specify the class of which that function is a member:

class Screen {
	// Window_mgr::clear must have been declared before class Screen
	friend void Window_mgr::clear(ScreenIndex);
	// ... rest of the Screen class
};

Making a member function a friend requires careful structuring of our programs to accommodate interdependencies among the declarations and definitions.

Overloaded Functions and Friendship

Although overloaded functions share a common name, they are still different functions. Therefore, a class must declare as a friend each function in a set of overloaded functions that it wishes to make a friend.

Classes and nonmember functions need not have been declared before they are used in a friend declaration. When a name first appears in a friend declaration, that name is implicitly assumed to be part of the surrounding scope.

Even if we define the function inside the class, we must still provide a declaration outside of the class itself to make that function visible. A declaration must exist even if we only call the friend from members of the friendship granting class.

It is important to understand that a friend declaration affects access but is not a declaration in an ordinary sense.

--
Type Member

In addition to defining data and function members, a class can define its own local names for types. Type names defined by a class are subject to the same access controls as any other member and may be either public or private:

Unlike ordinary members, members that define types must appear before they are used. As a result, type members usually appear at the beginning of the class.

Example:

class Screen {
public:
    typedef std::string::size_type pos;
private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};

We defined pos in the public part of Screen because we want users to use that name.

We can equivalently use a type alias:

class Screen {
public:
    // alternative way to declare a type member using a type alias
    using pos = std::string::size_type;
    // other members as before
};

--
Making Members inline

class Screen {
public:
    typedef std::string::size_type pos;
    Screen() = default; // needed because Screen has another constructor
    // cursor initialized to 0 by its in-class initializer
    Screen(pos ht, pos wd, char c): height(ht), width(wd),
    contents(ht * wd, c) { }

    // get the character at the cursor
    // implicitly inline
    char get() const {
      return contents[cursor]; 
    } 

    inline char get(pos ht, pos wd) const; // explicitly inline
    Screen &move(pos r, pos c); // can be made inline later

private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};

Classes often have small functions that can benefit from being inlined. As we‚Äôve seen, member functions defined inside the class are automatically inline. Thus, Screen‚Äôs constructors and the version of get that returns the character denoted by the cursor are inline by default.

We can explicitly declare a member function as inline as part of its declaration inside the class body. Alternatively, we can specify inline on the function definition that appears outside the class body:

inline // we can specify inline on the definition
Screen &Screen::move(pos r, pos c) {
    pos row = r * width; // compute the row location
    cursor = row + c ; // move cursor to the column within that row
    return *this; // return this object as an lvalue
}

//tao: checked and it has no inline specifier
char Screen::get(pos r, pos c) const { // declared as inline in the class 
    pos row = r * width; // compute row location
    return contents[row + c]; // return character at the given column
}

Although we are not required to do so, it is legal to specify inline on both the declaration and the definition. However, specifying inline only on the definition outside the class can make the class easier to read.

For the same reasons that we define inline functions in headers, inline member functions should be defined in the same header as the corresponding class definition.

--
mutable Data Members

A mutable data member is never const, even when it is a member of a const object. Accordingly, a const member function may change a mutable member.

class Screen {
public:
    void some_member() const;

private:
    mutable size_t access_ctr; // may change even in a const object
    // other members as before
};

void Screen::some_member() const {
    ++access_ctr; // keep a count of the calls to any member function
    // whatever other work this member needs to do
}

--
Initializers for Data Members of Class Type

class Window_mgr {
private:
    std::vector<Screen> screens{Screen(24, 80, ' ') };
};

As we‚Äôve seen, in-class initializers must use either the = form of initialization (which we used when we initialized the the data members of Screen) or the direct form of initialization using curly braces (as we do for screens).

--
Functions That Return *this

class Screen {
public:
    Screen &set(char);
    Screen &set(pos, pos, char);
    // other members as before
};

inline Screen &Screen::set(char c) {
    contents[cursor] = c; // set the new value at the current cursor location
    return *this; // return this object as an lvalue
}

inline Screen &Screen::set(pos r, pos col, char ch) {
    contents[r*width + col] = ch; // set specified location to given value
    return *this; // return this object as an lvalue
}

Our set members return a reference to the object on which
they are called. Functions that return a reference are lvalues, which means that they return the object itself, not a copy of the object. If we concatenate a sequence of these actions into a single expression:

// tao: the move function also returns *this
// move the cursor to a given position, and set that character

myScreen.move(4,0).set('#');

these operations will execute on the same object. 

--
Returning *this from a const Member Function

Tao: first search for "find constmemberfunction"

We‚Äôll add an operation, which we‚Äôll name display, to print the contents of the Screen. If display is a const member, then this (tao: the this pointer is returned by display) is a pointer to const and *this is a const object. if display returns a reference to const, we won‚Äôt be able to embed display into a series of actions (tao: see reason after the following code): 

Screen myScreen;
// if display returns a const reference, the call to set is an error
myScreen.display(cout).set('*');

we can only call const member functions on a const object. We can call either version on a nonconst object, but the nonconst version will be a better match.

In the following example, we‚Äôll define a private member named do_display to do the actual work of printing the Screen. Each of the display operations will call this function and then return the object on which it is executing:

class Screen {
public:
    // display overloaded on whether the object is const or not
    Screen &display(std::ostream &os) { 
        do_display(os); return *this; 
    }

    const Screen &display(std::ostream &os) const { 
        do_display(os); return *this; 
    }

private:
    // function to do the work of displaying a Screen
    void do_display(std::ostream &os) const {
        os << contents;
    }
    // other members as before
};

When we call display on an object, whether that object is const determines which version of display is called:

Screen myScreen(5,3);
const Screen blank(5, 3);
myScreen.set('#').display(cout); // calls non const version
blank.display(cout); // calls const version

--
Benefits of Encapsulation:

Encapsulation provides two important advantages:

- User code cannot inadvertently corrupt the state of an encapsulated object.

- The implementation of an encapsulated class can change over time without requiring changes in user-level code.

By defining data members as private, the class author is free to make changes in the data. If the implementation changes, only the class code needs to be examined to see what effect the change may have. User code needs to change only when the interface changes. If the data are public, then any code that used the old data members might be broken. It would be
necessary to locate and rewrite any code that relied on the old representation before the program could be used again.

Another advantage of making data members private is that the data are protected from mistakes that users might introduce. If there is a bug that corrupts an object‚Äôs state, the places to look for the bug are localized: Only code that is part of the implementation could be responsible for the error. The search for the mistake is limited, greatly easing the problems of
maintenance and program correctness.

--
Class type

Just as we can declare a function apart from its definition, we can also declare a class without defining it:

class Screen; // declaration of the Screen class

After a declaration and before a definition is seen, the type Screen is an incomplete type‚Äîit‚Äôs known that Screen is a class type but not known what members that type contains.

We can use an incomplete type in only limited ways: We can define pointers or references to such types, and we can declare (but not define) functions that use an incomplete type as a parameter or return type.

A class must be defined‚Äînot just declared‚Äîbefore we can write code that creates objects of that type. Otherwise, the compiler does not know how much storage such objects need. Similarly, the class must be defined before a reference or pointer is used
to access a member of the type.

A class cannot have data members of its own type. A class can have data members that are pointers or references to its own type.

--
Implicit Class-Type Conversions

The language defines several automatic conversions among the built-in types. We also noted that classes can define implicit conversions as well. Every constructor that can be called with a single argument defines an implicit conversion to a class type. Such constructors are sometimes referred to as converting constructors. A constructor that can be called with a single argument defines an implicit conversion from the constructor‚Äôs parameter type to the class type. The Sales_data constructors that take a string and that take an istream both define implicit conversions from those types to Sales_data. That is, we can use a
string or an istream where an object of type Sales_data is expected.

Suppressing Implicit Conversions Defined by Constructors
 
We can prevent the use of a constructor in a context that requires an implicit conversion by declaring the constructor as explicit:

class Sales_data {
public:
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p):
               bookNo(s), units_sold(n), revenue(p*n) { }
    explicit Sales_data(const std::string &s): bookNo(s) { }
    explicit Sales_data(std::istream&);
    // remaining members as before
};
 
Now, neither constructor can be used to implicitly create a Sales_data object. 

The explicit keyword is meaningful only on constructors that can be called with a single argument. Constructors that require more arguments are not used to perform an implicit conversion, so there is no need to designate such constructors as explicit. The explicit keyword is used only on the constructor declaration inside the class.

explicit Constructors Can Be Used Only for Direct Initialization

Sales_data item1 (null_book); // ok: direct initialization
Sales_data item2 = null_book; // error: cannot use the copy form of initialization with an explicit constructor

--
Aggregate Classes

An aggregate class gives users direct access to its members and has special initialization syntax. A class is an aggregate if
 
‚Ä¢ All of its data members are public
‚Ä¢ It does not define any constructors
‚Ä¢ It has no in-class initializers 
‚Ä¢ It has no base classes or virtual functions, which are class-related features that we‚Äôll cover in Chapter 15

For example, the following class is an aggregate:
 
struct Data {
    int ival;
    string s;
};
 
We can initialize the data members of an aggregate class by providing a braced list of member initializers:
 
// val1.ival = 0; val1.s = string("Anna")
Data val1 = { 0, "Anna" };
 
The initializers must appear in declaration order of the data members.

It is worth noting that there are three significant drawbacks to explicitly initializing (tao: in the above way) the members of an object of class type:

1. ... public ...
2. ... error-prone ...
3. ... member added or removed ...

--
Literal Classes

We noted that the parameters and return type of a constexpr
function must be literal types. In addition to the arithmetic types, references, and pointers, certain classes are also literal types. Unlike other classes, classes that are
literal types may have function members that are constexpr. Such members must meet all the requirements of a constexpr function. These member functions are implicitly const

An aggregate class whose data members are all of literal type is a literal class. A nonaggregate class, that meets the following restrictions, is also a literal class:
 
‚Ä¢ The data members all must have literal type.
‚Ä¢ The class must have at least one constexpr constructor.
‚Ä¢ If a data member has an in-class initializer, the initializer for a member of built-in type must be a constant expression, or if the member has class type, the initializer must use the member‚Äôs own constexpr constructor.
‚Ä¢ The class must use default definition for its destructor, which is the member that destroys objects of the class type.

constexpr Constructors
 
Although constructors can‚Äôt be const, constructors in a literal class can be constexpr functions. Indeed, a literal class must provide at least one constexpr constructor.
 
A constexpr constructor can be declared as = default (or as a
deleted function, which we cover later). Otherwise, a constexpr
constructor must meet the requirements of a constructor‚Äîmeaning it can have no return statement‚Äîand of a constexpr function‚Äîmeaning the only executable statement it can have is a return statement. As a result, the body of a constexpr constructor is typically empty. We define a constexpr constructor by preceding its declaration with the keyword constexpr:

class Debug {
public:
    constexpr Debug(bool b = true): hw(b), io(b), other(b) {
}
    constexpr Debug(bool h, bool i, bool o):
                                    hw(h), io(i), other(o) {
}
    constexpr bool any() { return hw || io || other; }
    void set_io(bool b) { io = b; }
    void set_hw(bool b) { hw = b; }
    void set_other(bool b) { hw = b; }
private:
    bool hw;    // hardware errors other than IO errors
    bool io;    // IO errors
    bool other; // other errors
};

 
A constexpr constructor must initialize every data member. The initializers must either use a constexpr constructor or be a constant expression.

A constexpr constructor is used to generate objects that are constexpr and for parameters or return types in constexpr functions.

--
(findstaticmember)
static Class Members

Classes sometimes need members that are associated with the class, rather than with individual objects of the class type. For example, a bank account class might need a data member to represent the current prime interest rate. In this case, we‚Äôd want to associate the rate with the class, not with each individual object. From an efficiency standpoint, there‚Äôd be no reason for each object to store the rate. Much more importantly, if the rate changes, we‚Äôd want each object to use the new value.

Declaring static Members
 
We say a member is associated with the class by adding the keyword static to its declaration. Like any other member, static members can be public or private. The type of a static data member can be const, reference, array, class type, and
so forth.

As an example, we‚Äôll define a class to represent an account record at a bank:
 
class Account {
public:
    void calculate() { amount += amount * interestRate; }
    static double rate() { return interestRate; }
    static void rate(double);
private:
    std::string owner;
    double amount;
    static double interestRate;
    static double initRate();
};
 
The static members of a class exist outside any object. Objects do not contain data associated with static data members. Thus, each Account object will contain two data members‚Äîowner and amount. There is only one interestRate object that will be shared by all the Account objects.

Similarly, static member functions are not bound to any object; they do not have a this pointer. As a result, static member functions may not be declared as const, and we may not refer to this in the body of a static member. This restriction applies both to explicit uses of this and to implicit uses of this by calling a nonstatic member.

Using a Class static Member
 
We can access a static member directly through the scope operator:
 
double r;
r = Account::rate(); // access a static member using the scope operator
 
Even though static members are not part of the objects of its class, we can use an object, reference, or pointer of the class type to access a static member:

Account ac1;
Account *ac2 = &ac1;
// equivalent ways to call the static member rate function
r = ac1.rate();      // through an Account object or reference
r = ac2->rate();     // through a pointer to an Account object
 
Member functions can use static members directly, without the scope operator.

Defining static Members
 
As with any other member function, we can define a static member function inside or outside of the class body. When we define a static member outside the class, we do not repeat the static keyword. The keyword appears only with the declaration
inside the class body:
  
void Account::rate(double newRate)
{
    interestRate = newRate;
}

Because static data members are not part of individual objects of the class type, they are not defined when we create objects of the class. As a result, they are not initialized by the class‚Äô constructors. Moreover, in general, we may not initialize a static member inside the class. Instead, we must define and initialize each static data member outside the class body. Like any other object, a static data member may be defined only once.

Like global objects, static data members are defined outside any
function. Hence, once they are defined, they continue to exist until the program completes.

// define and initialize a static class member
double Account::interestRate = initRate();

Note also that even though initRate is private, we can use this function to initialize interestRate.

static Members Can Be Used in Ways Ordinary Members Can‚Äôt
 
As we‚Äôve seen, static members exist independently of any other object. As a result, they can be used in ways that would be illegal for nonstatic data members. As one example, a static data member can have incomplete type. In particular, a static data member can have the same type as the class type of which
MX K√º it is a member. A nonstatic data member is restricted to being declared as a pointer or a reference to an object of its class:

class Bar {
public:
    // ...
private:
    static Bar mem1; // ok: static member can have incomplete type
    Bar *mem2;       // ok: pointer member can have incomplete type
    Bar mem3;        // error: data members must have complete type
};
 
Another difference between static and ordinary members is that we can use a static member as a default argument:
 
class Screen {
public:
    // bkground refers to the static member
    // declared later in the class definition
    Screen& clear(char = bkground);
private:
    static const char bkground;
};
 
A nonstatic data member may not be used as a default argument because its value is part of the object of which it is a member. Using a nonstatic data member as a default argument provides no object from which to obtain the member‚Äôs value and so is an error.

--
(finddestructor)               
destructor

This destructor notes records the file c_primer_5th_edition.pdf.pdf everything in section "13.1.3. The Destructor".

Destructors do whatever work is needed to free the resources used by an object and destroy the data members of the object.

The destructor is a member function with the name of the class prefixed by a tilde (~). It has no return value and takes no parameters. Because it takes no parameters, it cannot be overloaded. There is always only one destructor for a given class.

class Sales_data {
public:
    ~Sales_data() { } // destructor
    ...
};

What a Destructor Does

Just as a constructor has an initialization part and a function body, a destructor has a function body and a destruction part. In a constructor, members are initialized before the function body is executed, and members are initialized in the same order as they appear in the class. In a destructor, the function body is executed first and then the members are destroyed. Members are destroyed in reverse order from the order in which they were initialized.

The function body of a destructor does whatever operations the class designer wishes to have executed subsequent to the last use of an object. Typically, the destructor frees resources an object allocated during its lifetime.

In a destructor, there is nothing akin to the constructor initializer list to control how members are destroyed; the destruction part is implicit. What happens when a member is destroyed depends on the type of the member. Members of class type are destroyed by running the member‚Äôs own destructor. The built-in types do not have destructors, so nothing is done to destroy members of built-in type. 

The implicit destruction of a member of built-in pointer type does not delete the object to which that pointer points.

When a Destructor Is Called

The destructor is used automatically whenever an object of its type is destroyed:

‚Ä¢ Variables are destroyed when they go out of scope.
‚Ä¢ Members of an object are destroyed when the object of which they are a part is destroyed.
‚Ä¢ Elements in a container‚Äîwhether a library container or an array‚Äîare destroyed when the container is destroyed.
‚Ä¢ Dynamically allocated objects are destroyed when the delete operator is applied to a pointer to the object.
‚Ä¢ Temporary objects are destroyed at the end of the full expression in which the temporary was created.

Because destructors are run automatically, our programs can allocate resources and (usually) not worry about when those resources are released.

For example, the following fragment defines four Sales_data objects:

{ // new scope
    // p and p2 point to dynamically allocated objects
    Sales_data *p = new Sales_data; // p is a built-in pointer
    auto p2 = make_shared<Sales_data>(); // p2 is a shared_ptr
    Sales_data item(*p); // copy constructor copies *p into item
    vector<Sales_data> vec; // local object
    vec.push_back(*p2); // copies the object to which p2 points
    delete p; // destructor called on the object pointed to
    by p
} // exit local scope; destructor called on item, p2, and vec
// destroying p2 decrements its use count; if the count goes to 0, the object is freed
// destroying vec destroys the elements in vec

The destructor is not run when a reference or a pointer to an object goes out of scope.

The Synthesized Destructor

The compiler defines a synthesized destructor for any class that does not define its own destructor. As with the copy constructor and the copy-assignment operator, for some classes, the synthesized destructor is defined to disallow objects of the type
from being destroyed. Otherwise, the synthesized destructor has an empty function body.

For example, the synthesized Sales_data destructor is equivalent to:

class Sales_data {
public:
    // no work to do other than destroying the members, which happens automatically
    ~Sales_data() { }
    // other members as before
};

The members are automatically destroyed after the (empty) destructor body is run.

It is important to realize that the destructor body does not directly destroy the members themselves. Members are destroyed as part of the implicit destruction phase that follows the destructor body. A destructor body executes in addition to the
memberwise destruction that takes place as part of destroying an object.




















