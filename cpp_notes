stopa: search for stopa in this file.

==
findcbegin                   C begin
findscanfc                   scanf in C
findstringc                  Strin in C
findboolc                    Bool in C
findincludec                 Include in C
findheaderc                  Header in C
findmathc                    math.h in C
findifc                      if in C
findswitchc                  switch in C
findwhilec                   while in C
findforc                     for in C
findcontinuec                C has "continue" and "break"
findbreakc                   C has "continue" and "break"
findgotoc                    goto in C
findarrayc                   Array in C
findfunctionc                Function in C
findstaticc                  static & extern in C
findexternc                  static & extern in C
findpointerc                 Pointer in C
findargsc                    Command line argument C
findcommandlineargumentc     Command line argument C
findstructc                  Struct in C
findunionc                   Union in C
findtypedefc                 typedef in C
findmallocc                  Dynamic memory allocation and free in C
findmemoryc                  Dynamic memory allocation and free in C
findconstantc                Constant(ÂÆè) in C
findfilec                    File in C
findreadfromfilec            Read from file in C
findwritetofilec             Write to file in C

findcppbegin                 C++ begin
findcout                     cout
findcin                      cin 
findmath                     Math operators
findreadfromfile             Read from file and output to file
findwritetofile              Read from file and output to file
findio                       IO
findistream                  Example of using istream
findostream                  Example of using ostream
findcast                     Cast
findconvertdatatype          Convert data types
findfor                      Range for 
findrangefor                 Range for 
findstaticallytyped          Statically typed launage
finddatatype                 Data types
findbool                     bool
findtypedef                  typedef
findtypealias                Type alias
findinitialization            Intialization
finddeclaration              declaration vs definition
finddefinition               declaration vs definition
findmax                      max
findintmax                   INT_MAX
findmaxint                   INT_MAX
findintmin                   INT_MIN
findminint                   INT_MIN
findheader                   Headers
findreference                Reference
findpassbyvalue              Pass by value
findpassbyreference          Pass by reference
findpointer                  Pointer
findnull                     null pointer
findpointertoarray           Pointer to array & array of pointers
findreferencetoarray         Reference to array & array of references
findpointertofunction        Pointer to function
findreturnpointer            Return pointer from a function
findreturnreference          Return reference from a function
finddynamicmemory            Dynamic memory
findnew                      new operator
findconst                    Constant
findconstparameter           const in function parameter
findconstantexpression       Constant expression
findsleep                    Sleep
findescape                   Escape sequence
findstring                   string
findsubstring                Substring (get and find substring)
findsplit                    split a string
findfind                     find the position of a substring in a string
findtrim                     trim
finderase                    erase
findargs                     Command line argument 
findcommandlineargument      Command line argument 
findvector                   vector
findsortvector               Sort a vector
findunorderedcontainers      Unordered associative containers
findunorderedset             unordered_set
findset                      set
findunorderedmap             unordered_map
findmap                      map
findstack                    stack
findqueue                    queue
findpriorityqueue            priority_queue
finddeque                    deque
finddequeue                  deque
finditerator                 iterator
findarray                    array
findand                      AND operator
findoperator                 operators
findincrement                ++ and -- operators
finddecrement                ++ and -- operators
find++                       ++ and -- operators
find--                       ++ and -- operators
findsizeof                   sizeof
commaoperator                Comma operator
findif                       if 
findswitch                   switch
findwhile                    while
findfor                      for
findbreak                    break
findcontinue                 continue
findgoto                     goto
findexception                Exception
findfunction                 function
findreturn                   return
findstatic                   Static variables
findoverload                 Overloaded Functions
findinlinefunctions          Inline Functions
findconstexprfunctions       constexpr Functions
findassert                   assert
findndebug                   NDEBUG
findstruct                   struct
findclass                    class
findpublic                   public
findprivate                  private
findmemberfunction           member function
findconstmemberfunction      const member functions
findconstructor              constructor
findfriend                   friend
findstaticmember             static Class Members
finddestructor               destructor

=============
(findcbegin)
C begins

//Sample C program, printf example:

#include<stdio.h>

void main() {
	int i, sum = 0;	
	for(i = 1; i <= 100; i++) 
		sum = sum + i;	
	printf("sum = %d\n", sum);		
}

printf("%d, %d", a, b + c);

Format:
d: int
f: float
e,E: exponential
c: single character
s: string

==
(findscanfc)
scanf in C:

scanf is also in stdio.h

scanf("%d, %d, %d", &x, &y, &z); <- Input should be deliminated by ,
scanf("%d%d%d", &x, &y, &z); <- Input should be deliminated by any number of white spaces
s = max(x, y, z);
printf("max = %d\n", s);

Format is the same as printf

==
(finddatatypec)
Data types in C

type   number of bytes
char       1


==
(findstringc)
No string type in C:

There is no String variable type in C, but there is String constant type in C (eg, "abc").

The length of "ab" is 3, because it is stored as "ab\0"

string and char array:

char a[15];
char a[5] = {"BOY"}; 
char a[5] = "BOY";
char a[] = {"string!"};
char a[] = "string";
char a[4][8] = {"ZHANG", "ZHONG", "HUANG", "LIANG"};

char *hostname = "localhost";

//a is a string:
scanf("%s", a);
printf("%s\n", a);

The following string functions are in <string.h>:

strcat(s1, s2):  Catenate s1 and s2, return the address of the first element of the new char array. s1 can not be a string constant.

strcpy(s1, s2): Copy s2 into s1. s1 can not be a string constant.

strcmp(s1, s2): Compare two strings. Note that "s1 == s2" is wrong. Should use "strcmp(s1, s2) == 0".

strlen(s): Return the length of s, excluding the "\0" at end.

strlwr(s): Replace the uppercase chars in s to lowercase.

strupr(s): Replace the lowercase chars in s to uppercase.

==
(findboolc)
There is no bool type in C, it uses 1 to represent true, 0 to represent false.

==
(findincludec)
(findheaderc)
(findmathc)
Include in C
Headers in C
math.h in C

stdio.h, math.h, string.h:

math.h has the following functions:

cos(0.2), exp(0.2), fabs(0.2), log(0.2), log10(0.2), 
pow(0.2, 3.0) <- 0.2^3.0, 
sin(0.2), sqrt(0.2), tan(0.2)

--
When to use header files: when many programs use some common constants, data, etc, can put them into .h files.

Difference between the following two:
#include <xxx.h>
#include "xxx.h"

The difference is that: 
If use <xxx.h>, then the system will only search for the header file in the designated directory for header files (the include directory). For the header files provided by C, it saves searching time to use this way.
If use "xxx.h", then the system will first search for the header file in the current directory, then in the designated directory for header files (the include directory).

==
(findifc)
if in C

if(a < b) a = b;

if(...) {
	...
} else {
	...
}

--
string finalgrade = (grade < 60) ? "fail" : "pass";

==
(findswitchc)
Switch in C

switch(grade) {
	case 'A': printf("Excellent\n");
	case 'B': printf("Good\n");
	case 'C': printf("Pass\n");
	case 'D': printf("Fail\n");
	default: printf("Invalid input.\n");
}

==
(findwhilec)
While in C

while(x > 0) printf("Helo\n");

--
do {
	i--;
	printf("a");
} while(i >= 0);

==
(findforc)
for in C

for(i = 1; i <= 100; i++) 
	sum = sum + i;	

==
(findcontinuec)
(findbreakc)

C has "continue" and "break"

==
(findgotoc)
goto in C

s = 0.0;
goto cal;
s = 0.5 * 2;
cal: printf("a");

==
(findarrayc)
Array in C

int a[10];
a[0] = 1;
int x[3] = {1, 2, 3};
int x[] = {1, 2, 3}; //Can omit the length

int x[3] = {0, 0, 0}; 
can be written as 
int x[3] = {0};

double s[5][5]

int x[2][4] = {{1,2,3,4}, {6,7,8,9}};
is equivalent as
int x[2][4] = {1,2,3,4,5,6,7,8,9};

Array name is the address of the 0-th element
These two expressions are equivalent: a, &a[0]
These two expressions are equivalent: a[i], *(a+i)

2-D array name is the address of the 0-th row.

==
(findfunctionc)
Function in C

int max(int a, int b) {
    if(a > b) return a;
    else return b;
}

If no returned value, use void. 
If no parameters, use ():

void func() {
    printf("a");
}

main function usually has no parameters, unlike Java.

Function parameters are often passed by value. But for array names, it passes its address, so it is passed by reference.

For array as parameter, can define an empty array (tao: in the parameter parenthesis). If need to operate on its elemets, can use another parameter to denote its length:

void sort_string(char str[], int n) {
    ...
}

// Call the above function in another functin:
char str[30]=‚ÄùABCDEFGHIJKLMNOPQRSTUVWXYZ‚Äù;
int i=26;
sort_string(str, i);

==
(findstaticc)
(findexternc)
static & extern in C

Static variable: 
Static variable in a function will have their values kept even after this function is been called.
Exmaple: 
static int i;

Extern variable: 
Can be used in two cases:
1. In a file, can define a variable as extern and use this variable before its definition. Before using it, need to declare it using "extern". 
2. In a file, can define a variable as extern and use this variable in another file. Before using it, need to declare it using "extern". 
Example: none.

Static function:
Can only be used in the same file.
Example: none.

Extern function:
Can be used in other files. If a function definition has no keyword "extern", then it is still extern by default. Before using extern function in another file, need to declare it using "extern". 
Example: none.

==
(findpointerc)
Pointer in C

int *p = &i;
// Pointer p equals the address of i
// Then *p is i, *p = 100 is equivalent to i = 100

If a pointer = 0, it means it does not point to anything.

Print the address of a variable:
printf("%p\n",(void*)&a);

Pointers must be initialized.

int a[20], *p;
p = &a[0]; // p points to the address of a[0]
p += 2; // p points to the address of a[2]

a = &a[1];
b = &a[3];
Then (b - a) equals 2

int* p[3]: p is an array of pointers (can be easily understood)
int (*p)[3]: p is a pointer which points to an array (because the above is array of pointers, so here it is a pointer which...)

Pointer to functions can be rememebered in the save way as above:
int* f(int x); //f is a function which returns pointer
int (*f)(int x); //f is a pointer which points to a function

int func(int x);
int (*f)(int x);
f = func; <- func has no (), no parameters. Function name is the address of the entrance of function.
(*f) is equivalent as func, eg (*f)(x)

Array name as function parameter (in a similar way as Java):

// Tao remembers online says this way passes by copying the array and this way should be avoided, needs to confirm
void sort(int x[], int n) {
	...
}

void main() {
	int a[10];
	...
	sort(a, 10);
}

A pointer to a string is the address of the first character in the string.

==
(findargsc)
(findcommandlineargumentc)
Convert command line argument to string in C

#include <iostream>
#include <string>
#include <vector>

int main(int argc, char *argv[]) // Don't forget first integral argument 'argc', which is count of arguments plus the current exec file.
{
  std::string current_exec_name = argv[0]; // Name of the current exec program
  std::string first_arge;
  std::vector<std::string> all_args;

  if (argc > 1) {
    first_arge = argv[1];
    all_args.assign(argv + 1, argv + argc);
  }
}


==
(findstructc)
Struct in C

From online:
Should struct definitions go in .h or .c file?
Private structures for that file should go in the .c file, 
with a declaration in the .h file if they are used by any functions in the .h .
Public structures should go in the .h file.

struct date {
    int year;
    int month;
    int day;
}; // Don't forget the ;

struct date d;

The above two statements can be written together:

struct date {
    int year;
    int month;
    int day;
} d;

Initialize struct:

struct date {
    int year;
    int month;
    int day;
} d = {1977, 11, 14};

int y = date.year;

struct array (every element is a struct type):

struct date d[3];
struct date d[3] = {{1977, 11, 14}, {1980, 3, 5};
struct date d[] = {{1977, 11, 14}, {1980, 3, 5}; //Can omit the length

A pointer to a struct points to the initial address of the struct.

struct date d;
struct date *p;
p = &d;
(*p).year
p->year

Linked list node (note the next pointer):

struct student {
    char name[8];
    float score;
    struct student *next;
}

==
(findunionc)
Union in C

union utag {
    int i;
    float f;
    char c;
};

The definition of union is the same as struct.
The reference to memebers of union (including pointers) is also the same as struct.

The difference between struct and union:
The members in a struct have their own memory units. The size of a struct is the sum of the size of its members.
The members in a union share the same memory unit. The size of a union is the size of its largest member. Tao's understanding is that a union can be different types (any of its member type) at different times. Just like Á≤æÁ•ûÂàÜË£ÇÁóá.

Can only initialize the first member of a union, can not initialize all members:

Correct:

union utag {
    int i;
    float f;
    char c;
} u1 = {100};

Wrong:

union utag u2 = {100, 31.6, 'a'};

==
(findtypedefc)
typedef in C

typedef defines new type which is equivalent as original types, like an alias:

typedef int INTEGER;
INTEGER x, y;

typedef char *POINTER;
POINTER p;
//Equivalent as: char *p;

typedef struct {
    int year;
    int month;
    int day;
} DATE;

DATE birthday;

//Equivalent as:

struct {
    int year;
    int month;
    int day;
} birthday;

typedef char STRING[50];
STRING s1, s2;
//Equivalent to: char s1[50], s2[50];

Good:
Steps to use typedef:
1. Write down the ordinary definition of a variale, like: char str[50];
2. Replace the variable name with new type name, like replace "str" with "STRING" -> char STRING[50];
3. Add "typedef" in front, like: typedef char STRING[50];
4. Then can use the new type name to define variables, like: STRING s1, s2;


==
(findmallocc)
(findmemoryc)
Dynamic memory allocation and free in C

#include <stdlib.h>

int *p;
p = (int *) malloc(sizeof(int)); //Allocates a memory of size int type, p points to this memory

struct date {
    int year;
    int month;
    int day;
} *q;

q = (struct date *) malloc(sizeof(struct date));

free(p); //Free the memory pointed by p

==
(findconstantc)
Constant in C
ÂÆè in C

#define PI 3.14
int a = PI;

==
(findfilec)
(findreadfromfilec)
(findwritetofilec)
File in C
Read from file in C
Write to file in C

All the following should include:
#include "sdio.h"

//Open a file:
FILE *fp;
fp = fopen("file1", "r");

//Close a file:
fclose(fp); //Now fp no longer points to this file

//Close all files:
fcloseall();

//Get a character from file:
ch = fgetc(fp);

//Returns whether fp points to the end of file:
feof(fp);

//Write a character to file at location pointed by fp:
fputc("a", fp);
fputc(c, stdout)//Outputs character c to terminal (screen), no "" around c.

//Read a string:
fgets()

//Write a string:
fputs()

//Read and print to file
fscanf(), fprintf()

//Read binary files:
fread(), fwrite()

//Foce the pointer fp to point to the beginning of file:
rewind(fp);

//Set the pointer position
fseek(file-pinter, offset, start-point)

*** C all recorded ***

====
(findcppbegin)
C++ begins

Common suffix for C++ programs: 
.cc .cpp .C .cxx .cp <- tao: .cpp is the most common I have seen online

Compile:
g++ -o file_name file_name.cc

Using C++ 11, in my Thinkpad (recommended to always compile in this way in my Thinkpad):
g++ -std=c++0x -o file_name file_name.cc

When writing leetcode, I can still compile using -std=c++11 in my Thinkpad.

Using C++ 11, in Mac:
g++ -std=c++11 -o file_name file_name.cc

Simpler way to compile and run:
g++ foo.c
./a.out

==
Sample C++ program:

#include<iostream>
using namespace std;
//using std::cout; <- can also use this

int main() {
    double a = 2.6;
    cout << a << endl;
    return 0;
}

Note that the main() function should be outside any class, which is opposite to Java.

==
Google C++ Style Guide:

https://google.github.io/styleguide/cppguide.html

==
Google's naming conventions:

(https://google.github.io/styleguide/cppguide.html#General_Naming_Rules)

Naming
The most important consistency rules are those that govern naming. The style of a name immediately informs us what sort of thing the named entity is: a type, a variable, a function, a constant, a macro, etc., without requiring us to search for the declaration of that entity. The pattern-matching engine in our brains relies a great deal on these naming rules.

Naming rules are pretty arbitrary, but we feel that consistency is more important than individual preferences in this area, so regardless of whether you find them sensible or not, the rules are the rules.

General Naming Rules
Names should be descriptive; avoid abbreviation.

Give as descriptive a name as possible, within reason. Do not worry about saving horizontal space as it is far more important to make your code immediately understandable by a new reader. Do not use abbreviations that are ambiguous or unfamiliar to readers outside your project, and do not abbreviate by deleting letters within a word. Abbreviations that would be familiar to someone outside your project with relevant domain knowledge are OK. As a rule of thumb, an abbreviation is probably OK if it's listed in Wikipedia.

int price_count_reader;    // No abbreviation.
int num_errors;            // "num" is a widespread convention.
int num_dns_connections;   // Most people know what "DNS" stands for.
int lstm_size;             // "LSTM" is a common machine learning abbreviation.
int n;                     // Meaningless.
int nerr;                  // Ambiguous abbreviation.
int n_comp_conns;          // Ambiguous abbreviation.
int wgc_connections;       // Only your group knows what this stands for.
int pc_reader;             // Lots of things can be abbreviated "pc".
int cstmr_id;              // Deletes internal letters.
FooBarRequestInfo fbri;    // Not even a word.
Note that certain universally-known abbreviations are OK, such as i for an iteration variable and T for a template parameter.

For some symbols, this style guide recommends names to start with a capital letter and to have a capital letter for each new word (a.k.a. "Camel Case" or "Pascal case"). When abbreviations or acronyms appear in such names, prefer to capitalize the abbreviations or acronyms as single words (i.e StartRpc(), not StartRPC()).

Template parameters should follow the naming style for their category: type template parameters should follow the rules for type names, and non-type template parameters should follow the rules for variable names.

File Names

Filenames should be all lowercase and can include underscores (_) or dashes (-). Follow the convention that your project uses. If there is no consistent local pattern to follow, prefer "_".

Examples of acceptable file names:

my_useful_class.cc
my-useful-class.cc
myusefulclass.cc
myusefulclass_test.cc // _unittest and _regtest are deprecated.

C++ files should end in .cc and header files should end in .h. Files that rely on being textually included at specific points should end in .inc (see also the section on self-contained headers).

Do not use filenames that already exist in /usr/include, such as db.h.

In general, make your filenames very specific. For example, use http_server_logs.h rather than logs.h. A very common case is to have a pair of files called, e.g., foo_bar.h and foo_bar.cc, defining a class called FooBar.

Type Names

Type names start with a capital letter and have a capital letter for each new word, with no underscores: MyExcitingClass, MyExcitingEnum.

The names of all types ‚Äî classes, structs, type aliases, enums, and type template parameters ‚Äî have the same naming convention. Type names should start with a capital letter and have a capital letter for each new word. No underscores. For example:

// classes and structs
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedefs
typedef hash_map<UrlTableProperties *, string> PropertiesMap;

// using aliases
using PropertiesMap = hash_map<UrlTableProperties *, string>;

// enums
enum UrlTableErrors { ...

Variable Names

The names of variables (including function parameters) and data members are all lowercase, with underscores between words. Data members of classes (but not structs) additionally have trailing underscores. For instance: a_local_variable, a_struct_data_member, a_class_data_member_.

Common Variable names

For example:

string table_name;  // OK - uses underscore.
string tablename;   // OK - all lowercase.
string tableName;   // Bad - mixed case.

Class Data Members

Data members of classes, both static and non-static, are named like ordinary nonmember variables, but with a trailing underscore.

class TableInfo {
  ...
 private:
  string table_name_;  // OK - underscore at end.
  string tablename_;   // OK.
  static Pool<TableInfo>* pool_;  // OK.
};

Struct Data Members

Data members of structs, both static and non-static, are named like ordinary nonmember variables. They do not have the trailing underscores that data members in classes have.

struct UrlTableProperties {
  string name;
  int num_entries;
  static Pool<UrlTableProperties>* pool;
};
See Structs vs. Classes for a discussion of when to use a struct versus a class.

Constant Names

Variables declared constexpr or const, and whose value is fixed for the duration of the program, are named with a leading "k" followed by mixed case. Underscores can be used as separators in the rare cases where capitalization cannot be used for separation. For example:

const int kDaysInAWeek = 7;
const int kAndroid8_0_0 = 24;  // Android 8.0.0
All such variables with static storage duration (i.e. statics and globals, see Storage Duration for details) should be named this way. This convention is optional for variables of other storage classes, e.g. automatic variables, otherwise the usual variable naming rules apply.

Function Names

Regular functions have mixed case; accessors and mutators may be named like variables.

Ordinarily, functions should start with a capital letter and have a capital letter for each new word.

AddTableEntry()
DeleteUrl()
OpenFileOrDie()

(The same naming rule applies to class- and namespace-scope constants that are exposed as part of an API and that are intended to look like functions, because the fact that they're objects rather than functions is an unimportant implementation detail.)

Accessors and mutators (get and set functions) may be named like variables. These often correspond to actual member variables, but this is not required. For example, int count() and void set_count(int count).

==
(finddatatype)                 
Data types

Type     Size
bool     NA
char     8 bits
int      16 bits
long     32 bits
float    6 significant digits
double   10 siginifcant digits

8 bits = 1 byte
(Remember: "bit" is shorter than "byte")

The arithmetic types are divided into two categories: integral types (which include character and boolean types, tao: should also include int) and floating-point types.

Tao: integral types means: int, character, boolean types. The concept of integral types will be used later.

--
Printing numbers in binary format:

#include <bitset>
using namespace std;
int v = 5;
cout << bitset<32>(v); //32 means outputs 32 bits

--
(findbool)
bool:

bool test = false; // The words true and false are literals of type bool

bool b = 42;
int i = b; // i has value 1

When we assign one non-bool types to a bool, the result is false if the value is 0, and true otherwise.

When we use a bool in an arithmetic expression, its value always converts to either 0 or 1.

The word nullptr is a pointer literal.

It is usually a bad idea to use the boolean literals true and false as operands in a comparison. For example:
if (val == true) { /* ...   */ }

Better way:
if (val)  { /*  ...  */ }

--
(findcast)
(findconvertdatatype)
Cast
Convert data types

//string -> int
#include <string>  
string str1 = "45";
int myint1 = stoi(str1); // myint1 = 45

//string -> double
string stest = "0.21";
double dtest = stod(stest);

//double -> string
string pi = std::to_string(3.1415926); // pi = "3.1415926" 

//int -> string
int a = std::to_string(28); // a = "28"

//int -> double
int a = 2;
double b = (double) a;

//double -> int
double a = 3.0;
double b = (int) a;

//char -> string
//constructor string s(int n, char x): Create a string of size n and fill the string with character x.
string s(1, 'a'); //s = "a"

--
cast:

The above "(int) a" is the old-style C++ casts. New styles are followings.

Although necessary at times, casts are inherently dangerous constructs.

Named Casts

A named cast has the following form:
cast-name<type>(expression);

where type is the target type of the conversion, and expression is the value to be cast. The cast-name may be one of static_cast, dynamic_cast, const_cast, and reinterpret_cast.

Old-style casts are less visible than are named casts. Because they are easily overlooked, it is more difficult to track down a rogue(ÊµÅÊ∞ì) cast.

==
(findtypedef)
typedef

typedef double wages; // wages is a synonym for double

--
(findtypealias)
Type alias

using pos = std::string::size_type; // pos is a synonym for std::string::size_type

==
(findmax)
max

#include <algorithm>  

max(1, 2)

==
(findintmax)
(findmaxint)
(findintmin)
(findminint)
INT_MAX and INT_MIN

From geeksforgeeks:

Most of the times, in competitive programming, there is a need to assign the variable, the maximum or minimum value that data type can hold, but remembering such a large and precise number comes out to be a difficult job. Therefore, C++ has certain macros to represent these numbers, so that these can be directly assigned to the variable without actually typing the whole number.

INT_MAX is a macro that specifies that an integer variable cannot store any value beyond this limit.
INT_MIN specifies that an integer variable cannot store any value below this limit.

Values of INT_MAX and INT_MIN may vary from compiler to compiler. Following are typical values in a compiler where integers are stored using 32 bits.

Value of INT_MAX is +2147483647.
Value of INT_MIN is -2147483648.

// C++ program to print values of INT_MAX 
// and INT_MIN 

#include <climits> 

int main() { 
   printf("%d\n", INT_MAX); //Output: 2147483647, which equals 2^31 ‚àí 1
   printf("%d", INT_MIN); //Output: -2147483648, which equals ‚àí2^31
   return 0; 
} 


==
(findinitialization)
Intialization:

//The followings are all equivalent:
int a = 0;
int a = {0};
int a{0};
int a(0);

If we do not initialize a string, then it is an empty string. (Seems different from Java).

We recommend initializing every object of built-in type.

--
Two forms of initialization

Sales_data item1 (null_book); // direct initialization
Sales_data item2 = null_book; // the copy form of initialization 

It is tempting to think of initialization as a form of assignment, but initialization and assignment are different operations in C++. 

Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object‚Äôs current value and replaces that value with a new one.

--
Default Initialization

When we define a variable without an initializer, the variable is default initialized. Such variables are given the ‚Äúdefault‚Äù value. What that default value is depends on the type of the variable and may also depend on where the variable is defined.

The value of an object of built-in type that is not explicitly initialized depends on where it is defined. Variables defined outside any function body are initialized to zero. With one exception, which we cover later, variables of built-in type defined inside a function are uninitialized. The value of an uninitialized variable of built-in type is undefined. It is an error to copy or otherwise try to access the value of a variable whose value is undefined.

Each class controls how we initialize objects of that class type. In particular, it is up to the class whether we can define objects of that type without an initializer. If we can, the class determines what value the resulting object will have.

Most classes let us define objects without explicit initializers. Such classes supply an appropriate default value for us. For example, as we‚Äôve just seen, the library string class says that if we do not supply an initializer, then the resulting string is the empty string:

std::string empty; // empty implicitly initialized to the empty string
Sales_item item; // default-initialized Sales_item object

Some classes require that every object be explicitly initialized. The compiler will complain if we try to create an object of such a class with no initializer.

Tao's practice:

If we create an array of built-in type inside a function using new as below (remember we must use new if we want to return the array or its elments, recored in this note), the values of the elements are also undefined:

bool *res = new bool[n];

//Note that the following initialization to res[i] is necessary, otherwise the values of res[i] is not defined (values are different in my computer and Leetcode OJ)
for(int i = 1; i <= n; ++i) res[i] = false;

For the above, I later used vector:
vector<bool> res(n, false);

==
(findheader)
Headers

Need to include when use:

#include <iostream>
#include <string>
#include <vector>
#include <iterator>
cctype //islower(c), tolower(c)
container header
container adaptor
iterator
algorithm
tuple
bind

using namespace std;

--
#include <iostream>
#include "Sales_item.h"

Headers from the standard library are enclosed in <>
Headers that are not part of the library are enclosed in ""

The standard library headers typically have no suffix.
Header files that we write usually have a suffix of .h

Headers (usually) contain entities (such as class definitions and const variables) that can be defined only once in any given file.

Code inside headers ordinarily should not use "using declarations". The reason is that the contents of a header are copied into the including program‚Äôs text. If a header has a using declaration, then every program that includes that header gets that same using declaration. As a result, a program that didn‚Äôt intend to use the specified library name might encounter unexpected name conflicts.

In addition to facilities defined specifically for C++, the C++ library incorporates the C library. Headers in C have names of the form name .h. The C++ versions of these headers are named c name‚Äîthey remove the .h suffix and precede the name with the letter c. The c indicates that the header is part of the C library. Hence, cctype has the same contents as ctype.h, but in a form that is appropriate for C++ programs. In particular, the names defined in the cname headers are defined inside the std namespace, whereas those defined in the .h versions are not. Ordinarily, C++ programs should use the cname versions of headers and not the name .h versions.

--
preprocessor

The most common technique for making it safe to include a header multiple times relies on the preprocessor. The preprocessor is a program that runs before the compiler and changes the source text of our programs.

Our programs already rely on one preprocessor facility, #include. When the preprocessor sees a #include, it replaces the #include with the contents of the specified header.

C++ programs also use the preprocessor to define header guards. Header guards rely on preprocessor variables. Preprocessor variables have one of two possible states: defined or not defined. The #define directive takes a name and defines that name as a preprocessor variable. There are two other directives that test whether a given preprocessor variable has or has not been defined: #ifdef is true if the variable has been defined, and #ifndef is true if the variable has not been defined. 

If the test is true, then everything following the #ifdef or #ifndef is processed up to the matching #endif.

tao: the following is the .h file which defines Sales_data. The benefit of the preprocessor in this .h file is that this .h file can be included in multiple files, and there will be no conflict, because SALES_DATA_H will be defined in the first file that includes this .h file, other files will have ifndef = false and will not execute this .h file.

#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
#endif

Preprocessor variables, including names of header guards, must be unique throughout the program. To avoid name clashes with other entities in our programs, preprocessor variables usually are written in all uppercase.

Headers should have guards, even if they aren‚Äôt (yet) included by another header. Header guards are trivial to write, and by habitually defining them you don‚Äôt need to decide whether they are needed.

--
How to include header in another folder (from online):

Just inlcude the path as well:

#include "../../Header/class1.h"

--
Whether to compile header files (from online):

Do I need to compile the header files (.h) in a C program?
No, there's no reason to "compile" these header files independently. 
Header files are intended to be included into implementation files, 
not fed to the compiler as independent translation units.

--
How to compile the files in the following example:

Suppose the files are organized in the following folders:

code
  - main.cpp

utils  
  - Time.h
  - Time.cpp 

Then in folder code, type the followings (list all the other cpp files after main.cpp.):
g++ main.cpp ../utils/Time.cpp 

This makes a compiled file in the same folder as main.cpp: a.out

In file Time.cpp, in the implementation of the Time member functions, it can use the other Time members directly without adding class name, note that the Time class is defined in another file Time.h

--
Separate Header and Implementation Files (from online, tao changed the path in the include for illustration)

How to compile the following files? See above.

In this section, we demonstrate how to make class reusable by separating it into another files.

Header File
Class declarations are stored in a separate file. A file that contains a class declaration is called header file. The name of the class is usually the same as the name of the class, with a .h extension. For example, the Time class would be declared in the file Time .h.

#ifndef TIME_H
#define TIME_H

class Time
{
     private :
          int hour;
          int minute;
          int second;
     public :
          //with default value
          Time(const int h = 0, const int m  = 0, const int s = 0);
          //    setter function
          void setTime(const int h, const int m, const int s);
          // Print a description of object in " hh:mm:ss"
          void print() const;
          //compare two time object
          bool equals(const Time&);
};
 
#endif
 
Implementation File

The member function definitions for a class are stored in a separate .cpp file, which is called the class implementation file. The file usually has the same name as the class, with the .cpp extension. For example the Time class member functions would be defined in the file Time.cpp.

#include <iostream>
#include <iomanip>
#include "Time.h" <- tao: since Time.cpp is in the same folder as Time.h, so no need to include path
using namespace std;
 
Time :: Time(const int h, const int m, const int s) 
  : hour(h), minute (m), second(s)
{}
 
void Time :: setTime(const int h, const int m, const int s) 
{
     hour = h;
     minute = m;
     second = s;     
}       
 
void Time :: print() const
{
     cout << setw(2) << setfill('0') << hour << ":"
    << setw(2) << setfill('0') << minute << ":"
    << setw(2) << setfill('0') << second << "\n";   
 
}
 
bool Time :: equals(const Time &otherTime)
{
     if(hour == otherTime.hour 
          && minute == otherTime.minute 
          && second == otherTime.second)
          return true;
     else
          return false;
}
 
Client Code

client code, is the one that includes the main function. This file should be stored by the name main.cpp
 
#include <iostream>
using namespace std;
#include "../utils/Time.h" <- tao: since main.cpp is in a different folder from Time.h, so need to include path

int main()
{
     Time t1(10, 50, 59);
     t1.print();   // 10:50:59
     Time t2;
     t2.print(); // 06:39:09
     t2.setTime(6, 39, 9);
     t2.print();  // 06:39:09
   
     if(t1.equals(t2))
          cout << "Two objects are equal\n";
     else
          cout << "Two objects are not equal\n";    
  
     return 0;
}
The advanages of storing class definition in separate file are

1. The class is reusable

2. The clients of the class know what member functions the class provides, how to call them and what return types to expect

3. The clients do not know how the class's member functions are implemented.

--
Separate Compilation

As our programs get more complicated, we‚Äôll want to store the various parts of the program in separate files. For example, we might store the functions we wrote in one file and store code that uses these functions in other source files. To allow programs to be written in logical parts, C++ supports what is commonly known as separate compilation. Separate compilation lets us split our programs into several files, each of which can be compiled independently.

As an example, assume that the definition of our fact function is in a file named fact.cc and its declaration is in a header file named Chapter6.h. Our fact.cc file, like any file that uses these functions, will include the Chapter6.h header. We‚Äôll store a main function that calls fact in a second file named factMain.cc. We might compile these files as follows:

g++ factMain.cc fact.cc -o main // generates main

If we have changed only one of our source files, we‚Äôd like to recompile only the file that actually changed. Most compilers provide a way to separately compile each file. This process usually yields a file with the .o file extension, indicating that the file contains object code.
 
The compiler lets us link object files together to form an executable. On the system we use, we would separately compile our program as follows:
 
g++ -c factMain.cc     // generates factMain.o
g++ -c fact.cc         // generates fact.o
g++ factMain.o fact.o -o main // generates main

==
(findcout)
(findcin)
cout, cin 

remember: t looks like <, n can be put into >

The left-hand operand of << must be an ostream object. The operator writes the given value on the given ostream. The result of the output operator is its left-hand operand (the ostream). The following example uses << twice, because << returns ostream.

Writing endl has the effect of ending the current line and flushing the buffer asociated with that device. Flusing the buffer ensures that all the output the program has generated so far is actually written to the output stream, rather than sitting in memory waiting to be written.

Buffer: a region of storage used to hold data. IO facilities often store input (or output) in a buffer and read or write the buffer independently from actions in the program. Output buffers can be explicitly flushed to force the buffer to be written. By default, reading cin flushes cout; cout is also flushed when the program ends normally.

//cout:
#include<iostream>
using namespace std;
//using std::cout; <- can also use this

int main() {
    double a = 2.6;
    cout << a << endl;
    return 0;
}

//cin:
#include<iostream>
using namespace std;

int main() {
    int a = 0;
    cin >> a; //tao: read input into a
    return 0;
}

while(cin >> value) sum += value;

End of file: ctrl+d

// s is a string
os << s //Writes s onto output stream os. Reurns os.
is >> s //Reads whitespace-separated string from is into s. Returns is. 

getline(is, s) //Reads a line of input from is into s. Returns is.

==
(findreadfromfile)
(findwritetofile)
Read from file and output to file

The following function reads all contents in the input file, and write them into output file. Note that if in my Thinkpad, it needs to be compiled in C++ 11.

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
using namespace std;

// g++ -std=c++0x -o convert convert.cc
void process_one_file(string input_file_name, string output_file) { 
    ifstream input_file(input_file_name);
    ofstream output_file(output_file_name);

    string line;

    while(getline(input_file, line)) {
        output_file << line << endl;
    }

    output_file.close();
    input_file.close();
}

==
(findio)
IO

The C++ language does not deal directly with input and output. Instead, IO is handled by a family of types defined in the standard library.

Our programs have already used many IO library facilities:
‚Ä¢ istream (input stream) type, which provides input operations
‚Ä¢ ostream (output stream) type, which provides output operations
‚Ä¢ cin, an istream object that reads the standard input
‚Ä¢ cout, an ostream object that writes to the standard output
‚Ä¢ cerr, an ostream object, typically used for program error messages, that
writes to the standard error
‚Ä¢ The >> operator, which is used to read input from an istream object
‚Ä¢ The << operator, which is used to write output to an ostream object
‚Ä¢ The getline function, which reads a line of input from a given istream into a given string

To support these different kinds of IO processing, the library defines a collection of IO types in addition to the istream and ostream types that we have already used.

These types, which are listed in Table 8.1, are defined in three separate headers: iostream defines the basic types used to read from and write to a stream, fstream defines the types used to read and write named files, and sstream defines the types used to read and write in-memory strings.

The library lets us ignore the differences among these different kinds of streams by using inheritance. Ordinarily, we can use an object of an inherited class as if it were an object of the same type as the class from which it inherits.

The types ifstream and istringstream inherit from istream. Thus, we can use objects of type ifstream or istringstream as if they were istream objects. We can use objects of these types in the same ways as we have used cin. For example, we can call getline on an ifstream or istringstream object, and we can use the >> to read data from an ifstream or istringstream. Similarly, the types ofstream and ostringstream inherit from ostream. Therefore, we can use objects of these types in the same ways that we have used cout.

Everything that we cover in the remainder of this section applies equally to
plain streams, file streams, and string streams and to the char or widecharacter stream versions.

we cannot copy or assign objects of the IO types:

ofstream out1, out2;
out1 = out2; // error: cannot assign stream objects
ofstream print(ofstream); // error: can't initialize the ofstream parameter
out2 = print(out2); // error: cannot copy stream objects

Because we can‚Äôt copy the IO types, we cannot have a parameter or return type that is one of the stream types (¬ß 6.2.1, p. 209). Functions that do IO typically pass and return the stream through references. Reading or writing an IO object changes its state, so the reference must not be const.

stopa: p401, 8.1.2. Condition States

==
(findmath)
Math operators:

power:

#include <cmath>
pow(3.4, 4.4) // Returns: 3.4^4.4 = 218.025

--
std::pow in the <cmath> header has these overloads:

pow(float, float);
pow(float, int);
pow(double, double); // taken over from C
pow(double, int);
pow(long double, long double);
pow(long double, int);

Now you can't just do
pow(2, N)
with N being an int, because it doesn't know which of float, double or long double version it should take, and you would get an ambiguity error. All three would need a conversion from int to floating point, and all three are equally costly!

Therefor, be sure to have the first argument typed so it matches one of those three perfectly. I usually use double

pow(2.0, N)
Some lawyer crap from me again. I've often fallen in this pitfall myself, so i'm going to warn you about it.


==
(finddeclaration)
(finddefinition)
declaration vs definition:

A declaration makes a name known to the program. We must declare the type of a variable before we can use that variable.  A file that wants to use a name defined elsewhere includes a declaration for that name. 

A definition creates the associated entity.

A variable declaration specifies the type and name of a varaible. A variable definition is a declaration. In addition to specifying the name and type, a definition also allocates storage and may provide the variable with an initial value.

To obtain a declaration that is not also a definition, we add the extern keyword and may not provide an explicit initializer:

extern int i; //delcares but does not define i
int j; //declares and defines j

Any declaration that includes an explicit initializer is a definition. 

Variables must be defined exactly once but can be declared many times.

To use a variable in more than one file requires declarations. To use the same variable in multiple files, we must define that variable in one‚Äîand only one‚Äîfile. Other files that use that variable must declare‚Äîbut not define‚Äîthat variable.



==
(findstaticallytyped)
Type checking (statically typed launage):

Some languages, such as Smalltalk and Python, check types at run time. In contrast, C++ is a statically typed language; type checking is done at compile time.

In C++, if we try to do things that the type does not support, the compiler generates an error message and does not produce an executable file.

==
(findreference)
Reference

int &refVal = ival; // refVal refers to (is another name for) ival

A reference defines an alternative name for an object.

A reference must be initialized (Avado, same as const types)

There is no way to rebind a reference to refer to a different object.

Because references are not objects, they don‚Äôt have addresses. Hence, we may not define a pointer to a reference.

==
(findpassbyvalue)              
(findpassbyreference)          
Pass by value vs Pass by reference

From online:

C++ Passing by value vs. passing by reference

First of all, this article is NOT going to explain C++ references and pointers. If you are not clear on what these are then this is quite probably the wrong article for you and you really should probably go read here, here or here.

In C++ all arguments are passed to functions by value. In other words, a copy of the value is taken and that is what the function has to work with. If you want to modify the original value you must either pass a pointer or reference to the original value you wish to modify. Of course, even the pointer or reference are still passed by value. Pointers and references are just another C++ type and when they are passed around you do so by value.

Now, what about the case where we don't want to modify the value? There's no need to pass by reference or pointer, right? Wrong! Now, in the case of fundemental types it probably doesn't make a huge deal of difference since these are unlikely to be any more complicated that a pointer or reference type; howver, in the case of fully blown class objects, such as string, vector, map, set or any other (including your own class objects) it can make a huge difference. You see, passing by value can be very expensive both in terms of memory usage and performance (time / space complexity)

Classes have copy constructors, which are defined to facilitate the correct copying semantics for a class. Now in C++ there are two types of copy, shallow and deep. A shallow copy is where all the values of the class are copied but pointers are not followed. A deep copy is where pointers are followed and all the objects that they point to are also copied, thus creating a copy of all the "deep" objects, too. Any class that contains references to other objects should (unless there is a very good reason not to) provide both an assignment and copy constructor such that the class is always copied deeply.

Consider the std::vector class. This class contains an internal buffer of memory that is managed by the vector. In reality, we can assume that the vector contains a pointer that points to memory allocated on the heap. The vector class implements a copy constructor that will perform a deep copy on a vector object if a copy is taken. This is the only sane thing to do, otherwise we have two objects referencing the same memory and then we have issues of ownership. In other words, which of the vectors is now responsible for managing and freeing that memory and what happens to the other vector if that memory is released? Of course, it'll be left with a dangling pointer that is referencing invalid memory! Bad mojo for all!!!

Now, imagine we have a vector class that contains thousands of items. If we pass this object to a function by value the whole of the internal buffer will be copied. Not only is this really very inefficient in terms of the time it will take to allocate the memory and copy the values from the original vector to the copy it also increases memory usage greatly and, as a side effect, the risk of memory fragmentation. Imagine if this same vector is copied around again and again (maybe in a loop); it should be pretty clear just how inefficient this is.

The solution is to pass things around by const reference (or const pointer in C). The cost of passing things around by const reference is trivial and about as expensive as passing around an int value. Not only is it so much more efficient to pass objects in this way, but the semantics of your function become way clearer. Just looking at the function prototype tells us that the value being passed is never meant to be modified by this function. You are helping to enforce your objects interface contract.

Let's see a trivial example. 
#include <vector>
#include <chrono>
#include <iostream>

void foo(std::vector<int> byValue)
{
// do nothing
}

void bar(std::vector<int> const & byRef)
{
// do nothing
}

int main()
{
   auto && v = std::vector<int>(0x7FFFFFF);

   auto && x1 = std::chrono::steady_clock::now();
   foo(v);
   auto && x2 = std::chrono::steady_clock::now();
   bar(v);
   auto && x3 = std::chrono::steady_clock::now();

   auto && d1 = std::chrono::duration_cast<std::chrono::nanoseconds>(x2 - x1);
   auto && d2 = std::chrono::duration_cast<std::chrono::nanoseconds>(x3 - x2);

   std::cout
         << "Time to call foo: " << d1.count() << std::endl
         << "Time to call bar: " << d2.count() << std::endl;
}

When running this on my Windows 7 laptop, build with Visual Studio 2013 and executed in as a Release build the call by value takes approximately 1 second whilst the call by reference takes less than a nanosecond. That makes the pass by value a billion times slower! Of course, this is a contrived example and on different machines with different compilers YMMV, but hopefully it serves to demonstrate just how slow passing by value can, when compared to passing by reference!

In the case of passing by value the cost in terms of both time and space complexity is O(N), where N is the number of bytes to be copied. Passing by reference will cost O(1), which is a significant improvement. Okay, the pedants amongst you may wish to argue that even for a reference it's O(N), because a reference is composed of bytes. True, but the big (massive) difference that the size of a reference is always constant and will be in the order of a few bytes (4 on a 32 bit machine, 8 on a 64 bit machine) and not hundreds, thousands, millions or even billion in the case of non-fundamental objects.

Note: that some compilers may optimize out the calls to the functions foo and bar due to the fact they don't do anything. This is most likely to happen if you have aggressive optimisation enabled on your compiler. You can either disable this or add some code to these functions to make use of the passed references. Whilst disabling optimisation may skew the results in an absolute sense, the relative comparison should still hold up because what we're truly interested in here is the asymtoptic variance (Big O) rather than wall clock time!

==
(findpointer)
Pointer

A pointer holds the address of another object. 
A pointer is an object in its own right. 
A pointer can be assigned and copied.
A pointer can point to several different objects over its lifetime.
A pointer do NOT need to be initialized at the time it is defined.

We can use the address operator & to get the address of an object.
We can use the dereference operator * to access the object being pointed.

   declaration  operator
&  reference    obtain address
*  pointer      yield object

int ival = 42;
int *p = &ival; // p holds the address of ival; p is a pointer to ival
int v = *p; //v = 42, dereference operator *
*p = 0; //Assign new value to ival
int* p1, p2; //Tao: practice shows this is wrong, should define different pointers in different lines.

(findnull)
//Null pointer. The following three lines are equivalent, to assign null pointer to p.
int *p = 0;
int *p = nullptr; 
int *p = NULL;//Must #include<cstdlib>, modern programs should avoid using NULL <- tao: practice confirms that cstdlib is also included in std namespace, so if we already wrote "using namespace std;", then we do not need to #include<cstdlib>

Recommended: If there is no object to bind to a pointer, then initialize the pointer to nullptr or 0.

There is an automatic conversion from arithmetic or pointer
types to bool. If the pointer or arithmetic value is zero, the conversion yields false; any other value yields true

if(p) {...} is equivalent to if(p != NULL) {...}. If p == 0, then p = false. Any nonzero pointer evaluates as true. This is consistent with converting int to bool.

if(!p) is equivalent to if(p == NULL) <- Remember: if p buxin, ie p == NULL
if(p) is equivalent to if(p != NULL) <- Rememebr: if p xin, ie p != NULL


Two pointers are equal (using ==) if they hold the same address.

double obj = 3.14;
void *pv = &obj; // The type void* is a special pointer type that can hold the address of any object.

Avadoles:
Variables defined inside a function ordinarily are not stored at a fixed address.
Tao: this is also the reason why my program did something wrong when I tried to return a pointer to a variable defined inside a function (see more below).

--
(findpointertoarray)
(findreferencetoarray)
Pointer to array & array of pointers
Reference to array & array of references

//Principle: the symbol that is closest to the variable name comes to the first in the type name

int* parr[42]; // parr is an array of 42 pointers to int. From this, tao sees why tao likes to write "int*" rather than "int *"
int (*parr)[10] = &arr; // parr is a pointer, which points to an array of ten ints

int& refs[10] = ... // error: no arrays of references
int (&arrRef)[10] = arr; // arrRef is a reference, which refers to an array of ten ints

int* (&arry)[10] = ptrs; // arry is a reference to an array of ten pointers

As with vector, arrays hold objects. Thus, there are no arrays of references. Because an array is an object, we can define both pointers and references to arrays.

When we use an array, the compiler ordinarily converts the array to a pointer.

--
Pointer to vector: vector<int> *t; t->push_back(10);
Vector of pointers: vector<int*> movies = ...

--
Reference to a vector: vector<int>& = ...
There is no vector of references. 

--
(findpointertofunction)
Pointer to function

A function pointer is just that‚Äîa pointer that denotes a function rather than an object. Like any other pointer, a function pointer points to a particular type. A function‚Äôs type is determined by its return type and the types of its parameters. The function‚Äôs name is not part of its type. For example:

// compares lengths of two strings
bool lengthCompare(const string &, const string &);

has type 

bool(const string&, const string&). 

To declare a pointer that can point at this function, we declare a pointer in place of the function name:

// pf points to a function returning bool that takes two const string references
bool (*pf)(const string &, const string &); // uninitialized

// declares a function named pf that returns a bool*
bool *pf(const string &, const string &);

Using Function Pointers

When we use the name of a function as a value, the function is automatically converted to a pointer. For example, we can assign the address of lengthCompare to pf as follows:

pf = lengthCompare; // pf now points to the function named lengthCompare
pf = &lengthCompare; // equivalent assignment: address-of operator is optional

Moreover, we can use a pointer to a function to call the function to which the pointer points. We can do so directly‚Äîthere is no need to dereference the pointer:

bool b1 = pf("hello", "goodbye"); // calls lengthCompare
bool b2 = (*pf)("hello", "goodbye"); // equivalent call

Function Pointer Parameters

Just as with arrays, we cannot define parameters of function type but can have a parameter that is a pointer to function. As with arrays, we can write a parameter that looks like a function type, but it will be treated as a pointer:

// third parameter is a function type and is automatically treated as a pointer to function
void useBigger(const string &s1, const string &s2, bool pf(const string &, const string &));

// equivalent declaration: explicitly define the parameter as a pointer to function
void useBigger(const string &s1, const string &s2, bool (*pf)(const string &, const string &));

Returning a Pointer to Function

As with arrays, we can‚Äôt return a function type but can return a
pointer to a function type.

Using auto or decltype for Function Pointer Types

If we know which function(s) we want to return, we can use decltype to simplify writing a function pointer return type. 

string::size_type sumLength(const string&, const string&);

decltype(sumLength) *getFcn(const string &);

The only tricky part in declaring getFcn is to remember that when we apply decltype to a function, it returns a function type, not a pointer to function type. We must add a * to indicate that we are returning a pointer, not a function.

--
(findreturnpointer)
Return pointer from a function (from tutorialspoint):

Tao's summary from below:
1. It is not good idea to return the address of a local variable to outside of the function, so you would have to define the local variable as static variable.
2. Can return a pointer created by the "new" operator. Extracted from "find new": Dynamically allocated objects have a lifetime that is independent of where they are created; they exist until they are explicitly freed. Functions that return pointers (rather than smart pointers) to dynamic memory put burden on their callers‚Äîthe caller must remember to delete the memory. We returned pointer created by "new" in leetcode, like pr_133 (leetcode discussion also did this).

As we have seen in last chapter how C++ allows to return an array from a function, similar way C++ allows you to return a pointer from a function. To do so, you would have to declare a function returning a pointer as in the following example ‚àí

int * myFunction() {
   .
   .
   .
}

Second point to remember is that, it is not good idea to return the address of a local variable to outside of the function, so you would have to define the local variable as static variable. Tao: if return the address of a local variable, the caller function would get a pointer containing wrong address value (from practice).

Now, consider the following function, which will generate 10 random numbers and return them using an array name which represents a pointer i.e., address of first array element.

 Live Demo
#include <iostream>
#include <ctime>
 
using namespace std;
 
// function to generate and retrun random numbers.
int * getRandom( ) {
   static int  r[10];
 
   // set the seed
   srand( (unsigned)time( NULL ) );
   
   for (int i = 0; i < 10; ++i) {
      r[i] = rand();
      cout << r[i] << endl;
   }
 
   return r;
}
 
// main function to call above defined function.
int main () {
   // a pointer to an int.
   int *p;
 
   p = getRandom();
   for ( int i = 0; i < 10; i++ ) {
      cout << "*(p + " << i << ") : ";
      cout << *(p + i) << endl;
   }
 
   return 0;
}
When the above code is compiled together and executed, it produces result something as follows ‚àí

624723190
1468735695
807113585
976495677
613357504
1377296355
1530315259
1778906708
1820354158
667126415
*(p + 0) : 624723190
*(p + 1) : 1468735695
*(p + 2) : 807113585
*(p + 3) : 976495677
*(p + 4) : 613357504
*(p + 5) : 1377296355
*(p + 6) : 1530315259
*(p + 7) : 1778906708
*(p + 8) : 1820354158
*(p + 9) : 667126415

--
(findreturnreference)
Return reference from a function (from tutorialspoint):

Tao's summary from below
1. Using (not limited to returning) reference is recommended rather than using pointer.
2. It is not legal to return a reference to local var. But you can always return a reference on a static variable.

A C++ program can be made easier to read and maintain by using references rather than pointers. A C++ function can return a reference in a similar way as it returns a pointer.

When a function returns a reference, it returns an implicit pointer to its return value. This way, a function can be used on the left side of an assignment statement. For example, consider this simple program ‚àí

#include <iostream>
#include <ctime>
 
using namespace std;
 
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double& setValues( int i ) {
   return vals[i];   // return a reference to the ith element
}
 
// main function to call above defined function.
int main () {
 
   cout << "Value before change" << endl;
   for ( int i = 0; i < 5; i++ ) {
      cout << "vals[" << i << "] = ";
      cout << vals[i] << endl;
   }
 
   setValues(1) = 20.23; // change 2nd element
   setValues(3) = 70.8;  // change 4th element
 
   cout << "Value after change" << endl;
   for ( int i = 0; i < 5; i++ ) {
      cout << "vals[" << i << "] = ";
      cout << vals[i] << endl;
   }
   return 0;
}
When the above code is compiled together and executed, it produces the following result ‚àí

Value before change
vals[0] = 10.1
vals[1] = 12.6
vals[2] = 33.1
vals[3] = 24.1
vals[4] = 50
Value after change
vals[0] = 10.1
vals[1] = 20.23
vals[2] = 33.1
vals[3] = 70.8
vals[4] = 50

When returning a reference, be careful that the object being referred to does not go out of scope. So it is not legal to return a reference to local var. But you can always return a reference on a static variable.

int& func() {
   int q;
   //! return q; // Compile time error
   static int x;
   return x;     // Safe, x lives outside this scope
}

==
(finddynamicmemory)            
Dynamic memory

(findnew)                      
new operator

Tao: the followings are selected from the book:

Dynamically allocated objects have a lifetime that is independent of where they are created; they exist until they are explicitly freed.

In C++, dynamic memory is managed through a pair of operators: "new", which allocates, and optionally initializes, an object in dynamic memory and returns a pointer to that object; and "delete", which takes a pointer to a dynamic object, destroys that object, and frees the associated memory.

The followings covers all of the section "12.1.2. Managing Memory Directly":

The language itself defines two operators that allocate and free dynamic memory. The new operator allocates memory, and delete frees memory allocated by new.

Objects allocated on the free store are unnamed, so new offers no way to name the objects that it allocates. Instead, new returns a pointer to the object it allocates:

//pi points to a dynamically allocated, unnamed, uninitialized int:
int *pi = new int; 

This new expression constructs an object of type int on the free store and returns a pointer to that object. 

By default, dynamically allocated objects are default initialized, which means that objects of built-in or compound type have undefined value; objects of class type are initialized by their default constructor.

string *ps = new string; // initialized to empty string
int *pi = new int; // pi points to an uninitialized int

We can initialize a dynamically allocated object using direct initialization. We can use traditional construction (using parentheses), and under the new standard, we can also use list initialization (with curly braces):

int *pi = new int(1024); // object to which pi points has value 1024
string *ps = new string(10, '9'); // *ps is "9999999999"

// vector with ten elements with values from 0 to 9
vector<int> *pv = new vector<int>{0,1,2,3,4,5,6,7,8,9};

We can also value initialize a dynamically allocated object by following the type name with a pair of empty parentheses:

string *ps1 = new string; // default initialized to the empty string
string *ps = new string(); // value initialized to the empty string
int *pi1 = new int; // default initialized; *pi1 is undefined
int *pi2 = new int(); // value initialized to 0; *pi2 is 0

For the same reasons as we usually initialize variables, it is also a good idea to initialize dynamically allocated objects.

When we provide an initializer inside parentheses, we can use auto to deduce the type of the object we want to allocate from that initializer. However, because the compiler uses the initializer‚Äôs type to deduce the type to allocate, we can use auto only with a single initializer inside parentheses:

auto p1 = new auto(obj); // p points to an object of the type of obj that object is initialized from obj
auto p2 = new auto{a,b,c}; // error: must use parentheses for the initializer

It is legal to use new to allocate const objects:

// allocate and initialize a const int
const int *pci = new const int(1024);

// allocate a default-initialized const empty string
const string *pcs = new const string;

Like any other const, a dynamically allocated const object must be initialized. A const dynamic object of a class type that defines a default constructor may be initialized implicitly. Objects of other types must be explicitly initialized. Because the allocated object is const, the pointer returned by new is a pointer to const.

Memory Exhaustion

Although modern machines tend to have huge memory capacity, it is always possible
that the free store will be exhausted. Once a program has used all of its available memory, new expressions will fail. By default, if new is unable to allocate the requested storage, it throws an exception of type bad_alloc. We can prevent new from throwing an exception by using a different form of new:

// if allocation fails, new returns a null pointer
int *p1 = new int; // if allocation fails, new throws std::bad_alloc
int *p2 = new (nothrow) int; // if allocation fails, new returns a null pointer

This form of new is referred to as placement new. A placement new expression lets us pass additional arguments to new. In this case, we pass an object named nothrow that is defined by the library.

When we pass nothrow to new, we tell new that it must not throw an exception. If this form of new is unable to allocate the requested storage, it will return a null pointer. Both bad_alloc and nothrow are defined in the new header.

Freeing Dynamic Memory

In order to prevent memory exhaustion, we must return dynamically allocated memory to the system once we are finished using it. We return memory through a delete expression. A delete expression takes a pointer to the object we want to free:

delete p; // p must point to a dynamically allocated object or be null

Like new, a delete expression performs two actions: It destroys the object to which
its given pointer points, and it frees the corresponding memory.

Although the value of a const object cannot be modified, the object itself can be destroyed.

Dynamically Allocated Objects Exist until They Are Freed

As we saw earlier, memory that is managed through a shared_ptr is automatically deleted when the last shared_ptr is destroyed. The same is not true for memory we manage using built-in pointers. A dynamic object managed through a built-in pointer exists until it is explicitly deleted.

Functions that return pointers (rather than smart pointers) to dynamic memory put burden on their callers‚Äîthe caller must remember to delete the memory:

// factory returns a pointer to a dynamically allocated object
Foo* factory(T arg) {
    // process arg as appropriate
    return new Foo(arg); // caller is responsible for deleting this memory
}

Like our earlier factory function, this version of factory allocates an object but does not delete it. Callers of factory are responsible for freeing this memory when they no longer need the allocated object. Unfortunately, all too often the caller forgets to do so:

void use_factory(T arg) {
    Foo *p = factory(arg);
    // use p but do not delete it
} // p goes out of scope, but the memory to which p points is not freed!

Here, our use_factory function calls factory, which allocates a new object of type Foo. When use_factory returns, the local variable p is destroyed. That variable is a built-in pointer, not a smart pointer.

Unlike class types, nothing happens when objects of built-in type are destroyed. In particular, when a pointer goes out of scope, nothing happens to the object to which the pointer points. If that pointer points to dynamic memory, that memory is not automatically freed.

Warning: Dynamic memory managed through built-in pointers (rather than smart
pointers) exists until it is explicitly freed.

In this example, p was the only pointer to the memory allocated by factory. Once use_factory returns, the program has no way to free that memory. Depending on the logic of our overall program, we should fix this bug by remembering to free the memory inside use_factory:

void use_factory(T arg) {
    Foo *p = factory(arg);
    // use p
    delete p; // remember to free the memory now that we no longer need it
}

or, if other code in our system needs to use the object allocated by use_factory,
we should change that function to return a pointer to the memory it allocated:

Foo* use_factory(T arg) {
    Foo *p = factory(arg);
    // use p
    return p; // caller must delete the memory
}

Resetting the Value of a Pointer after a delete ...

When we delete a pointer, that pointer becomes invalid. Although the pointer is invalid, on many machines the pointer continues to hold the address of the (freed) dynamic memory. After the delete, the pointer becomes what is referred to as a
dangling pointer. A dangling pointer is one that refers to memory that once held an object but no longer does so.

Dangling pointers have all the problems of uninitialized pointers (tao: like trying to accessing the object pointed by the dangling pointer). We can avoid the problems with dangling pointers by deleting the memory associated with a pointer just before the pointer itself goes out of scope. That way there is no chance to use the pointer after the memory associated with the pointer is freed. If we need to keep the pointer around, we can assign nullptr to the pointer after we use delete. Doing so makes it clear that the pointer points to no object.

...Provides Only Limited Protection

A fundamental problem with dynamic memory is that there can be several pointers that point to the same memory. Resetting the pointer we use to delete that memory lets us check that particular pointer but has no effect on any of the other pointers that
still point at the (freed) memory. For example:

int *p(new int(42)); // p points to dynamic memory
auto q = p; // p and q point to the same memory
delete p; // invalidates both p and q
p = nullptr; // indicates that p is no longer bound to an object

Here both p and q point at the same dynamically allocated object. We delete that memory and set p to nullptr, indicating that the pointer no longer points to an object. However, resetting p has no effect on q, which became invalid when we deleted the memory to which p (and q!) pointed. In real systems, finding all the pointers that point to the same memory is surprisingly difficult.

==
(findconst)
const

We can make a variable unchangeable by defining the variable‚Äôs type as const.
const object MUST be initilized after being created.

const int bufSize = 512;
extern const int bufSize = 512; // A const that is accessible to other files

//Reference to const:
const int ci = 1024;
const int &r1 = ci; // Both reference and underlying object are const. See following summary for remember.

//const refrence: no such thing

//Pointer to const:
const double pi = 3.14;
const double *cptr = &pi; // Store the address of a const object only in a pointer to const. See following summary for remember.

//const pointer:
int *const curErr = &errNumb; // curErr will always point to errNumb. See following summary for remember.

Summary from the above:
1. int is always on the left of *, like int *
2. const can be on the left or right of int *, like const int *, int * const
3. Principle: the symbol that is closest to the variable name is comes to the first in the type name: 
   const double *cptr = &pi: cptr is a pointer to const
   int *const curErr = &errNumb: curErr is a const pointer

We use the term top-level const to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a low-level const.

The distinction between top-level and low-level matters when we copy an object. When we copy an object, top-level consts are ignored. Example:

const int ci = i, &cr = ci;
auto b = ci; // b is an int (top-level const in ci is dropped)

On the other hand, low-level const is never ignored. When we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects. In general, we can convert a nonconst to const but not the other way round.

const and reference must be initialized.

--
(findconstantexpression)
Constant expression

A constant expression is an expression whose value cannot change and that can be evaluated at compile time. A literal is a constant expression. A const object that is initialized from a constant expression is also a constant expression. Examples:

const int max_files = 20; // max_files is a constant expression
const int limit = max_files + 1; // limit is a constant expression
int staff_size = 27; // staff_size is not a constant expression
const int sz = get_size(); // sz is not a constant expression

Even though sz is a const, the value of its initializer is not known until run time. Hence, sz is not a constant expression.

==
(findfor)
(findrangefor)

Range for in C++ 2011:

vector<int> v = {1, 3, 5, 7, 9};

for (auto x : v)
    cout << x << ' ';

==
(findsleep)
Sleep

Compile the following file:

g++ -o sleep sleep.cc -std=c++0x -D_GLIBCXX_USE_NANOSLEEP

--- File sleep.cc starts ---
#include <iostream>
#include <chrono>
#include <thread>
using namespace std;

int main() {
    std::this_thread::sleep_for(std::chrono::milliseconds(5000));
    cout << "Hello world" << endl;
}
--- File sleep.cc ends ---

==
(findescape)
Escape sequence:

newline:       \n
double quote:  \"
single quote:  \'
backslash:     \\
question mark: \?

Examples: 
cout << '\n'; //prints a newline
cout << "Hi \n"

==
(findstring)
string

#include <string>
using std::string;

string s1;
string s2 = s1; //copy initialization, s2 is a copy of s1
string s3 = "hiya"; //direct initialization

When we initialize a variable using =, we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created. Otherwise, when we omit the =, we use direct initialization.

string literal: the compiler appends a null character ('\0') to every string literal. Thus, the actual size of a string literal is one more than its apparent size.

s.empty() //Returns bool
s.size() //Returns number, which is a string::size_type, see below
s[3] //Returns a reference to the char. The subscript operator (the [ ] operator) takes a string::size_type.
s[0] = 'a'; //Charaters in a string can be changed in C++! Different from Java.
s1 + s2 //Returns string
s1 += s2 //Equivalent to s1 = s1 + s2
s1 = s2 //Replaces characters in s1 with a copy of s2.
s1 == s2 //s1 and s2 are equal if they contain the same characters. Equality is case-sensitive.
s1 != s2
s1 <= s2 //Comparisons are case-sensitive and use dictionary ordering.

From online: create a string with five dot characters:
string foo = string(5, '.') // foo = "....."

string::size_type:
The string class‚Äîand most other library types‚Äîdefines several companion types. These companion types make it possible to use the library types in a machine-independent manner. The type size_type is one of these companion types. Although we don‚Äôt know the precise type of string::size_type, we do know that it is an unsigned type big enough to hold the size of any string. Because size returns an unsigned type, it is essential to remember that expressions that mix signed and unsigned data can have surprising results. You can avoid problems due to conversion between unsigned and int by not using ints in expressions that use size().

The string library lets us convert both character literals and character string literals to strings. Because we can use these literals where a string is expected.

When we mix strings and string or character literals, at least one operand to each
+ operator must be of string type: 
string s4 = s1 + ", "; // ok: adding a string and a literal
string s5 = "hello" + ", "; // error: no string operand (tao: both are string literals, which are not string type variables, see below)

For historical reasons, and for compatibility with C, string literals are not standard library strings. It is important to remember that these types differ when you use string literals and library strings.

//The followings should include the "cctype" header:
//c is a character
isalnum(c) //true if c is a letter or a digit.
isalpha(c) //true if c is a letter
isdigit(c) //true if c is a digit
islower(c) //true if c is a lowercase letter
isupper(c) //true if c is an uppercase letter
tolower(c) //If c is an upercase letter, returns its lowercase equivalent, otherwise returns c unchanged
toupper(c) //If c is a lowercase letter, returns its upercase equivalent, otherwise returns c unchanged
isspace(c) //true if c is whitespace (ie, a space, tab, vertical tab, return, newline, or formfeed)

string s2 = s.erase (pos, len); //Erases the portion of the string value that begins at the character position pos and spans len characters (or until the end of the string, from online)

s2.append("helo"); // equivalent as below. The parameter of append() can only be string, it can not be char.
s.insert(s.size(), "helo"); 

--
In some computers (like my Thinkpad), some functions (like ifstream) needs the input to string to be defined as type: const char*, for example:

const char* filename = "helo";
ifstream input_file(filename);

However, I can use string instead of const char* if compile using std C++ 11.

In some computers (like the Mac), it can be written as:

string filename = "helo";
ifstream input_file(filename);

--
(findsubstring)
Substring (get and find)

Get a substring:

string s2 = s.substr(pos, n) // return a string containing n characters fro s starting at pos. pos defaults to 0. n defaults to a value that causes the library to copy all the characters in s starting from pos.

Find a substring in a string:

Use std::string::find as follows:

if (s1.find(s2) != std::string::npos) {
    std::cout << "found!" << '\n';
}
Note: "found!" will be printed if s2 is a substring of s1, both s1 and s2 are of type std::string. 

string test = "123";
string res = test.substr(1, 0);
res.size(); //returns: 0

--
(findsplit)
split a string

** Split by a char **

Problem: Split a string by a delim, and return a vector of strings containing no delim

Use stringstream getline
Signature istream& getline (istream&& is, string& str, char delim)

#include <sstream>

//tao: notice the function parameter uses reference to a string
vector<string> split(const string &s, char delim) {
    stringstream ss(s);
    string item;
    vector<string> tokens;
    while (getline(ss, item, delim)) {
        tokens.push_back(item);
    }
    return tokens;
}

Tao's example of using the above function split:

string test_str = "Helo,how,are,you";
vector<string> strs = split(test_str, ',');
for(int i = 0; i < strs.size(); i++) cout << strs[i] << " ";
cout << endl;

Output:
Helo how are you

** Split by a string **

You can use the string::find() function to find the position of your string delimiter, then use string::substr() to get a token.

Example:

string s = "scott>=tiger";
string delimiter = ">=";
string token = s.substr(0, s.find(delimiter)); // token is "scott"

The substr(size_t pos = 0, size_t n = npos) function returns a substring of the object, starting at position pos and of length npos.

(findfind)
The find(const string& str, size_t pos = 0) function returns the position of the first occurrence of str in the string, or npos if the string is not found.
Tao's example:
string s = "helo";
s.find("lo")// Returns: 2
while((pos = s.find(delimiter)) != string::npos) {...}

If you have multiple delimiters, after you have extracted one token, you can remove it (delimiter included) to proceed with subsequent extractions (if you want to preserve the original string, just use  s = s.substr(pos + delimiter.length());):

s.erase(0, s.find(delimiter) + delimiter.length());
This way you can easily loop to get each token.

Complete Example
string s = "scott>=tiger>=mushroom";
string delimiter = ">=";

size_t pos = 0;
string token;
while ((pos = s.find(delimiter)) != string::npos) {
    token = s.substr(0, pos);
    cout << token << endl;
    s.erase(0, pos + delimiter.length());
}
cout << s << endl;
Output:

scott
tiger
mushroom

--
C-style charater strings are null terminated char arrays. 

C-style charater string functions: 
strlen, strcmp, strcat, strcpy.

For most applications, in addition to being safer, it is also more efficient to use library strings rather than C-style strings.

tao: convert a char array to string (from online: Note that this only works for constant NULL-terminated C-strings.)
char a1[2] = {'a', 'b', '\0'};
string str1(a1);

from online: convert a string to char array:
string temp = "cat";
char * tab2 = new char [temp.length()+1];
strcpy (tab2, temp.c_str());

==
(findtrim)
trim

Tao: the simplest way to trim the spaces at beginning and end of a string is:

string str = "   35   ";

str.erase(0, str.find_first_not_of(' '));
str.erase(str.find_last_not_of(' ') + 1);

cout << str << endl; //Output: 35
cout << str.size() << endl; //Ouptut: 2

From online:

There is no standard way of trimming a string, but it‚Äôs possible to implement using the methods in the string class:

Left trim: Use find_first_not_of() to find the characters to erase
Right trim: Use find_first_of() to find the characters to erase
Trim: Do a right trim followed by a left trim (or vice-versa)
Use erase() to actually erase the characters.

Here is my implementation. It defaults to trimming whitespace characters but you can specify any string of characters as the second argument.

string& ltrim(string& str, const string& chars = "\t\n\v\f\r ") {
    str.erase(0, str.find_first_not_of(chars)); //tao: see erase() by searching "find erase"
    return str;
}
 
string& rtrim(string& str, const string& chars = "\t\n\v\f\r ") {
    str.erase(str.find_last_not_of(chars) + 1);
    return str;
}

string& trim(string& str, const string& chars = "\t\n\v\f\r ") {
    return ltrim(rtrim(str, chars), chars);
}

string extract_column_names(string line) {
    return line + "\n";
}

Example:

string str = " test ";
trim(str);

==
(finderase)
erase

std::string::erase in C++

The function erases a part of the string content, shortening the length of the string. The characters affected depend on the member function version used:
Return value : erase() returns *this.

string& string ::erase ()
Erases all characters in a string

string& string ::erase (size_type pos)
Erases all characters after position ‚Äòpos‚Äô. 
Throw out_of_range if idx > size().

string& string ::erase (size_type idx, size_type len ) 
Erases at most, len characters of *this, starting at index idx. 
If len is missing, all remaining characters are removed. 
Throw out_of_range if idx > size().
Example: 
string str("Hello World!");
str.erase(1, 4); //str = "H World!", tao: yes it is in-place, confirmed.

string& string ::erase (iterator pos)
Erase the single character at iterator position pos.
Return the first character after the last character removed
If no such character is remaining then, returns 
string::end() i.e. position after the last character.

string& string ::erase (iterator beg, iterator end )
Erase the single character at iterator position pos.
Erases all characters of the range [ beg, end)
Returns end i.e. the first character after the last character removed.
If no such character is remaining then, returns 
string::end() i.e. position after the last character

==
(findargs)                    
(findcommandlineargument)      
Command line argument 

Note that if in my Thinkpad, the following should be compiled in C++ 11.

#include <string>
using namespace std;

int main(int argc, char** argv) {
    int nfiles = stoi(argv[1]); // If run as: ./main 5, then argv[1] = "5"
    cout << "nfiles = " << nfiles << endl;
    return 0;
}

Run the program:
./main 5

Then the output is:
nfiles = 5

==
(findvector)
vector

#include <vector>
using std::vector;

--
vector<int> v1; //v1 is empty (tao: ie, v1.size() = 0, proved by many practices)
vector<int> v2 = v1; //v2 is a copy of the elements in v1 (tao: copies the values of v1 to v2)
vector<int> v1(10); //v1 has n copies of a value-initialized object. 10 elements, each initialized to 0.
vector<string> v1(10); //10 elements, each an empty string
vector<int> v1(n, val); //v1 has n elements with value val
vector<vector<int>> v(10, vector<int>(10,1)); //From online. v is a 10*10 vector, all elements initialized to 1.
vector<int> v1 = {1, 2, 3};//C++11, does not work in the old C++ version
vector<int> v1{1,2,3};//Does not work

Searched online, in the old C++ version, to initialize a vector, we can only use push_back(). 

vector<vector<double> > v1 //correct, note the space between > >
vector<vector<double>> v1 //wrong <- tao: in the Mac (or C++11?), this is also correct.

vector< vector<int> > a(n,vector<int>(n)); //a is an 2D (n*n) vector, from HackerRank

v.push_back(3) //Adds an element with value 3 to end of v
v.empty() //Returns a bool
v.size() //Returns a number, which is of type vector<int>::size_type
v[5] //Returns a reference to the element
v1 = v2 //Replaces the elements in v1 with a copy of the elements in v2
v1 == v2 //Equal if each element in v1 is equal to the corresponding element in v2. 
v1 != v2
v1 <= v2 //Have their normal meanings using dictionary ordering.
vec.clear() //Removes all elements from the vector (which are destroyed), leaving the container with a size of 0.

We can define vectors to hold objects of most any type. Because references are not objects, we cannot have a vector of references.

vector is a template, not a type. Types generated from vector must include the element type, for example, vector<int>.

--
Traverse a vector (in C++ 11):

//vec is type vector<Person*>
for(auto p : vec) {
  cout << p->height << endl;
}

--
Vector iterator:

#include <iostream>
#include <vector>
using namespace std;

int main ()
{
  vector<int> myvector;
  for (int i=1; i<=5; i++) myvector.push_back(i);

  cout << "myvector contains:";
  for (vector<int>::iterator it = myvector.begin() ; it != myvector.end(); ++it)
    cout << ' ' << *it;
  cout << '\n';

  return 0;
}
Edit & Run

--
The following experiment shows that vectors are also saved contiguously in memory, same as array:

vector<int> vec = {1, 2, 3, 4, 5};
int n = vec.size();

for(int *p = &vec[0]; p < &vec[n]; ++p) cout << *p << " ";
cout << endl;

Output: 1 2 3 4 5

--
Vector of objects:

From my leetcode code:

vector<Interval> res;
res.push_back(*iterator); // *iterator is an object of Interval

--
How to find out if an item is present in a vector?

You can use std::find from <algorithm>:

std::find(vector.begin(), vector.end(), item) != vector.end()
This returns a bool (true if present, false otherwise). With your example:

#include <algorithm>

if ( std::find(vector.begin(), vector.end(), item) != vector.end() )
   do_this();
else
   do_that();

Tao's experiment shows that finding an element from a vector is much slower than from a set. 

--
(findsortvector)
Sort a vector:

// C++ program to sort a vector in non-decreasing 
// order. 
#include <iostream>
#include <vector>
using namespace std; 
  
int main() 
{ 
    vector<int> v{ 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 }; 
  
    sort(v.begin(), v.end()); 
  
    for (auto x : v) cout << x << " "; //Ouptut is sorted: 0 1 2 3 4 5 6 7 8 9
  
    return 0; 
} 

How to sort in descending order?
sort() takes a third parameter that is used to specify the order in which elements are to be sorted. We can pass ‚Äúgreater()‚Äù function to sort in descending order. This function does comparison in a way that puts greater element before.

// C++ program to sort a vector in non-increasing 
// order. 
#include <iostream>
#include <vector>
using namespace std; 
  
int main() 
{ 
    vector<int> v{ 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 }; 
  
    sort(v.begin(), v.end(), greater<int>()); 
  
    for (auto x : v) cout << x << " "; //Ouptut: 9 8 7 6 5 4 3 2 1 0
  
    return 0; 
} 

How to sort in particular order?
We can also write our own comparator function and pass it as a third parameter.

// A C++ program to sort vector using 
// our own comparator 
#include <iostream>
#include <vector>
using namespace std; 
  
// An interval has start time and end time 
struct Interval { 
    int start, end; 
}; 
 
// Tao: in the following compare function, if for i1 < i2 it returns true, then in the sort, smaller elements will be put in front.

// Tao's experience shows that the following function compareInterval should be defined outside of a class (it can be used either inside or outside a class). If I must put it inside a class, define it as a static function: static bool compareInterval(Interval i1, Interval i2) {...}
// Compares two intervals according to staring times. 
bool compareInterval(Interval i1, Interval i2) 
{ 
    return (i1.start < i2.start); 
} 
  
int main() 
{ 
    vector<Interval> v { { 6, 8 }, { 1, 9 }, { 2, 4 }, { 4, 7 } }; 
  
    // sort the intervals in increasing order of 
    // start time 
    sort(v.begin(), v.end(), compareInterval); 
  
    cout << "Intervals sorted by start time : \n"; 
    for (auto x : v) 
        cout << "[" << x.start << ", " << x.end << "] "; 
  
    return 0; 
} 

Output :

Intervals sorted by start time : 
[1, 9] [2, 4] [4, 7] [6, 8] 


--
Concatenating two vectors:

vector1.insert( vector1.end(), vector2.begin(), vector2.end() );

--
Convert array to vector:

#include <iterator>
#include <vector>
using namespace std;

int x[] = { 1, 2, 3, 4, 5 };
vector<int> v(begin(x), end(x));

--
Pass a vector to a function (from online):

It depends on if you want to pass the vector as a reference or as a pointer (I am disregarding the option of passing it by value as clearly undesirable).

As a pointer:

int binarySearch(int first, int last, int search4, vector<int>* random);

vector<int> random(100);
// ...
found = binarySearch(first, last, search4, &random);

As a reference:

int binarySearch(int first, int last, int search4, vector<int>& random);

vector<int> random(100);
// ...
found = binarySearch(first, last, search4, random);

--
Return a vector from function (from online):

In leetcode, the default code follows this pattern:
Input parameter is a reference to vector, output is a vector:

vector<vector<int>> permute(vector<int>& nums) { 
    vector<vector<int>> res;
    ...
    return res; //Practice shows it is OK to return a vector defined inside a function (unlike pointer).
}

vector<Interval> merge(vector<Interval>& intervals) {
    ...
    return intervals; //Practice shows it is OK to return the input reference.
}

Question:

Efficient way to return a std::vector in c++

How much data is copied, when returning a std::vector in a function and how big an optimization will it be to place the std::vector in free-store (on the heap) and return a pointer instead i.e. is:

std::vector *f()
{
  std::vector *result = new std::vector();
  /*
    Insert elements into result
  */
  return result;
} 
more efficient than:

std::vector f()
{
  std::vector result;
  /*
    Insert elements into result
  */
  return result;
} 

Answer:

In C++11, this is the preferred way:

std::vector<X> f();

That is, return by value.

With C++11, std::vector has move-semantics, which means the local vector declared in your function will be moved on return and in some cases even the move can be elided by the compiler.

Question:

Why is it OK to return vector from function?

Please consider this code. I have seen this type of code several times. words is a local vector. How is it possible to return it from a function? Can we guarantee it will not die?

 std::vector<std::string> read_file(const std::string& path)
 {
    std::ifstream file("E:\\names.txt");

    if (!file.is_open())
    {
        std::cerr << "Unable to open file" << "\n";
        std::exit(-1);
    }

    std::vector<string> words;//this vector will be returned 
    std::string token;

    while (std::getline(file, token, ','))
    {
        words.push_back(token);
    }

    return words;
}

Pre C++11:
The function will not return the local variable but rather a copy of it. Your compiler might however perform an optimization where no actual copy action is made.

See this question & answer for further details

C++11:
The function will move the value, see this answer for further details

Question:

What is std::move(), and when should it be used?

What is it?
What does it do?
When should it be used?
Good links are appreciated.

Answer:

Wikipedia Page on C++11 R-value references and move constructors

1. In C++11, in addition to copy constructors, objects can have move constructors.
(And in addition to copy assignment operators, they have move assignment operators.)

2. The move constructor is used instead of the copy constructor, if the object has type "rvalue-reference" (Type &&).

3. std::move() is a cast that produces an rvalue-reference to an object, to enable moving from it. It's a new C++ way to avoid copies. For example, using a move constructor, a std::vector could just copy its internal pointer to data to the new object, leaving the moved object in an incorrect state, avoiding to copy all data. This would be C++-valid.

Try googling for move semantics, rvalue, perfect forwarding.

--
vector<int> v;
for(vector<int>::size_type i = 0; i < 10; ++i) {
    v[i] = i; // Wrong. Segmentation fault: 11. Because v is always an empty vector, so can not assign.
    v.push_back(i); // Correct
}

--
From geeksforgeeks:

Certain functions associated with the vector are:
Iterators

begin() ‚Äì Returns an iterator pointing to the first element in the vector
end() ‚Äì Returns an iterator pointing to the theoretical element that follows the last element in the vector
rbegin() ‚Äì Returns a reverse iterator pointing to the last element in the vector (reverse beginning). It moves from last to first element
rend() ‚Äì Returns a reverse iterator pointing to the theoretical element preceding the first element in the vector (considered as reverse end)
cbegin() ‚Äì Returns a constant iterator pointing to the first element in the vector.
cend() ‚Äì Returns a constant iterator pointing to the theoretical element that follows the last element in the vector.
crbegin() ‚Äì Returns a constant reverse iterator pointing to the last element in the vector (reverse beginning). It moves from last to first element
crend() ‚Äì Returns a constant reverse iterator pointing to the theoretical element preceding the first element in the vector (considered as reverse end)

// C++ program to illustrate the 
// iterators in vector 
#include <iostream> 
#include <vector> 
  
using namespace std; 
  
int main() 
{ 
    vector<int> g1; 
  
    for (int i = 1; i <= 5; i++) 
        g1.push_back(i); 
  
    cout << "Output of begin and end: "; 
    for (auto i = g1.begin(); i != g1.end(); ++i) 
        cout << *i << " "; 
  
    cout << "\nOutput of cbegin and cend: "; 
    for (auto i = g1.cbegin(); i != g1.cend(); ++i) 
        cout << *i << " "; 
  
    cout << "\nOutput of rbegin and rend: "; //tao: reverse the vector, note it is ++ir, not --ir
    for (auto ir = g1.rbegin(); ir != g1.rend(); ++ir) 
        cout << *ir << " "; 
  
    cout << "\nOutput of crbegin and crend : "; 
    for (auto ir = g1.crbegin(); ir != g1.crend(); ++ir) 
        cout << *ir << " "; 
  
    return 0; 
} 

Output:
Output of begin and end: 1 2 3 4 5 
Output of cbegin and cend: 1 2 3 4 5 
Output of rbegin and rend: 5 4 3 2 1 
Output of crbegin and crend : 5 4 3 2 1

Capacity

size() ‚Äì Returns the number of elements in the vector.
max_size() ‚Äì Returns the maximum number of elements that the vector can hold.
capacity() ‚Äì Returns the size of the storage space currently allocated to the vector expressed as number of elements.
resize() ‚Äì Resizes the container so that it contains ‚Äòg‚Äô elements.
empty() ‚Äì Returns whether the container is empty.
shrink_to_fit() ‚Äì Reduces the capacity of the container to fit its size and destroys all elements beyond the capacity.
reserve() ‚Äì Requests that the vector capacity be at least enough to contain n elements. Tao: after calling reverse(vec.begin(),vec.end()), vector vec is reversed. reverse() does not return a vector, it reverses the original vector.

// C++ program to illustrate the 
// capacity function in vector 
#include <iostream> 
#include <vector> 
  
using namespace std; 
  
int main() 
{ 
    vector<int> g1; 
  
    for (int i = 1; i <= 5; i++) 
        g1.push_back(i); 
  
    cout << "Size : " << g1.size(); 
    cout << "\nCapacity : " << g1.capacity(); 
    cout << "\nMax_Size : " << g1.max_size(); 
  
    // resizes the vector size to 4 
    g1.resize(4); 
  
    // prints the vector size after resize() 
    cout << "\nSize : " << g1.size(); 
  
    // checks if the vector is empty or not 
    if (g1.empty() == false) 
        cout << "\nVector is not empty"; 
    else
        cout << "\nVector is empty"; 
  
    // Shrinks the vector 
    g1.shrink_to_fit(); 
    cout << "\nVector elements are: "; 
    for (auto it = g1.begin(); it != g1.end(); it++) 
        cout << *it << " "; 
  
    return 0; 
} 

Output:
Size : 5
Capacity : 8
Max_Size : 4611686018427387903
Size : 4
Vector is not empty
Vector elements are: 1 2 3 4

Element access:

reference operator [g] ‚Äì Returns a reference to the element at position ‚Äòg‚Äô in the vector
at(g) ‚Äì Returns a reference to the element at position ‚Äòg‚Äô in the vector
front() ‚Äì Returns a reference to the first element in the vector
back() ‚Äì Returns a reference to the last element in the vector
data() ‚Äì Returns a direct pointer to the memory array used internally by the vector to store its owned elements.

// C++ program to illustrate the 
// element accesser in vector 
#include <bits/stdc++.h> 
using namespace std; 
  
int main() 
{ 
    vector<int> g1; 
  
    for (int i = 1; i <= 10; i++) 
        g1.push_back(i * 10); 
  
    cout << "\nReference operator [g] : g1[2] = " << g1[2]; 
  
    cout << "\nat : g1.at(4) = " << g1.at(4); 
  
    cout << "\nfront() : g1.front() = " << g1.front(); 
  
    cout << "\nback() : g1.back() = " << g1.back(); 
  
    // pointer to the first element 
    int* pos = g1.data(); 
  
    cout << "\nThe first element is " << *pos; 
    return 0; 
} 

Output:
Reference operator [g] : g1[2] = 30
at : g1.at(4) = 50
front() : g1.front() = 10
back() : g1.back() = 100
The first element is 10
Modifiers:

assign() ‚Äì It assigns new value to the vector elements by replacing old ones
push_back() ‚Äì It push the elements into a vector from the back
pop_back() ‚Äì It is used to pop or remove elements from a vector from the back.
insert() ‚Äì It inserts new elements before the element at the specified position. (tao: online example: v1.insert(v1.begin()+i, v2[i]))
erase() ‚Äì It is used to remove elements from a container from the specified position or range. (tao: online example: vec.erase(vec.begin() + 1))
swap() ‚Äì It is used to swap the contents of one vector with another vector of same type and size.
clear() ‚Äì It is used to remove all the elements of the vector container
emplace() ‚Äì It extends the container by inserting new element at position
emplace_back() ‚Äì It is used to insert a new element into the vector container, the new element is added to the end of the vector
.

// C++ program to illustrate the 
// Modifiers in vector 
#include <bits/stdc++.h> 
#include <vector> 
using namespace std; 
  
int main() 
{ 
    // Assign vector 
    vector<int> v; 
  
    // fill the array with 10 five times 
    v.assign(5, 10); 
  
    cout << "The vector elements are: "; 
    for (int i = 0; i < v.size(); i++) 
        cout << v[i] << " "; 
  
    // inserts 15 to the last position 
    v.push_back(15); 
    int n = v.size(); 
    cout << "\nThe last element is: " << v[n - 1]; 
  
    // removes last element 
    v.pop_back(); 
  
    // prints the vector 
    cout << "\nThe vector elements are: "; 
    for (int i = 0; i < v.size(); i++) 
        cout << v[i] << " "; 
  
    // inserts 5 at the beginning 
    v.insert(v.begin(), 5); 
  
    cout << "\nThe first element is: " << v[0]; 
  
    // removes the first element 
    v.erase(v.begin()); 
  
    cout << "\nThe first element is: " << v[0]; 
  
    // inserts at the beginning 
    v.emplace(v.begin(), 5); 
    cout << "\nThe first element is: " << v[0]; 
  
    // Inserts 20 at the end 
    v.emplace_back(20); 
    n = v.size(); 
    cout << "\nThe last element is: " << v[n - 1]; 
  
    // erases the vector 
    v.clear(); 
    cout << "\nVector size after erase(): " << v.size(); 
  
    // two vector to perform swap 
    vector<int> v1, v2; 
    v1.push_back(1); 
    v1.push_back(2); 
    v2.push_back(3); 
    v2.push_back(4); 
  
    cout << "\n\nVector 1: "; 
    for (int i = 0; i < v1.size(); i++) 
        cout << v1[i] << " "; 
  
    cout << "\nVector 2: "; 
    for (int i = 0; i < v2.size(); i++) 
        cout << v2[i] << " "; 
  
    // Swaps v1 and v2 
    v1.swap(v2); 
  
    cout << "\nAfter Swap \nVector 1: "; 
    for (int i = 0; i < v1.size(); i++) 
        cout << v1[i] << " "; 
  
    cout << "\nVector 2: "; 
    for (int i = 0; i < v2.size(); i++) 
        cout << v2[i] << " "; 
} 

Output:
The vector elements are: 10 10 10 10 10 
The last element is: 15
The vector elements are: 10 10 10 10 10 
The first element is: 5
The first element is: 10
The first element is: 5
The last element is: 20
Vector size after erase(): 0

Vector 1: 1 2 
Vector 2: 3 4 
After Swap 
Vector 1: 3 4 
Vector 2: 1 2

==
(findunorderedcontainers)
Unordered associative containers

From the book:
The new standard defines four unordered associative containers.

From wikipedia:

unordered_set (C++11) 
unordered_map (C++11) 
unordered_multiset (C++11) 
unordered_multimap (C++11)

The containers are defined in headers named after the names of the containers, e.g., unordered_set is defined in header <unordered_set>. All containers satisfy the requirements of the Container concept, which means they have begin(), end(), size(), max_size(), empty(), and swap() methods.

==
(findunorderedset)
unordered_set

Tao's impression: the functions of unordered_set are the same as set.

#include <iostream>
#include <unordered_set>
#include <algorithm>

From geeksforgeeks:

unorderd_set in C++ STL
unordered_set is implemented using hash table where keys are hashed into indices of this hash table so it is not possible to maintain an order. All operation on unordered_set takes constant time O(1) on an average which can go up to linear time in worst case which depends on the internally used hash function but practically they perform very well and generally provide constant time lookup operation.
The unordered-set can contain key of any type ‚Äì predefined or user-defined data structure but when we define key of type user define type, we need to specify our comparison function according to which keys will be compared.

set vs unordered_set
Set set is an ordered sequence of unique keys whereas unordered_set is a set in which key can be stored in any order, so unordered.
Set is implemented as balanced tree structure that is why it is possible to maintain an order between the elements (by specific tree traversal). Time complexity of set operations is O(Log n) while for unordered_set, it is O(1).

Methods on unordered_set
For unordered_set many function are defined among which most useful are size and empty for capacity, find for searching a key, insert and erase for modification.
The Unordered_set allows only unique keys, for duplicate keys unordered_multiset should be used.

Example of declaration, find, insert and iteration in unordered_set is given below :

// C++ program to demonstrate various function of unordered_set 
#include <bits/stdc++.h> 
using namespace std; 
  
int main() 
{ 
    // declaring set for storing string data-type 
    unordered_set<string> stringSet; 
  
    // inserting various string, same string will be stored 
    // once in set 
    stringSet.insert("code"); 
    stringSet.insert("in"); 
    stringSet.insert("c++"); 
    stringSet.insert("is"); 
    stringSet.insert("fast"); 
  
    string key = "slow"; 
  
    //     find returns end iterator if key is not found, 
    //  else it returns iterator to that key 
    if (stringSet.find(key) == stringSet.end()) 
        cout << key << " not found\n\n"; 
    else
        cout << "Found " << key << endl << endl; 
  
    key = "c++"; 
    if (stringSet.find(key) == stringSet.end()) 
        cout << key << " not found\n"; 
    else
        cout << "Found " << key << endl; 
  
    // now iterating over whole set and printing its 
    // content 
    cout << "\nAll elements : "; 
    unordered_set<string> :: iterator itr; 
    for (itr = stringSet.begin(); itr != stringSet.end(); itr++) 
        cout << (*itr) << endl; 
} 

==
(findset)
set

From geeksforgeeks:

Functions associated with Set:

pair <iterator, bool> insert(const g) ‚Äì Adds a new element ‚Äòg‚Äô to the set
find(const g) ‚Äì Returns an iterator to the element ‚Äòg‚Äô in the set if found, else returns the iterator to end
begin() ‚Äì Returns an iterator to the first element in the set
end() ‚Äì Returns an iterator to the theoretical element that follows last element in the set

size() ‚Äì Returns the number of elements in the set
empty() ‚Äì Returns whether the set is empty

iterator insert (iterator position, const g) ‚Äì Adds a new element ‚Äòg‚Äô at the position pointed by iterator
max_size() ‚Äì Returns the maximum number of elements that the set can hold
erase(iterator position) ‚Äì Removes the element at the position pointed by the iterator
erase(const g)- Removes the value ‚Äòg‚Äô from the set
clear() ‚Äì Removes all the elements from the set
key_comp() / value_comp() ‚Äì Returns the object that determines how the elements in the set are ordered (‚Äò<‚Äò by default)
count(const g) ‚Äì Returns 1 or 0 based on the element ‚Äòg‚Äô is present in the set or not.
lower_bound(const g) ‚Äì Returns an iterator to the first element that is equivalent to ‚Äòg‚Äô or definitely will not go before the element ‚Äòg‚Äô in the set
upper_bound(const g) ‚Äì Returns an iterator to the first element that is equivalent to ‚Äòg‚Äô or definitely will go after the element ‚Äòg‚Äô in the set

Example:

#include <iostream> 
#include <set> 
#include <iterator> 
  
using namespace std; 
  
int main() 
{ 
    // empty set container 
    set <int, greater <int> > gquiz1;         
  
    // insert elements in random order 
    gquiz1.insert(40); 
    gquiz1.insert(30); 
    gquiz1.insert(60); 
    gquiz1.insert(20); 
    gquiz1.insert(50); 
    gquiz1.insert(50); // only one 50 will be added to the set 
    gquiz1.insert(10); 
  
    // printing set gquiz1 
    set <int, greater <int> > :: iterator itr; 
    cout << "\nThe set gquiz1 is : "; 
    for (itr = gquiz1.begin(); itr != gquiz1.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
    cout << endl; 
  
    // assigning the elements from gquiz1 to gquiz2 
    set <int> gquiz2(gquiz1.begin(), gquiz1.end()); 
  
    // print all elements of the set gquiz2 
    cout << "\nThe set gquiz2 after assign from gquiz1 is : "; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
    cout << endl; 
  
    // remove all elements up to 30 in gquiz2 
    cout << "\ngquiz2 after removal of elements less than 30 : "; 
    gquiz2.erase(gquiz2.begin(), gquiz2.find(30)); 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
  
    // remove element with value 50 in gquiz2 
    int num; 
    num = gquiz2.erase (50); 
    cout << "\ngquiz2.erase(50) : "; 
    cout << num << " removed \t" ; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout << '\t' << *itr; 
    } 
  
    cout << endl; 
  
    //lower bound and upper bound for set gquiz1 
    cout << "gquiz1.lower_bound(40) : "
         << *gquiz1.lower_bound(40) << endl; 
    cout << "gquiz1.upper_bound(40) : "
         << *gquiz1.upper_bound(40) << endl; 
  
    //lower bound and upper bound for set gquiz2 
    cout << "gquiz2.lower_bound(40) : "
         << *gquiz2.lower_bound(40) << endl; 
    cout << "gquiz2.upper_bound(40) : "
         << *gquiz2.upper_bound(40) << endl; 
  
    return 0; 
  
} 

==
(findunorderedmap)
unordered_map

Tao's impression: the functions of unordered_map are the same as map.

From geeksforgeeks:

unordered_map in C++ STL
unordered_map is an associated container that stores elements formed by combination of key value and a mapped value. The key value is used to uniquely identify the element and mapped value is the content associated with the key. Both key and value can be of any type predefined or user-defined.

Internally unordered_map is implemented using Hash Table, the key provided to map are hashed into indices of hash table that is why performance of data structure depends on hash function a lot but on an average the cost of search, insert and delete from hash table is O(1).

// C++ program to demonstrate functionality of unordered_map 
#include <iostream> 
#include <unordered_map> 
using namespace std; 
  
int main() 
{ 
    // Declaring umap to be of <string, int> type 
    // key will be of string type and mapped value will 
    // be of double type 
    unordered_map<string, int> umap; 
  
    // inserting values by using [] operator 
    umap["GeeksforGeeks"] = 10; 
    umap["Practice"] = 20; 
    umap["Contribute"] = 30; 
  
    // Traversing an unordered map 
    for (auto x : umap) 
      cout << x.first << " " << x.second << endl; 
  
} 

==
(findmap)
map

Tao: the simplest way to insert into a map is the same as Python (ie, same way as updating an existing element value), no need to use insert function. At least two people in leetcode discussion did in this way.

unordered_map<Node*, Node*> mp;
Node* copy = new Node(node -> label);
mp[node] = copy;

From geeksforgeeks:

Functions associated with Map:

find(const g) ‚Äì Returns an iterator to the element with key value ‚Äòg‚Äô in the map if found, else returns the iterator to end
begin() ‚Äì Returns an iterator to the first element in the map
end() ‚Äì Returns an iterator to the theoretical element that follows last element in the map

size() ‚Äì Returns the number of elements in the map
empty() ‚Äì Returns whether the map is empty

pair insert(keyvalue,mapvalue) ‚Äì Adds a new element to the map
max_size() ‚Äì Returns the maximum number of elements that the map can hold
erase(iterator position) ‚Äì Removes the element at the position pointed by the iterator
erase(const g)‚Äì Removes the key value ‚Äòg‚Äô from the map
clear() ‚Äì Removes all the elements from the map
key_comp() / value_comp() ‚Äì Returns the object that determines how the elements in the map are ordered (‚Äò<' by default)
count(const g) ‚Äì Returns the number of matches to element with key value ‚Äòg‚Äô in the map
lower_bound(const g) ‚Äì Returns an iterator to the first element that is equivalent to mapped value with key value ‚Äòg‚Äô or definitely will not go before the element with key value ‚Äòg‚Äô in the map
upper_bound(const g) ‚Äì Returns an iterator to the first element that is equivalent to mapped value with key value ‚Äòg‚Äô or definitely will go after the element with key value ‚Äòg‚Äô in the map


Example:

#include <iostream> 
#include <map> 
#include <iterator> 
  
using namespace std; 
  
int main() 
{ 
    map <int, int> gquiz1;        // empty map container 
  
    // insert elements in random order 
    gquiz1.insert(pair <int, int> (1, 40)); 
    gquiz1.insert(pair <int, int> (2, 30)); 
    gquiz1.insert(pair <int, int> (3, 60)); 
    gquiz1.insert(pair <int, int> (4, 20)); 
    gquiz1.insert(pair <int, int> (5, 50)); 
    gquiz1.insert(pair <int, int> (6, 50));  
    gquiz1.insert(pair <int, int> (7, 10)); 
  
    // printing map gquiz1 
    map <int, int> :: iterator itr; 
    cout << "\nThe map gquiz1 is : \n"; 
    cout << "\tKEY\tELEMENT\n"; 
    for (itr = gquiz1.begin(); itr != gquiz1.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
    cout << endl; 
  
    // assigning the elements from gquiz1 to gquiz2 
    map <int, int> gquiz2(gquiz1.begin(), gquiz1.end()); 
  
    // print all elements of the map gquiz2 
    cout << "\nThe map gquiz2 after assign from gquiz1 is : \n"; 
    cout << "\tKEY\tELEMENT\n"; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
    cout << endl; 
  
    // remove all elements up to element with key=3 in gquiz2 
    cout << "\ngquiz2 after removal of elements less than key=3 : \n"; 
    cout << "\tKEY\tELEMENT\n"; 
    gquiz2.erase(gquiz2.begin(), gquiz2.find(3)); 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
  
    // remove all elements with key = 4 
    int num; 
    num = gquiz2.erase (4); 
    cout << "\ngquiz2.erase(4) : "; 
    cout << num << " removed \n" ; 
    cout << "\tKEY\tELEMENT\n"; 
    for (itr = gquiz2.begin(); itr != gquiz2.end(); ++itr) 
    { 
        cout  <<  '\t' << itr->first  
              <<  '\t' << itr->second << '\n'; 
    } 
  
    cout << endl; 
  
    //lower bound and upper bound for map gquiz1 key = 5 
    cout << "gquiz1.lower_bound(5) : " << "\tKEY = "; 
    cout << gquiz1.lower_bound(5)->first << '\t'; 
    cout << "\tELEMENT = " << gquiz1.lower_bound(5)->second << endl; 
    cout << "gquiz1.upper_bound(5) : " << "\tKEY = "; 
    cout << gquiz1.upper_bound(5)->first << '\t'; 
    cout << "\tELEMENT = " << gquiz1.upper_bound(5)->second << endl; 
      
    return 0; 
  
} 

==
(findstack)
stack

From geeksforgeeks:

The functions associated with stack are:

push(g) ‚Äì Adds the element ‚Äòg‚Äô at the top of the stack ‚Äì Time Complexity : O(1)
top() ‚Äì Returns a reference to the top most element of the stack ‚Äì Time Complexity : O(1)
pop() ‚Äì Deletes the top most element of the stack ‚Äì Time Complexity : O(1)

empty() ‚Äì Returns whether the stack is empty ‚Äì Time Complexity : O(1)
size() ‚Äì Returns the size of the stack ‚Äì Time Complexity : O(1)


Example:

// CPP program to demonstrate working of STL stack 
#include <iostream> 
#include <stack> 
using namespace std; 
  
void showstack(stack <int> s) 
{ 
    while (!s.empty()) 
    { 
        cout << '\t' << s.top(); 
        s.pop(); 
    } 
    cout << '\n'; 
} 
  
int main () 
{ 
    stack <int> s; 
    s.push(10); 
    s.push(30); 
    s.push(20); 
    s.push(5); 
    s.push(1); 
  
    cout << "The stack is : "; 
    showstack(s); 
  
    cout << "\ns.size() : " << s.size(); 
    cout << "\ns.top() : " << s.top(); 
  
  
    cout << "\ns.pop() : "; 
    s.pop(); 
    showstack(s); 
  
    return 0; 
} 

==
(findqueue)
queue

From geeksforgeeks:

The functions supported by queue are :

push(g) ‚Äì Adds the element ‚Äòg‚Äô at the end of the queue
front() ‚Äì Returns a reference to the first element of the queue
pop() ‚Äì Deletes the first element of the queue

back() ‚Äì Returns a reference to the last element of the queue

empty() ‚Äì Returns whether the queue is empty
size() ‚Äì Returns the size of the queue

Example:

// CPP code to illustrate  
// Queue in Standard Template Library (STL) 
#include <iostream> 
#include <queue> 
  
using namespace std; 
  
void showq(queue <int> gq) 
{ 
    queue <int> g = gq; 
    while (!g.empty()) 
    { 
        cout << '\t' << g.front(); 
        g.pop(); 
    } 
    cout << '\n'; 
} 
  
int main() 
{ 
    queue <int> gquiz; 
    gquiz.push(10); 
    gquiz.push(20); 
    gquiz.push(30); 
  
    cout << "The queue gquiz is : "; 
    showq(gquiz); 
  
    cout << "\ngquiz.size() : " << gquiz.size(); 
    cout << "\ngquiz.front() : " << gquiz.front(); 
    cout << "\ngquiz.back() : " << gquiz.back(); 
  
    cout << "\ngquiz.pop() : "; 
    gquiz.pop(); 
    showq(gquiz); 
  
    return 0; 
}

==
(findpriorityqueue)
priority_queue

From geeksforgeeks:

The functions associated with priority queue are:

push(g) ‚Äì Adds the element ‚Äòg‚Äô at the end of the queue
top() ‚Äì Returns a reference to the top most element of the queue
pop() ‚Äì Deletes the first element of the queue

empty() ‚Äì Returns whether the queue is empty
size() ‚Äì Returns the size of the queue

Example:

#include <iostream> 
#include <queue> 
  
using namespace std; 
  
void showpq(priority_queue <int> gq) 
{ 
    priority_queue <int> g = gq; 
    while (!g.empty()) 
    { 
        cout << '\t' << g.top(); 
        g.pop(); 
    } 
    cout << '\n'; 
} 
  
int main () 
{ 
    priority_queue <int> gquiz; 
    gquiz.push(10); 
    gquiz.push(30); 
    gquiz.push(20); 
    gquiz.push(5); 
    gquiz.push(1); 
  
    cout << "The priority queue gquiz is : "; 
    showpq(gquiz); 
  
    cout << "\ngquiz.size() : " << gquiz.size(); 
    cout << "\ngquiz.top() : " << gquiz.top(); 
  
  
    cout << "\ngquiz.pop() : "; 
    gquiz.pop(); 
    showpq(gquiz); 
  
    return 0; 
} 

==
(finddeque)
(finddequeue)
deque

Tao's summary:

#include <deque> 
deque<int> gquiz; 
gquiz.push_back(10); 
gquiz.push_front(20); 
ngquiz.front();
ngquiz.back();
ngquiz.pop_front();
ngquiz.pop_back();
ngquiz.clear();
ngquiz.erase();

1. dequename.erase(position)
2. dequename.erase(startingposition, endingposition)

Examples:

Input: mydeque{1, 2, 3, 4, 5}, pos= 2
mydeque.erase(pos);
Output : 1, 2, 4, 5

Input: mydeque{1, 2, 3, 4, 5, 6, 7, 8}, pos1= 3, pos2= 6
mydeque.erase(pos1, pos2);
Output : 1, 2, 3, 8

--
From geeksforgeeks:

Double ended queues are sequence containers with the feature of expansion and contraction on both the ends. They are similar to vectors, but are more efficient in case of insertion and deletion of elements at the end, and also the beginning. Unlike vectors, contiguous storage allocation may not be guaranteed.

The functions for deque are same as vector, with an addition of push and pop operations for both front and back.

#include <iostream> 
#include <deque> 
  
using namespace std; 
  
void showdq(deque <int> g) 
{ 
    deque <int> :: iterator it; 
    for (it = g.begin(); it != g.end(); ++it) 
        cout << '\t' << *it; 
    cout << '\n'; 
} 
  
int main() 
{ 
    deque <int> gquiz; 
    gquiz.push_back(10); 
    gquiz.push_front(20); 
    gquiz.push_back(30); 
    gquiz.push_front(15); 
    cout << "The deque gquiz is : "; 
    showdq(gquiz); 
  
    cout << "\ngquiz.size() : " << gquiz.size(); 
    cout << "\ngquiz.max_size() : " << gquiz.max_size(); 
  
    cout << "\ngquiz.at(2) : " << gquiz.at(2); 
    cout << "\ngquiz.front() : " << gquiz.front(); 
    cout << "\ngquiz.back() : " << gquiz.back(); 
  
    cout << "\ngquiz.pop_front() : "; 
    gquiz.pop_front(); 
    showdq(gquiz); 
  
    cout << "\ngquiz.pop_back() : "; 
    gquiz.pop_back(); 
    showdq(gquiz); 
  
    return 0;

The output of the above program is :

The deque gquiz is :     15    20    10    30

gquiz.size() : 4
gquiz.max_size() : 4611686018427387903
gquiz.at(2) : 10
gquiz.front() : 15
gquiz.back() : 30
gquiz.pop_front() :     20    10    30

gquiz.pop_back() :     20    10

Methods of Deque:

deque insert() function in C++ STL: Returns an iterator that points to the first of the newly inserted elements.
deque rbegin() function in C++ STL: Returns a reverse iterator which points to the last element of the deque (i.e., its reverse beginning).
deque rend() function in C++ STL: Returns a reverse iterator which points to the position before the beginning of the deque (which is considered its reverse end).
deque cbegin() in C++ STL: Returns an iterator pointing to the first element of the container.
deque max_size() function in C++ STL: Returns the maximum number of elements that a deque container can hold.
deque assign() function in C++ STL: Assign values to the same or different deque container.
deque resize() function in C++ STL: Function which changes the size of the deque.
deque::push_front() in C++ STL: This function is used to push elements into a deque from the front.
deque::push_back() in C++ STL: This function is used to push elements into a deque from the back.
deque::pop_front() and deque::pop_back() in C++ STL: pop_front() function is used to pop or remove elements from a deque from the front. pop_back() function is used to pop or remove elements from a deque from the back.
deque::front() and deque::back() in C++ STL: front() function is used to reference the first element of the deque container. back() function is used to reference the last element of the deque container.
deque::clear() and deque::erase() in C++ STL: clear() function is used to remove all the elements of the deque container, thus making its size 0. erase() function is used to remove elements from a container from the specified position or range.
deque::empty() and deque::size() in C++ STL: empty() function is used to check if the deque container is empty or not. size() function is used to return the size of the deque container or the number of elements in the deque container.
deque::operator= and deque::operator[] in C++ STL:
operator= operator is used to assign new contents to the container by replacing the existing contents. operator[] operator is used to reference the element present at position given inside the operator.
deque::at() and deque::swap() in C++ STL: at() function is used reference the element present at the position given as the parameter to the function. swap() function is used to swap the contents of one deque with another deque of same type and size.
deque::begin() and deque::end in C++ STL: begin() function is used to return an iterator pointing to the first element of the deque container. end() function is used to return an iterator pointing to the last element of the deque container.
deque::emplace_front() and deque::emplace_back() in C++ STL: emplace_front() function is used to insert a new element into the deque container, the new element is added to the beginning of the deque. emplace_back() function is used to insert a new element into the deque container, the new element is added to the end of the deque.

==
(finditerator)
iterator

Although we can use subscripts to access the characters of a string or the elements in a vector, there is a more general mechanism‚Äîknown as iterators‚Äîthat we can use for the same purpose. 

In addition to vector, the library defines several other kinds of containers. All of the library containers have iterators, but only a few of them support the subscript operator.

Like pointers, iterators give us indirect access to an object. In the case of an iterator, that object is an element in a container or a character in a string.

Types that have iterators have members that return iterators. In particular, these types have members named begin and end. The begin member returns an iterator that denotes the first element (or first character).

auto b = v.begin(), e = v.end(); //Note that auto is C++11

The iterator returned by end is an iterator positioned ‚Äúone past the end‚Äù of the associated container (or string). This iterator denotes a nonexistent element ‚Äúoff the end‚Äù of the container. It is used as a marker indicating when we have processed all the elements. The iterator returned by end is often referred to as the off-the-end iterator or abbreviated as ‚Äúthe end iterator.‚Äù If the container is empty, begin returns the same iterator as the one returned by end.

Iterators support only a few operations, which are listed below (tao: these operations are very similar to pointers):

(In the folllowng, an example of iter is: auto iter = v.begin())
*iter //Returns a reference to the element denoted by the iterator iter.
iter->mem //Dereferences iter and fetches the memeber named mem from the underlying element. Equivalent to (*iter).mem
++iter //Increments iter to refer to the next element in the container.
--iter //Decrements iter to refer to the previous element in the container.
iter1 == iter2 //Two iterators are equal if they denote the same element or if they are the off-the-end iterator for the same container.
iter1 != iter2
iter + n // Adding (substracting) an integral value n to (from) an iterator yields an iterator that many elements forward (backward) within the container.
iter - n
iter += n
iter -= n
iter1 - iter2 //Returns the distance between the iterators. The result type is a signed integral type named difference_type. Both vector and string define difference_type. This type is signed, because subtraction might have a negative result.
iter1 <= iter2 //One iterator is less than another if it refers to an element that appears in the container before the one referred to by the other iterator.

Example: capitalize the first character of a string:

string s("some string");
if (s.begin() != s.end()) { // make sure s is not empty
    auto it = s.begin(); // it denotes the first character in s
    *it = toupper(*it); // make that character uppercase, tao: note the characters in a string can be changed in C++
}

Example: capitalize the first word in a string:

for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
    *it = toupper(*it); // capitalize the current character

Programmers coming to C++ from C or Java might be surprised that we used != rather than < in our for loops. C++ programmers use != as a matter of habit. They do so for the same reason that they use iterators rather than subscripts: This coding style applies equally well to various kinds of containers provided by the library. As we‚Äôve seen, only a few library types, vector and string being among them, have the subscript operator. Similarly, all of the library containers have iterators that define the == and != operators. Most of those iterators do not have the < operator. By routinely using iterators and !=, we don‚Äôt have to worry about the precise type of container we‚Äôre processing.

As with size_type, the library types that have iterators define types named iterator and const_iterator that represent actual iterator types:

vector<int>::iterator it; // it can read and write vector<int> elements
string::iterator it2; // it2 can read and write characters in a string
vector<int>::const_iterator it3; // it3 can read but not write elements
string::const_iterator it4; // it4 can read but not write characters

A const_iterator behaves like a const pointer. Like a const pointer, a const_iterator may read but not write the element it denotes; an object of type iterator can both read and write. If a vector or string is const, we may use only its const_iterator type. With a nonconst vector or string, we can use either iterator or const_iterator.

The type returned by begin and end depends on whether the object on which they operator is const. If the object is const, then begin and end return a const_iterator; if the object is not const, they return iterator:

vector<int> v;
const vector<int> cv;
auto it1 = v.begin(); // it1 has type vector<int>::iterator
auto it2 = cv.begin(); // it2 has type vector<int>::const_iterator

It is important to realize that loops that use iterators should not add elements to the container to which the iterators refer.

==
(findarray)
array

int a[10]; // array of 10 ints. The elements are default initialized.
int a[3] = {0,1,2};
int a[] = {0,1,2};
unsigned scores[11] = {}; // 11 buckets, all value initialized to 0
int *p = a;

int arr[3][4];
int arr[2][3] = {{1,2},{3,4},{5,6}};

Fill in an array with the same values:
int arr[5];
std::fill_n(arr, 5, 2); //Now arr = {2, 2, 2, 2, 2}

As in the case of string or vector, it is best to use a range for when we want to traverse the entire array.

for (auto i : scores)
    cout << i << " ";  

--
tao: practice shows that the type of the array size can be int, but it should be const:
const int aSize = 3;
char a[aSize] = {'A', 'B', 'C'};

The number of elements in an array is part of the array‚Äôs type. As a result, the dimension must be known at compile time, which means that the dimension must be a constant expression. 

Because arrays have fixed size, they sometimes offer better run-time performance for specialized applications. However, that run-time advantage comes at the cost of lost flexibility.

Tao: in C++, there is no function to find array size (different from Java). So if need to use size, should not use array in the beginning, use vector instead. <- Confirmed later from online (including recommending using vector). If you must use the size of an array, you can do it as below:

int num_files = sizeof(file_names) / sizeof(file_names[0]);

Character arrays have an additional form of initialization: We can initialize such arrays from a string literal. When we use this form of initialization, it is important to remember that string literals end with a null character. That null character is copied into the array along with the characters in the literal:

char a1[] = {'C', '+', '+'}; // size = 3. 
char a2[] = {'C', '+', '+', '\0'}; // size = 4
char a3[] = "C++"; // size = 4, null terminator added automatically

--
When we use a variable to subscript an array, we normally should define that variable to have type size_t. size_t is a machine-specific unsigned type that is guaranteed to be large enough to hold the size of any object in memory. The size_t type is defined in the cstddef header.


--
Although we can compute an off-the-end pointer, doing so is error-prone. To make it easier and safer to use pointers, the new library includes two functions, named begin and end.

int *beg = begin(ia); // pointer to the first element in ia
int *last = end(ia);  // pointer one past the last element in ia

These functions are defined in the iterator header.

A pointer ‚Äúone past‚Äù the end of a built-in array behaves the same way as the iterator returned by the end operation of a vector.

As with iterators, subtracting two pointers gives us the distance between those pointers. 

The result of subtracting two pointers is a library type named ptrdiff_t. Like size_t,the ptrdiff_t type is a machine-specific type and is defined in the cstddef header. Because subtraction might yield a negative distance, ptrdiff_t is a signed integral type.

We can use the subscript operator on any pointer, as long as that pointer points to an element (or one past the last element) in an array:

int *p = &ia[2];  // p points to the element indexed by 2
int j = p[1];     // p[1] is equivalent to *(p + 1),
                  // p[1] is the same element as ia[3]
int k = p[-2];    // p[-2] is the same element as ia[0]

--
string *p = &nums[0];   // p points to the first element in nums

When we use an array, the compiler automatically substitutes a pointer to the first element:

string *p2 = nums;      // equivalent to p2 = &nums[0]

when we use an array as an
initializer for a variable defined using auto (¬ß 2.5.2, p. 68), the deduced type is a
pointer, not an array:

int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia is an array of ten ints
auto ia2(ia); // ia2 is an int* that points to the first element in ia

It is worth noting that this conversion does not happen when we use decltype. The type returned by decltype(ia) is array of ten ints:

decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9}; //Tao: decltype(ia) returns a type name
ia3[4] = i; // ok: assigns the value of i to an element in ia3

Pointers to array elements support the same operations as iterators on vectors or strings. For example, we can use the increment operator to move from one element in an array to the next:
  
int arr[] = {0,1,2,3,4,5,6,7,8,9};
int *p = arr; // p points to the first element in arr
++p;          // p points to arr[1]

--
Using an Array to Initialize a vector
 
We noted that we cannot initialize a built-in array from another array. Nor can we initialize an array from a vector. However, we can use an array to initialize a vector. To do so, we specify the address of the first element and one past the last element that we wish to copy:

int int_arr[] = {0, 1, 2, 3, 4, 5};
vector<int> ivec(begin(int_arr), end(int_arr));

The specified range can be a subset of the array:
vector<int> subVec(int_arr + 1, int_arr + 4);

--
Modern C++ programs should use vectors and iterators instead of built-in arrays and pointers, and use strings rather than C-style array-based character strings.

--
Multidimensional Arrays

Strictly speaking, there are no multidimensional arrays in C++. What are commonly referred to as multidimensional arrays are actually arrays of arrays.

int ia[3][4]; // array of size 3; each element is an array of ints of size 4

int arr[10][20][30] = {0}; // initialize all elements to 0

In a two-dimensional array, the first dimension is usually referred to as the row and the second as the column.

Multidimensional arrays may be initialized by specifying bracketed values for each row:

int ia[3][4] = {    
    {0, 1, 2, 3},   
    {4, 5, 6, 7},   
    {8, 9, 10, 11}  
};

The nested braces are optional. The following initialization is equivalent, although considerably less clear:

int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};

Under the new standard we can simplify the previous loop by using a range for:

size_t cnt = 0;

for (auto &row : ia)        
    for (auto &col : row) { 
        col = cnt;          
        ++cnt;            
    }

In the previous example, we used references as our loop control variables because we wanted to change the elements in the array. However, there is a deeper reason for using references.

Had we neglected the reference and written these loops as:
 
for (auto row : ia)
    for (auto col : row)
 
our program would not compile. As before, the first for iterates through ia, whose elements are arrays of size 4. As a result, in this loop the type of row is int*. The inner for loop is illegal, it attempts to iterate over an int*

As with any array, when we use the name of a multidimensional array, it is automatically converted to a pointer to the first element in the array (tao: note this is not an actual element, but an inner array):

int ia[3][4]
int (*p)[4] = ia; // p points to an array of four ints

The result of *p is an array of four ints. As usual, when we use an array, it is converted automatically to a pointer to its first element.

--
Return array from function

Tao: practice shows that we should do the following even returning an element from a local array:

bool *res = new bool[5]; //Correct way
// bool res[5]; <- wrong way, returned res[2] value will be random
return res[2];

From geeksforgeeks:

How to return a local array from a C/C++ function?

Consider the below C++ program. Is it right way of returning array from a function?

brightness_4
#include<iostream> 
using namespace std; 
  
int *fun() 
{ 
   int arr[100]; 
  
   /* Some operations on arr[] */
   arr[0] = 10; 
   arr[1] = 20; 
     
   return arr; 
} 
  
int main() 
{ 
    int *ptr = fun(); 
    cout << ptr[0] << " " << ptr[1]; 
    return 0; 
} 

In function 'int* fun()':
6:8: warning: address of local variable 'arr' returned [-Wreturn-local-addr]
    int arr[100];
        ^
The above program is WRONG. It may produce values 10 20 as output or may produce garbage values or may crash. The problem is, we return address of a local variable which is not advised as local variables may not exist in memory after function call is over.

Following are some correct ways of returning array:

Using Dynamically Allocated Array :

Dynamically allocated memory (allocated using new or malloc()) remains their until we delete it using delete or free(). So we can create a dynamically allocated array and we can delete it once we come out of function.

#include<iostream> 
using namespace std; 
  
int *fun() 
{ 
   int *arr = new int[100]; 
  
   /* Some operations on arr[] */
   arr[0] = 10; 
   arr[1] = 20; 
     
   return arr; 
} 
  
int main() 
{ 
    int *ptr = fun(); 
    cout << ptr[0] << " " << ptr[1]; 
    return 0; 
} 

Output :

10 20

Using static array:

Lifetime of a static variable is throughout the program. So we can always create a local static array and return it.

#include<iostream> 
using namespace std; 
  
int *fun() 
{ 
   static int arr[100]; 
  
   /* Some operations on arr[] */
   arr[0] = 10; 
   arr[1] = 20; 
     
   return arr; 
} 
  
int main() 
{ 
    int *ptr = fun(); 
    cout << ptr[0] << " " << ptr[1]; 
    return 0; 
} 

Output :

10 20

Using struct:

We can wrap array in a structure/class and return an instance of the struct/class. The reason for this work is, array members of structures are deeply copied. In below program deep copy happens when we returned instance is copied in main.

#include<iostream> 
using namespace std; 
  
struct arrWrap 
{ 
   int arr[100]; 
}; 
  
struct arrWrap fun() 
{ 
   struct arrWrap x; 
  
   x.arr[0] = 10; 
   x.arr[1] = 20; 
     
   return x; 
} 
  
int main() 
{ 
   struct arrWrap x = fun(); 
   cout << x.arr[0] << " " << x.arr[1]; 
   return 0; 
} 

Output :

10 20

==
(findoperator)
(findand)
Operators

Logical operators:
AND: &&
OR:  ||
NOT: !

--
Bitwise operators:
AND: &
OR:  |
XOR: ^ (a^b is equivalent to a != b)
NOT: ~ (eg: ~expr) 
Left shift: << (eg: expr1 << expr2)
Right shift: >> (eg: expr1 >> expr2)

The left-shift operator (the << operator) inserts 0-valued bits on the right. The behavior of the right-shift operator (the >> operator) depends on the type of the left-hand operand: If that operand is unsigned, then the operator inserts 0-valued bits on the left; if it is a signed type, the result is implementation defined‚Äîeither copies of the sign bit or 0-valued bits are inserted on the left.

The bitwise NOT operator (the ~ operator) generates a new value with the bits of its operand inverted. Each 1 bit is set to 0; each 0 bit is set to 1.

Because there are no guarantees for how the sign bit is handled, we strongly recommend using unsigned types with the bitwise operators.

Overloaded versions of these operators for IO: 
cout << "Helo" << endl;

--
Remainder (modulus) operator: %

--
Compound assignments:
+=   -=   *=   /=   %=   (arithmetic operators)
<<=  >>=   &=   ^=   |=  (bitwise operators)

--
Order of Evaluation

Rember: ->|

--
Lvalues and Rvalues

Every expression in C++ is either an rvalue or an lvalue. lvalues could stand on the left-hand side of an assignment whereas rvalues could not. In C++, the distinction is less simple. Roughly speaking, when we use an object as an rvalue, we use the object‚Äôs value (its contents). When we use an object as an lvalue, we use
the object‚Äôs identity (its location in memory).

--
In assignment, if the types of the left and right operands differ, the right-hand operand is converted to the type of the left.

--
(findincrement)
(finddecrement)
(find++)
(find--)
The increment (++) and decrement (--) operators

int i = 0;
++i; // i = 1. Prefix returns new value 1 (remeber: ee)
i++; // i = 1. Postfix returns old value 0 (remember: oo)

Readers from a C background might be surprised that we use the prefix increment in the programs we‚Äôve written. The reason is simple: The prefix version avoids unnecessary work. It increments the value and returns the incremented version. The postfix operator must store the original value so that it can return the unincremented value as its result. If we don‚Äôt need the
unincremented value, there‚Äôs no need for the extra work done by the postfix operator.

--
p->size() is equivalent to (*p).size()

--
(findsizeof)
sizeof

The sizeof operator returns the size, in bytes, of an expression or a type name. The result of sizeof is a constant expression of type size_t. The operator takes one of two forms:
 
sizeof (type)
sizeof expr
 
In the second form, sizeof returns the size of the type returned by the given expression. The sizeof operator is unusual in that it does not evaluate its operand:

sizeof an array is the size of the entire array. It is equivalent to taking the sizeof the element type times the number of elements in the array. Note that sizeof does not convert the array to a pointer.

sizeof a string or a vector returns only the size of the fixed part of these types; it does not return the size used by the object‚Äôs elements. Tao's understanding: think of how vector and string is implememted using array and doubles its size when reached maximum, sizeof only takes the fixed part and may not return the correct size of a vector or string.

Example:

constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr2[sz];  // ok sizeof returns a constant expression 

Because sizeof returns a constant expression, we can use the result of a sizeof expression to specify the dimension of an array.

==
(commaoperator)
Comma operator

The comma operator takes two operands, which it evaluates from left to right. Like
the logical AND and logical OR and the conditional operator, the comma operator
guarantees the order in which its operands are evaluated.

The left-hand expression is evaluated and its result is discarded. The result of a
comma expression is the value of its right-hand expression.

Example:

for(vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt)
ivec[ix] = cnt;

This loop increments ix and decrements cnt in the expression in the for header. Both ix and cnt are changed on each trip through the loop.

==
The simplest statement is the empty statement, also known as a null statement. A null statement is a single semicolon:
; // null statement

A null statement is useful where the language requires a statement but the program‚Äôs logic does not. Such usage is most common when a loop‚Äôs work can be done within its condition.

while (cin >> s && s != sought)
	; // null statement

Null statements should be commented. That way anyone reading the code can see that the statement was omitted intentionally.

An empty block is equivalent to a null statement:

while (cin >> s && s != sought)
	{ } // empty block

==
(findif)
if 

int a;

if (grade < 60)
	a = 1;
else
	a = 2;


if (grade == 2) {
	a = 5;
} else if (grade == 9) {
	a = 8;
}

It is a common mistake to forget the curly braces when multiple statements must be executed as a block. To avoid such problems, some coding styles recommend always using braces after an if or an else (and also around the bodies of while and for statements).
Doing so avoids any possible confusion. It also means that the braces are already in place if later modifications of the code require adding statements.

==
(findswitch)
switch

A switch statement provides a convenient way of selecting among a (possibly large) number of fixed alternatives.

unsigned aCnt = 0, eCnt = 0, otherCunt = 0;

char ch;

switch (ch) {
	case 'a':
		++aCnt;
		break;
	case 'e':
		++eCnt;
		break;
 	default:
 		++otherCunt;
 		break;
}

In this case, the break transfers control out of the switch. Forgetting a break Is a Common Source of Bugs.

The case keyword and its associated value together are known as the case label. case labels must be integral constant expressions.

char ch = getVal();
int ival = 42;
switch(ch) {
	case 3.14: // error: noninteger as case label
	case ival: // error: nonconstant as case label
// . . .

It can be useful to define a default label even if there is no work for the default case. Defining an empty default section indicates to subsequent readers that the case was considered. If a switch ends with a default case that has no work to do, then the default label must be followed by a null statement or an empty block.

==
(findwhile)
while

while(a > 3) {
	cout << a << endl;
}

--
do while

A do while statement is like a while but the condition is tested after the statement body completes. Regardless of the value of the condition, we execute the loop at least once.

A do while ends with a semicolon after the parenthesized condition.

Variables used in condition must be defined outside the body of the do while statement.

// repeatedly ask the user for a pair of numbers to sum
string rsp;  // used in the condition; can't be defined inside the do

do {
    cout << "please enter two values: ";
    int val1 = 0, val2 = 0;
    cin  >> val1 >> val2;
    cout << "The sum of " << val1 << " and " << val2
         << " = " << val1 + val2 << "\n\n"
         << "More? Enter yes or no: ";
    cin  >> rsp;
} while (!rsp.empty() && rsp[0] != 'n');

==
(findfor)
for

for(int i = 0; i < 5; ++i) {
	cout << i << endl;
}

for (decltype(v.size()) i = 0, sz = v.size(); i != sz; ++i)
    v.push_back(v[i]);

--
Range for (in C++11):

If we want to write to the elements in the sequence, the
loop variable must be a reference type.

vector<int> v = {0,1,2,3,4,5,6,7,8,9};

// range variable must be a reference so we can write to the elements
for (auto &r : v)   // for each element in v
    r *= 2; // double the value of each element in v

we cannot use a range for to add elements to a vector (or
other container). 

==
(findbreak)
break

A break statement terminates the nearest enclosing while, do while, for, or switch statement. Execution resumes at the statement immediately following the terminated statement.

for (auto it = buf.begin()+1; it != buf.end(); ++it) {
	  if (*it == ' ')
	       break; // leaves the for loop
}

==
(findcontinue)
continue

A continue statement terminates the current iteration of the nearest enclosing loop and immediately begins the next iteration. A continue can appear only inside a for, while, or do while loop. 

In the case of a while or a do while, execution continues by evaluating the condition. In a traditional for loop, execution continues at the expression inside the for header.

==
(findgoto)
goto

A goto statement provides an unconditional jump from the goto to a another statement in the same function. Programs should not use gotos. gotos make programs hard to understand and hard to modify.


goto label;
 
where label is an identifier that identifies a statement. A labeled statement is any statement that is preceded by an identifier followed by a colon:

end: return;  // labeled statement; may be the target of a goto

Label identifiers are independent of names used for variables and other identifiers.

==
(findexception)
Exception

Exceptions are run-time anomalies‚Äîsuch as losing a database connection or encountering unexpected input‚Äîthat exist outside the normal functioning of a program. Dealing with anomalous behavior can be one of the most difficult parts of designing any system.

Exception handling is generally used when one part of a program detects a problem that it cannot resolve and the problem is such that the detecting part of the program cannot continue. In such cases, the detecting part needs a way to signal that something happened and that it cannot continue. Moreover, the detecting part needs a way to signal the problem without knowing what part of the program will deal with the exceptional condition. Having signaled what happened, the detecting part stops processing.
 
A program that contains code that might raise an exception (usually) has another part to handle whatever happened. For example, if the problem is invalid input, the handling part might ask the user to provide correct input. If the database was lost, the handling part might alert an operator.
 
Exception handling supports this cooperation between the detecting and handling parts of a program. In C++, exception handling involves
 
- throw expressions, which the detecting part uses to indicate that it encountered something it can‚Äôt handle. We say that a throw raises an exception.
 
- try blocks, which the handling part uses to deal with an exception. A try block starts with the keyword try and ends with one or more catch clauses.Exceptions thrown from code executed inside a try block are usually handled by one of the catch clauses. Because they ‚Äúhandle‚Äù the exception, catch clauses are also known as exception handlers.

- A set of exception classes that are used to pass information about what happened between a throw and an associated catch.

--
A throw Expression:

// first check that the data are for the same item
if (item1.isbn() != item2.isbn())
    throw runtime_error("Data must refer to same ISBN");
// if we're still here, the ISBNs are the same
cout << item1 + item2 << endl;
 
In this code, if the ISBN s differ, we throw an expression that is an object of type runtime_error. Throwing an exception terminates the current function and transfers control to a handler that will know how to handle this error.

The type runtime_error is one of the standard library exception types and is defined in the stdexcept header. We must initialize a runtime_error by giving it a string or a C-style character string. That string provides additional information about the problem.

--
The try Block:

The general form of a try block is
 
try {
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
} // . . .

When a catch is selected to handle an exception, the associated block is executed. Once the catch finishes, execution continues with the statement immediately following the last catch clause of the try block.

The program-statements inside the try constitute the normal logic of the program. Like any other blocks, they can contain any C++ statement, including declarations. As with any block, variables declared inside a try block are inaccessible outside the block ‚Äî in particular, they are not accessible to the catch clauses.

--
Writing a Handler:\
while (cin >> item1 >> item2) {
    try {
        // execute code that will add the two Sales_items
        // if the addition fails, the code throws a runtime_error exception
    } catch (runtime_error err) {
        // remind the user that the ISBNs must match and prompt for another pair
        cout << err.what()
             << "\nTry Again?  Enter y or n" << endl;
        char c;
        cin >> c;
        if (!cin || c == 'n')
            break;      // break out of the while loop
    }
}

The prompt to the user prints the return from err.what(). We know that err has type runtime_error. Each of the library exception classes defines a member function named what. These functions take no arguments and return a C-style character string (i.e., a const char*). The what member of runtime_error
returns a copy of the string used to initialize the particular object.

If no appropriate catch is found, execution is transferred to a library function named terminate. The behavior of that function is system dependent but is guaranteed to stop further execution of the program.

--
Standard Exceptions:

The C++ library defines several classes that it uses to report problems encountered in the functions in the standard library. These classes are defined in four headers:
 
- The "exception" header defines the most general kind of exception class named "exception". It communicates only that an exception occurred but provides no additional information.

- The "stdexcept" header defines several general-purpose exception classes, which are listed below.

- The "new" header dfines the "bad_alloc" exception type.

- The "type_info" header defines the "bad_cast" exception type. 

Standard exception classes defined in <stdexcetp>:

exception: The most general kind of problem

runtime_error: Problem that can be deteced only at run time.

range_error: Run-time error: result generatd outside the range of values that are meaningful.

overflow_error: Run-time error: computation that overflowed.

underflow_error: Run-time error: computation that underflowed.

logic_error: Error in the logic of the program.

domain_error: Logic error: argument for which no result exists.

invalid_argument: Logic error: inappropriate argument.

length_error: Logic error: attempt to create an object larger than the maximum size for that type.

out_of_range: logic error: used a value outside the valid range.

We can only default initialize exception, bad_alloc, and bad_cast objects; it is not possible to provide an initializer for objects of these exception types.
 
The other exception types have the opposite behavior: We can initialize those objects from either a string or a C-style string, but we cannot default initialize them. When we create objects of any of these other exception types, we must supply an
initializer. That initializer is used to provide additional information about the error that occurred.
 
The exception types define only a single operation named what. That function takes no arguments and returns a const char* that points to a C-style character string. The purpose of this C-style character string is to provide some sort of textual description of the exception thrown.

==
(findfunction)
function

Example:

int fact(int val) {
  int ret = 1; 
  while (val > 1)
    ret *= val--; 
  return ret;
}

The statements after the return statement will not be executed (tao's practice).

--
For compatibility with C, we also can use the keyword void to indicate that there are no parameters:

int f1(){ /* ... */ } // implicit void parameter list

int f2(void){ /* ... */ } // explicit void parameter list

--
The return type can be void, which means that the function does not return a value.

The return type may not be an array type or a function type. However, a function may return a pointer to an array or a function. 

--
Argument Passing

If the parameter is a reference, then the parameter is bound to its argument. Otherwise, the argument‚Äôs value is copied.

When a parameter is a reference, we say that its corresponding argument is ‚Äúpassed by reference‚Äù or that the function is ‚Äúcalled by reference.‚Äù The parameter is an alias for its corresponding argument.
 
When the argument value is copied, the parameter and argument are independent objects. We say such arguments are ‚Äúpassed by value‚Äù or alternatively that the function is ‚Äúcalled by value.‚Äù

-- 
Passing Arguments by Value

Nothing the function does to the parameter can affect the argument.

Pointer Parameters
 
Pointers behave like any other nonreference type. When we copy a
pointer, the value of the pointer is copied. After the copy, the two pointers are distinct. However, a pointer also gives us indirect access to the object to which that pointer points.

(Avadoles) Programmers accustomed to programming in C often use pointer parameters to access objects outside a function. In C++, programmers generally use reference parameters instead.

--
Passing Arguments by Reference

void reset(int &i)  // i is just another name for the object passed to reset
{
    i = 0;  // changes the value of the object to which i refers
}

int j = 42;
reset(j);  // j is passed by reference; the value in j is changed
cout << "j = " << j  << endl;  // prints j = 0

Using References to Avoid Copies
 
It can be inefficient to copy objects of large class types or large containers. Moreover, some class types (including the IO types) cannot be copied. Functions must use reference parameters to operate on objects of a type that cannot be copied.

(findconstparameter)
As an example, we‚Äôll write a function to compare the length of two strings. Because strings can be long, we‚Äôd like to avoid copying them, so we‚Äôll make our parameters references. Because comparing two strings does not involve changing the strings, we‚Äôll make the parameters references to const. Reference parameters that are not changed inside a function should be references to const.

// compare the length of two strings
bool isShorter(const string &s1, const string &s2) {
    return s1.size() < s2.size();
}

Tao did not see any functions returning a const. If I see it, record it here.

Use Reference to const When Possible

It is a somewhat common mistake to define parameters that a function does not change as (plain) references. Doing so gives the function‚Äôs caller the misleading impression that the function might change its argument‚Äôs value.

Using Reference Parameters to Return Additional Information
 
A function can return only a single value. However, sometimes a function has more than one value to return. Reference parameters let us effectively return multiple results.

// returns the index of the first occurrence of c in s
// the reference parameter occurs counts how often c occurs
string::size_type find_char(const string &s, char c, string::size_type &occurs) {
    auto ret = s.size();   // position of the first occurrence, if any
    occurs = 0;            // set the occurrence count parameter
    for (decltype(ret) i = 0; i != s.size(); ++i) {
        if (s[i] == c) {
            if (ret == s.size())
                ret = i;   // remember the first occurrence of c
            ++occurs;      // increment the occurrence count
         }
    }
    return ret;            // count is returned implicitly in occurs
}

auto index = find_char(s, 'o', ctr);
 
After the call, the value of ctr will be the number of times o occurs.

--
Array Parameters

Arrays have two special properties that affect how we define and use functions that operate on arrays: We cannot copy an array, and when we use an array it is (usually) converted to a pointer. Because we cannot copy an array, we cannot pass an array by value. Because arrays are converted to pointers, when we pass an array to a function, we are actually passing a pointer to the array‚Äôs first element.

Even though we cannot pass an array by value, we can write a parameter that looks like an array:

// despite appearances, these three declarations of print are equivalent:

// each function has a single parameter of type const int*
void print(const int*);
void print(const int[]);   // shows the intent that the function takes an array
void print(const int[10]); // dimension for documentation purposes (at best)

int j[2] = {0, 1};
print(j);  // ok: j is converted to an int* that points to j[0]

Because arrays are passed as pointers, functions ordinarily don‚Äôt know the size of the array they are given. They must rely on additional information provided by the caller. There are three common techniques used to manage pointer parameters.

Using a Marker to Specify the Extent of an Array

The first approach to managing array arguments requires the array itself to contain an end marker. C-style character strings are an example of this approach. C-style strings are stored in character arrays in which the last character of the string is followed by a null character. Functions that deal with C-style strings stop processing the array when they see a null character.

Using the Standard Library Conventions
 
A second technique used to manage array arguments is to pass pointers to the first and one past the last element in the array.

Using this approach, we‚Äôll print the elements in an array as follows:

void print(const int *beg, const int *end) {
    // print every element starting at beg up to but not including end
    while (beg != end)
        cout << *beg++ << endl; // print the current element and advance the pointer
}

To call this function, we pass two pointers:

int j[2] = {0, 1};

print(begin(j), end(j));

Explicitly Passing a Size Parameter

A third approach for array arguments, which is common in C programs and older C++ programs, is to define a second parameter that indicates the size of the array.

// const int ia[] is equivalent to const int* ia
// size is passed explicitly and used to control access to elements of ia

void print(const int ia[], size_t size) {
    for (size_t i = 0; i != size; ++i) {
        cout << ia[i] << endl;
    }
}

int j[] = { 0, 1 };  // int array of size 2
print(j, end(j) - begin(j));

--
Array Parameters and const
 
Note that all three versions of our print function defined their array parameters as pointers to const. The discussion in ¬ß 6.2.3 applies equally to pointers as to references. When a function does not need write access to the array elements, the array parameter should be a pointer to const. A parameter should be
a plain pointer to a nonconst type only if the function needs to change element values.

--
Array Reference Parameters
 
Just as we can define a variable that is a reference to an array, we can define a parameter that is a reference to an array.

void print(int (&arr)[10]) {
    for (auto elem : arr)
        cout << elem << endl;
}

Because the size of an array is part of its type, it is safe to rely on the dimension in the body of the function. However, the fact that the size is part of the type limits the usefulness of this version of print. We may call this function only for an array of exactly ten ints:

j[2] = {0, 1};
int k[10] = {0,1,2,3,4,5,6,7,8,9};

print(j);    // error: argument is not an array of ten ints
print(k);    // ok: argument is an array of ten ints

--
Passing a Multidimensional Array

As with any array, a multidimensional array is passed as a pointer to its first element. Because we are dealing with an array of arrays, that element is an array, so the pointer is a pointer to an array. The size of the second (and any subsequent) dimension is part of the element type and must be specified:

// matrix points to the first element in an array whose elements are arrays of ten ints
void print(int (*matrix)[10], int rowSize) { /* . . . */ }

declares matrix as a pointer to an array of ten ints.

We can also define our function using array syntax. As usual, the compiler ignores the first dimension, so it is best not to include it:

// equivalent definition
void print(int matrix[][10], int rowSize) { /* . . . */ }

--
Returning a Pointer to an Array

Because we cannot copy an array, a function cannot return an array. However, a function can return a pointer or a reference to an array Unfortunately, the syntax used to define functions that return pointers or references to arrays can be intimidating. Fortunately, there are ways to simplify such declarations. The most straightforward way is to use a type alias

typedef int arrT[10];  // arrT is a synonym for the type array of ten ints

using arrtT = int[10]; // equivalent declaration of arrT; 

arrT* func(int i);     // func returns a pointer to an array of five ints

Declaring a Function That Returns a Pointer to an Array
 
To declare func without using a type alias, we must remember that the dimension of an array follows the name being defined:
  
int arr[10];          // arr is an array of ten ints
int *p1[10];          // p1 is an array of ten pointers
int (*p2)[10] = &arr; // p2 points to an array of ten ints
 
As with these declarations, if we want to define a function that returns a pointer to an array, the dimension must follow the function‚Äôs name. However, a function includes a parameter list, which also follows the name. The parameter list precedes the
dimension. Hence, the form of a function that returns a pointer to an array is:

Type (*function(parameter_list))[dimension]

As a concrete example, the following declares func without using a type alias:

int (*func(int i))[10];

Using a Trailing Return Type (C++11)

Under the new standard, another way to simplify the declaration of func is by using a trailing return type.

A trailing return type follows the parameter list and is preceded by ->. To signal that the return follows the parameter list, we use auto where the return type ordinarily appears:

// fcn takes an int argument and returns a pointer to an array of ten ints
auto func(int i) -> int(*)[10];

Using decltype

As another alternative, if we know the array(s) to which our function can return a pointer, we can use decltype to declare the return type.

int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
// returns a pointer to an array of five int elements
decltype(odd) *arrPtr(int i)
{
    return (i % 2) ? &odd : &even; // returns a pointer to the array
}

--
Functions with Varying Parameters

Sometimes we do not know in advance how many arguments we need to pass to a function.

The new standard provides two primary ways to write a function that takes a varying number of arguments: If all the arguments have the same type, we can pass a library type named initializer_list. If the argument types vary, we can write a special kind of function, known as a variadic template.

C++ also has a special parameter type, ellipsis, that can be used to pass a varying number of arguments.

--
initializer_list Parameters (C++11)

We can write a function that takes an unknown number of arguments of a single type by using an initializer_list parameter. An initializer_list is a library type that represents an array of values of the specified type. This type is defined in the initializer_list header. The operations that initializer_list provides are listed below:

initializer_list<T> lst: Default initialization, an empty list of element sof type T.

initializer_list<T> lst(a, b, c...): lst has as many elements as there are initializers, elements are copies of the corresponding initializers. Elements in the list are const.

lst2(lst), lst2 = lst: Copying or assigning an initializer_list does not copy the elements in the list. After the copy, the original and the copy share the elements.

lst.size(): Number of elements in the list.

lst.begin(), lst.end(): Returns a pointer to the first and one past the last elments in the lst.

Example:

initializer_list<int> li;    // initializer_list of ints

Unlike vector, the elements in an initializer_list are always const values; there is no way to change the value of an element in an initializer_list.

void error_msg(initializer_list<string> il) {
    for (auto beg = il.begin(); beg != il.end(); ++beg)
        cout << *beg << " " ;
    cout << endl;
}

When we pass a sequence of values to an initializer_list parameter, we must enclose the sequence in curly braces:

error_msg({"functionX", "okay"});

A function with an initializer_list parameter can have other parameters as well.

void error_msg(ErrCode e, initializer_list<string> il)

error_msg(ErrCode(0), {"functionX", "okay"});

--
Ellipsis Parameters

Ellipsis parameters are in C++ to allow programs to interface to C code that uses a C library facility named varargs. Generally an ellipsis parameter should not be used for other purposes.

Ellipsis parameters should be used only for types that are common to both C and C++. In particular, objects of most class types are not copied properly when passed to an ellipsis parameter.

An ellipsis parameter may appear only as the last element in a parameter list and may take either of two forms:
 
void foo(parm_list, ...);
void foo(...);

--
(findreturn)
return

A return statement terminates the function that is currently executing and returns control to the point from which the function was called. There are two forms of return statements:
 
return;
return expression;

Functions with No Return Value

A return with no value may be used only in a function that has a return type of void. Functions that return void are not required to contain a return. In a void function, an implicit return takes place after the function‚Äôs last statement.
  
Typically, void functions use a return to exit the function at an intermediate point. This use of return is analogous to the use of a break statement to exit a loop.

Functions That Return a Value

Every return in a function with a return type other than void must return a value.

Never Return a Reference or Pointer to a Local Object

When a function completes, its storage is freed. After a function terminates, references to local objects refer to memory that is no longer valid:

// disaster: this function returns a reference to a local object
const string &manip() {
    string ret;
   // transform ret in some way
   if (!ret.empty())
       return ret;     // WRONG: returning a reference to a local object!
   else
       return "Empty"; // WRONG: "Empty" is a local temporary string
}

If a function returns a pointer, reference or object of class type, we can use the result of a call to call a member of the resulting object:

auto sz = shorterString(s1, s2).size();

Reference Returns Are Lvalues. we can assign to the result of a function that returns a reference to nonconst:

char &get_val(string &str, string::size_type ix) {
    return str[ix]; // get_val assumes the given index is valid
}

get_val(s, 0) = 'A'; // changes s[0] to A

It may be surprising to see a function call on the left-hand side of an assignment. However, nothing special is involved.

--
List Initializing the Return Value (C++11)

Under the new standard, functions can return a braced list of values.

vector<string> process() {
    // . . .
    return {"functionX", expected, actual};
}

--
Return from main

There is one exception to the rule that a function with a return type other than void must return a value: The main function is allowed to terminate without a return. If control reaches the end of main and there is no return, then the compiler implicitly
inserts a return of 0.

The value returned from main is treated as a status indicator. A zero return indicates success; most other values indicate failure. A nonzero value has a machine-dependent meaning. To make return values machine independent, the cstdlib header defines two preprocessor variables that we can use to indicate success or failure:

int main() {
    if (some_failure)
        return EXIT_FAILURE;  // defined in cstdlib
    else
        return EXIT_SUCCESS;  // defined in cstdlib
}
 
Because these are preprocessor variables, we must not precede them with std::, nor may we mention them in using declarations.

--
Recursion

A function that calls itself, either directly or indirectly, is a recursive function.

// calculate val!, which is 1 * 2 * 3 . . . * val
int factorial(int val) {
    if (val > 1)
        return factorial(val-1) * val;
    return 1;
}

There must always be a path through a recursive function that does not involve a recursive call; otherwise, the function will recurse ‚Äúforever‚Äù.

The main function may not call itself.


--
(findstatic)
Local static objects
Static variables

It can be useful to have a local variable whose lifetime continues across calls to the function. We obtain such objects by defining a local variable as static. Each local static object is initialized before the first time execution passes through the object‚Äôs definition. Local statics are not destroyed when a function ends; they are destroyed when the program terminates.

As a trivial example, here is a function that counts how many times it is called. This program will print the numbers from 1 through 10 inclusive.
 
size_t count_calls() {
    static size_t ctr = 0;  // value will persist across calls
    return ++ctr;
}

int main() {
    for (size_t i = 0; i != 10; ++i)
        cout << count_calls() << endl;
    return 0;
}
 
If a local static has no explicit initializer, it is value initialized, meaning that local statics of built-in type are initialized to zero.

--
Function Declarations

Like any other name, the name of a function must be declared before we can use it. As with variables, a function may be defined only once but may be declared multiple times.

A function declaration is just like a function definition except that a declaration has no function body. In a declaration, a semicolon replaces the function body.
 
Because a function declaration has no body, there is no need for parameter names. Hence, parameter names are often omitted in a declaration. Although parameter names are not required, they can be used to help users of the function understand what the function does:
 
void print(vector<int>::const_iterator beg, vector<int>::const_iterator end);

Function declarations are also known as the function prototype.

Function Declarations Go in Header Files
 
Recall that variables are declared in header files and defined in source files. For the same reasons, functions should be declared in header files and defined in source files.

It may be tempting‚Äîand would be legal‚Äîto put a function declaration directly in each source file that uses the function. However, doing so is tedious and error-prone. When we use header files for our function declarations, we can ensure that all the
declarations for a given function agree. The source file that defines a function should include the header that contains that function‚Äôs declaration.

--
(findoverload)
Overloaded Functions

Functions that have the same name but different parameter lists and that appear in the same scope are overloaded.

Examples:

void print(const char *cp);
void print(const int *beg, const int *end);
void print(const int ia[], size_t size);

When we call these functions, the compiler can deduce which function we want based on the argument type we pass:

print("Hello World");        // calls print(const char*)
print(j, end(j) - begin(j)); // calls print(const int*, size_t)
print(begin(j), end(j));     // calls print(const int*, const int*)

Function overloading eliminates the need to invent‚Äîand remember‚Äînames that exist only to help the compiler figure out which function to call.

The main function may not be overloaded.

Overloaded functions must differ in the number or the type(s) of their parameters.

It is an error for two functions to differ only in terms of their return types.
 
Two parameter lists can be identical, even if they don‚Äôt look the same.

Although overloading lets us avoid having to invent (and remember) names for common operations, we should only overload operations that actually do similar things. There are some cases where providing different function names adds information that makes the program easier to understand.

Function matching (also known as overload resolution) is the process by which a particular function call is associated with a
specific function from a set of overloaded functions.

Names do not overload across scopes.

--
Default Arguments

string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');
 
Here we‚Äôve provided a default for each parameter. A default argument is specified as an initializer for a parameter in the parameter list. We may define defaults for one or more parameters. However, if a parameter has a default argument, all the parameters that follow it must also have default arguments.

If we want to use the default argument, we omit that argument when we call the function.

window = screen();  // equivalent to screen(24,80,' ')

window = screen(66);// equivalent to screen(66,80,' ')
window = screen(66, 256);      // screen(66,256,' ')
window = screen(66, 256, '#'); // screen(66,256,'#')
 
Arguments in the call are resolved by position. 

The default arguments are used for the trailing (right-most) arguments of a call:

window = screen(, , '?'); // error: can omit only trailing arguments
window = screen('?');     // calls screen('?',80,' ')

Part of the work of designing a function with default arguments is ordering the parameters so that those least likely to use a default value appear first and those most likely to use a default appear last.

Default Argument Declarations
 
Although it is normal practice to declare a function once inside a header, it is legal to redeclare a function multiple times. However, each parameter can have its default specified only once in a given scope. Thus, any subsequent declaration can add a
default only for a parameter that has not previously had a default specified. As usual, defaults can be specified only if all parameters to the right already have defaults.

Local variables may not be used as a default argument.

--
(findinlinefunctions)
Inline Functions

We can define shorterString as an inline function by putting the keyword inline before the function‚Äôs return type:

// inline version: find the shorter of two strings
inline const string & shorterString(const string &s1, const string &s2) {
	return s1.size() <= s2.size() ? s1 : s2;
}

A function specified as inline (usually) is expanded ‚Äúin line‚Äù at each call. If shorterString were defined as inline, then this call

cout << shorterString(s1, s2) << endl;

(probably) would be expanded during compilation into something like

cout << (s1.size() < s2.size() ? s1 : s2) << endl;

The run-time overhead of making shorterString a function is thus removed.

The inline specification is only a request to the compiler. The compiler may choose to ignore this request.

In general, the inline mechanism is meant to optimize small, straight-line functions that are called frequently. Many compilers will not inline a recursive function. A 75-line function will almost surely not be expanded inline.

--
(findconstexprfunctions)
constexpr Functions

A constexpr function is a function that can be used in a constant expression. A constexpr function is defined like any other function but must meet certain restrictions: The return type and the type of each parameter in a must be a literal type, and the function body must contain exactly one return statement:

constexpr int new_sz() { return 42; }
constexpr int foo = new_sz(); // ok: foo is a constant expression

When it can do so, the compiler will replace a call to a constexpr function with its resulting value. In order to be able to expand the function immediately, constexpr functions are implicitly inline.

A constexpr function body may contain other statements so long as those
statements generate no actions at run time. For example, a constexpr function may contain null statements, type aliases (¬ß 2.5.1, p. 67), and using declarations.

A constexpr function is permitted to return a value that is not a constant:

// scale(arg) is a constant expression if arg is a constant expression
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }

Put inline and constexpr Functions in Header Files 

Unlike other functions, inline and constexpr functions may be defined multiple times in the program. After all, the compiler needs the definition, not just the declaration, in order to expand the code. However, all of the definitions of a given inline or constexpr must match exactly. As a result, inline and constexpr functions normally are defined in headers.

--
(findassert)
The assert Preprocessor Macro

C++ programmers sometimes use a technique similar to header guards to conditionally execute debugging code. The idea is that the program will contain debugging code that is executed only while the program is being developed. When the application is completed and ready to ship, the debugging code is turned off. This approach uses two preprocessor facilities: assert and NDEBUG.

The assert Preprocessor Macro assert is a preprocessor macro. A preprocessor macro is a preprocessor variable that acts somewhat like an inline function. The assert macro takes a single expression, which it uses as a condition:

assert(expr);

evaluates expr and if the expression is false (i.e., zero), then assert writes a message and terminates the program. If the expression is true (i.e., is nonzero), then assert does nothing.

The assert macro is defined in the cassert header. As we‚Äôve seen, preprocessor names are managed by the preprocessor not the compiler. As a result, we use preprocessor names directly and do not provide a using declaration for them. That is, we refer to assert, not std::assert, and provide no using declaration for assert. 

As with preprocessor variables, macro names must be unique within the program. Programs that include the cassert header may not define a variable, function, or other entity named assert. In practice, it is a good idea to avoid using the name assert for our own purposes even if we don‚Äôt include cassert. Many headers include the cassert header, which means that even if you don‚Äôt directly include that file, your programs are likely to have it included anyway.

The assert macro is often used to check for conditions that ‚Äúcannot happen.‚Äù For example, a program that does some manipulation of input text might know that all words it is given are always longer than a threshold. That program might contain a statement such as

assert(word.size() > threshold);

--
(findndebug)
The NDEBUG Preprocessor Variable

The behavior of assert depends on the status of a preprocessor variable named NDEBUG. If NDEBUG is defined, assert does nothing. By default, NDEBUG is not defined, so, by default, assert performs a run-time check.

We can ‚Äúturn off‚Äù debugging by providing a #define to define NDEBUG.
Alternatively, most compilers provide a command-line option that lets us define preprocessor variables:

g++ -D NDEBUG main.C 

has the same effect as writing #define NDEBUG at the beginning of main.C.

In addition to using assert, we can write our own conditional debugging code using NDEBUG. If NDEBUG is not defined, the code between the #ifndef and the #endif is executed. If NDEBUG is defined, that code is ignored:

void print(const int ia[], size_t size) {
	#ifndef NDEBUG

	// _ _func_ _ is a local static defined by the compiler that holds the function's name

	cerr << _ _func_ _ << ": array size is " << size << endl;

	#endif
	// ...
}

Here we use a variable named _ _func_ _ to print the name of the function we are debugging. The compiler defines _ _func_ _ in every function. It is a local static array of const char that holds the name of the function.

In addition to _ _func_ _, which the C++ compiler defines, the preprocessor defines four other names that can be useful in debugging:

_ _FILE_ _ string literal containing the name of the file
_ _LINE_ _ integer literal containing the current line number
_ _TIME_ _ string literal containing the time the file was compiled
_ _DATE_ _ string literal containing the date the file was compiled

We might use these constants to report additional information in error messages:

if (word.size() < threshold)
	cerr << "Error: " << _ _FILE_ _
		 << " : in function " << _ _func_ _
		 << " at line " << _ _LINE_ _ << endl
		 << " Compiled on " << _ _DATE_ _
		 << " at " << _ _TIME_ _ << endl
		 << " Word read was \"" << word
		 << "\": Length too short" << endl;

If we give this program a string that is shorter than the threshold, then the following error message will be generated:

Error: wdebug.cc : in function main at line 27
Compiled on Jul 11 2012 at 20:50:03
Word read was "foo": Length too short

==
(findstruct)
Struct

struct Sales_data {
    string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
}; //Tao: note the ;

Sales_data accum;
Sales_data* salesptr;

To see the difference between struct and class, search for "find public", and look at the end of that part.

--
From Google C++ Style Guide:

Structs vs. Classes

Use a struct only for passive objects that carry data; everything else is a class.

structs should be used for passive objects that carry data, and may have associated constants, but lack any functionality other than access/setting the data members. The accessing/setting of fields is done by directly accessing the fields rather than through method invocations. Methods should not provide behavior but should only be used to set up the data members, e.g., constructor, destructor, Initialize(), Reset(), Validate().

If more functionality is required, a class is more appropriate. If in doubt, make it a class.

==
(findclass)
class

Classes ordinarily are not defined inside functions.

In order to ensure that the class definition is the same in each file, classes are usually defined in header files.

Tao: don't foreget the ; at the end of a class!

Tao: note public and private has no identitation. There is no identiation in this book, and in leetcode default code, in online examples, and sublime also removes these identitaction automatically.


class Sales_data {
public:
    Sales_data() = default; // default constructor
    Sales_data(string &s, double p) : bookNo(s), revenue(p) {}  

private:
    string bookNo;
    double revenue = 0.0;
    
    double price() {
        ...
    }
};

If our class does not explicitly define any constructors, the compiler will implicitly define the default constructor for us (know as the synthesized default constructor).

Sales_data item;
Screen myScreen(5, 3);
Screen myScreen = Screen(5, 3);//Added by Tao, works in practice.

Sales_data obj(); // oops! declares a function, not an object
Sales_data obj2; // ok: obj2 is an object, not a function

--
(findpublic)
(findprivate)

Access specifiers (public & private)

public:

Members defined after a public specifier are accessible to all parts of the program. The public members define the interface to the class.

private:

Members defined after a private specifier are accessible to the member functions of the class but are not accessible to code that uses the class. The private sections encapsulate (i.e., hide) the implementation.

Example:

class Sales_data {
public: // tao: this line has no identation (same in leetcode)
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
    Sales_data(const std::string &s): bookNo(s) { }
    Sales_data(std::istream&);
    std::string isbn() const { return bookNo; }
    Sales_data &combine(const Sales_data&);

private: // tao: this line has no identation (same in leetcode)
    double avg_price() const { 
        return units_sold ? revenue/units_sold : 0; 
    }
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

A class may contain zero or more access specifiers, and there are no restrictions on how often an access specifier may appear. Each access specifier specifies the access level of the succeeding members. The specified access level remains in effect until the next access specifier or the end of the class body.

We also made another, more subtle, change: We used the class keyword rather than struct to open the class definition. This change is strictly stylistic; we can define a class type using either keyword. The only difference between struct and class is
the default access level.

If we use the struct keyword, the members defined before the first access specifier are public; if we use class, then
the members are private.

As a matter of programming style, when we define a class intending for all of its members to be public, we use struct. If we intend to have private members, then we use class.

--
(findmemberfunction)
member function

We define and declare member functions similarly to ordinary functions. Member functions must be declared inside the class. Member
functions may be defined inside the class itself or outside the class body. Nonmember functions that are part of the interface, such as add, read, and print, are declared and defined outside the class.

struct Sales_data {
	// new members: operations on Sales_data objects
	std::string isbn() const { return bookNo; } //Tao: will explain const later
	Sales_data& combine(const Sales_data&);
	double avg_price() const;

	// data members:
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};

// nonmember Sales_data interface functions
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);

Note: Functions defined in the class are implicitly inline

Member functions access the object on which they were called through an extra, implicit parameter named this. When we call a member function, this is initialized with the address of the object on which the function was invoked. For example, when we call

total.isbn() //tao: total is an object of Sales_data

the compiler passes the address of total to the implicit this parameter in isbn. It is as if the compiler rewrites this call as

// pseudo-code illustration of how a call to a member function is translated
Sales_data::isbn(&total)

which calls the isbn member of Sales_data passing the address of total.

Inside a member function, we can refer directly to the members of the object on which the function was called. We do not have to use a member access operator to use the members of the object to which this points. Any direct use of a member of the class is assumed to be an implicit reference through this. That is, when isbn uses bookNo, it is implicitly using the member to which this points. It is as if we had written this->bookNo.

The this parameter is defined for us implicitly. Indeed, it is illegal for us to define a parameter or variable named this. Inside the body of a member function, we can use this. It would be legal, although unnecessary, to define isbn as

std::string isbn() const { return this->bookNo; }

Because this is intended to always refer to ‚Äúthis‚Äù object, this is a const pointer. We cannot change the address that this holds.

It is worth noting that isbn can use bookNo even though bookNo is defined after isbn. The compiler processes classes in two steps‚Äî
the member declarations are compiled first, after which the member function bodies, if any, are processed. Thus, member function bodies may use other members of their class regardless of where in the class those members appear.

Defining a Member Function outside the Class

As with any other function, when we define a member function outside the class body, the member‚Äôs definition must match its declaration. If the member was declared as a const member function (search for find constmemberfunction), then the definition must also specify const after the parameter list. The name of a member defined outside the class must include the name of the class of which it is a member:

double Sales_data::avg_price() const {
	if (units_sold)
		return revenue/units_sold;
	else
		return 0;
}

The function name, Sales_data::avg_price, uses the scope operator to say that we are defining the function named avg_price that is declared in the scope of the Sales_data class. Once the compiler sees the function name, the rest of the code is interpreted as being inside the scope of the class. Thus, when avg_price refers to revenue and units_sold, it is implicitly referring to the members of Sales_data.

As with nonmember functions, member functions may be overloaded so long as the functions differ by the number and/or types of parameters.

--
(findconstmemberfunction)
const member functions

Tao's summary:
1. const member function is like the following (note the const)
   string isbn() const { return bookNo; }
2. Purpose of const member function:
   non-const member function can not be called by a const object.
   const member function can be called by a const object.
   
Tao: this was the quesion asked by Teacher Ma's son.
Tao: copied all the content of this topic (const member functions) to the followings.

The other important part about the isbn function is the keyword const that follows the parameter list. The purpose of that const is to modify the type of the implicit this pointer.

By default, the type of this is a const pointer to the nonconst version of the class type. For example, by default, the type of this in a Sales_data member function is Sales_data *const. Although this is implicit, it follows the normal initialization rules, which means that (by default) we cannot bind this to a const object. This fact, in turn, means that we cannot call an ordinary member function on a const object.

If isbn were an ordinary function and if this were an ordinary pointer parameter, we would declare this as const Sales_data *const. After all, the body of isbn doesn‚Äôt change the object to which this points, so our function would be more flexible if this were a pointer to const.

However, this is implicit and does not appear in the parameter list. There is no place to indicate that this should be a pointer to const. The language resolves this problem by letting us put const after the parameter list of a member function. A const following the parameter list indicates that this is a pointer to const. Member functions that use const in this way are const member functions.

We can think of the body of isbn as if it were written as

// pseudo-code illustration of how the implicit this pointer is used
// this code is illegal: we may not explicitly define the this pointer ourselves
// note that this is a pointer to const because isbn is a const member
std::string Sales_data::isbn(const Sales_data *const this)
{ return this->isbn; }

The fact that this is a pointer to const means that const member functions cannot change the object on which they are called. Thus, isbn may read but not write to the data members of the objects on which it is called.

Note: Objects that are const, and references or pointers to const objects, may call only const member functions.

--
Defining a Function to Return ‚ÄúThis‚Äù Object

The combine function is intended to act like the compound assignment operator, +=. The object on which this function is called represents the left-hand operand of the assignment. The right-hand operand is passed as an explicit argument:

Sales_data& Sales_data::combine(const Sales_data &rhs) {
	units_sold += rhs.units_sold; // add the members of rhs into
	revenue += rhs.revenue; // the members of ''this'' object
	return *this; // return the object on which the function was called
}

When our transaction-processing program calls

total.combine(trans); // update the running total

the address of total is bound to the implicit this parameter and rhs is bound to trans. Thus, when combine executes

units_sold += rhs.units_sold; // add the members of rhs into

the effect is to add total.units_sold and trans.units_sold, storing the result back into total.units_sold.

The interesting part about this function is its return type and the return statement. Ordinarily, when we define a function that operates like a built-in operator, our function should mimic the behavior of that operator. The built-in assignment operators return their left-hand operand as an lvalue. To return an lvalue, our combine function must return a reference. Because the left-hand operand is a Sales_data object, the return type is Sales_data&.

As we‚Äôve seen, we do not need to use the implicit this pointer to access the members of the object on which a member function is executing. However, we do need to use this to access the object as a whole:

return *this; // return the object on which the function was called

Here the return statement dereferences this to obtain the object on which the function is executing. That is, for the call above, we return a reference to total.

--
Defining Nonmember Class-Related Functions

Class authors often define auxiliary functions, such as our add, read, and print functions. Although such functions define operations that are conceptually part of the interface of the class, they are not part of the class itself.

We define nonmember functions as we would any other function. As with any other function, we normally separate the declaration of the function from its definition. Functions that are conceptually part of a class, but not defined inside the class, are typically declared (but not defined) in the same header as the class itself. That way users need to include only one file to use any part of the interface.

The read and print functions do the same job as the code in xxx and not surprisingly, the bodies of our functions look a lot like the code presented there:

(findistream)
(findostream)

// input transactions contain ISBN, number of copies sold, and sales price
istream &read(istream &is, Sales_data &item) {
	double price = 0;
	is >> item.bookNo >> item.units_sold >> price;
	item.revenue = price * item.units_sold;
	return is;
}

ostream &print(ostream &os, const Sales_data &item) {
	os << item.isbn() << " " << item.units_sold << " "
	   << item.revenue << " " << item.avg_price();
	return os;
}

The read function reads data from the given stream into the given object. The print function prints the contents of the given object on the given stream.

However, there are two points worth noting about these functions. First, both read and write take a reference to their respective IO class types. The IO classes are types that cannot be copied, so we may only pass them by reference. Moreover, reading or writing to a stream changes that stream, so both functions take ordinary references, not references to const.

The second thing to note is that print does not print a newline. Ordinarily, functions that do output should do minimal formatting. That way user code can decide whether the newline is needed.

--
(findconstructor)              
constructor

Constructors have the same name as the class. Unlike other functions, constructors have no return type. Like other functions, constructors have a (possibly empty) parameter list and a (possibly empty) function body. A class can have multiple constructors. Like any other overloaded function, the constructors must differ from each other in the number or types of their parameters.

Unlike other member functions, constructors may not be declared as const. When we create a const object of a class type, the object does not assume its ‚Äúconstness‚Äù until after the constructor completes the object‚Äôs initialization. Thus, constructors can write to const objects during their construction.

The Synthesized Default Constructor

Our Sales_data class does not define any constructors, yet the programs we‚Äôve written that use Sales_data objects compile and run correctly:

Sales_data total;

We did not supply an initializer for these objects, so we know that they are default initialized. Classes control default initialization by defining a special constructor, known as the default constructor. The default constructor is one that takes no arguments (tao: remember).

As we‚Äôll, see the default constructor is special in various ways, one of which is that if our class does not explicitly define any constructors, the compiler will implicitly define the default constructor for us

The compiler-generated constructor is known as the synthesized default constructor. For most classes, this synthesized constructor initializes each data member of the class as follows:

‚Ä¢ If there is an in-class initializer, use it to initialize the member.
‚Ä¢ Otherwise, default-initialize the member.

Some Classes Cannot Rely on the Synthesized Default Constructor Only fairly simple classes‚Äîsuch as the current definition of Sales_data‚Äîcan rely on the synthesized default constructor. The most common reason that a class must define its own default constructor is that the compiler generates the default for us only if we do not define any other constructors for the class. If we define any constructors, the
class will not have a default constructor unless we define that constructor ourselves. The basis for this rule is that if a class requires control to initialize an object in one case, then the class is likely to require control in all cases.

Note: The compiler generates a default constructor automatically only if a class declares no constructors.

A second reason to define the default constructor is that for some classes, the synthesized default constructor does the wrong thing. Remember that objects of builtin or compound type (such as arrays and pointers) that are defined inside a block have undefined value when they are default initialized. The same rule applies to members of built-in type that are default initialized. Therefore, classes that
have members of built-in or compound type should ordinarily either initialize those members inside the class or define their own version of the default constructor. Otherwise, users could create objects with members that have undefined value.

A third reason that some classes must define their own default constructor is that sometimes the compiler is unable to synthesize one. For example, if a class has a member that has a class type, and that class doesn‚Äôt have a default constructor, then the compiler can‚Äôt initialize that member. For such classes, we must define our own version of the default constructor.

Constructor example:

struct Sales_data {
    // constructors added
    Sales_data() = default;
    Sales_data(const std::string &s): bookNo(s) { } 
    Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
    Sales_data(std::istream &);

    // other members as before
    std::string isbn() const { return bookNo; }
    Sales_data& combine(const Sales_data&);
    double avg_price() const;
    std::string bookNo;
    unsigned units_sold = 0; //Tao: in-class initializer, see below
    double revenue = 0.0; //Tao: in-class initializer, see below
};

Constructor examples from Leetcode default code:

struct Interval {
    int start;
    int end;
    Interval() : start(0), end(0) {}
    Interval(int s, int e) : start(s), end(e) {}
};

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
}; 

In the constructor, the code between the colon and the curly braces is a constructor initializer list, which specifies initial values for one or more data members of the object being created. The constructor initializer is a list of member names, each of which is followed by that member‚Äôs initial value in parentheses (or inside curly braces). Multiple member initializations are separated by commas.

When a member is omitted from the constructor initializer list, it is implicitly initialized using the same process as is used by the synthesized default constructor.

It is usually best for a constructor to use an in-class initializer if one exists and gives the member the correct value. On the other hand, if your compiler does not yet support in-class initializers, then every constructor should explicitly initialize every member of built-in type.

It is worth noting that both constructors have empty function bodies. The only work these constructors need to do is give the data members their values. If there is no further work, then the function body is empty.

Defining a Constructor outside the Class Body

Unlike our other constructors, the constructor that takes an istream does have work to do. Inside its function body, this constructor calls read to give the data members new values:

The function read below will read a transaction from is into this object 

Tao: read is a user defined function. read returns *this. I recorded some notes about functions that return *this somewhere below.

Sales_data::Sales_data(std::istream &is) {
    read(is, *this); 
}

Constructors have no return type, so this definition starts with the name of the function we are defining. As with any other member function, when we define a constructor outside of the class body, we must specify the class of which the
constructor is a member. Thus, Sales_data::Sales_data says that we‚Äôre defining the Sales_data member named Sales_data. This member is a constructor because it has the same name as its class.

In this constructor there is no constructor initializer list, although technically speaking, it would be more correct to say that the constructor initializer list is empty. Even though the constructor initializer list is empty, the members of this object are still initialized before the constructor body is executed.

Members that do not appear in the constructor initializer list are initialized by the corresponding in-class initializer (if there is one) or are default initialized.

Constructor Initializers Are Sometimes Required

We can often, but not always, ignore the distinction between whether a member is initialized or assigned. Members that are const or references must be initialized. Similarly, members that are of a class type that does not define a default constructor also must be initialized. For example:

class ConstRef {
public:
	ConstRef(int ii);

private:
	int i;
	const int ci;
	int &ri;
};

Like any other const object or reference, the members ci and ri must be initialized. As a result, omitting a constructor initializer for these members is an error.

By the time the body of the constructor begins executing, initialization is complete. Our only chance to initialize const or reference data members is in the constructor initializer.

The way to initialize them is:

ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) { }

We must use the constructor initializer list to provide values for members that are const, reference, or of a class type that does not have a default constructor.

Order of Member Initialization

Members are initialized in the order in which they appear in the class definition.  The order in which initializers appear in the constructor initializer list does not change the order of initialization.

The order of initialization often doesn‚Äôt matter. However, if one member is initialized in terms of another, then the order in which members are initialized is crucially important.

It is a good idea to write constructor initializers in the same order as the members are declared. Moreover, when possible, avoid using members to initialize other members.

--
Copy, Assignment, and Destruction

In addition to defining how objects of the class type are initialized, classes also control what happens when we copy, assign, or destroy objects of the class type. 

Objects are copied in several contexts, such as when we initialize a variable (tao: can be either =, or int a(b), confirmed) or when we pass or return an object by value. Objects are assigned when we use the assignment operator (tao: =, confirmed). Objects are destroyed when they cease to exist, such as when a local object is destroyed on exit from the block in which it was created. Objects stored in a vector (or an array) are
destroyed when that vector (or array) is destroyed.

If we do not define these operations, the compiler will synthesize them for us. Ordinarily, the versions that the compiler generates for us execute by copying, assigning, or destroying each member of the object. For example, in our bookstore program, when the compiler executes this assignment

total = trans; // process the next book

it executes as if we had written

// default assignment for Sales_data is equivalent to:
total.bookNo = trans.bookNo;
total.units_sold = trans.units_sold;
total.revenue = trans.revenue;

Some Classes Cannot Rely on the Synthesized Versions

--
Delegating Constructors

The new standard extends the use of constructor initializers to let us define so-called delegating constructors. A delegating constructor uses another constructor from its own class to perform its initialization. It is said to ‚Äúdelegate‚Äù some (or all) of its work to this other constructor.

Like any other constructor, a delegating constructor has a member initializer list and a function body. In a delegating constructor, the member initializer list has a single
entry that is the name of the class itself. Like other member initializers, the name of the class is followed by a parenthesized list of arguments. The argument list must
match another constructor in the class.

As an example, we‚Äôll rewrite the Sales_data class to use delegating constructors as follows:

class Sales_data {
public:
	// nondelegating constructor initializes members from corresponding arguments
	Sales_data(std::string s, unsigned cnt, double price):
	bookNo(s), units_sold(cnt), revenue(cnt*price) {
	}
	// remaining constructors all delegate to another constructor
	Sales_data(): Sales_data("", 0, 0) {}
	Sales_data(std::string s): Sales_data(s, 0,0) {}
	Sales_data(std::istream &is): Sales_data()
	{ read(is, *this); }
	// other members as before
};

In this version of Sales_data, all but one of the constructors delegate their work. The first constructor takes three arguments, uses those arguments to initialize the
data members, and does no further work. In this version of the class, we define the default constructor (the default constructor is one that takes no arguments) to use the three-argument constructor to do its initialization. It too
has no additional work, as indicated by the empty constructor body. The constructor that takes a string also delegates to the three-argument version.

The constructor that takes an istream& also delegates. It delegates to the default constructor, which in turn delegates to the three-argument constructor.

When a constructor delegates to another constructor, the constructor initializer list and function body of the delegated-to constructor are both executed.

--
The Role of the Default Constructor

The default constructor is used automatically whenever an object is default or value initialized. Default initialization happens

‚Ä¢ When we define nonstatic variables or arrays at block scope without initializers

‚Ä¢ When a class that itself has members of class type uses the synthesized default constructor

‚Ä¢ When members of class type are not explicitly initialized in a constructor initializer list  Value initialization happens

‚Ä¢ During array initialization when we provide fewer initializers than the size of the array 

‚Ä¢ When we define a local static object without an initializer 

‚Ä¢ When we explicitly request value initialization by writing an expressions of the form T() where T is the name of a type (

Classes must have a default constructor in order to be used in these contexts.

In practice, it is almost always right to provide a default constructor if other constructors are being defined.

--
(findfriend)                   
friend

A class can allow another class or function to access its nonpublic members by making that class or function a friend. A class makes a function its friend by including a declaration for that function preceded by the keyword friend. Friend declarations may appear only inside a class definition; they may appear anywhere in the class. Ordinarily it is a good idea to group friend declarations together at the beginning or end of the class definition.

Example:

class Sales_data {

// friend declarations for nonmember Sales_data operations added
// tao: the following friend lines have no identation in the book
friend Sales_data add(const Sales_data&, const Sales_data&);
friend std::istream &read(std::istream&, Sales_data&);
friend std::ostream &print(std::ostream&, const Sales_data&);

// other members and access specifiers as before

public:
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
    Sales_data(const std::string &s): bookNo(s) { }
    Sales_data(std::istream&);
    std::string isbn() const { return bookNo; }
    Sales_data &combine(const Sales_data&);

private:
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

// declarations for nonmember parts of the Sales_data interface

Sales_data add(const Sales_data&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);

A class can also make another class its friend or it can declare specific member functions of another (previously defined) class as friends. In addition, a friend function can be defined inside the class body. Such functions are implicitly inline.

As an example of class friendship, our Window_mgr class will have members that will need access to the internal data of the Screen objects it manages. To allow this access, Screen can designate Window_mgr as its friend: 

class Screen {
	// Window_mgr members can access the private parts of class Screen
	friend class Window_mgr;
	// ... rest of the Screen class
};

The member functions of a friend class can access all the members, including the nonpublic members, of the class granting friendship. 

It is important to understand that friendship is not transitive. That is, if class Window_mgr has its own friends, those friends have no special access to Screen.

Rather than making the entire Window_mgr class a friend, Screen can instead specify that only the clear member is allowed access. When we declare a member function to be a friend, we must specify the class of which that function is a member:

class Screen {
	// Window_mgr::clear must have been declared before class Screen
	friend void Window_mgr::clear(ScreenIndex);
	// ... rest of the Screen class
};

Making a member function a friend requires careful structuring of our programs to accommodate interdependencies among the declarations and definitions.

Overloaded Functions and Friendship

Although overloaded functions share a common name, they are still different functions. Therefore, a class must declare as a friend each function in a set of overloaded functions that it wishes to make a friend.

Classes and nonmember functions need not have been declared before they are used in a friend declaration. When a name first appears in a friend declaration, that name is implicitly assumed to be part of the surrounding scope.

Even if we define the function inside the class, we must still provide a declaration outside of the class itself to make that function visible. A declaration must exist even if we only call the friend from members of the friendship granting class.

It is important to understand that a friend declaration affects access but is not a declaration in an ordinary sense.

--
Type Member

In addition to defining data and function members, a class can define its own local names for types. Type names defined by a class are subject to the same access controls as any other member and may be either public or private:

Unlike ordinary members, members that define types must appear before they are used. As a result, type members usually appear at the beginning of the class.

Example:

class Screen {
public:
    typedef std::string::size_type pos;
private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};

We defined pos in the public part of Screen because we want users to use that name.

We can equivalently use a type alias:

class Screen {
public:
    // alternative way to declare a type member using a type alias
    using pos = std::string::size_type;
    // other members as before
};

--
Making Members inline

class Screen {
public:
    typedef std::string::size_type pos;
    Screen() = default; // needed because Screen has another constructor
    // cursor initialized to 0 by its in-class initializer
    Screen(pos ht, pos wd, char c): height(ht), width(wd),
    contents(ht * wd, c) { }

    // get the character at the cursor
    // implicitly inline
    char get() const {
      return contents[cursor]; 
    } 

    inline char get(pos ht, pos wd) const; // explicitly inline
    Screen &move(pos r, pos c); // can be made inline later

private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};

Classes often have small functions that can benefit from being inlined. As we‚Äôve seen, member functions defined inside the class are automatically inline. Thus, Screen‚Äôs constructors and the version of get that returns the character denoted by the cursor are inline by default.

We can explicitly declare a member function as inline as part of its declaration inside the class body. Alternatively, we can specify inline on the function definition that appears outside the class body:

inline // we can specify inline on the definition
Screen &Screen::move(pos r, pos c) {
    pos row = r * width; // compute the row location
    cursor = row + c ; // move cursor to the column within that row
    return *this; // return this object as an lvalue
}

//tao: checked and it has no inline specifier
char Screen::get(pos r, pos c) const { // declared as inline in the class 
    pos row = r * width; // compute row location
    return contents[row + c]; // return character at the given column
}

Although we are not required to do so, it is legal to specify inline on both the declaration and the definition. However, specifying inline only on the definition outside the class can make the class easier to read.

For the same reasons that we define inline functions in headers, inline member functions should be defined in the same header as the corresponding class definition.

--
mutable Data Members

A mutable data member is never const, even when it is a member of a const object. Accordingly, a const member function may change a mutable member.

class Screen {
public:
    void some_member() const;

private:
    mutable size_t access_ctr; // may change even in a const object
    // other members as before
};

void Screen::some_member() const {
    ++access_ctr; // keep a count of the calls to any member function
    // whatever other work this member needs to do
}

--
Initializers for Data Members of Class Type

class Window_mgr {
private:
    std::vector<Screen> screens{Screen(24, 80, ' ') };
};

As we‚Äôve seen, in-class initializers must use either the = form of initialization (which we used when we initialized the the data members of Screen) or the direct form of initialization using curly braces (as we do for screens).

--
Functions That Return *this

class Screen {
public:
    Screen &set(char);
    Screen &set(pos, pos, char);
    // other members as before
};

inline Screen &Screen::set(char c) {
    contents[cursor] = c; // set the new value at the current cursor location
    return *this; // return this object as an lvalue
}

inline Screen &Screen::set(pos r, pos col, char ch) {
    contents[r*width + col] = ch; // set specified location to given value
    return *this; // return this object as an lvalue
}

Our set members return a reference to the object on which
they are called. Functions that return a reference are lvalues, which means that they return the object itself, not a copy of the object. If we concatenate a sequence of these actions into a single expression:

// tao: the move function also returns *this
// move the cursor to a given position, and set that character

myScreen.move(4,0).set('#');

these operations will execute on the same object. 

--
Returning *this from a const Member Function

Tao: first search for "find constmemberfunction"

We‚Äôll add an operation, which we‚Äôll name display, to print the contents of the Screen. If display is a const member, then this (tao: the this pointer is returned by display) is a pointer to const and *this is a const object. if display returns a reference to const, we won‚Äôt be able to embed display into a series of actions (tao: see reason after the following code): 

Screen myScreen;
// if display returns a const reference, the call to set is an error
myScreen.display(cout).set('*');

we can only call const member functions on a const object. We can call either version on a nonconst object, but the nonconst version will be a better match.

In the following example, we‚Äôll define a private member named do_display to do the actual work of printing the Screen. Each of the display operations will call this function and then return the object on which it is executing:

class Screen {
public:
    // display overloaded on whether the object is const or not
    Screen &display(std::ostream &os) { 
        do_display(os); return *this; 
    }

    const Screen &display(std::ostream &os) const { 
        do_display(os); return *this; 
    }

private:
    // function to do the work of displaying a Screen
    void do_display(std::ostream &os) const {
        os << contents;
    }
    // other members as before
};

When we call display on an object, whether that object is const determines which version of display is called:

Screen myScreen(5,3);
const Screen blank(5, 3);
myScreen.set('#').display(cout); // calls non const version
blank.display(cout); // calls const version

--
Benefits of Encapsulation:

Encapsulation provides two important advantages:

- User code cannot inadvertently corrupt the state of an encapsulated object.

- The implementation of an encapsulated class can change over time without requiring changes in user-level code.

By defining data members as private, the class author is free to make changes in the data. If the implementation changes, only the class code needs to be examined to see what effect the change may have. User code needs to change only when the interface changes. If the data are public, then any code that used the old data members might be broken. It would be
necessary to locate and rewrite any code that relied on the old representation before the program could be used again.

Another advantage of making data members private is that the data are protected from mistakes that users might introduce. If there is a bug that corrupts an object‚Äôs state, the places to look for the bug are localized: Only code that is part of the implementation could be responsible for the error. The search for the mistake is limited, greatly easing the problems of
maintenance and program correctness.

--
Class type

Just as we can declare a function apart from its definition, we can also declare a class without defining it:

class Screen; // declaration of the Screen class

After a declaration and before a definition is seen, the type Screen is an incomplete type‚Äîit‚Äôs known that Screen is a class type but not known what members that type contains.

We can use an incomplete type in only limited ways: We can define pointers or references to such types, and we can declare (but not define) functions that use an incomplete type as a parameter or return type.

A class must be defined‚Äînot just declared‚Äîbefore we can write code that creates objects of that type. Otherwise, the compiler does not know how much storage such objects need. Similarly, the class must be defined before a reference or pointer is used
to access a member of the type.

A class cannot have data members of its own type. A class can have data members that are pointers or references to its own type.

--
Implicit Class-Type Conversions

The language defines several automatic conversions among the built-in types. We also noted that classes can define implicit conversions as well. Every constructor that can be called with a single argument defines an implicit conversion to a class type. Such constructors are sometimes referred to as converting constructors. A constructor that can be called with a single argument defines an implicit conversion from the constructor‚Äôs parameter type to the class type. The Sales_data constructors that take a string and that take an istream both define implicit conversions from those types to Sales_data. That is, we can use a
string or an istream where an object of type Sales_data is expected.

Suppressing Implicit Conversions Defined by Constructors
 
We can prevent the use of a constructor in a context that requires an implicit conversion by declaring the constructor as explicit:

class Sales_data {
public:
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p):
               bookNo(s), units_sold(n), revenue(p*n) { }
    explicit Sales_data(const std::string &s): bookNo(s) { }
    explicit Sales_data(std::istream&);
    // remaining members as before
};
 
Now, neither constructor can be used to implicitly create a Sales_data object. 

The explicit keyword is meaningful only on constructors that can be called with a single argument. Constructors that require more arguments are not used to perform an implicit conversion, so there is no need to designate such constructors as explicit. The explicit keyword is used only on the constructor declaration inside the class.

explicit Constructors Can Be Used Only for Direct Initialization

Sales_data item1 (null_book); // ok: direct initialization
Sales_data item2 = null_book; // error: cannot use the copy form of initialization with an explicit constructor

--
Aggregate Classes

An aggregate class gives users direct access to its members and has special initialization syntax. A class is an aggregate if
 
‚Ä¢ All of its data members are public
‚Ä¢ It does not define any constructors
‚Ä¢ It has no in-class initializers 
‚Ä¢ It has no base classes or virtual functions, which are class-related features that we‚Äôll cover in Chapter 15

For example, the following class is an aggregate:
 
struct Data {
    int ival;
    string s;
};
 
We can initialize the data members of an aggregate class by providing a braced list of member initializers:
 
// val1.ival = 0; val1.s = string("Anna")
Data val1 = { 0, "Anna" };
 
The initializers must appear in declaration order of the data members.

It is worth noting that there are three significant drawbacks to explicitly initializing (tao: in the above way) the members of an object of class type:

1. ... public ...
2. ... error-prone ...
3. ... member added or removed ...

--
Literal Classes

We noted that the parameters and return type of a constexpr
function must be literal types. In addition to the arithmetic types, references, and pointers, certain classes are also literal types. Unlike other classes, classes that are
literal types may have function members that are constexpr. Such members must meet all the requirements of a constexpr function. These member functions are implicitly const

An aggregate class whose data members are all of literal type is a literal class. A nonaggregate class, that meets the following restrictions, is also a literal class:
 
‚Ä¢ The data members all must have literal type.
‚Ä¢ The class must have at least one constexpr constructor.
‚Ä¢ If a data member has an in-class initializer, the initializer for a member of built-in type must be a constant expression, or if the member has class type, the initializer must use the member‚Äôs own constexpr constructor.
‚Ä¢ The class must use default definition for its destructor, which is the member that destroys objects of the class type.

constexpr Constructors
 
Although constructors can‚Äôt be const, constructors in a literal class can be constexpr functions. Indeed, a literal class must provide at least one constexpr constructor.
 
A constexpr constructor can be declared as = default (or as a
deleted function, which we cover later). Otherwise, a constexpr
constructor must meet the requirements of a constructor‚Äîmeaning it can have no return statement‚Äîand of a constexpr function‚Äîmeaning the only executable statement it can have is a return statement. As a result, the body of a constexpr constructor is typically empty. We define a constexpr constructor by preceding its declaration with the keyword constexpr:

class Debug {
public:
    constexpr Debug(bool b = true): hw(b), io(b), other(b) {
}
    constexpr Debug(bool h, bool i, bool o):
                                    hw(h), io(i), other(o) {
}
    constexpr bool any() { return hw || io || other; }
    void set_io(bool b) { io = b; }
    void set_hw(bool b) { hw = b; }
    void set_other(bool b) { hw = b; }
private:
    bool hw;    // hardware errors other than IO errors
    bool io;    // IO errors
    bool other; // other errors
};

 
A constexpr constructor must initialize every data member. The initializers must either use a constexpr constructor or be a constant expression.

A constexpr constructor is used to generate objects that are constexpr and for parameters or return types in constexpr functions.

--
(findstaticmember)
static Class Members

Classes sometimes need members that are associated with the class, rather than with individual objects of the class type. For example, a bank account class might need a data member to represent the current prime interest rate. In this case, we‚Äôd want to associate the rate with the class, not with each individual object. From an efficiency standpoint, there‚Äôd be no reason for each object to store the rate. Much more importantly, if the rate changes, we‚Äôd want each object to use the new value.

Declaring static Members
 
We say a member is associated with the class by adding the keyword static to its declaration. Like any other member, static members can be public or private. The type of a static data member can be const, reference, array, class type, and
so forth.

As an example, we‚Äôll define a class to represent an account record at a bank:
 
class Account {
public:
    void calculate() { amount += amount * interestRate; }
    static double rate() { return interestRate; }
    static void rate(double);
private:
    std::string owner;
    double amount;
    static double interestRate;
    static double initRate();
};
 
The static members of a class exist outside any object. Objects do not contain data associated with static data members. Thus, each Account object will contain two data members‚Äîowner and amount. There is only one interestRate object that will be shared by all the Account objects.

Similarly, static member functions are not bound to any object; they do not have a this pointer. As a result, static member functions may not be declared as const, and we may not refer to this in the body of a static member. This restriction applies both to explicit uses of this and to implicit uses of this by calling a nonstatic member.

Using a Class static Member
 
We can access a static member directly through the scope operator:
 
double r;
r = Account::rate(); // access a static member using the scope operator
 
Even though static members are not part of the objects of its class, we can use an object, reference, or pointer of the class type to access a static member:

Account ac1;
Account *ac2 = &ac1;
// equivalent ways to call the static member rate function
r = ac1.rate();      // through an Account object or reference
r = ac2->rate();     // through a pointer to an Account object
 
Member functions can use static members directly, without the scope operator.

Defining static Members
 
As with any other member function, we can define a static member function inside or outside of the class body. When we define a static member outside the class, we do not repeat the static keyword. The keyword appears only with the declaration
inside the class body:
  
void Account::rate(double newRate)
{
    interestRate = newRate;
}

Because static data members are not part of individual objects of the class type, they are not defined when we create objects of the class. As a result, they are not initialized by the class‚Äô constructors. Moreover, in general, we may not initialize a static member inside the class. Instead, we must define and initialize each static data member outside the class body. Like any other object, a static data member may be defined only once.

Like global objects, static data members are defined outside any
function. Hence, once they are defined, they continue to exist until the program completes.

// define and initialize a static class member
double Account::interestRate = initRate();

Note also that even though initRate is private, we can use this function to initialize interestRate.

static Members Can Be Used in Ways Ordinary Members Can‚Äôt
 
As we‚Äôve seen, static members exist independently of any other object. As a result, they can be used in ways that would be illegal for nonstatic data members. As one example, a static data member can have incomplete type. In particular, a static data member can have the same type as the class type of which
MX K√º it is a member. A nonstatic data member is restricted to being declared as a pointer or a reference to an object of its class:

class Bar {
public:
    // ...
private:
    static Bar mem1; // ok: static member can have incomplete type
    Bar *mem2;       // ok: pointer member can have incomplete type
    Bar mem3;        // error: data members must have complete type
};
 
Another difference between static and ordinary members is that we can use a static member as a default argument:
 
class Screen {
public:
    // bkground refers to the static member
    // declared later in the class definition
    Screen& clear(char = bkground);
private:
    static const char bkground;
};
 
A nonstatic data member may not be used as a default argument because its value is part of the object of which it is a member. Using a nonstatic data member as a default argument provides no object from which to obtain the member‚Äôs value and so is an error.

--
(finddestructor)               
destructor

This destructor notes records the file c_primer_5th_edition.pdf.pdf everything in section "13.1.3. The Destructor".

Destructors do whatever work is needed to free the resources used by an object and destroy the data members of the object.

The destructor is a member function with the name of the class prefixed by a tilde (~). It has no return value and takes no parameters. Because it takes no parameters, it cannot be overloaded. There is always only one destructor for a given class.

class Sales_data {
public:
    ~Sales_data() { } // destructor
    ...
};

What a Destructor Does

Just as a constructor has an initialization part and a function body, a destructor has a function body and a destruction part. In a constructor, members are initialized before the function body is executed, and members are initialized in the same order as they appear in the class. In a destructor, the function body is executed first and then the members are destroyed. Members are destroyed in reverse order from the order in which they were initialized.

The function body of a destructor does whatever operations the class designer wishes to have executed subsequent to the last use of an object. Typically, the destructor frees resources an object allocated during its lifetime.

In a destructor, there is nothing akin to the constructor initializer list to control how members are destroyed; the destruction part is implicit. What happens when a member is destroyed depends on the type of the member. Members of class type are destroyed by running the member‚Äôs own destructor. The built-in types do not have destructors, so nothing is done to destroy members of built-in type. 

The implicit destruction of a member of built-in pointer type does not delete the object to which that pointer points.

When a Destructor Is Called

The destructor is used automatically whenever an object of its type is destroyed:

‚Ä¢ Variables are destroyed when they go out of scope.
‚Ä¢ Members of an object are destroyed when the object of which they are a part is destroyed.
‚Ä¢ Elements in a container‚Äîwhether a library container or an array‚Äîare destroyed when the container is destroyed.
‚Ä¢ Dynamically allocated objects are destroyed when the delete operator is applied to a pointer to the object.
‚Ä¢ Temporary objects are destroyed at the end of the full expression in which the temporary was created.

Because destructors are run automatically, our programs can allocate resources and (usually) not worry about when those resources are released.

For example, the following fragment defines four Sales_data objects:

{ // new scope
    // p and p2 point to dynamically allocated objects
    Sales_data *p = new Sales_data; // p is a built-in pointer
    auto p2 = make_shared<Sales_data>(); // p2 is a shared_ptr
    Sales_data item(*p); // copy constructor copies *p into item
    vector<Sales_data> vec; // local object
    vec.push_back(*p2); // copies the object to which p2 points
    delete p; // destructor called on the object pointed to
    by p
} // exit local scope; destructor called on item, p2, and vec
// destroying p2 decrements its use count; if the count goes to 0, the object is freed
// destroying vec destroys the elements in vec

The destructor is not run when a reference or a pointer to an object goes out of scope.

The Synthesized Destructor

The compiler defines a synthesized destructor for any class that does not define its own destructor. As with the copy constructor and the copy-assignment operator, for some classes, the synthesized destructor is defined to disallow objects of the type
from being destroyed. Otherwise, the synthesized destructor has an empty function body.

For example, the synthesized Sales_data destructor is equivalent to:

class Sales_data {
public:
    // no work to do other than destroying the members, which happens automatically
    ~Sales_data() { }
    // other members as before
};

The members are automatically destroyed after the (empty) destructor body is run.

It is important to realize that the destructor body does not directly destroy the members themselves. Members are destroyed as part of the implicit destruction phase that follows the destructor body. A destructor body executes in addition to the
memberwise destruction that takes place as part of destroying an object.




















